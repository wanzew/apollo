// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/drivers/gnss/proto/config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
namespace apollo {
namespace drivers {
namespace gnss {
namespace config {
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class NovatelConfig;
struct NovatelConfigDefaultTypeInternal;
extern NovatelConfigDefaultTypeInternal _NovatelConfig_default_instance_;
class Stream;
struct StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class Stream_Ntrip;
struct Stream_NtripDefaultTypeInternal;
extern Stream_NtripDefaultTypeInternal _Stream_Ntrip_default_instance_;
class Stream_Serial;
struct Stream_SerialDefaultTypeInternal;
extern Stream_SerialDefaultTypeInternal _Stream_Serial_default_instance_;
class Stream_Tcp;
struct Stream_TcpDefaultTypeInternal;
extern Stream_TcpDefaultTypeInternal _Stream_Tcp_default_instance_;
class Stream_Udp;
struct Stream_UdpDefaultTypeInternal;
extern Stream_UdpDefaultTypeInternal _Stream_Udp_default_instance_;
class TF;
struct TFDefaultTypeInternal;
extern TFDefaultTypeInternal _TF_default_instance_;
class UbloxConfig;
struct UbloxConfigDefaultTypeInternal;
extern UbloxConfigDefaultTypeInternal _UbloxConfig_default_instance_;
}  // namespace config
}  // namespace gnss
}  // namespace drivers
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::drivers::gnss::config::Config* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Config>(Arena*);
template<> ::apollo::drivers::gnss::config::NovatelConfig* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::NovatelConfig>(Arena*);
template<> ::apollo::drivers::gnss::config::Stream* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Stream>(Arena*);
template<> ::apollo::drivers::gnss::config::Stream_Ntrip* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Stream_Ntrip>(Arena*);
template<> ::apollo::drivers::gnss::config::Stream_Serial* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Stream_Serial>(Arena*);
template<> ::apollo::drivers::gnss::config::Stream_Tcp* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Stream_Tcp>(Arena*);
template<> ::apollo::drivers::gnss::config::Stream_Udp* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Stream_Udp>(Arena*);
template<> ::apollo::drivers::gnss::config::TF* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::TF>(Arena*);
template<> ::apollo::drivers::gnss::config::UbloxConfig* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::UbloxConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace drivers {
namespace gnss {
namespace config {

enum Stream_Format : int {
  Stream_Format_UNKNOWN = 0,
  Stream_Format_NMEA = 1,
  Stream_Format_RTCM_V2 = 2,
  Stream_Format_RTCM_V3 = 3,
  Stream_Format_NOVATEL_TEXT = 10,
  Stream_Format_NOVATEL_BINARY = 11,
  Stream_Format_UBLOX_TEXT = 20,
  Stream_Format_UBLOX_BINARY = 21
};
bool Stream_Format_IsValid(int value);
constexpr Stream_Format Stream_Format_Format_MIN = Stream_Format_UNKNOWN;
constexpr Stream_Format Stream_Format_Format_MAX = Stream_Format_UBLOX_BINARY;
constexpr int Stream_Format_Format_ARRAYSIZE = Stream_Format_Format_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Stream_Format_descriptor();
template<typename T>
inline const std::string& Stream_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Stream_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Stream_Format_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Stream_Format_descriptor(), enum_t_value);
}
inline bool Stream_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Stream_Format* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Stream_Format>(
    Stream_Format_descriptor(), name, value);
}
enum Config_RtkSolutionType : int {
  Config_RtkSolutionType_RTK_RECEIVER_SOLUTION = 1,
  Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION = 2
};
bool Config_RtkSolutionType_IsValid(int value);
constexpr Config_RtkSolutionType Config_RtkSolutionType_RtkSolutionType_MIN = Config_RtkSolutionType_RTK_RECEIVER_SOLUTION;
constexpr Config_RtkSolutionType Config_RtkSolutionType_RtkSolutionType_MAX = Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION;
constexpr int Config_RtkSolutionType_RtkSolutionType_ARRAYSIZE = Config_RtkSolutionType_RtkSolutionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_RtkSolutionType_descriptor();
template<typename T>
inline const std::string& Config_RtkSolutionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_RtkSolutionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_RtkSolutionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_RtkSolutionType_descriptor(), enum_t_value);
}
inline bool Config_RtkSolutionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_RtkSolutionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_RtkSolutionType>(
    Config_RtkSolutionType_descriptor(), name, value);
}
enum ImuType : int {
  IMAR_FSAS = 13,
  ISA100C = 26,
  ADIS16488 = 31,
  STIM300 = 32,
  ISA100 = 34,
  ISA100_400HZ = 38,
  ISA100C_400HZ = 39,
  CPT_XW5651 = 40,
  G320N = 41,
  UM442 = 42,
  IAM20680 = 57
};
bool ImuType_IsValid(int value);
constexpr ImuType ImuType_MIN = IMAR_FSAS;
constexpr ImuType ImuType_MAX = IAM20680;
constexpr int ImuType_ARRAYSIZE = ImuType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImuType_descriptor();
template<typename T>
inline const std::string& ImuType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImuType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImuType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImuType_descriptor(), enum_t_value);
}
inline bool ImuType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImuType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImuType>(
    ImuType_descriptor(), name, value);
}
// ===================================================================

class Stream_Serial final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Stream.Serial) */ {
 public:
  inline Stream_Serial() : Stream_Serial(nullptr) {}
  ~Stream_Serial() override;
  explicit PROTOBUF_CONSTEXPR Stream_Serial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream_Serial(const Stream_Serial& from);
  Stream_Serial(Stream_Serial&& from) noexcept
    : Stream_Serial() {
    *this = ::std::move(from);
  }

  inline Stream_Serial& operator=(const Stream_Serial& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream_Serial& operator=(Stream_Serial&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream_Serial& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream_Serial* internal_default_instance() {
    return reinterpret_cast<const Stream_Serial*>(
               &_Stream_Serial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Stream_Serial& a, Stream_Serial& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream_Serial* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream_Serial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stream_Serial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stream_Serial>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream_Serial& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stream_Serial& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream_Serial* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Stream.Serial";
  }
  protected:
  explicit Stream_Serial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kBaudRateFieldNumber = 2,
  };
  // optional bytes device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const std::string& device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // optional int32 baud_rate = 2 [default = 9600];
  bool has_baud_rate() const;
  private:
  bool _internal_has_baud_rate() const;
  public:
  void clear_baud_rate();
  int32_t baud_rate() const;
  void set_baud_rate(int32_t value);
  private:
  int32_t _internal_baud_rate() const;
  void _internal_set_baud_rate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Stream.Serial)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
    int32_t baud_rate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Stream_Tcp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Stream.Tcp) */ {
 public:
  inline Stream_Tcp() : Stream_Tcp(nullptr) {}
  ~Stream_Tcp() override;
  explicit PROTOBUF_CONSTEXPR Stream_Tcp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream_Tcp(const Stream_Tcp& from);
  Stream_Tcp(Stream_Tcp&& from) noexcept
    : Stream_Tcp() {
    *this = ::std::move(from);
  }

  inline Stream_Tcp& operator=(const Stream_Tcp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream_Tcp& operator=(Stream_Tcp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream_Tcp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream_Tcp* internal_default_instance() {
    return reinterpret_cast<const Stream_Tcp*>(
               &_Stream_Tcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Stream_Tcp& a, Stream_Tcp& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream_Tcp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream_Tcp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stream_Tcp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stream_Tcp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream_Tcp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stream_Tcp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream_Tcp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Stream.Tcp";
  }
  protected:
  explicit Stream_Tcp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // optional bytes address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional int32 port = 2 [default = 3001];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Stream.Tcp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int32_t port_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Stream_Udp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Stream.Udp) */ {
 public:
  inline Stream_Udp() : Stream_Udp(nullptr) {}
  ~Stream_Udp() override;
  explicit PROTOBUF_CONSTEXPR Stream_Udp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream_Udp(const Stream_Udp& from);
  Stream_Udp(Stream_Udp&& from) noexcept
    : Stream_Udp() {
    *this = ::std::move(from);
  }

  inline Stream_Udp& operator=(const Stream_Udp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream_Udp& operator=(Stream_Udp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream_Udp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream_Udp* internal_default_instance() {
    return reinterpret_cast<const Stream_Udp*>(
               &_Stream_Udp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Stream_Udp& a, Stream_Udp& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream_Udp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream_Udp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stream_Udp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stream_Udp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream_Udp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stream_Udp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream_Udp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Stream.Udp";
  }
  protected:
  explicit Stream_Udp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // optional bytes address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional int32 port = 2 [default = 3001];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Stream.Udp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int32_t port_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Stream_Ntrip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Stream.Ntrip) */ {
 public:
  inline Stream_Ntrip() : Stream_Ntrip(nullptr) {}
  ~Stream_Ntrip() override;
  explicit PROTOBUF_CONSTEXPR Stream_Ntrip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream_Ntrip(const Stream_Ntrip& from);
  Stream_Ntrip(Stream_Ntrip&& from) noexcept
    : Stream_Ntrip() {
    *this = ::std::move(from);
  }

  inline Stream_Ntrip& operator=(const Stream_Ntrip& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream_Ntrip& operator=(Stream_Ntrip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream_Ntrip& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream_Ntrip* internal_default_instance() {
    return reinterpret_cast<const Stream_Ntrip*>(
               &_Stream_Ntrip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Stream_Ntrip& a, Stream_Ntrip& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream_Ntrip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream_Ntrip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stream_Ntrip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stream_Ntrip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream_Ntrip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stream_Ntrip& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream_Ntrip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Stream.Ntrip";
  }
  protected:
  explicit Stream_Ntrip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kMountPointFieldNumber = 3,
    kUserFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kPortFieldNumber = 2,
    kTimeoutSFieldNumber = 6,
  };
  // optional bytes address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional bytes mount_point = 3;
  bool has_mount_point() const;
  private:
  bool _internal_has_mount_point() const;
  public:
  void clear_mount_point();
  const std::string& mount_point() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mount_point(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mount_point();
  PROTOBUF_NODISCARD std::string* release_mount_point();
  void set_allocated_mount_point(std::string* mount_point);
  private:
  const std::string& _internal_mount_point() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mount_point(const std::string& value);
  std::string* _internal_mutable_mount_point();
  public:

  // optional bytes user = 4;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // optional bytes password = 5;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional int32 port = 2 [default = 2101];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // optional uint32 timeout_s = 6 [default = 30];
  bool has_timeout_s() const;
  private:
  bool _internal_has_timeout_s() const;
  public:
  void clear_timeout_s();
  uint32_t timeout_s() const;
  void set_timeout_s(uint32_t value);
  private:
  uint32_t _internal_timeout_s() const;
  void _internal_set_timeout_s(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Stream.Ntrip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mount_point_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    int32_t port_;
    uint32_t timeout_s_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Stream final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Stream) */ {
 public:
  inline Stream() : Stream(nullptr) {}
  ~Stream() override;
  explicit PROTOBUF_CONSTEXPR Stream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream(const Stream& from);
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream& operator=(Stream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kSerial = 2,
    kTcp = 3,
    kUdp = 4,
    kNtrip = 5,
    TYPE_NOT_SET = 0,
  };

  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stream& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Stream";
  }
  protected:
  explicit Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Stream_Serial Serial;
  typedef Stream_Tcp Tcp;
  typedef Stream_Udp Udp;
  typedef Stream_Ntrip Ntrip;

  typedef Stream_Format Format;
  static constexpr Format UNKNOWN =
    Stream_Format_UNKNOWN;
  static constexpr Format NMEA =
    Stream_Format_NMEA;
  static constexpr Format RTCM_V2 =
    Stream_Format_RTCM_V2;
  static constexpr Format RTCM_V3 =
    Stream_Format_RTCM_V3;
  static constexpr Format NOVATEL_TEXT =
    Stream_Format_NOVATEL_TEXT;
  static constexpr Format NOVATEL_BINARY =
    Stream_Format_NOVATEL_BINARY;
  static constexpr Format UBLOX_TEXT =
    Stream_Format_UBLOX_TEXT;
  static constexpr Format UBLOX_BINARY =
    Stream_Format_UBLOX_BINARY;
  static inline bool Format_IsValid(int value) {
    return Stream_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    Stream_Format_Format_MIN;
  static constexpr Format Format_MAX =
    Stream_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    Stream_Format_Format_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Format_descriptor() {
    return Stream_Format_descriptor();
  }
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return Stream_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return Stream_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
    kPushLocationFieldNumber = 6,
    kSerialFieldNumber = 2,
    kTcpFieldNumber = 3,
    kUdpFieldNumber = 4,
    kNtripFieldNumber = 5,
  };
  // optional .apollo.drivers.gnss.config.Stream.Format format = 1;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::apollo::drivers::gnss::config::Stream_Format format() const;
  void set_format(::apollo::drivers::gnss::config::Stream_Format value);
  private:
  ::apollo::drivers::gnss::config::Stream_Format _internal_format() const;
  void _internal_set_format(::apollo::drivers::gnss::config::Stream_Format value);
  public:

  // optional bool push_location = 6;
  bool has_push_location() const;
  private:
  bool _internal_has_push_location() const;
  public:
  void clear_push_location();
  bool push_location() const;
  void set_push_location(bool value);
  private:
  bool _internal_push_location() const;
  void _internal_set_push_location(bool value);
  public:

  // .apollo.drivers.gnss.config.Stream.Serial serial = 2;
  bool has_serial() const;
  private:
  bool _internal_has_serial() const;
  public:
  void clear_serial();
  const ::apollo::drivers::gnss::config::Stream_Serial& serial() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::Stream_Serial* release_serial();
  ::apollo::drivers::gnss::config::Stream_Serial* mutable_serial();
  void set_allocated_serial(::apollo::drivers::gnss::config::Stream_Serial* serial);
  private:
  const ::apollo::drivers::gnss::config::Stream_Serial& _internal_serial() const;
  ::apollo::drivers::gnss::config::Stream_Serial* _internal_mutable_serial();
  public:
  void unsafe_arena_set_allocated_serial(
      ::apollo::drivers::gnss::config::Stream_Serial* serial);
  ::apollo::drivers::gnss::config::Stream_Serial* unsafe_arena_release_serial();

  // .apollo.drivers.gnss.config.Stream.Tcp tcp = 3;
  bool has_tcp() const;
  private:
  bool _internal_has_tcp() const;
  public:
  void clear_tcp();
  const ::apollo::drivers::gnss::config::Stream_Tcp& tcp() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::Stream_Tcp* release_tcp();
  ::apollo::drivers::gnss::config::Stream_Tcp* mutable_tcp();
  void set_allocated_tcp(::apollo::drivers::gnss::config::Stream_Tcp* tcp);
  private:
  const ::apollo::drivers::gnss::config::Stream_Tcp& _internal_tcp() const;
  ::apollo::drivers::gnss::config::Stream_Tcp* _internal_mutable_tcp();
  public:
  void unsafe_arena_set_allocated_tcp(
      ::apollo::drivers::gnss::config::Stream_Tcp* tcp);
  ::apollo::drivers::gnss::config::Stream_Tcp* unsafe_arena_release_tcp();

  // .apollo.drivers.gnss.config.Stream.Udp udp = 4;
  bool has_udp() const;
  private:
  bool _internal_has_udp() const;
  public:
  void clear_udp();
  const ::apollo::drivers::gnss::config::Stream_Udp& udp() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::Stream_Udp* release_udp();
  ::apollo::drivers::gnss::config::Stream_Udp* mutable_udp();
  void set_allocated_udp(::apollo::drivers::gnss::config::Stream_Udp* udp);
  private:
  const ::apollo::drivers::gnss::config::Stream_Udp& _internal_udp() const;
  ::apollo::drivers::gnss::config::Stream_Udp* _internal_mutable_udp();
  public:
  void unsafe_arena_set_allocated_udp(
      ::apollo::drivers::gnss::config::Stream_Udp* udp);
  ::apollo::drivers::gnss::config::Stream_Udp* unsafe_arena_release_udp();

  // .apollo.drivers.gnss.config.Stream.Ntrip ntrip = 5;
  bool has_ntrip() const;
  private:
  bool _internal_has_ntrip() const;
  public:
  void clear_ntrip();
  const ::apollo::drivers::gnss::config::Stream_Ntrip& ntrip() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::Stream_Ntrip* release_ntrip();
  ::apollo::drivers::gnss::config::Stream_Ntrip* mutable_ntrip();
  void set_allocated_ntrip(::apollo::drivers::gnss::config::Stream_Ntrip* ntrip);
  private:
  const ::apollo::drivers::gnss::config::Stream_Ntrip& _internal_ntrip() const;
  ::apollo::drivers::gnss::config::Stream_Ntrip* _internal_mutable_ntrip();
  public:
  void unsafe_arena_set_allocated_ntrip(
      ::apollo::drivers::gnss::config::Stream_Ntrip* ntrip);
  ::apollo::drivers::gnss::config::Stream_Ntrip* unsafe_arena_release_ntrip();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Stream)
 private:
  class _Internal;
  void set_has_serial();
  void set_has_tcp();
  void set_has_udp();
  void set_has_ntrip();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int format_;
    bool push_location_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::apollo::drivers::gnss::config::Stream_Serial* serial_;
      ::apollo::drivers::gnss::config::Stream_Tcp* tcp_;
      ::apollo::drivers::gnss::config::Stream_Udp* udp_;
      ::apollo::drivers::gnss::config::Stream_Ntrip* ntrip_;
    } type_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class NovatelConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.NovatelConfig) */ {
 public:
  inline NovatelConfig() : NovatelConfig(nullptr) {}
  ~NovatelConfig() override;
  explicit PROTOBUF_CONSTEXPR NovatelConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NovatelConfig(const NovatelConfig& from);
  NovatelConfig(NovatelConfig&& from) noexcept
    : NovatelConfig() {
    *this = ::std::move(from);
  }

  inline NovatelConfig& operator=(const NovatelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline NovatelConfig& operator=(NovatelConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NovatelConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const NovatelConfig* internal_default_instance() {
    return reinterpret_cast<const NovatelConfig*>(
               &_NovatelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NovatelConfig& a, NovatelConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(NovatelConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NovatelConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NovatelConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NovatelConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NovatelConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NovatelConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NovatelConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.NovatelConfig";
  }
  protected:
  explicit NovatelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImuOrientationFieldNumber = 1,
  };
  // optional int32 imu_orientation = 1 [default = 5];
  bool has_imu_orientation() const;
  private:
  bool _internal_has_imu_orientation() const;
  public:
  void clear_imu_orientation();
  int32_t imu_orientation() const;
  void set_imu_orientation(int32_t value);
  private:
  int32_t _internal_imu_orientation() const;
  void _internal_set_imu_orientation(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.NovatelConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t imu_orientation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class UbloxConfig final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.UbloxConfig) */ {
 public:
  inline UbloxConfig() : UbloxConfig(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UbloxConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UbloxConfig(const UbloxConfig& from);
  UbloxConfig(UbloxConfig&& from) noexcept
    : UbloxConfig() {
    *this = ::std::move(from);
  }

  inline UbloxConfig& operator=(const UbloxConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline UbloxConfig& operator=(UbloxConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UbloxConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const UbloxConfig* internal_default_instance() {
    return reinterpret_cast<const UbloxConfig*>(
               &_UbloxConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UbloxConfig& a, UbloxConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(UbloxConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UbloxConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UbloxConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UbloxConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UbloxConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UbloxConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.UbloxConfig";
  }
  protected:
  explicit UbloxConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.UbloxConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class TF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.TF) */ {
 public:
  inline TF() : TF(nullptr) {}
  ~TF() override;
  explicit PROTOBUF_CONSTEXPR TF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TF(const TF& from);
  TF(TF&& from) noexcept
    : TF() {
    *this = ::std::move(from);
  }

  inline TF& operator=(const TF& from) {
    CopyFrom(from);
    return *this;
  }
  inline TF& operator=(TF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TF& default_instance() {
    return *internal_default_instance();
  }
  static inline const TF* internal_default_instance() {
    return reinterpret_cast<const TF*>(
               &_TF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TF& a, TF& b) {
    a.Swap(&b);
  }
  inline void Swap(TF* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TF& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TF* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.TF";
  }
  protected:
  explicit TF(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameIdFieldNumber = 1,
    kChildFrameIdFieldNumber = 2,
    kEnableFieldNumber = 3,
  };
  // optional string frame_id = 1 [default = "world"];
  bool has_frame_id() const;
  private:
  bool _internal_has_frame_id() const;
  public:
  void clear_frame_id();
  const std::string& frame_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_id();
  PROTOBUF_NODISCARD std::string* release_frame_id();
  void set_allocated_frame_id(std::string* frame_id);
  private:
  const std::string& _internal_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_id(const std::string& value);
  std::string* _internal_mutable_frame_id();
  public:

  // optional string child_frame_id = 2 [default = "novatel"];
  bool has_child_frame_id() const;
  private:
  bool _internal_has_child_frame_id() const;
  public:
  void clear_child_frame_id();
  const std::string& child_frame_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_child_frame_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_child_frame_id();
  PROTOBUF_NODISCARD std::string* release_child_frame_id();
  void set_allocated_child_frame_id(std::string* child_frame_id);
  private:
  const std::string& _internal_child_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_child_frame_id(const std::string& value);
  std::string* _internal_mutable_child_frame_id();
  public:

  // optional bool enable = 3 [default = false];
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.TF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_frame_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_id_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_child_frame_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_frame_id_;
    bool enable_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  explicit PROTOBUF_CONSTEXPR Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceConfigCase {
    kNovatelConfig = 7,
    kUbloxConfig = 8,
    DEVICE_CONFIG_NOT_SET = 0,
  };

  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Config& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Config";
  }
  protected:
  explicit Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_RtkSolutionType RtkSolutionType;
  static constexpr RtkSolutionType RTK_RECEIVER_SOLUTION =
    Config_RtkSolutionType_RTK_RECEIVER_SOLUTION;
  static constexpr RtkSolutionType RTK_SOFTWARE_SOLUTION =
    Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION;
  static inline bool RtkSolutionType_IsValid(int value) {
    return Config_RtkSolutionType_IsValid(value);
  }
  static constexpr RtkSolutionType RtkSolutionType_MIN =
    Config_RtkSolutionType_RtkSolutionType_MIN;
  static constexpr RtkSolutionType RtkSolutionType_MAX =
    Config_RtkSolutionType_RtkSolutionType_MAX;
  static constexpr int RtkSolutionType_ARRAYSIZE =
    Config_RtkSolutionType_RtkSolutionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RtkSolutionType_descriptor() {
    return Config_RtkSolutionType_descriptor();
  }
  template<typename T>
  static inline const std::string& RtkSolutionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RtkSolutionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RtkSolutionType_Name.");
    return Config_RtkSolutionType_Name(enum_t_value);
  }
  static inline bool RtkSolutionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RtkSolutionType* value) {
    return Config_RtkSolutionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLoginCommandsFieldNumber = 5,
    kLogoutCommandsFieldNumber = 6,
    kProj4TextFieldNumber = 11,
    kWheelParametersFieldNumber = 13,
    kGpsbinFolderFieldNumber = 14,
    kDataFieldNumber = 1,
    kCommandFieldNumber = 2,
    kRtkFromFieldNumber = 3,
    kRtkToFieldNumber = 4,
    kTfFieldNumber = 12,
    kRtkSolutionTypeFieldNumber = 9,
    kImuTypeFieldNumber = 10,
    kNovatelConfigFieldNumber = 7,
    kUbloxConfigFieldNumber = 8,
  };
  // repeated bytes login_commands = 5;
  int login_commands_size() const;
  private:
  int _internal_login_commands_size() const;
  public:
  void clear_login_commands();
  const std::string& login_commands(int index) const;
  std::string* mutable_login_commands(int index);
  void set_login_commands(int index, const std::string& value);
  void set_login_commands(int index, std::string&& value);
  void set_login_commands(int index, const char* value);
  void set_login_commands(int index, const void* value, size_t size);
  std::string* add_login_commands();
  void add_login_commands(const std::string& value);
  void add_login_commands(std::string&& value);
  void add_login_commands(const char* value);
  void add_login_commands(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& login_commands() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_login_commands();
  private:
  const std::string& _internal_login_commands(int index) const;
  std::string* _internal_add_login_commands();
  public:

  // repeated bytes logout_commands = 6;
  int logout_commands_size() const;
  private:
  int _internal_logout_commands_size() const;
  public:
  void clear_logout_commands();
  const std::string& logout_commands(int index) const;
  std::string* mutable_logout_commands(int index);
  void set_logout_commands(int index, const std::string& value);
  void set_logout_commands(int index, std::string&& value);
  void set_logout_commands(int index, const char* value);
  void set_logout_commands(int index, const void* value, size_t size);
  std::string* add_logout_commands();
  void add_logout_commands(const std::string& value);
  void add_logout_commands(std::string&& value);
  void add_logout_commands(const char* value);
  void add_logout_commands(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& logout_commands() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_logout_commands();
  private:
  const std::string& _internal_logout_commands(int index) const;
  std::string* _internal_add_logout_commands();
  public:

  // optional string proj4_text = 11;
  bool has_proj4_text() const;
  private:
  bool _internal_has_proj4_text() const;
  public:
  void clear_proj4_text();
  const std::string& proj4_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proj4_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proj4_text();
  PROTOBUF_NODISCARD std::string* release_proj4_text();
  void set_allocated_proj4_text(std::string* proj4_text);
  private:
  const std::string& _internal_proj4_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proj4_text(const std::string& value);
  std::string* _internal_mutable_proj4_text();
  public:

  // optional string wheel_parameters = 13;
  bool has_wheel_parameters() const;
  private:
  bool _internal_has_wheel_parameters() const;
  public:
  void clear_wheel_parameters();
  const std::string& wheel_parameters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wheel_parameters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wheel_parameters();
  PROTOBUF_NODISCARD std::string* release_wheel_parameters();
  void set_allocated_wheel_parameters(std::string* wheel_parameters);
  private:
  const std::string& _internal_wheel_parameters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wheel_parameters(const std::string& value);
  std::string* _internal_mutable_wheel_parameters();
  public:

  // optional string gpsbin_folder = 14;
  bool has_gpsbin_folder() const;
  private:
  bool _internal_has_gpsbin_folder() const;
  public:
  void clear_gpsbin_folder();
  const std::string& gpsbin_folder() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gpsbin_folder(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gpsbin_folder();
  PROTOBUF_NODISCARD std::string* release_gpsbin_folder();
  void set_allocated_gpsbin_folder(std::string* gpsbin_folder);
  private:
  const std::string& _internal_gpsbin_folder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gpsbin_folder(const std::string& value);
  std::string* _internal_mutable_gpsbin_folder();
  public:

  // optional .apollo.drivers.gnss.config.Stream data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::apollo::drivers::gnss::config::Stream& data() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::Stream* release_data();
  ::apollo::drivers::gnss::config::Stream* mutable_data();
  void set_allocated_data(::apollo::drivers::gnss::config::Stream* data);
  private:
  const ::apollo::drivers::gnss::config::Stream& _internal_data() const;
  ::apollo::drivers::gnss::config::Stream* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::apollo::drivers::gnss::config::Stream* data);
  ::apollo::drivers::gnss::config::Stream* unsafe_arena_release_data();

  // optional .apollo.drivers.gnss.config.Stream command = 2;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::apollo::drivers::gnss::config::Stream& command() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::Stream* release_command();
  ::apollo::drivers::gnss::config::Stream* mutable_command();
  void set_allocated_command(::apollo::drivers::gnss::config::Stream* command);
  private:
  const ::apollo::drivers::gnss::config::Stream& _internal_command() const;
  ::apollo::drivers::gnss::config::Stream* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::apollo::drivers::gnss::config::Stream* command);
  ::apollo::drivers::gnss::config::Stream* unsafe_arena_release_command();

  // optional .apollo.drivers.gnss.config.Stream rtk_from = 3;
  bool has_rtk_from() const;
  private:
  bool _internal_has_rtk_from() const;
  public:
  void clear_rtk_from();
  const ::apollo::drivers::gnss::config::Stream& rtk_from() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::Stream* release_rtk_from();
  ::apollo::drivers::gnss::config::Stream* mutable_rtk_from();
  void set_allocated_rtk_from(::apollo::drivers::gnss::config::Stream* rtk_from);
  private:
  const ::apollo::drivers::gnss::config::Stream& _internal_rtk_from() const;
  ::apollo::drivers::gnss::config::Stream* _internal_mutable_rtk_from();
  public:
  void unsafe_arena_set_allocated_rtk_from(
      ::apollo::drivers::gnss::config::Stream* rtk_from);
  ::apollo::drivers::gnss::config::Stream* unsafe_arena_release_rtk_from();

  // optional .apollo.drivers.gnss.config.Stream rtk_to = 4;
  bool has_rtk_to() const;
  private:
  bool _internal_has_rtk_to() const;
  public:
  void clear_rtk_to();
  const ::apollo::drivers::gnss::config::Stream& rtk_to() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::Stream* release_rtk_to();
  ::apollo::drivers::gnss::config::Stream* mutable_rtk_to();
  void set_allocated_rtk_to(::apollo::drivers::gnss::config::Stream* rtk_to);
  private:
  const ::apollo::drivers::gnss::config::Stream& _internal_rtk_to() const;
  ::apollo::drivers::gnss::config::Stream* _internal_mutable_rtk_to();
  public:
  void unsafe_arena_set_allocated_rtk_to(
      ::apollo::drivers::gnss::config::Stream* rtk_to);
  ::apollo::drivers::gnss::config::Stream* unsafe_arena_release_rtk_to();

  // optional .apollo.drivers.gnss.config.TF tf = 12;
  bool has_tf() const;
  private:
  bool _internal_has_tf() const;
  public:
  void clear_tf();
  const ::apollo::drivers::gnss::config::TF& tf() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::TF* release_tf();
  ::apollo::drivers::gnss::config::TF* mutable_tf();
  void set_allocated_tf(::apollo::drivers::gnss::config::TF* tf);
  private:
  const ::apollo::drivers::gnss::config::TF& _internal_tf() const;
  ::apollo::drivers::gnss::config::TF* _internal_mutable_tf();
  public:
  void unsafe_arena_set_allocated_tf(
      ::apollo::drivers::gnss::config::TF* tf);
  ::apollo::drivers::gnss::config::TF* unsafe_arena_release_tf();

  // optional .apollo.drivers.gnss.config.Config.RtkSolutionType rtk_solution_type = 9;
  bool has_rtk_solution_type() const;
  private:
  bool _internal_has_rtk_solution_type() const;
  public:
  void clear_rtk_solution_type();
  ::apollo::drivers::gnss::config::Config_RtkSolutionType rtk_solution_type() const;
  void set_rtk_solution_type(::apollo::drivers::gnss::config::Config_RtkSolutionType value);
  private:
  ::apollo::drivers::gnss::config::Config_RtkSolutionType _internal_rtk_solution_type() const;
  void _internal_set_rtk_solution_type(::apollo::drivers::gnss::config::Config_RtkSolutionType value);
  public:

  // optional .apollo.drivers.gnss.config.ImuType imu_type = 10;
  bool has_imu_type() const;
  private:
  bool _internal_has_imu_type() const;
  public:
  void clear_imu_type();
  ::apollo::drivers::gnss::config::ImuType imu_type() const;
  void set_imu_type(::apollo::drivers::gnss::config::ImuType value);
  private:
  ::apollo::drivers::gnss::config::ImuType _internal_imu_type() const;
  void _internal_set_imu_type(::apollo::drivers::gnss::config::ImuType value);
  public:

  // .apollo.drivers.gnss.config.NovatelConfig novatel_config = 7;
  bool has_novatel_config() const;
  private:
  bool _internal_has_novatel_config() const;
  public:
  void clear_novatel_config();
  const ::apollo::drivers::gnss::config::NovatelConfig& novatel_config() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::NovatelConfig* release_novatel_config();
  ::apollo::drivers::gnss::config::NovatelConfig* mutable_novatel_config();
  void set_allocated_novatel_config(::apollo::drivers::gnss::config::NovatelConfig* novatel_config);
  private:
  const ::apollo::drivers::gnss::config::NovatelConfig& _internal_novatel_config() const;
  ::apollo::drivers::gnss::config::NovatelConfig* _internal_mutable_novatel_config();
  public:
  void unsafe_arena_set_allocated_novatel_config(
      ::apollo::drivers::gnss::config::NovatelConfig* novatel_config);
  ::apollo::drivers::gnss::config::NovatelConfig* unsafe_arena_release_novatel_config();

  // .apollo.drivers.gnss.config.UbloxConfig ublox_config = 8;
  bool has_ublox_config() const;
  private:
  bool _internal_has_ublox_config() const;
  public:
  void clear_ublox_config();
  const ::apollo::drivers::gnss::config::UbloxConfig& ublox_config() const;
  PROTOBUF_NODISCARD ::apollo::drivers::gnss::config::UbloxConfig* release_ublox_config();
  ::apollo::drivers::gnss::config::UbloxConfig* mutable_ublox_config();
  void set_allocated_ublox_config(::apollo::drivers::gnss::config::UbloxConfig* ublox_config);
  private:
  const ::apollo::drivers::gnss::config::UbloxConfig& _internal_ublox_config() const;
  ::apollo::drivers::gnss::config::UbloxConfig* _internal_mutable_ublox_config();
  public:
  void unsafe_arena_set_allocated_ublox_config(
      ::apollo::drivers::gnss::config::UbloxConfig* ublox_config);
  ::apollo::drivers::gnss::config::UbloxConfig* unsafe_arena_release_ublox_config();

  void clear_device_config();
  DeviceConfigCase device_config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Config)
 private:
  class _Internal;
  void set_has_novatel_config();
  void set_has_ublox_config();

  inline bool has_device_config() const;
  inline void clear_has_device_config();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> login_commands_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> logout_commands_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proj4_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wheel_parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gpsbin_folder_;
    ::apollo::drivers::gnss::config::Stream* data_;
    ::apollo::drivers::gnss::config::Stream* command_;
    ::apollo::drivers::gnss::config::Stream* rtk_from_;
    ::apollo::drivers::gnss::config::Stream* rtk_to_;
    ::apollo::drivers::gnss::config::TF* tf_;
    int rtk_solution_type_;
    int imu_type_;
    union DeviceConfigUnion {
      constexpr DeviceConfigUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::apollo::drivers::gnss::config::NovatelConfig* novatel_config_;
      ::apollo::drivers::gnss::config::UbloxConfig* ublox_config_;
    } device_config_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Stream_Serial

// optional bytes device = 1;
inline bool Stream_Serial::_internal_has_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream_Serial::has_device() const {
  return _internal_has_device();
}
inline void Stream_Serial::clear_device() {
  _impl_.device_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Stream_Serial::device() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Serial.device)
  return _internal_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Serial::set_device(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.device_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Serial.device)
}
inline std::string* Stream_Serial::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Serial.device)
  return _s;
}
inline const std::string& Stream_Serial::_internal_device() const {
  return _impl_.device_.Get();
}
inline void Stream_Serial::_internal_set_device(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream_Serial::_internal_mutable_device() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.device_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream_Serial::release_device() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Serial.device)
  if (!_internal_has_device()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.device_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_.IsDefault()) {
    _impl_.device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Stream_Serial::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_.SetAllocated(device, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_.IsDefault()) {
    _impl_.device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Serial.device)
}

// optional int32 baud_rate = 2 [default = 9600];
inline bool Stream_Serial::_internal_has_baud_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream_Serial::has_baud_rate() const {
  return _internal_has_baud_rate();
}
inline void Stream_Serial::clear_baud_rate() {
  _impl_.baud_rate_ = 9600;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Stream_Serial::_internal_baud_rate() const {
  return _impl_.baud_rate_;
}
inline int32_t Stream_Serial::baud_rate() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Serial.baud_rate)
  return _internal_baud_rate();
}
inline void Stream_Serial::_internal_set_baud_rate(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.baud_rate_ = value;
}
inline void Stream_Serial::set_baud_rate(int32_t value) {
  _internal_set_baud_rate(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Serial.baud_rate)
}

// -------------------------------------------------------------------

// Stream_Tcp

// optional bytes address = 1;
inline bool Stream_Tcp::_internal_has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream_Tcp::has_address() const {
  return _internal_has_address();
}
inline void Stream_Tcp::clear_address() {
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Stream_Tcp::address() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Tcp.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Tcp::set_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Tcp.address)
}
inline std::string* Stream_Tcp::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Tcp.address)
  return _s;
}
inline const std::string& Stream_Tcp::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Stream_Tcp::_internal_set_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream_Tcp::_internal_mutable_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream_Tcp::release_address() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Tcp.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Stream_Tcp::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Tcp.address)
}

// optional int32 port = 2 [default = 3001];
inline bool Stream_Tcp::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream_Tcp::has_port() const {
  return _internal_has_port();
}
inline void Stream_Tcp::clear_port() {
  _impl_.port_ = 3001;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Stream_Tcp::_internal_port() const {
  return _impl_.port_;
}
inline int32_t Stream_Tcp::port() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Tcp.port)
  return _internal_port();
}
inline void Stream_Tcp::_internal_set_port(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.port_ = value;
}
inline void Stream_Tcp::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Tcp.port)
}

// -------------------------------------------------------------------

// Stream_Udp

// optional bytes address = 1;
inline bool Stream_Udp::_internal_has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream_Udp::has_address() const {
  return _internal_has_address();
}
inline void Stream_Udp::clear_address() {
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Stream_Udp::address() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Udp.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Udp::set_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Udp.address)
}
inline std::string* Stream_Udp::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Udp.address)
  return _s;
}
inline const std::string& Stream_Udp::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Stream_Udp::_internal_set_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream_Udp::_internal_mutable_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream_Udp::release_address() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Udp.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Stream_Udp::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Udp.address)
}

// optional int32 port = 2 [default = 3001];
inline bool Stream_Udp::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream_Udp::has_port() const {
  return _internal_has_port();
}
inline void Stream_Udp::clear_port() {
  _impl_.port_ = 3001;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Stream_Udp::_internal_port() const {
  return _impl_.port_;
}
inline int32_t Stream_Udp::port() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Udp.port)
  return _internal_port();
}
inline void Stream_Udp::_internal_set_port(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.port_ = value;
}
inline void Stream_Udp::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Udp.port)
}

// -------------------------------------------------------------------

// Stream_Ntrip

// optional bytes address = 1;
inline bool Stream_Ntrip::_internal_has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_address() const {
  return _internal_has_address();
}
inline void Stream_Ntrip::clear_address() {
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Stream_Ntrip::address() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Ntrip::set_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.address)
}
inline std::string* Stream_Ntrip::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Ntrip.address)
  return _s;
}
inline const std::string& Stream_Ntrip::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Stream_Ntrip::_internal_set_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::_internal_mutable_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::release_address() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Ntrip.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Stream_Ntrip::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Ntrip.address)
}

// optional int32 port = 2 [default = 2101];
inline bool Stream_Ntrip::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_port() const {
  return _internal_has_port();
}
inline void Stream_Ntrip::clear_port() {
  _impl_.port_ = 2101;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Stream_Ntrip::_internal_port() const {
  return _impl_.port_;
}
inline int32_t Stream_Ntrip::port() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.port)
  return _internal_port();
}
inline void Stream_Ntrip::_internal_set_port(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.port_ = value;
}
inline void Stream_Ntrip::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.port)
}

// optional bytes mount_point = 3;
inline bool Stream_Ntrip::_internal_has_mount_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_mount_point() const {
  return _internal_has_mount_point();
}
inline void Stream_Ntrip::clear_mount_point() {
  _impl_.mount_point_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Stream_Ntrip::mount_point() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.mount_point)
  return _internal_mount_point();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Ntrip::set_mount_point(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mount_point_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.mount_point)
}
inline std::string* Stream_Ntrip::mutable_mount_point() {
  std::string* _s = _internal_mutable_mount_point();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Ntrip.mount_point)
  return _s;
}
inline const std::string& Stream_Ntrip::_internal_mount_point() const {
  return _impl_.mount_point_.Get();
}
inline void Stream_Ntrip::_internal_set_mount_point(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mount_point_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::_internal_mutable_mount_point() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mount_point_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::release_mount_point() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Ntrip.mount_point)
  if (!_internal_has_mount_point()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mount_point_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mount_point_.IsDefault()) {
    _impl_.mount_point_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Stream_Ntrip::set_allocated_mount_point(std::string* mount_point) {
  if (mount_point != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mount_point_.SetAllocated(mount_point, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mount_point_.IsDefault()) {
    _impl_.mount_point_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Ntrip.mount_point)
}

// optional bytes user = 4;
inline bool Stream_Ntrip::_internal_has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_user() const {
  return _internal_has_user();
}
inline void Stream_Ntrip::clear_user() {
  _impl_.user_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Stream_Ntrip::user() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Ntrip::set_user(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.user_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.user)
}
inline std::string* Stream_Ntrip::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Ntrip.user)
  return _s;
}
inline const std::string& Stream_Ntrip::_internal_user() const {
  return _impl_.user_.Get();
}
inline void Stream_Ntrip::_internal_set_user(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::release_user() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Ntrip.user)
  if (!_internal_has_user()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.user_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Stream_Ntrip::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Ntrip.user)
}

// optional bytes password = 5;
inline bool Stream_Ntrip::_internal_has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_password() const {
  return _internal_has_password();
}
inline void Stream_Ntrip::clear_password() {
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Stream_Ntrip::password() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Ntrip::set_password(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.password_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.password)
}
inline std::string* Stream_Ntrip::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Ntrip.password)
  return _s;
}
inline const std::string& Stream_Ntrip::_internal_password() const {
  return _impl_.password_.Get();
}
inline void Stream_Ntrip::_internal_set_password(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::_internal_mutable_password() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::release_password() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Ntrip.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.password_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Stream_Ntrip::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Ntrip.password)
}

// optional uint32 timeout_s = 6 [default = 30];
inline bool Stream_Ntrip::_internal_has_timeout_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_timeout_s() const {
  return _internal_has_timeout_s();
}
inline void Stream_Ntrip::clear_timeout_s() {
  _impl_.timeout_s_ = 30u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t Stream_Ntrip::_internal_timeout_s() const {
  return _impl_.timeout_s_;
}
inline uint32_t Stream_Ntrip::timeout_s() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.timeout_s)
  return _internal_timeout_s();
}
inline void Stream_Ntrip::_internal_set_timeout_s(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.timeout_s_ = value;
}
inline void Stream_Ntrip::set_timeout_s(uint32_t value) {
  _internal_set_timeout_s(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.timeout_s)
}

// -------------------------------------------------------------------

// Stream

// optional .apollo.drivers.gnss.config.Stream.Format format = 1;
inline bool Stream::_internal_has_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream::has_format() const {
  return _internal_has_format();
}
inline void Stream::clear_format() {
  _impl_.format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::drivers::gnss::config::Stream_Format Stream::_internal_format() const {
  return static_cast< ::apollo::drivers::gnss::config::Stream_Format >(_impl_.format_);
}
inline ::apollo::drivers::gnss::config::Stream_Format Stream::format() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.format)
  return _internal_format();
}
inline void Stream::_internal_set_format(::apollo::drivers::gnss::config::Stream_Format value) {
  assert(::apollo::drivers::gnss::config::Stream_Format_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.format_ = value;
}
inline void Stream::set_format(::apollo::drivers::gnss::config::Stream_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.format)
}

// .apollo.drivers.gnss.config.Stream.Serial serial = 2;
inline bool Stream::_internal_has_serial() const {
  return type_case() == kSerial;
}
inline bool Stream::has_serial() const {
  return _internal_has_serial();
}
inline void Stream::set_has_serial() {
  _impl_._oneof_case_[0] = kSerial;
}
inline void Stream::clear_serial() {
  if (_internal_has_serial()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.serial_;
    }
    clear_has_type();
  }
}
inline ::apollo::drivers::gnss::config::Stream_Serial* Stream::release_serial() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.serial)
  if (_internal_has_serial()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Serial* temp = _impl_.type_.serial_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.serial_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::Stream_Serial& Stream::_internal_serial() const {
  return _internal_has_serial()
      ? *_impl_.type_.serial_
      : reinterpret_cast< ::apollo::drivers::gnss::config::Stream_Serial&>(::apollo::drivers::gnss::config::_Stream_Serial_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream_Serial& Stream::serial() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.serial)
  return _internal_serial();
}
inline ::apollo::drivers::gnss::config::Stream_Serial* Stream::unsafe_arena_release_serial() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Stream.serial)
  if (_internal_has_serial()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Serial* temp = _impl_.type_.serial_;
    _impl_.type_.serial_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_serial(::apollo::drivers::gnss::config::Stream_Serial* serial) {
  clear_type();
  if (serial) {
    set_has_serial();
    _impl_.type_.serial_ = serial;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Stream.serial)
}
inline ::apollo::drivers::gnss::config::Stream_Serial* Stream::_internal_mutable_serial() {
  if (!_internal_has_serial()) {
    clear_type();
    set_has_serial();
    _impl_.type_.serial_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::Stream_Serial >(GetArenaForAllocation());
  }
  return _impl_.type_.serial_;
}
inline ::apollo::drivers::gnss::config::Stream_Serial* Stream::mutable_serial() {
  ::apollo::drivers::gnss::config::Stream_Serial* _msg = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.serial)
  return _msg;
}

// .apollo.drivers.gnss.config.Stream.Tcp tcp = 3;
inline bool Stream::_internal_has_tcp() const {
  return type_case() == kTcp;
}
inline bool Stream::has_tcp() const {
  return _internal_has_tcp();
}
inline void Stream::set_has_tcp() {
  _impl_._oneof_case_[0] = kTcp;
}
inline void Stream::clear_tcp() {
  if (_internal_has_tcp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.tcp_;
    }
    clear_has_type();
  }
}
inline ::apollo::drivers::gnss::config::Stream_Tcp* Stream::release_tcp() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.tcp)
  if (_internal_has_tcp()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Tcp* temp = _impl_.type_.tcp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.tcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::Stream_Tcp& Stream::_internal_tcp() const {
  return _internal_has_tcp()
      ? *_impl_.type_.tcp_
      : reinterpret_cast< ::apollo::drivers::gnss::config::Stream_Tcp&>(::apollo::drivers::gnss::config::_Stream_Tcp_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream_Tcp& Stream::tcp() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.tcp)
  return _internal_tcp();
}
inline ::apollo::drivers::gnss::config::Stream_Tcp* Stream::unsafe_arena_release_tcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Stream.tcp)
  if (_internal_has_tcp()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Tcp* temp = _impl_.type_.tcp_;
    _impl_.type_.tcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_tcp(::apollo::drivers::gnss::config::Stream_Tcp* tcp) {
  clear_type();
  if (tcp) {
    set_has_tcp();
    _impl_.type_.tcp_ = tcp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Stream.tcp)
}
inline ::apollo::drivers::gnss::config::Stream_Tcp* Stream::_internal_mutable_tcp() {
  if (!_internal_has_tcp()) {
    clear_type();
    set_has_tcp();
    _impl_.type_.tcp_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::Stream_Tcp >(GetArenaForAllocation());
  }
  return _impl_.type_.tcp_;
}
inline ::apollo::drivers::gnss::config::Stream_Tcp* Stream::mutable_tcp() {
  ::apollo::drivers::gnss::config::Stream_Tcp* _msg = _internal_mutable_tcp();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.tcp)
  return _msg;
}

// .apollo.drivers.gnss.config.Stream.Udp udp = 4;
inline bool Stream::_internal_has_udp() const {
  return type_case() == kUdp;
}
inline bool Stream::has_udp() const {
  return _internal_has_udp();
}
inline void Stream::set_has_udp() {
  _impl_._oneof_case_[0] = kUdp;
}
inline void Stream::clear_udp() {
  if (_internal_has_udp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.udp_;
    }
    clear_has_type();
  }
}
inline ::apollo::drivers::gnss::config::Stream_Udp* Stream::release_udp() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.udp)
  if (_internal_has_udp()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Udp* temp = _impl_.type_.udp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.udp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::Stream_Udp& Stream::_internal_udp() const {
  return _internal_has_udp()
      ? *_impl_.type_.udp_
      : reinterpret_cast< ::apollo::drivers::gnss::config::Stream_Udp&>(::apollo::drivers::gnss::config::_Stream_Udp_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream_Udp& Stream::udp() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.udp)
  return _internal_udp();
}
inline ::apollo::drivers::gnss::config::Stream_Udp* Stream::unsafe_arena_release_udp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Stream.udp)
  if (_internal_has_udp()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Udp* temp = _impl_.type_.udp_;
    _impl_.type_.udp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_udp(::apollo::drivers::gnss::config::Stream_Udp* udp) {
  clear_type();
  if (udp) {
    set_has_udp();
    _impl_.type_.udp_ = udp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Stream.udp)
}
inline ::apollo::drivers::gnss::config::Stream_Udp* Stream::_internal_mutable_udp() {
  if (!_internal_has_udp()) {
    clear_type();
    set_has_udp();
    _impl_.type_.udp_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::Stream_Udp >(GetArenaForAllocation());
  }
  return _impl_.type_.udp_;
}
inline ::apollo::drivers::gnss::config::Stream_Udp* Stream::mutable_udp() {
  ::apollo::drivers::gnss::config::Stream_Udp* _msg = _internal_mutable_udp();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.udp)
  return _msg;
}

// .apollo.drivers.gnss.config.Stream.Ntrip ntrip = 5;
inline bool Stream::_internal_has_ntrip() const {
  return type_case() == kNtrip;
}
inline bool Stream::has_ntrip() const {
  return _internal_has_ntrip();
}
inline void Stream::set_has_ntrip() {
  _impl_._oneof_case_[0] = kNtrip;
}
inline void Stream::clear_ntrip() {
  if (_internal_has_ntrip()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.ntrip_;
    }
    clear_has_type();
  }
}
inline ::apollo::drivers::gnss::config::Stream_Ntrip* Stream::release_ntrip() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.ntrip)
  if (_internal_has_ntrip()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Ntrip* temp = _impl_.type_.ntrip_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.ntrip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::Stream_Ntrip& Stream::_internal_ntrip() const {
  return _internal_has_ntrip()
      ? *_impl_.type_.ntrip_
      : reinterpret_cast< ::apollo::drivers::gnss::config::Stream_Ntrip&>(::apollo::drivers::gnss::config::_Stream_Ntrip_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream_Ntrip& Stream::ntrip() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.ntrip)
  return _internal_ntrip();
}
inline ::apollo::drivers::gnss::config::Stream_Ntrip* Stream::unsafe_arena_release_ntrip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Stream.ntrip)
  if (_internal_has_ntrip()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Ntrip* temp = _impl_.type_.ntrip_;
    _impl_.type_.ntrip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_ntrip(::apollo::drivers::gnss::config::Stream_Ntrip* ntrip) {
  clear_type();
  if (ntrip) {
    set_has_ntrip();
    _impl_.type_.ntrip_ = ntrip;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Stream.ntrip)
}
inline ::apollo::drivers::gnss::config::Stream_Ntrip* Stream::_internal_mutable_ntrip() {
  if (!_internal_has_ntrip()) {
    clear_type();
    set_has_ntrip();
    _impl_.type_.ntrip_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::Stream_Ntrip >(GetArenaForAllocation());
  }
  return _impl_.type_.ntrip_;
}
inline ::apollo::drivers::gnss::config::Stream_Ntrip* Stream::mutable_ntrip() {
  ::apollo::drivers::gnss::config::Stream_Ntrip* _msg = _internal_mutable_ntrip();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.ntrip)
  return _msg;
}

// optional bool push_location = 6;
inline bool Stream::_internal_has_push_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream::has_push_location() const {
  return _internal_has_push_location();
}
inline void Stream::clear_push_location() {
  _impl_.push_location_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Stream::_internal_push_location() const {
  return _impl_.push_location_;
}
inline bool Stream::push_location() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.push_location)
  return _internal_push_location();
}
inline void Stream::_internal_set_push_location(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.push_location_ = value;
}
inline void Stream::set_push_location(bool value) {
  _internal_set_push_location(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.push_location)
}

inline bool Stream::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Stream::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Stream::TypeCase Stream::type_case() const {
  return Stream::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NovatelConfig

// optional int32 imu_orientation = 1 [default = 5];
inline bool NovatelConfig::_internal_has_imu_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NovatelConfig::has_imu_orientation() const {
  return _internal_has_imu_orientation();
}
inline void NovatelConfig::clear_imu_orientation() {
  _impl_.imu_orientation_ = 5;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t NovatelConfig::_internal_imu_orientation() const {
  return _impl_.imu_orientation_;
}
inline int32_t NovatelConfig::imu_orientation() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.NovatelConfig.imu_orientation)
  return _internal_imu_orientation();
}
inline void NovatelConfig::_internal_set_imu_orientation(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.imu_orientation_ = value;
}
inline void NovatelConfig::set_imu_orientation(int32_t value) {
  _internal_set_imu_orientation(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.NovatelConfig.imu_orientation)
}

// -------------------------------------------------------------------

// UbloxConfig

// -------------------------------------------------------------------

// TF

// optional string frame_id = 1 [default = "world"];
inline bool TF::_internal_has_frame_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TF::has_frame_id() const {
  return _internal_has_frame_id();
}
inline void TF::clear_frame_id() {
  _impl_.frame_id_.ClearToDefault(::apollo::drivers::gnss::config::TF::Impl_::_i_give_permission_to_break_this_code_default_frame_id_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TF::frame_id() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.TF.frame_id)
  if (_impl_.frame_id_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_frame_id_.get();
  return _internal_frame_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TF::set_frame_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.frame_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.TF.frame_id)
}
inline std::string* TF::mutable_frame_id() {
  std::string* _s = _internal_mutable_frame_id();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.TF.frame_id)
  return _s;
}
inline const std::string& TF::_internal_frame_id() const {
  return _impl_.frame_id_.Get();
}
inline void TF::_internal_set_frame_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.frame_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TF::_internal_mutable_frame_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.frame_id_.Mutable(::apollo::drivers::gnss::config::TF::Impl_::_i_give_permission_to_break_this_code_default_frame_id_, GetArenaForAllocation());
}
inline std::string* TF::release_frame_id() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.TF.frame_id)
  if (!_internal_has_frame_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.frame_id_.Release();
  return p;
}
inline void TF::set_allocated_frame_id(std::string* frame_id) {
  if (frame_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.frame_id_.SetAllocated(frame_id, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.TF.frame_id)
}

// optional string child_frame_id = 2 [default = "novatel"];
inline bool TF::_internal_has_child_frame_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TF::has_child_frame_id() const {
  return _internal_has_child_frame_id();
}
inline void TF::clear_child_frame_id() {
  _impl_.child_frame_id_.ClearToDefault(::apollo::drivers::gnss::config::TF::Impl_::_i_give_permission_to_break_this_code_default_child_frame_id_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TF::child_frame_id() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.TF.child_frame_id)
  if (_impl_.child_frame_id_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_child_frame_id_.get();
  return _internal_child_frame_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TF::set_child_frame_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.child_frame_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.TF.child_frame_id)
}
inline std::string* TF::mutable_child_frame_id() {
  std::string* _s = _internal_mutable_child_frame_id();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.TF.child_frame_id)
  return _s;
}
inline const std::string& TF::_internal_child_frame_id() const {
  return _impl_.child_frame_id_.Get();
}
inline void TF::_internal_set_child_frame_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.child_frame_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TF::_internal_mutable_child_frame_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.child_frame_id_.Mutable(::apollo::drivers::gnss::config::TF::Impl_::_i_give_permission_to_break_this_code_default_child_frame_id_, GetArenaForAllocation());
}
inline std::string* TF::release_child_frame_id() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.TF.child_frame_id)
  if (!_internal_has_child_frame_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.child_frame_id_.Release();
  return p;
}
inline void TF::set_allocated_child_frame_id(std::string* child_frame_id) {
  if (child_frame_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.child_frame_id_.SetAllocated(child_frame_id, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.TF.child_frame_id)
}

// optional bool enable = 3 [default = false];
inline bool TF::_internal_has_enable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TF::has_enable() const {
  return _internal_has_enable();
}
inline void TF::clear_enable() {
  _impl_.enable_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TF::_internal_enable() const {
  return _impl_.enable_;
}
inline bool TF::enable() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.TF.enable)
  return _internal_enable();
}
inline void TF::_internal_set_enable(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.enable_ = value;
}
inline void TF::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.TF.enable)
}

// -------------------------------------------------------------------

// Config

// optional .apollo.drivers.gnss.config.Stream data = 1;
inline bool Config::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline bool Config::has_data() const {
  return _internal_has_data();
}
inline void Config::clear_data() {
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::drivers::gnss::config::Stream& Config::_internal_data() const {
  const ::apollo::drivers::gnss::config::Stream* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::gnss::config::Stream&>(
      ::apollo::drivers::gnss::config::_Stream_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream& Config::data() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.data)
  return _internal_data();
}
inline void Config::unsafe_arena_set_allocated_data(
    ::apollo::drivers::gnss::config::Stream* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.data)
}
inline ::apollo::drivers::gnss::config::Stream* Config::release_data() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::drivers::gnss::config::Stream* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.data)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::drivers::gnss::config::Stream* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::gnss::config::Stream>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::apollo::drivers::gnss::config::Stream* Config::mutable_data() {
  ::apollo::drivers::gnss::config::Stream* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.data)
  return _msg;
}
inline void Config::set_allocated_data(::apollo::drivers::gnss::config::Stream* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.data)
}

// optional .apollo.drivers.gnss.config.Stream command = 2;
inline bool Config::_internal_has_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.command_ != nullptr);
  return value;
}
inline bool Config::has_command() const {
  return _internal_has_command();
}
inline void Config::clear_command() {
  if (_impl_.command_ != nullptr) _impl_.command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::drivers::gnss::config::Stream& Config::_internal_command() const {
  const ::apollo::drivers::gnss::config::Stream* p = _impl_.command_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::gnss::config::Stream&>(
      ::apollo::drivers::gnss::config::_Stream_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream& Config::command() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.command)
  return _internal_command();
}
inline void Config::unsafe_arena_set_allocated_command(
    ::apollo::drivers::gnss::config::Stream* command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_);
  }
  _impl_.command_ = command;
  if (command) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.command)
}
inline ::apollo::drivers::gnss::config::Stream* Config::release_command() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::drivers::gnss::config::Stream* temp = _impl_.command_;
  _impl_.command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.command)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::drivers::gnss::config::Stream* temp = _impl_.command_;
  _impl_.command_ = nullptr;
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::_internal_mutable_command() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.command_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::gnss::config::Stream>(GetArenaForAllocation());
    _impl_.command_ = p;
  }
  return _impl_.command_;
}
inline ::apollo::drivers::gnss::config::Stream* Config::mutable_command() {
  ::apollo::drivers::gnss::config::Stream* _msg = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.command)
  return _msg;
}
inline void Config::set_allocated_command(::apollo::drivers::gnss::config::Stream* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.command_;
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(command);
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.command_ = command;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.command)
}

// optional .apollo.drivers.gnss.config.Stream rtk_from = 3;
inline bool Config::_internal_has_rtk_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rtk_from_ != nullptr);
  return value;
}
inline bool Config::has_rtk_from() const {
  return _internal_has_rtk_from();
}
inline void Config::clear_rtk_from() {
  if (_impl_.rtk_from_ != nullptr) _impl_.rtk_from_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::apollo::drivers::gnss::config::Stream& Config::_internal_rtk_from() const {
  const ::apollo::drivers::gnss::config::Stream* p = _impl_.rtk_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::gnss::config::Stream&>(
      ::apollo::drivers::gnss::config::_Stream_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream& Config::rtk_from() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.rtk_from)
  return _internal_rtk_from();
}
inline void Config::unsafe_arena_set_allocated_rtk_from(
    ::apollo::drivers::gnss::config::Stream* rtk_from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rtk_from_);
  }
  _impl_.rtk_from_ = rtk_from;
  if (rtk_from) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.rtk_from)
}
inline ::apollo::drivers::gnss::config::Stream* Config::release_rtk_from() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::apollo::drivers::gnss::config::Stream* temp = _impl_.rtk_from_;
  _impl_.rtk_from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::unsafe_arena_release_rtk_from() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.rtk_from)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::apollo::drivers::gnss::config::Stream* temp = _impl_.rtk_from_;
  _impl_.rtk_from_ = nullptr;
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::_internal_mutable_rtk_from() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.rtk_from_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::gnss::config::Stream>(GetArenaForAllocation());
    _impl_.rtk_from_ = p;
  }
  return _impl_.rtk_from_;
}
inline ::apollo::drivers::gnss::config::Stream* Config::mutable_rtk_from() {
  ::apollo::drivers::gnss::config::Stream* _msg = _internal_mutable_rtk_from();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.rtk_from)
  return _msg;
}
inline void Config::set_allocated_rtk_from(::apollo::drivers::gnss::config::Stream* rtk_from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rtk_from_;
  }
  if (rtk_from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rtk_from);
    if (message_arena != submessage_arena) {
      rtk_from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtk_from, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.rtk_from_ = rtk_from;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.rtk_from)
}

// optional .apollo.drivers.gnss.config.Stream rtk_to = 4;
inline bool Config::_internal_has_rtk_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rtk_to_ != nullptr);
  return value;
}
inline bool Config::has_rtk_to() const {
  return _internal_has_rtk_to();
}
inline void Config::clear_rtk_to() {
  if (_impl_.rtk_to_ != nullptr) _impl_.rtk_to_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::apollo::drivers::gnss::config::Stream& Config::_internal_rtk_to() const {
  const ::apollo::drivers::gnss::config::Stream* p = _impl_.rtk_to_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::gnss::config::Stream&>(
      ::apollo::drivers::gnss::config::_Stream_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream& Config::rtk_to() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.rtk_to)
  return _internal_rtk_to();
}
inline void Config::unsafe_arena_set_allocated_rtk_to(
    ::apollo::drivers::gnss::config::Stream* rtk_to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rtk_to_);
  }
  _impl_.rtk_to_ = rtk_to;
  if (rtk_to) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.rtk_to)
}
inline ::apollo::drivers::gnss::config::Stream* Config::release_rtk_to() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::apollo::drivers::gnss::config::Stream* temp = _impl_.rtk_to_;
  _impl_.rtk_to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::unsafe_arena_release_rtk_to() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.rtk_to)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::apollo::drivers::gnss::config::Stream* temp = _impl_.rtk_to_;
  _impl_.rtk_to_ = nullptr;
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::_internal_mutable_rtk_to() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.rtk_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::gnss::config::Stream>(GetArenaForAllocation());
    _impl_.rtk_to_ = p;
  }
  return _impl_.rtk_to_;
}
inline ::apollo::drivers::gnss::config::Stream* Config::mutable_rtk_to() {
  ::apollo::drivers::gnss::config::Stream* _msg = _internal_mutable_rtk_to();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.rtk_to)
  return _msg;
}
inline void Config::set_allocated_rtk_to(::apollo::drivers::gnss::config::Stream* rtk_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rtk_to_;
  }
  if (rtk_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rtk_to);
    if (message_arena != submessage_arena) {
      rtk_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtk_to, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.rtk_to_ = rtk_to;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.rtk_to)
}

// repeated bytes login_commands = 5;
inline int Config::_internal_login_commands_size() const {
  return _impl_.login_commands_.size();
}
inline int Config::login_commands_size() const {
  return _internal_login_commands_size();
}
inline void Config::clear_login_commands() {
  _impl_.login_commands_.Clear();
}
inline std::string* Config::add_login_commands() {
  std::string* _s = _internal_add_login_commands();
  // @@protoc_insertion_point(field_add_mutable:apollo.drivers.gnss.config.Config.login_commands)
  return _s;
}
inline const std::string& Config::_internal_login_commands(int index) const {
  return _impl_.login_commands_.Get(index);
}
inline const std::string& Config::login_commands(int index) const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.login_commands)
  return _internal_login_commands(index);
}
inline std::string* Config::mutable_login_commands(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.login_commands)
  return _impl_.login_commands_.Mutable(index);
}
inline void Config::set_login_commands(int index, const std::string& value) {
  _impl_.login_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::set_login_commands(int index, std::string&& value) {
  _impl_.login_commands_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::set_login_commands(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.login_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::set_login_commands(int index, const void* value, size_t size) {
  _impl_.login_commands_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.drivers.gnss.config.Config.login_commands)
}
inline std::string* Config::_internal_add_login_commands() {
  return _impl_.login_commands_.Add();
}
inline void Config::add_login_commands(const std::string& value) {
  _impl_.login_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::add_login_commands(std::string&& value) {
  _impl_.login_commands_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::add_login_commands(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.login_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::add_login_commands(const void* value, size_t size) {
  _impl_.login_commands_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.drivers.gnss.config.Config.login_commands)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Config::login_commands() const {
  // @@protoc_insertion_point(field_list:apollo.drivers.gnss.config.Config.login_commands)
  return _impl_.login_commands_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Config::mutable_login_commands() {
  // @@protoc_insertion_point(field_mutable_list:apollo.drivers.gnss.config.Config.login_commands)
  return &_impl_.login_commands_;
}

// repeated bytes logout_commands = 6;
inline int Config::_internal_logout_commands_size() const {
  return _impl_.logout_commands_.size();
}
inline int Config::logout_commands_size() const {
  return _internal_logout_commands_size();
}
inline void Config::clear_logout_commands() {
  _impl_.logout_commands_.Clear();
}
inline std::string* Config::add_logout_commands() {
  std::string* _s = _internal_add_logout_commands();
  // @@protoc_insertion_point(field_add_mutable:apollo.drivers.gnss.config.Config.logout_commands)
  return _s;
}
inline const std::string& Config::_internal_logout_commands(int index) const {
  return _impl_.logout_commands_.Get(index);
}
inline const std::string& Config::logout_commands(int index) const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.logout_commands)
  return _internal_logout_commands(index);
}
inline std::string* Config::mutable_logout_commands(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.logout_commands)
  return _impl_.logout_commands_.Mutable(index);
}
inline void Config::set_logout_commands(int index, const std::string& value) {
  _impl_.logout_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::set_logout_commands(int index, std::string&& value) {
  _impl_.logout_commands_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::set_logout_commands(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.logout_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::set_logout_commands(int index, const void* value, size_t size) {
  _impl_.logout_commands_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.drivers.gnss.config.Config.logout_commands)
}
inline std::string* Config::_internal_add_logout_commands() {
  return _impl_.logout_commands_.Add();
}
inline void Config::add_logout_commands(const std::string& value) {
  _impl_.logout_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::add_logout_commands(std::string&& value) {
  _impl_.logout_commands_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::add_logout_commands(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.logout_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::add_logout_commands(const void* value, size_t size) {
  _impl_.logout_commands_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.drivers.gnss.config.Config.logout_commands)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Config::logout_commands() const {
  // @@protoc_insertion_point(field_list:apollo.drivers.gnss.config.Config.logout_commands)
  return _impl_.logout_commands_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Config::mutable_logout_commands() {
  // @@protoc_insertion_point(field_mutable_list:apollo.drivers.gnss.config.Config.logout_commands)
  return &_impl_.logout_commands_;
}

// .apollo.drivers.gnss.config.NovatelConfig novatel_config = 7;
inline bool Config::_internal_has_novatel_config() const {
  return device_config_case() == kNovatelConfig;
}
inline bool Config::has_novatel_config() const {
  return _internal_has_novatel_config();
}
inline void Config::set_has_novatel_config() {
  _impl_._oneof_case_[0] = kNovatelConfig;
}
inline void Config::clear_novatel_config() {
  if (_internal_has_novatel_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.device_config_.novatel_config_;
    }
    clear_has_device_config();
  }
}
inline ::apollo::drivers::gnss::config::NovatelConfig* Config::release_novatel_config() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.novatel_config)
  if (_internal_has_novatel_config()) {
    clear_has_device_config();
    ::apollo::drivers::gnss::config::NovatelConfig* temp = _impl_.device_config_.novatel_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.device_config_.novatel_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::NovatelConfig& Config::_internal_novatel_config() const {
  return _internal_has_novatel_config()
      ? *_impl_.device_config_.novatel_config_
      : reinterpret_cast< ::apollo::drivers::gnss::config::NovatelConfig&>(::apollo::drivers::gnss::config::_NovatelConfig_default_instance_);
}
inline const ::apollo::drivers::gnss::config::NovatelConfig& Config::novatel_config() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.novatel_config)
  return _internal_novatel_config();
}
inline ::apollo::drivers::gnss::config::NovatelConfig* Config::unsafe_arena_release_novatel_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Config.novatel_config)
  if (_internal_has_novatel_config()) {
    clear_has_device_config();
    ::apollo::drivers::gnss::config::NovatelConfig* temp = _impl_.device_config_.novatel_config_;
    _impl_.device_config_.novatel_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_novatel_config(::apollo::drivers::gnss::config::NovatelConfig* novatel_config) {
  clear_device_config();
  if (novatel_config) {
    set_has_novatel_config();
    _impl_.device_config_.novatel_config_ = novatel_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.novatel_config)
}
inline ::apollo::drivers::gnss::config::NovatelConfig* Config::_internal_mutable_novatel_config() {
  if (!_internal_has_novatel_config()) {
    clear_device_config();
    set_has_novatel_config();
    _impl_.device_config_.novatel_config_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::NovatelConfig >(GetArenaForAllocation());
  }
  return _impl_.device_config_.novatel_config_;
}
inline ::apollo::drivers::gnss::config::NovatelConfig* Config::mutable_novatel_config() {
  ::apollo::drivers::gnss::config::NovatelConfig* _msg = _internal_mutable_novatel_config();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.novatel_config)
  return _msg;
}

// .apollo.drivers.gnss.config.UbloxConfig ublox_config = 8;
inline bool Config::_internal_has_ublox_config() const {
  return device_config_case() == kUbloxConfig;
}
inline bool Config::has_ublox_config() const {
  return _internal_has_ublox_config();
}
inline void Config::set_has_ublox_config() {
  _impl_._oneof_case_[0] = kUbloxConfig;
}
inline void Config::clear_ublox_config() {
  if (_internal_has_ublox_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.device_config_.ublox_config_;
    }
    clear_has_device_config();
  }
}
inline ::apollo::drivers::gnss::config::UbloxConfig* Config::release_ublox_config() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.ublox_config)
  if (_internal_has_ublox_config()) {
    clear_has_device_config();
    ::apollo::drivers::gnss::config::UbloxConfig* temp = _impl_.device_config_.ublox_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.device_config_.ublox_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::UbloxConfig& Config::_internal_ublox_config() const {
  return _internal_has_ublox_config()
      ? *_impl_.device_config_.ublox_config_
      : reinterpret_cast< ::apollo::drivers::gnss::config::UbloxConfig&>(::apollo::drivers::gnss::config::_UbloxConfig_default_instance_);
}
inline const ::apollo::drivers::gnss::config::UbloxConfig& Config::ublox_config() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.ublox_config)
  return _internal_ublox_config();
}
inline ::apollo::drivers::gnss::config::UbloxConfig* Config::unsafe_arena_release_ublox_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Config.ublox_config)
  if (_internal_has_ublox_config()) {
    clear_has_device_config();
    ::apollo::drivers::gnss::config::UbloxConfig* temp = _impl_.device_config_.ublox_config_;
    _impl_.device_config_.ublox_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_ublox_config(::apollo::drivers::gnss::config::UbloxConfig* ublox_config) {
  clear_device_config();
  if (ublox_config) {
    set_has_ublox_config();
    _impl_.device_config_.ublox_config_ = ublox_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.ublox_config)
}
inline ::apollo::drivers::gnss::config::UbloxConfig* Config::_internal_mutable_ublox_config() {
  if (!_internal_has_ublox_config()) {
    clear_device_config();
    set_has_ublox_config();
    _impl_.device_config_.ublox_config_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::UbloxConfig >(GetArenaForAllocation());
  }
  return _impl_.device_config_.ublox_config_;
}
inline ::apollo::drivers::gnss::config::UbloxConfig* Config::mutable_ublox_config() {
  ::apollo::drivers::gnss::config::UbloxConfig* _msg = _internal_mutable_ublox_config();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.ublox_config)
  return _msg;
}

// optional .apollo.drivers.gnss.config.Config.RtkSolutionType rtk_solution_type = 9;
inline bool Config::_internal_has_rtk_solution_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Config::has_rtk_solution_type() const {
  return _internal_has_rtk_solution_type();
}
inline void Config::clear_rtk_solution_type() {
  _impl_.rtk_solution_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::apollo::drivers::gnss::config::Config_RtkSolutionType Config::_internal_rtk_solution_type() const {
  return static_cast< ::apollo::drivers::gnss::config::Config_RtkSolutionType >(_impl_.rtk_solution_type_);
}
inline ::apollo::drivers::gnss::config::Config_RtkSolutionType Config::rtk_solution_type() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.rtk_solution_type)
  return _internal_rtk_solution_type();
}
inline void Config::_internal_set_rtk_solution_type(::apollo::drivers::gnss::config::Config_RtkSolutionType value) {
  assert(::apollo::drivers::gnss::config::Config_RtkSolutionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.rtk_solution_type_ = value;
}
inline void Config::set_rtk_solution_type(::apollo::drivers::gnss::config::Config_RtkSolutionType value) {
  _internal_set_rtk_solution_type(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.rtk_solution_type)
}

// optional .apollo.drivers.gnss.config.ImuType imu_type = 10;
inline bool Config::_internal_has_imu_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Config::has_imu_type() const {
  return _internal_has_imu_type();
}
inline void Config::clear_imu_type() {
  _impl_.imu_type_ = 13;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::apollo::drivers::gnss::config::ImuType Config::_internal_imu_type() const {
  return static_cast< ::apollo::drivers::gnss::config::ImuType >(_impl_.imu_type_);
}
inline ::apollo::drivers::gnss::config::ImuType Config::imu_type() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.imu_type)
  return _internal_imu_type();
}
inline void Config::_internal_set_imu_type(::apollo::drivers::gnss::config::ImuType value) {
  assert(::apollo::drivers::gnss::config::ImuType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.imu_type_ = value;
}
inline void Config::set_imu_type(::apollo::drivers::gnss::config::ImuType value) {
  _internal_set_imu_type(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.imu_type)
}

// optional string proj4_text = 11;
inline bool Config::_internal_has_proj4_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Config::has_proj4_text() const {
  return _internal_has_proj4_text();
}
inline void Config::clear_proj4_text() {
  _impl_.proj4_text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Config::proj4_text() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.proj4_text)
  return _internal_proj4_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config::set_proj4_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.proj4_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.proj4_text)
}
inline std::string* Config::mutable_proj4_text() {
  std::string* _s = _internal_mutable_proj4_text();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.proj4_text)
  return _s;
}
inline const std::string& Config::_internal_proj4_text() const {
  return _impl_.proj4_text_.Get();
}
inline void Config::_internal_set_proj4_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.proj4_text_.Set(value, GetArenaForAllocation());
}
inline std::string* Config::_internal_mutable_proj4_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.proj4_text_.Mutable(GetArenaForAllocation());
}
inline std::string* Config::release_proj4_text() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.proj4_text)
  if (!_internal_has_proj4_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.proj4_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proj4_text_.IsDefault()) {
    _impl_.proj4_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Config::set_allocated_proj4_text(std::string* proj4_text) {
  if (proj4_text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.proj4_text_.SetAllocated(proj4_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proj4_text_.IsDefault()) {
    _impl_.proj4_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.proj4_text)
}

// optional .apollo.drivers.gnss.config.TF tf = 12;
inline bool Config::_internal_has_tf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tf_ != nullptr);
  return value;
}
inline bool Config::has_tf() const {
  return _internal_has_tf();
}
inline void Config::clear_tf() {
  if (_impl_.tf_ != nullptr) _impl_.tf_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::apollo::drivers::gnss::config::TF& Config::_internal_tf() const {
  const ::apollo::drivers::gnss::config::TF* p = _impl_.tf_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::gnss::config::TF&>(
      ::apollo::drivers::gnss::config::_TF_default_instance_);
}
inline const ::apollo::drivers::gnss::config::TF& Config::tf() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.tf)
  return _internal_tf();
}
inline void Config::unsafe_arena_set_allocated_tf(
    ::apollo::drivers::gnss::config::TF* tf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tf_);
  }
  _impl_.tf_ = tf;
  if (tf) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.tf)
}
inline ::apollo::drivers::gnss::config::TF* Config::release_tf() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::apollo::drivers::gnss::config::TF* temp = _impl_.tf_;
  _impl_.tf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::gnss::config::TF* Config::unsafe_arena_release_tf() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.tf)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::apollo::drivers::gnss::config::TF* temp = _impl_.tf_;
  _impl_.tf_ = nullptr;
  return temp;
}
inline ::apollo::drivers::gnss::config::TF* Config::_internal_mutable_tf() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.tf_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::gnss::config::TF>(GetArenaForAllocation());
    _impl_.tf_ = p;
  }
  return _impl_.tf_;
}
inline ::apollo::drivers::gnss::config::TF* Config::mutable_tf() {
  ::apollo::drivers::gnss::config::TF* _msg = _internal_mutable_tf();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.tf)
  return _msg;
}
inline void Config::set_allocated_tf(::apollo::drivers::gnss::config::TF* tf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tf_;
  }
  if (tf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tf);
    if (message_arena != submessage_arena) {
      tf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tf, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.tf_ = tf;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.tf)
}

// optional string wheel_parameters = 13;
inline bool Config::_internal_has_wheel_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Config::has_wheel_parameters() const {
  return _internal_has_wheel_parameters();
}
inline void Config::clear_wheel_parameters() {
  _impl_.wheel_parameters_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Config::wheel_parameters() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.wheel_parameters)
  return _internal_wheel_parameters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config::set_wheel_parameters(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.wheel_parameters_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.wheel_parameters)
}
inline std::string* Config::mutable_wheel_parameters() {
  std::string* _s = _internal_mutable_wheel_parameters();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.wheel_parameters)
  return _s;
}
inline const std::string& Config::_internal_wheel_parameters() const {
  return _impl_.wheel_parameters_.Get();
}
inline void Config::_internal_set_wheel_parameters(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wheel_parameters_.Set(value, GetArenaForAllocation());
}
inline std::string* Config::_internal_mutable_wheel_parameters() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.wheel_parameters_.Mutable(GetArenaForAllocation());
}
inline std::string* Config::release_wheel_parameters() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.wheel_parameters)
  if (!_internal_has_wheel_parameters()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.wheel_parameters_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wheel_parameters_.IsDefault()) {
    _impl_.wheel_parameters_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Config::set_allocated_wheel_parameters(std::string* wheel_parameters) {
  if (wheel_parameters != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.wheel_parameters_.SetAllocated(wheel_parameters, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wheel_parameters_.IsDefault()) {
    _impl_.wheel_parameters_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.wheel_parameters)
}

// optional string gpsbin_folder = 14;
inline bool Config::_internal_has_gpsbin_folder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Config::has_gpsbin_folder() const {
  return _internal_has_gpsbin_folder();
}
inline void Config::clear_gpsbin_folder() {
  _impl_.gpsbin_folder_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Config::gpsbin_folder() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.gpsbin_folder)
  return _internal_gpsbin_folder();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config::set_gpsbin_folder(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.gpsbin_folder_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.gpsbin_folder)
}
inline std::string* Config::mutable_gpsbin_folder() {
  std::string* _s = _internal_mutable_gpsbin_folder();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.gpsbin_folder)
  return _s;
}
inline const std::string& Config::_internal_gpsbin_folder() const {
  return _impl_.gpsbin_folder_.Get();
}
inline void Config::_internal_set_gpsbin_folder(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gpsbin_folder_.Set(value, GetArenaForAllocation());
}
inline std::string* Config::_internal_mutable_gpsbin_folder() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.gpsbin_folder_.Mutable(GetArenaForAllocation());
}
inline std::string* Config::release_gpsbin_folder() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.gpsbin_folder)
  if (!_internal_has_gpsbin_folder()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.gpsbin_folder_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gpsbin_folder_.IsDefault()) {
    _impl_.gpsbin_folder_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Config::set_allocated_gpsbin_folder(std::string* gpsbin_folder) {
  if (gpsbin_folder != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.gpsbin_folder_.SetAllocated(gpsbin_folder, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gpsbin_folder_.IsDefault()) {
    _impl_.gpsbin_folder_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.gpsbin_folder)
}

inline bool Config::has_device_config() const {
  return device_config_case() != DEVICE_CONFIG_NOT_SET;
}
inline void Config::clear_has_device_config() {
  _impl_._oneof_case_[0] = DEVICE_CONFIG_NOT_SET;
}
inline Config::DeviceConfigCase Config::device_config_case() const {
  return Config::DeviceConfigCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config
}  // namespace gnss
}  // namespace drivers
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::drivers::gnss::config::Stream_Format> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::gnss::config::Stream_Format>() {
  return ::apollo::drivers::gnss::config::Stream_Format_descriptor();
}
template <> struct is_proto_enum< ::apollo::drivers::gnss::config::Config_RtkSolutionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::gnss::config::Config_RtkSolutionType>() {
  return ::apollo::drivers::gnss::config::Config_RtkSolutionType_descriptor();
}
template <> struct is_proto_enum< ::apollo::drivers::gnss::config::ImuType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::gnss::config::ImuType>() {
  return ::apollo::drivers::gnss::config::ImuType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto
