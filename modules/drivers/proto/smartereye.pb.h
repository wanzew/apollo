// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/drivers/proto/smartereye.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fdrivers_2fproto_2fsmartereye_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fdrivers_2fproto_2fsmartereye_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/common/proto/header.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fdrivers_2fproto_2fsmartereye_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fdrivers_2fproto_2fsmartereye_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fdrivers_2fproto_2fsmartereye_2eproto;
namespace apollo {
namespace drivers {
class LdwDataPacks;
struct LdwDataPacksDefaultTypeInternal;
extern LdwDataPacksDefaultTypeInternal _LdwDataPacks_default_instance_;
class LdwLane;
struct LdwLaneDefaultTypeInternal;
extern LdwLaneDefaultTypeInternal _LdwLane_default_instance_;
class LdwLaneBoundary;
struct LdwLaneBoundaryDefaultTypeInternal;
extern LdwLaneBoundaryDefaultTypeInternal _LdwLaneBoundary_default_instance_;
class LdwLensInfo;
struct LdwLensInfoDefaultTypeInternal;
extern LdwLensInfoDefaultTypeInternal _LdwLensInfo_default_instance_;
class LdwRoadway;
struct LdwRoadwayDefaultTypeInternal;
extern LdwRoadwayDefaultTypeInternal _LdwRoadway_default_instance_;
class OutputObstacle;
struct OutputObstacleDefaultTypeInternal;
extern OutputObstacleDefaultTypeInternal _OutputObstacle_default_instance_;
class SmartereyeLanemark;
struct SmartereyeLanemarkDefaultTypeInternal;
extern SmartereyeLanemarkDefaultTypeInternal _SmartereyeLanemark_default_instance_;
class SmartereyeObstacles;
struct SmartereyeObstaclesDefaultTypeInternal;
extern SmartereyeObstaclesDefaultTypeInternal _SmartereyeObstacles_default_instance_;
class SmartereyeObstacles_OutputObstaclesEntry_DoNotUse;
struct SmartereyeObstacles_OutputObstaclesEntry_DoNotUseDefaultTypeInternal;
extern SmartereyeObstacles_OutputObstaclesEntry_DoNotUseDefaultTypeInternal _SmartereyeObstacles_OutputObstaclesEntry_DoNotUse_default_instance_;
}  // namespace drivers
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::drivers::LdwDataPacks* Arena::CreateMaybeMessage<::apollo::drivers::LdwDataPacks>(Arena*);
template<> ::apollo::drivers::LdwLane* Arena::CreateMaybeMessage<::apollo::drivers::LdwLane>(Arena*);
template<> ::apollo::drivers::LdwLaneBoundary* Arena::CreateMaybeMessage<::apollo::drivers::LdwLaneBoundary>(Arena*);
template<> ::apollo::drivers::LdwLensInfo* Arena::CreateMaybeMessage<::apollo::drivers::LdwLensInfo>(Arena*);
template<> ::apollo::drivers::LdwRoadway* Arena::CreateMaybeMessage<::apollo::drivers::LdwRoadway>(Arena*);
template<> ::apollo::drivers::OutputObstacle* Arena::CreateMaybeMessage<::apollo::drivers::OutputObstacle>(Arena*);
template<> ::apollo::drivers::SmartereyeLanemark* Arena::CreateMaybeMessage<::apollo::drivers::SmartereyeLanemark>(Arena*);
template<> ::apollo::drivers::SmartereyeObstacles* Arena::CreateMaybeMessage<::apollo::drivers::SmartereyeObstacles>(Arena*);
template<> ::apollo::drivers::SmartereyeObstacles_OutputObstaclesEntry_DoNotUse* Arena::CreateMaybeMessage<::apollo::drivers::SmartereyeObstacles_OutputObstaclesEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace drivers {

enum OutputObstacle_RecognitionType : int {
  OutputObstacle_RecognitionType_INVALID = 0,
  OutputObstacle_RecognitionType_VEHICLE = 1,
  OutputObstacle_RecognitionType_PEDESTRIAN = 2,
  OutputObstacle_RecognitionType_CHILD = 3,
  OutputObstacle_RecognitionType_BICYCLE = 4,
  OutputObstacle_RecognitionType_MOTO = 5,
  OutputObstacle_RecognitionType_TRUCK = 6,
  OutputObstacle_RecognitionType_BUS = 7,
  OutputObstacle_RecognitionType_OTHERS = 8,
  OutputObstacle_RecognitionType_ESTIMATED = 9,
  OutputObstacle_RecognitionType_CONTINUOUS = 10
};
bool OutputObstacle_RecognitionType_IsValid(int value);
constexpr OutputObstacle_RecognitionType OutputObstacle_RecognitionType_RecognitionType_MIN = OutputObstacle_RecognitionType_INVALID;
constexpr OutputObstacle_RecognitionType OutputObstacle_RecognitionType_RecognitionType_MAX = OutputObstacle_RecognitionType_CONTINUOUS;
constexpr int OutputObstacle_RecognitionType_RecognitionType_ARRAYSIZE = OutputObstacle_RecognitionType_RecognitionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OutputObstacle_RecognitionType_descriptor();
template<typename T>
inline const std::string& OutputObstacle_RecognitionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OutputObstacle_RecognitionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OutputObstacle_RecognitionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OutputObstacle_RecognitionType_descriptor(), enum_t_value);
}
inline bool OutputObstacle_RecognitionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OutputObstacle_RecognitionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OutputObstacle_RecognitionType>(
    OutputObstacle_RecognitionType_descriptor(), name, value);
}
enum LdwVersions : int {
  LDW_VERSION_C1 = 0,
  LDW_VERSION_C2 = 1,
  LDW_VERSION_FOUR_LANE_C2 = 2
};
bool LdwVersions_IsValid(int value);
constexpr LdwVersions LdwVersions_MIN = LDW_VERSION_C1;
constexpr LdwVersions LdwVersions_MAX = LDW_VERSION_FOUR_LANE_C2;
constexpr int LdwVersions_ARRAYSIZE = LdwVersions_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LdwVersions_descriptor();
template<typename T>
inline const std::string& LdwVersions_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LdwVersions>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LdwVersions_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LdwVersions_descriptor(), enum_t_value);
}
inline bool LdwVersions_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LdwVersions* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LdwVersions>(
    LdwVersions_descriptor(), name, value);
}
enum LdwLaneStyle : int {
  LDW_LANE_STYLE_NONE_LANE = 0,
  LDW_LANE_STYLE_PREDICT_LANE = 1,
  LDW_LANE_STYLE_BROKEN_LANE = 2,
  LDW_LANE_STYLE_SOLID_LANE = 3,
  LDW_LANE_STYLE_DOUBLE_BROKEN_LANE = 4,
  LDW_LANE_STYLE_DOUBLE_SOLID_LANE = 5,
  LDW_LANE_STYLE_TRIPLE_LANE = 6
};
bool LdwLaneStyle_IsValid(int value);
constexpr LdwLaneStyle LdwLaneStyle_MIN = LDW_LANE_STYLE_NONE_LANE;
constexpr LdwLaneStyle LdwLaneStyle_MAX = LDW_LANE_STYLE_TRIPLE_LANE;
constexpr int LdwLaneStyle_ARRAYSIZE = LdwLaneStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LdwLaneStyle_descriptor();
template<typename T>
inline const std::string& LdwLaneStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LdwLaneStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LdwLaneStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LdwLaneStyle_descriptor(), enum_t_value);
}
inline bool LdwLaneStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LdwLaneStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LdwLaneStyle>(
    LdwLaneStyle_descriptor(), name, value);
}
enum LdwSteerStatus : int {
  LDW_NORMAL_STEER = 0,
  LDW_STEER_ON_LEFT__LANE = 1,
  LDW_STEER_ON_RIGHT_LANE = 2,
  LDW_STEER_WARNING_LEFT_ = 3,
  LDW_STEER_WARNING_RIGHT = 4
};
bool LdwSteerStatus_IsValid(int value);
constexpr LdwSteerStatus LdwSteerStatus_MIN = LDW_NORMAL_STEER;
constexpr LdwSteerStatus LdwSteerStatus_MAX = LDW_STEER_WARNING_RIGHT;
constexpr int LdwSteerStatus_ARRAYSIZE = LdwSteerStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LdwSteerStatus_descriptor();
template<typename T>
inline const std::string& LdwSteerStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LdwSteerStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LdwSteerStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LdwSteerStatus_descriptor(), enum_t_value);
}
inline bool LdwSteerStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LdwSteerStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LdwSteerStatus>(
    LdwSteerStatus_descriptor(), name, value);
}
enum LdwSoftStatus : int {
  LDW_SOFT_DETECTION = 0,
  LDW_SOFT_SELF_LEARNING = 1,
  LDW_SOFT_MANUAL_LEARNING_MODE0 = 2,
  LDW_SOFT_MANUAL_LEARNING_MODE1 = 3
};
bool LdwSoftStatus_IsValid(int value);
constexpr LdwSoftStatus LdwSoftStatus_MIN = LDW_SOFT_DETECTION;
constexpr LdwSoftStatus LdwSoftStatus_MAX = LDW_SOFT_MANUAL_LEARNING_MODE1;
constexpr int LdwSoftStatus_ARRAYSIZE = LdwSoftStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LdwSoftStatus_descriptor();
template<typename T>
inline const std::string& LdwSoftStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LdwSoftStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LdwSoftStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LdwSoftStatus_descriptor(), enum_t_value);
}
inline bool LdwSoftStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LdwSoftStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LdwSoftStatus>(
    LdwSoftStatus_descriptor(), name, value);
}
enum LdwWarningGrade : int {
  LDW_WARNING_LOW = 0,
  LDW_WARNING_NORMAL = 1,
  LDW_WARNING_HIGHT = 2
};
bool LdwWarningGrade_IsValid(int value);
constexpr LdwWarningGrade LdwWarningGrade_MIN = LDW_WARNING_LOW;
constexpr LdwWarningGrade LdwWarningGrade_MAX = LDW_WARNING_HIGHT;
constexpr int LdwWarningGrade_ARRAYSIZE = LdwWarningGrade_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LdwWarningGrade_descriptor();
template<typename T>
inline const std::string& LdwWarningGrade_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LdwWarningGrade>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LdwWarningGrade_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LdwWarningGrade_descriptor(), enum_t_value);
}
inline bool LdwWarningGrade_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LdwWarningGrade* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LdwWarningGrade>(
    LdwWarningGrade_descriptor(), name, value);
}
// ===================================================================

class LdwLaneBoundary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.LdwLaneBoundary) */ {
 public:
  inline LdwLaneBoundary() : LdwLaneBoundary(nullptr) {}
  ~LdwLaneBoundary() override;
  explicit PROTOBUF_CONSTEXPR LdwLaneBoundary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LdwLaneBoundary(const LdwLaneBoundary& from);
  LdwLaneBoundary(LdwLaneBoundary&& from) noexcept
    : LdwLaneBoundary() {
    *this = ::std::move(from);
  }

  inline LdwLaneBoundary& operator=(const LdwLaneBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  inline LdwLaneBoundary& operator=(LdwLaneBoundary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LdwLaneBoundary& default_instance() {
    return *internal_default_instance();
  }
  static inline const LdwLaneBoundary* internal_default_instance() {
    return reinterpret_cast<const LdwLaneBoundary*>(
               &_LdwLaneBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LdwLaneBoundary& a, LdwLaneBoundary& b) {
    a.Swap(&b);
  }
  inline void Swap(LdwLaneBoundary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LdwLaneBoundary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LdwLaneBoundary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LdwLaneBoundary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LdwLaneBoundary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LdwLaneBoundary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LdwLaneBoundary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.LdwLaneBoundary";
  }
  protected:
  explicit LdwLaneBoundary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kC0PositionFieldNumber = 2,
    kC1HeadingAngleFieldNumber = 3,
    kC2CurvatureFieldNumber = 4,
    kC3CurvatureDerivativeFieldNumber = 5,
    kDegreeFieldNumber = 1,
  };
  // optional double c0_position = 2;
  bool has_c0_position() const;
  private:
  bool _internal_has_c0_position() const;
  public:
  void clear_c0_position();
  double c0_position() const;
  void set_c0_position(double value);
  private:
  double _internal_c0_position() const;
  void _internal_set_c0_position(double value);
  public:

  // optional double c1_heading_angle = 3;
  bool has_c1_heading_angle() const;
  private:
  bool _internal_has_c1_heading_angle() const;
  public:
  void clear_c1_heading_angle();
  double c1_heading_angle() const;
  void set_c1_heading_angle(double value);
  private:
  double _internal_c1_heading_angle() const;
  void _internal_set_c1_heading_angle(double value);
  public:

  // optional double c2_curvature = 4;
  bool has_c2_curvature() const;
  private:
  bool _internal_has_c2_curvature() const;
  public:
  void clear_c2_curvature();
  double c2_curvature() const;
  void set_c2_curvature(double value);
  private:
  double _internal_c2_curvature() const;
  void _internal_set_c2_curvature(double value);
  public:

  // optional double c3_curvature_derivative = 5;
  bool has_c3_curvature_derivative() const;
  private:
  bool _internal_has_c3_curvature_derivative() const;
  public:
  void clear_c3_curvature_derivative();
  double c3_curvature_derivative() const;
  void set_c3_curvature_derivative(double value);
  private:
  double _internal_c3_curvature_derivative() const;
  void _internal_set_c3_curvature_derivative(double value);
  public:

  // optional int32 degree = 1;
  bool has_degree() const;
  private:
  bool _internal_has_degree() const;
  public:
  void clear_degree();
  int32_t degree() const;
  void set_degree(int32_t value);
  private:
  int32_t _internal_degree() const;
  void _internal_set_degree(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.LdwLaneBoundary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double c0_position_;
    double c1_heading_angle_;
    double c2_curvature_;
    double c3_curvature_derivative_;
    int32_t degree_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fproto_2fsmartereye_2eproto;
};
// -------------------------------------------------------------------

class LdwLane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.LdwLane) */ {
 public:
  inline LdwLane() : LdwLane(nullptr) {}
  ~LdwLane() override;
  explicit PROTOBUF_CONSTEXPR LdwLane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LdwLane(const LdwLane& from);
  LdwLane(LdwLane&& from) noexcept
    : LdwLane() {
    *this = ::std::move(from);
  }

  inline LdwLane& operator=(const LdwLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline LdwLane& operator=(LdwLane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LdwLane& default_instance() {
    return *internal_default_instance();
  }
  static inline const LdwLane* internal_default_instance() {
    return reinterpret_cast<const LdwLane*>(
               &_LdwLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LdwLane& a, LdwLane& b) {
    a.Swap(&b);
  }
  inline void Swap(LdwLane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LdwLane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LdwLane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LdwLane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LdwLane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LdwLane& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LdwLane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.LdwLane";
  }
  protected:
  explicit LdwLane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftBoundaryFieldNumber = 4,
    kRightBoundaryFieldNumber = 5,
    kWidthFieldNumber = 1,
    kQualityFieldNumber = 2,
    kStyleFieldNumber = 3,
  };
  // optional .apollo.drivers.LdwLaneBoundary left_boundary = 4;
  bool has_left_boundary() const;
  private:
  bool _internal_has_left_boundary() const;
  public:
  void clear_left_boundary();
  const ::apollo::drivers::LdwLaneBoundary& left_boundary() const;
  PROTOBUF_NODISCARD ::apollo::drivers::LdwLaneBoundary* release_left_boundary();
  ::apollo::drivers::LdwLaneBoundary* mutable_left_boundary();
  void set_allocated_left_boundary(::apollo::drivers::LdwLaneBoundary* left_boundary);
  private:
  const ::apollo::drivers::LdwLaneBoundary& _internal_left_boundary() const;
  ::apollo::drivers::LdwLaneBoundary* _internal_mutable_left_boundary();
  public:
  void unsafe_arena_set_allocated_left_boundary(
      ::apollo::drivers::LdwLaneBoundary* left_boundary);
  ::apollo::drivers::LdwLaneBoundary* unsafe_arena_release_left_boundary();

  // optional .apollo.drivers.LdwLaneBoundary right_boundary = 5;
  bool has_right_boundary() const;
  private:
  bool _internal_has_right_boundary() const;
  public:
  void clear_right_boundary();
  const ::apollo::drivers::LdwLaneBoundary& right_boundary() const;
  PROTOBUF_NODISCARD ::apollo::drivers::LdwLaneBoundary* release_right_boundary();
  ::apollo::drivers::LdwLaneBoundary* mutable_right_boundary();
  void set_allocated_right_boundary(::apollo::drivers::LdwLaneBoundary* right_boundary);
  private:
  const ::apollo::drivers::LdwLaneBoundary& _internal_right_boundary() const;
  ::apollo::drivers::LdwLaneBoundary* _internal_mutable_right_boundary();
  public:
  void unsafe_arena_set_allocated_right_boundary(
      ::apollo::drivers::LdwLaneBoundary* right_boundary);
  ::apollo::drivers::LdwLaneBoundary* unsafe_arena_release_right_boundary();

  // optional int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 quality = 2;
  bool has_quality() const;
  private:
  bool _internal_has_quality() const;
  public:
  void clear_quality();
  int32_t quality() const;
  void set_quality(int32_t value);
  private:
  int32_t _internal_quality() const;
  void _internal_set_quality(int32_t value);
  public:

  // optional .apollo.drivers.LdwLaneStyle style = 3;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  ::apollo::drivers::LdwLaneStyle style() const;
  void set_style(::apollo::drivers::LdwLaneStyle value);
  private:
  ::apollo::drivers::LdwLaneStyle _internal_style() const;
  void _internal_set_style(::apollo::drivers::LdwLaneStyle value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.LdwLane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::drivers::LdwLaneBoundary* left_boundary_;
    ::apollo::drivers::LdwLaneBoundary* right_boundary_;
    int32_t width_;
    int32_t quality_;
    int style_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fproto_2fsmartereye_2eproto;
};
// -------------------------------------------------------------------

class LdwRoadway final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.LdwRoadway) */ {
 public:
  inline LdwRoadway() : LdwRoadway(nullptr) {}
  ~LdwRoadway() override;
  explicit PROTOBUF_CONSTEXPR LdwRoadway(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LdwRoadway(const LdwRoadway& from);
  LdwRoadway(LdwRoadway&& from) noexcept
    : LdwRoadway() {
    *this = ::std::move(from);
  }

  inline LdwRoadway& operator=(const LdwRoadway& from) {
    CopyFrom(from);
    return *this;
  }
  inline LdwRoadway& operator=(LdwRoadway&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LdwRoadway& default_instance() {
    return *internal_default_instance();
  }
  static inline const LdwRoadway* internal_default_instance() {
    return reinterpret_cast<const LdwRoadway*>(
               &_LdwRoadway_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LdwRoadway& a, LdwRoadway& b) {
    a.Swap(&b);
  }
  inline void Swap(LdwRoadway* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LdwRoadway* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LdwRoadway* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LdwRoadway>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LdwRoadway& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LdwRoadway& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LdwRoadway* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.LdwRoadway";
  }
  protected:
  explicit LdwRoadway(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftLaneFieldNumber = 5,
    kRightLaneFieldNumber = 6,
    kAdjLeftLaneFieldNumber = 7,
    kAdjRightLaneFieldNumber = 8,
    kWidth0FieldNumber = 1,
    kWidth1FieldNumber = 2,
    kWidth2FieldNumber = 3,
    kIsTrackingFieldNumber = 4,
  };
  // optional .apollo.drivers.LdwLane left_lane = 5;
  bool has_left_lane() const;
  private:
  bool _internal_has_left_lane() const;
  public:
  void clear_left_lane();
  const ::apollo::drivers::LdwLane& left_lane() const;
  PROTOBUF_NODISCARD ::apollo::drivers::LdwLane* release_left_lane();
  ::apollo::drivers::LdwLane* mutable_left_lane();
  void set_allocated_left_lane(::apollo::drivers::LdwLane* left_lane);
  private:
  const ::apollo::drivers::LdwLane& _internal_left_lane() const;
  ::apollo::drivers::LdwLane* _internal_mutable_left_lane();
  public:
  void unsafe_arena_set_allocated_left_lane(
      ::apollo::drivers::LdwLane* left_lane);
  ::apollo::drivers::LdwLane* unsafe_arena_release_left_lane();

  // optional .apollo.drivers.LdwLane right_lane = 6;
  bool has_right_lane() const;
  private:
  bool _internal_has_right_lane() const;
  public:
  void clear_right_lane();
  const ::apollo::drivers::LdwLane& right_lane() const;
  PROTOBUF_NODISCARD ::apollo::drivers::LdwLane* release_right_lane();
  ::apollo::drivers::LdwLane* mutable_right_lane();
  void set_allocated_right_lane(::apollo::drivers::LdwLane* right_lane);
  private:
  const ::apollo::drivers::LdwLane& _internal_right_lane() const;
  ::apollo::drivers::LdwLane* _internal_mutable_right_lane();
  public:
  void unsafe_arena_set_allocated_right_lane(
      ::apollo::drivers::LdwLane* right_lane);
  ::apollo::drivers::LdwLane* unsafe_arena_release_right_lane();

  // optional .apollo.drivers.LdwLane adj_left_lane = 7;
  bool has_adj_left_lane() const;
  private:
  bool _internal_has_adj_left_lane() const;
  public:
  void clear_adj_left_lane();
  const ::apollo::drivers::LdwLane& adj_left_lane() const;
  PROTOBUF_NODISCARD ::apollo::drivers::LdwLane* release_adj_left_lane();
  ::apollo::drivers::LdwLane* mutable_adj_left_lane();
  void set_allocated_adj_left_lane(::apollo::drivers::LdwLane* adj_left_lane);
  private:
  const ::apollo::drivers::LdwLane& _internal_adj_left_lane() const;
  ::apollo::drivers::LdwLane* _internal_mutable_adj_left_lane();
  public:
  void unsafe_arena_set_allocated_adj_left_lane(
      ::apollo::drivers::LdwLane* adj_left_lane);
  ::apollo::drivers::LdwLane* unsafe_arena_release_adj_left_lane();

  // optional .apollo.drivers.LdwLane adj_right_lane = 8;
  bool has_adj_right_lane() const;
  private:
  bool _internal_has_adj_right_lane() const;
  public:
  void clear_adj_right_lane();
  const ::apollo::drivers::LdwLane& adj_right_lane() const;
  PROTOBUF_NODISCARD ::apollo::drivers::LdwLane* release_adj_right_lane();
  ::apollo::drivers::LdwLane* mutable_adj_right_lane();
  void set_allocated_adj_right_lane(::apollo::drivers::LdwLane* adj_right_lane);
  private:
  const ::apollo::drivers::LdwLane& _internal_adj_right_lane() const;
  ::apollo::drivers::LdwLane* _internal_mutable_adj_right_lane();
  public:
  void unsafe_arena_set_allocated_adj_right_lane(
      ::apollo::drivers::LdwLane* adj_right_lane);
  ::apollo::drivers::LdwLane* unsafe_arena_release_adj_right_lane();

  // optional int32 width_0 = 1;
  bool has_width_0() const;
  private:
  bool _internal_has_width_0() const;
  public:
  void clear_width_0();
  int32_t width_0() const;
  void set_width_0(int32_t value);
  private:
  int32_t _internal_width_0() const;
  void _internal_set_width_0(int32_t value);
  public:

  // optional int32 width_1 = 2;
  bool has_width_1() const;
  private:
  bool _internal_has_width_1() const;
  public:
  void clear_width_1();
  int32_t width_1() const;
  void set_width_1(int32_t value);
  private:
  int32_t _internal_width_1() const;
  void _internal_set_width_1(int32_t value);
  public:

  // optional int32 width_2 = 3;
  bool has_width_2() const;
  private:
  bool _internal_has_width_2() const;
  public:
  void clear_width_2();
  int32_t width_2() const;
  void set_width_2(int32_t value);
  private:
  int32_t _internal_width_2() const;
  void _internal_set_width_2(int32_t value);
  public:

  // optional bool is_tracking = 4;
  bool has_is_tracking() const;
  private:
  bool _internal_has_is_tracking() const;
  public:
  void clear_is_tracking();
  bool is_tracking() const;
  void set_is_tracking(bool value);
  private:
  bool _internal_is_tracking() const;
  void _internal_set_is_tracking(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.LdwRoadway)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::drivers::LdwLane* left_lane_;
    ::apollo::drivers::LdwLane* right_lane_;
    ::apollo::drivers::LdwLane* adj_left_lane_;
    ::apollo::drivers::LdwLane* adj_right_lane_;
    int32_t width_0_;
    int32_t width_1_;
    int32_t width_2_;
    bool is_tracking_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fproto_2fsmartereye_2eproto;
};
// -------------------------------------------------------------------

class LdwLensInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.LdwLensInfo) */ {
 public:
  inline LdwLensInfo() : LdwLensInfo(nullptr) {}
  ~LdwLensInfo() override;
  explicit PROTOBUF_CONSTEXPR LdwLensInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LdwLensInfo(const LdwLensInfo& from);
  LdwLensInfo(LdwLensInfo&& from) noexcept
    : LdwLensInfo() {
    *this = ::std::move(from);
  }

  inline LdwLensInfo& operator=(const LdwLensInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LdwLensInfo& operator=(LdwLensInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LdwLensInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LdwLensInfo* internal_default_instance() {
    return reinterpret_cast<const LdwLensInfo*>(
               &_LdwLensInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LdwLensInfo& a, LdwLensInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LdwLensInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LdwLensInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LdwLensInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LdwLensInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LdwLensInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LdwLensInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LdwLensInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.LdwLensInfo";
  }
  protected:
  explicit LdwLensInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXImageFocalFieldNumber = 1,
    kYImageFocalFieldNumber = 2,
    kXratioFocalPixelFieldNumber = 3,
    kYratioFocalPixelFieldNumber = 4,
    kMountingheightFieldNumber = 5,
    kMcosrxFieldNumber = 6,
    kMsinrxFieldNumber = 7,
    kMcosryFieldNumber = 8,
    kMsinryFieldNumber = 9,
  };
  // optional float x_image_focal = 1;
  bool has_x_image_focal() const;
  private:
  bool _internal_has_x_image_focal() const;
  public:
  void clear_x_image_focal();
  float x_image_focal() const;
  void set_x_image_focal(float value);
  private:
  float _internal_x_image_focal() const;
  void _internal_set_x_image_focal(float value);
  public:

  // optional float y_image_focal = 2;
  bool has_y_image_focal() const;
  private:
  bool _internal_has_y_image_focal() const;
  public:
  void clear_y_image_focal();
  float y_image_focal() const;
  void set_y_image_focal(float value);
  private:
  float _internal_y_image_focal() const;
  void _internal_set_y_image_focal(float value);
  public:

  // optional float xratio_focal_pixel = 3;
  bool has_xratio_focal_pixel() const;
  private:
  bool _internal_has_xratio_focal_pixel() const;
  public:
  void clear_xratio_focal_pixel();
  float xratio_focal_pixel() const;
  void set_xratio_focal_pixel(float value);
  private:
  float _internal_xratio_focal_pixel() const;
  void _internal_set_xratio_focal_pixel(float value);
  public:

  // optional float yratio_focal_pixel = 4;
  bool has_yratio_focal_pixel() const;
  private:
  bool _internal_has_yratio_focal_pixel() const;
  public:
  void clear_yratio_focal_pixel();
  float yratio_focal_pixel() const;
  void set_yratio_focal_pixel(float value);
  private:
  float _internal_yratio_focal_pixel() const;
  void _internal_set_yratio_focal_pixel(float value);
  public:

  // optional float mountingheight = 5;
  bool has_mountingheight() const;
  private:
  bool _internal_has_mountingheight() const;
  public:
  void clear_mountingheight();
  float mountingheight() const;
  void set_mountingheight(float value);
  private:
  float _internal_mountingheight() const;
  void _internal_set_mountingheight(float value);
  public:

  // optional float mcosrx = 6;
  bool has_mcosrx() const;
  private:
  bool _internal_has_mcosrx() const;
  public:
  void clear_mcosrx();
  float mcosrx() const;
  void set_mcosrx(float value);
  private:
  float _internal_mcosrx() const;
  void _internal_set_mcosrx(float value);
  public:

  // optional float msinrx = 7;
  bool has_msinrx() const;
  private:
  bool _internal_has_msinrx() const;
  public:
  void clear_msinrx();
  float msinrx() const;
  void set_msinrx(float value);
  private:
  float _internal_msinrx() const;
  void _internal_set_msinrx(float value);
  public:

  // optional float mcosry = 8;
  bool has_mcosry() const;
  private:
  bool _internal_has_mcosry() const;
  public:
  void clear_mcosry();
  float mcosry() const;
  void set_mcosry(float value);
  private:
  float _internal_mcosry() const;
  void _internal_set_mcosry(float value);
  public:

  // optional float msinry = 9;
  bool has_msinry() const;
  private:
  bool _internal_has_msinry() const;
  public:
  void clear_msinry();
  float msinry() const;
  void set_msinry(float value);
  private:
  float _internal_msinry() const;
  void _internal_set_msinry(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.LdwLensInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_image_focal_;
    float y_image_focal_;
    float xratio_focal_pixel_;
    float yratio_focal_pixel_;
    float mountingheight_;
    float mcosrx_;
    float msinrx_;
    float mcosry_;
    float msinry_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fproto_2fsmartereye_2eproto;
};
// -------------------------------------------------------------------

class LdwDataPacks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.LdwDataPacks) */ {
 public:
  inline LdwDataPacks() : LdwDataPacks(nullptr) {}
  ~LdwDataPacks() override;
  explicit PROTOBUF_CONSTEXPR LdwDataPacks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LdwDataPacks(const LdwDataPacks& from);
  LdwDataPacks(LdwDataPacks&& from) noexcept
    : LdwDataPacks() {
    *this = ::std::move(from);
  }

  inline LdwDataPacks& operator=(const LdwDataPacks& from) {
    CopyFrom(from);
    return *this;
  }
  inline LdwDataPacks& operator=(LdwDataPacks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LdwDataPacks& default_instance() {
    return *internal_default_instance();
  }
  static inline const LdwDataPacks* internal_default_instance() {
    return reinterpret_cast<const LdwDataPacks*>(
               &_LdwDataPacks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LdwDataPacks& a, LdwDataPacks& b) {
    a.Swap(&b);
  }
  inline void Swap(LdwDataPacks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LdwDataPacks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LdwDataPacks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LdwDataPacks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LdwDataPacks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LdwDataPacks& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LdwDataPacks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.LdwDataPacks";
  }
  protected:
  explicit LdwDataPacks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoadwayFieldNumber = 1,
    kLensFieldNumber = 4,
    kSoftstatusFieldNumber = 2,
    kSteerstatusFieldNumber = 3,
  };
  // optional .apollo.drivers.LdwRoadway roadway = 1;
  bool has_roadway() const;
  private:
  bool _internal_has_roadway() const;
  public:
  void clear_roadway();
  const ::apollo::drivers::LdwRoadway& roadway() const;
  PROTOBUF_NODISCARD ::apollo::drivers::LdwRoadway* release_roadway();
  ::apollo::drivers::LdwRoadway* mutable_roadway();
  void set_allocated_roadway(::apollo::drivers::LdwRoadway* roadway);
  private:
  const ::apollo::drivers::LdwRoadway& _internal_roadway() const;
  ::apollo::drivers::LdwRoadway* _internal_mutable_roadway();
  public:
  void unsafe_arena_set_allocated_roadway(
      ::apollo::drivers::LdwRoadway* roadway);
  ::apollo::drivers::LdwRoadway* unsafe_arena_release_roadway();

  // optional .apollo.drivers.LdwLensInfo lens = 4;
  bool has_lens() const;
  private:
  bool _internal_has_lens() const;
  public:
  void clear_lens();
  const ::apollo::drivers::LdwLensInfo& lens() const;
  PROTOBUF_NODISCARD ::apollo::drivers::LdwLensInfo* release_lens();
  ::apollo::drivers::LdwLensInfo* mutable_lens();
  void set_allocated_lens(::apollo::drivers::LdwLensInfo* lens);
  private:
  const ::apollo::drivers::LdwLensInfo& _internal_lens() const;
  ::apollo::drivers::LdwLensInfo* _internal_mutable_lens();
  public:
  void unsafe_arena_set_allocated_lens(
      ::apollo::drivers::LdwLensInfo* lens);
  ::apollo::drivers::LdwLensInfo* unsafe_arena_release_lens();

  // optional .apollo.drivers.LdwSoftStatus softstatus = 2;
  bool has_softstatus() const;
  private:
  bool _internal_has_softstatus() const;
  public:
  void clear_softstatus();
  ::apollo::drivers::LdwSoftStatus softstatus() const;
  void set_softstatus(::apollo::drivers::LdwSoftStatus value);
  private:
  ::apollo::drivers::LdwSoftStatus _internal_softstatus() const;
  void _internal_set_softstatus(::apollo::drivers::LdwSoftStatus value);
  public:

  // optional .apollo.drivers.LdwSteerStatus steerstatus = 3;
  bool has_steerstatus() const;
  private:
  bool _internal_has_steerstatus() const;
  public:
  void clear_steerstatus();
  ::apollo::drivers::LdwSteerStatus steerstatus() const;
  void set_steerstatus(::apollo::drivers::LdwSteerStatus value);
  private:
  ::apollo::drivers::LdwSteerStatus _internal_steerstatus() const;
  void _internal_set_steerstatus(::apollo::drivers::LdwSteerStatus value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.LdwDataPacks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::drivers::LdwRoadway* roadway_;
    ::apollo::drivers::LdwLensInfo* lens_;
    int softstatus_;
    int steerstatus_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fproto_2fsmartereye_2eproto;
};
// -------------------------------------------------------------------

class OutputObstacle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.OutputObstacle) */ {
 public:
  inline OutputObstacle() : OutputObstacle(nullptr) {}
  ~OutputObstacle() override;
  explicit PROTOBUF_CONSTEXPR OutputObstacle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutputObstacle(const OutputObstacle& from);
  OutputObstacle(OutputObstacle&& from) noexcept
    : OutputObstacle() {
    *this = ::std::move(from);
  }

  inline OutputObstacle& operator=(const OutputObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputObstacle& operator=(OutputObstacle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputObstacle& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputObstacle* internal_default_instance() {
    return reinterpret_cast<const OutputObstacle*>(
               &_OutputObstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OutputObstacle& a, OutputObstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputObstacle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputObstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutputObstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutputObstacle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutputObstacle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OutputObstacle& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputObstacle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.OutputObstacle";
  }
  protected:
  explicit OutputObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OutputObstacle_RecognitionType RecognitionType;
  static constexpr RecognitionType INVALID =
    OutputObstacle_RecognitionType_INVALID;
  static constexpr RecognitionType VEHICLE =
    OutputObstacle_RecognitionType_VEHICLE;
  static constexpr RecognitionType PEDESTRIAN =
    OutputObstacle_RecognitionType_PEDESTRIAN;
  static constexpr RecognitionType CHILD =
    OutputObstacle_RecognitionType_CHILD;
  static constexpr RecognitionType BICYCLE =
    OutputObstacle_RecognitionType_BICYCLE;
  static constexpr RecognitionType MOTO =
    OutputObstacle_RecognitionType_MOTO;
  static constexpr RecognitionType TRUCK =
    OutputObstacle_RecognitionType_TRUCK;
  static constexpr RecognitionType BUS =
    OutputObstacle_RecognitionType_BUS;
  static constexpr RecognitionType OTHERS =
    OutputObstacle_RecognitionType_OTHERS;
  static constexpr RecognitionType ESTIMATED =
    OutputObstacle_RecognitionType_ESTIMATED;
  static constexpr RecognitionType CONTINUOUS =
    OutputObstacle_RecognitionType_CONTINUOUS;
  static inline bool RecognitionType_IsValid(int value) {
    return OutputObstacle_RecognitionType_IsValid(value);
  }
  static constexpr RecognitionType RecognitionType_MIN =
    OutputObstacle_RecognitionType_RecognitionType_MIN;
  static constexpr RecognitionType RecognitionType_MAX =
    OutputObstacle_RecognitionType_RecognitionType_MAX;
  static constexpr int RecognitionType_ARRAYSIZE =
    OutputObstacle_RecognitionType_RecognitionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RecognitionType_descriptor() {
    return OutputObstacle_RecognitionType_descriptor();
  }
  template<typename T>
  static inline const std::string& RecognitionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RecognitionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RecognitionType_Name.");
    return OutputObstacle_RecognitionType_Name(enum_t_value);
  }
  static inline bool RecognitionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RecognitionType* value) {
    return OutputObstacle_RecognitionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentspeedFieldNumber = 1,
    kFramerateFieldNumber = 2,
    kTrackidFieldNumber = 3,
    kTrackframenumFieldNumber = 4,
    kStatelabelFieldNumber = 5,
    kClasslabelFieldNumber = 6,
    kContinuouslabelFieldNumber = 7,
    kFuzzyestimationvalidFieldNumber = 8,
    kObstacletypeFieldNumber = 9,
    kAvgdispFieldNumber = 10,
    kAvgdistancezFieldNumber = 11,
    kNeardistancezFieldNumber = 12,
    kFardistancezFieldNumber = 13,
    kReal3DleftxFieldNumber = 14,
    kReal3DrightxFieldNumber = 15,
    kReal3DcenterxFieldNumber = 16,
    kReal3DupyFieldNumber = 17,
    kReal3DlowyFieldNumber = 18,
    kFirstpointxFieldNumber = 19,
    kFirstpointyFieldNumber = 20,
    kSecondpointxFieldNumber = 21,
    kSecondpointyFieldNumber = 22,
    kThirdpointxFieldNumber = 23,
    kThirdpointyFieldNumber = 24,
    kFourthpointxFieldNumber = 25,
    kFourthpointyFieldNumber = 26,
    kFuzzyrelativedistancezFieldNumber = 27,
    kFuzzyrelativespeedzFieldNumber = 28,
    kFuzzycollisiontimezFieldNumber = 29,
    kFuzzycollisionxFieldNumber = 30,
    kFuzzy3DwidthFieldNumber = 31,
    kFuzzy3DcenterxFieldNumber = 32,
    kFuzzy3DleftxFieldNumber = 33,
    kFuzzy3DrightxFieldNumber = 34,
    kFuzzy3DheightFieldNumber = 35,
    kFuzzy3DupyFieldNumber = 36,
    kFuzzy3DlowyFieldNumber = 37,
    kFuzzyrelativespeedcenterxFieldNumber = 38,
    kFuzzyrelativespeedleftxFieldNumber = 39,
    kFuzzyrelativespeedrightxFieldNumber = 40,
  };
  // optional float currentspeed = 1;
  bool has_currentspeed() const;
  private:
  bool _internal_has_currentspeed() const;
  public:
  void clear_currentspeed();
  float currentspeed() const;
  void set_currentspeed(float value);
  private:
  float _internal_currentspeed() const;
  void _internal_set_currentspeed(float value);
  public:

  // optional float framerate = 2;
  bool has_framerate() const;
  private:
  bool _internal_has_framerate() const;
  public:
  void clear_framerate();
  float framerate() const;
  void set_framerate(float value);
  private:
  float _internal_framerate() const;
  void _internal_set_framerate(float value);
  public:

  // optional uint32 trackid = 3;
  bool has_trackid() const;
  private:
  bool _internal_has_trackid() const;
  public:
  void clear_trackid();
  uint32_t trackid() const;
  void set_trackid(uint32_t value);
  private:
  uint32_t _internal_trackid() const;
  void _internal_set_trackid(uint32_t value);
  public:

  // optional uint32 trackframenum = 4;
  bool has_trackframenum() const;
  private:
  bool _internal_has_trackframenum() const;
  public:
  void clear_trackframenum();
  uint32_t trackframenum() const;
  void set_trackframenum(uint32_t value);
  private:
  uint32_t _internal_trackframenum() const;
  void _internal_set_trackframenum(uint32_t value);
  public:

  // optional uint32 statelabel = 5;
  bool has_statelabel() const;
  private:
  bool _internal_has_statelabel() const;
  public:
  void clear_statelabel();
  uint32_t statelabel() const;
  void set_statelabel(uint32_t value);
  private:
  uint32_t _internal_statelabel() const;
  void _internal_set_statelabel(uint32_t value);
  public:

  // optional uint32 classlabel = 6;
  bool has_classlabel() const;
  private:
  bool _internal_has_classlabel() const;
  public:
  void clear_classlabel();
  uint32_t classlabel() const;
  void set_classlabel(uint32_t value);
  private:
  uint32_t _internal_classlabel() const;
  void _internal_set_classlabel(uint32_t value);
  public:

  // optional uint32 continuouslabel = 7;
  bool has_continuouslabel() const;
  private:
  bool _internal_has_continuouslabel() const;
  public:
  void clear_continuouslabel();
  uint32_t continuouslabel() const;
  void set_continuouslabel(uint32_t value);
  private:
  uint32_t _internal_continuouslabel() const;
  void _internal_set_continuouslabel(uint32_t value);
  public:

  // optional uint32 fuzzyestimationvalid = 8;
  bool has_fuzzyestimationvalid() const;
  private:
  bool _internal_has_fuzzyestimationvalid() const;
  public:
  void clear_fuzzyestimationvalid();
  uint32_t fuzzyestimationvalid() const;
  void set_fuzzyestimationvalid(uint32_t value);
  private:
  uint32_t _internal_fuzzyestimationvalid() const;
  void _internal_set_fuzzyestimationvalid(uint32_t value);
  public:

  // optional .apollo.drivers.OutputObstacle.RecognitionType obstacletype = 9;
  bool has_obstacletype() const;
  private:
  bool _internal_has_obstacletype() const;
  public:
  void clear_obstacletype();
  ::apollo::drivers::OutputObstacle_RecognitionType obstacletype() const;
  void set_obstacletype(::apollo::drivers::OutputObstacle_RecognitionType value);
  private:
  ::apollo::drivers::OutputObstacle_RecognitionType _internal_obstacletype() const;
  void _internal_set_obstacletype(::apollo::drivers::OutputObstacle_RecognitionType value);
  public:

  // optional float avgdisp = 10;
  bool has_avgdisp() const;
  private:
  bool _internal_has_avgdisp() const;
  public:
  void clear_avgdisp();
  float avgdisp() const;
  void set_avgdisp(float value);
  private:
  float _internal_avgdisp() const;
  void _internal_set_avgdisp(float value);
  public:

  // optional float avgdistancez = 11;
  bool has_avgdistancez() const;
  private:
  bool _internal_has_avgdistancez() const;
  public:
  void clear_avgdistancez();
  float avgdistancez() const;
  void set_avgdistancez(float value);
  private:
  float _internal_avgdistancez() const;
  void _internal_set_avgdistancez(float value);
  public:

  // optional float neardistancez = 12;
  bool has_neardistancez() const;
  private:
  bool _internal_has_neardistancez() const;
  public:
  void clear_neardistancez();
  float neardistancez() const;
  void set_neardistancez(float value);
  private:
  float _internal_neardistancez() const;
  void _internal_set_neardistancez(float value);
  public:

  // optional float fardistancez = 13;
  bool has_fardistancez() const;
  private:
  bool _internal_has_fardistancez() const;
  public:
  void clear_fardistancez();
  float fardistancez() const;
  void set_fardistancez(float value);
  private:
  float _internal_fardistancez() const;
  void _internal_set_fardistancez(float value);
  public:

  // optional float real3dleftx = 14;
  bool has_real3dleftx() const;
  private:
  bool _internal_has_real3dleftx() const;
  public:
  void clear_real3dleftx();
  float real3dleftx() const;
  void set_real3dleftx(float value);
  private:
  float _internal_real3dleftx() const;
  void _internal_set_real3dleftx(float value);
  public:

  // optional float real3drightx = 15;
  bool has_real3drightx() const;
  private:
  bool _internal_has_real3drightx() const;
  public:
  void clear_real3drightx();
  float real3drightx() const;
  void set_real3drightx(float value);
  private:
  float _internal_real3drightx() const;
  void _internal_set_real3drightx(float value);
  public:

  // optional float real3dcenterx = 16;
  bool has_real3dcenterx() const;
  private:
  bool _internal_has_real3dcenterx() const;
  public:
  void clear_real3dcenterx();
  float real3dcenterx() const;
  void set_real3dcenterx(float value);
  private:
  float _internal_real3dcenterx() const;
  void _internal_set_real3dcenterx(float value);
  public:

  // optional float real3dupy = 17;
  bool has_real3dupy() const;
  private:
  bool _internal_has_real3dupy() const;
  public:
  void clear_real3dupy();
  float real3dupy() const;
  void set_real3dupy(float value);
  private:
  float _internal_real3dupy() const;
  void _internal_set_real3dupy(float value);
  public:

  // optional float real3dlowy = 18;
  bool has_real3dlowy() const;
  private:
  bool _internal_has_real3dlowy() const;
  public:
  void clear_real3dlowy();
  float real3dlowy() const;
  void set_real3dlowy(float value);
  private:
  float _internal_real3dlowy() const;
  void _internal_set_real3dlowy(float value);
  public:

  // optional uint32 firstpointx = 19;
  bool has_firstpointx() const;
  private:
  bool _internal_has_firstpointx() const;
  public:
  void clear_firstpointx();
  uint32_t firstpointx() const;
  void set_firstpointx(uint32_t value);
  private:
  uint32_t _internal_firstpointx() const;
  void _internal_set_firstpointx(uint32_t value);
  public:

  // optional uint32 firstpointy = 20;
  bool has_firstpointy() const;
  private:
  bool _internal_has_firstpointy() const;
  public:
  void clear_firstpointy();
  uint32_t firstpointy() const;
  void set_firstpointy(uint32_t value);
  private:
  uint32_t _internal_firstpointy() const;
  void _internal_set_firstpointy(uint32_t value);
  public:

  // optional uint32 secondpointx = 21;
  bool has_secondpointx() const;
  private:
  bool _internal_has_secondpointx() const;
  public:
  void clear_secondpointx();
  uint32_t secondpointx() const;
  void set_secondpointx(uint32_t value);
  private:
  uint32_t _internal_secondpointx() const;
  void _internal_set_secondpointx(uint32_t value);
  public:

  // optional uint32 secondpointy = 22;
  bool has_secondpointy() const;
  private:
  bool _internal_has_secondpointy() const;
  public:
  void clear_secondpointy();
  uint32_t secondpointy() const;
  void set_secondpointy(uint32_t value);
  private:
  uint32_t _internal_secondpointy() const;
  void _internal_set_secondpointy(uint32_t value);
  public:

  // optional uint32 thirdpointx = 23;
  bool has_thirdpointx() const;
  private:
  bool _internal_has_thirdpointx() const;
  public:
  void clear_thirdpointx();
  uint32_t thirdpointx() const;
  void set_thirdpointx(uint32_t value);
  private:
  uint32_t _internal_thirdpointx() const;
  void _internal_set_thirdpointx(uint32_t value);
  public:

  // optional uint32 thirdpointy = 24;
  bool has_thirdpointy() const;
  private:
  bool _internal_has_thirdpointy() const;
  public:
  void clear_thirdpointy();
  uint32_t thirdpointy() const;
  void set_thirdpointy(uint32_t value);
  private:
  uint32_t _internal_thirdpointy() const;
  void _internal_set_thirdpointy(uint32_t value);
  public:

  // optional uint32 fourthpointx = 25;
  bool has_fourthpointx() const;
  private:
  bool _internal_has_fourthpointx() const;
  public:
  void clear_fourthpointx();
  uint32_t fourthpointx() const;
  void set_fourthpointx(uint32_t value);
  private:
  uint32_t _internal_fourthpointx() const;
  void _internal_set_fourthpointx(uint32_t value);
  public:

  // optional uint32 fourthpointy = 26;
  bool has_fourthpointy() const;
  private:
  bool _internal_has_fourthpointy() const;
  public:
  void clear_fourthpointy();
  uint32_t fourthpointy() const;
  void set_fourthpointy(uint32_t value);
  private:
  uint32_t _internal_fourthpointy() const;
  void _internal_set_fourthpointy(uint32_t value);
  public:

  // optional float fuzzyrelativedistancez = 27;
  bool has_fuzzyrelativedistancez() const;
  private:
  bool _internal_has_fuzzyrelativedistancez() const;
  public:
  void clear_fuzzyrelativedistancez();
  float fuzzyrelativedistancez() const;
  void set_fuzzyrelativedistancez(float value);
  private:
  float _internal_fuzzyrelativedistancez() const;
  void _internal_set_fuzzyrelativedistancez(float value);
  public:

  // optional float fuzzyrelativespeedz = 28;
  bool has_fuzzyrelativespeedz() const;
  private:
  bool _internal_has_fuzzyrelativespeedz() const;
  public:
  void clear_fuzzyrelativespeedz();
  float fuzzyrelativespeedz() const;
  void set_fuzzyrelativespeedz(float value);
  private:
  float _internal_fuzzyrelativespeedz() const;
  void _internal_set_fuzzyrelativespeedz(float value);
  public:

  // optional float fuzzycollisiontimez = 29;
  bool has_fuzzycollisiontimez() const;
  private:
  bool _internal_has_fuzzycollisiontimez() const;
  public:
  void clear_fuzzycollisiontimez();
  float fuzzycollisiontimez() const;
  void set_fuzzycollisiontimez(float value);
  private:
  float _internal_fuzzycollisiontimez() const;
  void _internal_set_fuzzycollisiontimez(float value);
  public:

  // optional uint32 fuzzycollisionx = 30;
  bool has_fuzzycollisionx() const;
  private:
  bool _internal_has_fuzzycollisionx() const;
  public:
  void clear_fuzzycollisionx();
  uint32_t fuzzycollisionx() const;
  void set_fuzzycollisionx(uint32_t value);
  private:
  uint32_t _internal_fuzzycollisionx() const;
  void _internal_set_fuzzycollisionx(uint32_t value);
  public:

  // optional float fuzzy3dwidth = 31;
  bool has_fuzzy3dwidth() const;
  private:
  bool _internal_has_fuzzy3dwidth() const;
  public:
  void clear_fuzzy3dwidth();
  float fuzzy3dwidth() const;
  void set_fuzzy3dwidth(float value);
  private:
  float _internal_fuzzy3dwidth() const;
  void _internal_set_fuzzy3dwidth(float value);
  public:

  // optional float fuzzy3dcenterx = 32;
  bool has_fuzzy3dcenterx() const;
  private:
  bool _internal_has_fuzzy3dcenterx() const;
  public:
  void clear_fuzzy3dcenterx();
  float fuzzy3dcenterx() const;
  void set_fuzzy3dcenterx(float value);
  private:
  float _internal_fuzzy3dcenterx() const;
  void _internal_set_fuzzy3dcenterx(float value);
  public:

  // optional float fuzzy3dleftx = 33;
  bool has_fuzzy3dleftx() const;
  private:
  bool _internal_has_fuzzy3dleftx() const;
  public:
  void clear_fuzzy3dleftx();
  float fuzzy3dleftx() const;
  void set_fuzzy3dleftx(float value);
  private:
  float _internal_fuzzy3dleftx() const;
  void _internal_set_fuzzy3dleftx(float value);
  public:

  // optional float fuzzy3drightx = 34;
  bool has_fuzzy3drightx() const;
  private:
  bool _internal_has_fuzzy3drightx() const;
  public:
  void clear_fuzzy3drightx();
  float fuzzy3drightx() const;
  void set_fuzzy3drightx(float value);
  private:
  float _internal_fuzzy3drightx() const;
  void _internal_set_fuzzy3drightx(float value);
  public:

  // optional float fuzzy3dheight = 35;
  bool has_fuzzy3dheight() const;
  private:
  bool _internal_has_fuzzy3dheight() const;
  public:
  void clear_fuzzy3dheight();
  float fuzzy3dheight() const;
  void set_fuzzy3dheight(float value);
  private:
  float _internal_fuzzy3dheight() const;
  void _internal_set_fuzzy3dheight(float value);
  public:

  // optional float fuzzy3dupy = 36;
  bool has_fuzzy3dupy() const;
  private:
  bool _internal_has_fuzzy3dupy() const;
  public:
  void clear_fuzzy3dupy();
  float fuzzy3dupy() const;
  void set_fuzzy3dupy(float value);
  private:
  float _internal_fuzzy3dupy() const;
  void _internal_set_fuzzy3dupy(float value);
  public:

  // optional float fuzzy3dlowy = 37;
  bool has_fuzzy3dlowy() const;
  private:
  bool _internal_has_fuzzy3dlowy() const;
  public:
  void clear_fuzzy3dlowy();
  float fuzzy3dlowy() const;
  void set_fuzzy3dlowy(float value);
  private:
  float _internal_fuzzy3dlowy() const;
  void _internal_set_fuzzy3dlowy(float value);
  public:

  // optional float fuzzyrelativespeedcenterx = 38;
  bool has_fuzzyrelativespeedcenterx() const;
  private:
  bool _internal_has_fuzzyrelativespeedcenterx() const;
  public:
  void clear_fuzzyrelativespeedcenterx();
  float fuzzyrelativespeedcenterx() const;
  void set_fuzzyrelativespeedcenterx(float value);
  private:
  float _internal_fuzzyrelativespeedcenterx() const;
  void _internal_set_fuzzyrelativespeedcenterx(float value);
  public:

  // optional float fuzzyrelativespeedleftx = 39;
  bool has_fuzzyrelativespeedleftx() const;
  private:
  bool _internal_has_fuzzyrelativespeedleftx() const;
  public:
  void clear_fuzzyrelativespeedleftx();
  float fuzzyrelativespeedleftx() const;
  void set_fuzzyrelativespeedleftx(float value);
  private:
  float _internal_fuzzyrelativespeedleftx() const;
  void _internal_set_fuzzyrelativespeedleftx(float value);
  public:

  // optional float fuzzyrelativespeedrightx = 40;
  bool has_fuzzyrelativespeedrightx() const;
  private:
  bool _internal_has_fuzzyrelativespeedrightx() const;
  public:
  void clear_fuzzyrelativespeedrightx();
  float fuzzyrelativespeedrightx() const;
  void set_fuzzyrelativespeedrightx(float value);
  private:
  float _internal_fuzzyrelativespeedrightx() const;
  void _internal_set_fuzzyrelativespeedrightx(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.OutputObstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float currentspeed_;
    float framerate_;
    uint32_t trackid_;
    uint32_t trackframenum_;
    uint32_t statelabel_;
    uint32_t classlabel_;
    uint32_t continuouslabel_;
    uint32_t fuzzyestimationvalid_;
    int obstacletype_;
    float avgdisp_;
    float avgdistancez_;
    float neardistancez_;
    float fardistancez_;
    float real3dleftx_;
    float real3drightx_;
    float real3dcenterx_;
    float real3dupy_;
    float real3dlowy_;
    uint32_t firstpointx_;
    uint32_t firstpointy_;
    uint32_t secondpointx_;
    uint32_t secondpointy_;
    uint32_t thirdpointx_;
    uint32_t thirdpointy_;
    uint32_t fourthpointx_;
    uint32_t fourthpointy_;
    float fuzzyrelativedistancez_;
    float fuzzyrelativespeedz_;
    float fuzzycollisiontimez_;
    uint32_t fuzzycollisionx_;
    float fuzzy3dwidth_;
    float fuzzy3dcenterx_;
    float fuzzy3dleftx_;
    float fuzzy3drightx_;
    float fuzzy3dheight_;
    float fuzzy3dupy_;
    float fuzzy3dlowy_;
    float fuzzyrelativespeedcenterx_;
    float fuzzyrelativespeedleftx_;
    float fuzzyrelativespeedrightx_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fproto_2fsmartereye_2eproto;
};
// -------------------------------------------------------------------

class SmartereyeObstacles_OutputObstaclesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SmartereyeObstacles_OutputObstaclesEntry_DoNotUse, 
    uint32_t, ::apollo::drivers::OutputObstacle,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SmartereyeObstacles_OutputObstaclesEntry_DoNotUse, 
    uint32_t, ::apollo::drivers::OutputObstacle,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SmartereyeObstacles_OutputObstaclesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SmartereyeObstacles_OutputObstaclesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SmartereyeObstacles_OutputObstaclesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SmartereyeObstacles_OutputObstaclesEntry_DoNotUse& other);
  static const SmartereyeObstacles_OutputObstaclesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SmartereyeObstacles_OutputObstaclesEntry_DoNotUse*>(&_SmartereyeObstacles_OutputObstaclesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_modules_2fdrivers_2fproto_2fsmartereye_2eproto;
};

// -------------------------------------------------------------------

class SmartereyeObstacles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.SmartereyeObstacles) */ {
 public:
  inline SmartereyeObstacles() : SmartereyeObstacles(nullptr) {}
  ~SmartereyeObstacles() override;
  explicit PROTOBUF_CONSTEXPR SmartereyeObstacles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartereyeObstacles(const SmartereyeObstacles& from);
  SmartereyeObstacles(SmartereyeObstacles&& from) noexcept
    : SmartereyeObstacles() {
    *this = ::std::move(from);
  }

  inline SmartereyeObstacles& operator=(const SmartereyeObstacles& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartereyeObstacles& operator=(SmartereyeObstacles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartereyeObstacles& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartereyeObstacles* internal_default_instance() {
    return reinterpret_cast<const SmartereyeObstacles*>(
               &_SmartereyeObstacles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SmartereyeObstacles& a, SmartereyeObstacles& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartereyeObstacles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartereyeObstacles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartereyeObstacles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartereyeObstacles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmartereyeObstacles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SmartereyeObstacles& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartereyeObstacles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.SmartereyeObstacles";
  }
  protected:
  explicit SmartereyeObstacles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOutputObstaclesFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kNumObstaclesFieldNumber = 2,
  };
  // map<uint32, .apollo.drivers.OutputObstacle> output_obstacles = 3;
  int output_obstacles_size() const;
  private:
  int _internal_output_obstacles_size() const;
  public:
  void clear_output_obstacles();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::apollo::drivers::OutputObstacle >&
      _internal_output_obstacles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::apollo::drivers::OutputObstacle >*
      _internal_mutable_output_obstacles();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::apollo::drivers::OutputObstacle >&
      output_obstacles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::apollo::drivers::OutputObstacle >*
      mutable_output_obstacles();

  // optional .apollo.common.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::apollo::common::Header& header() const;
  PROTOBUF_NODISCARD ::apollo::common::Header* release_header();
  ::apollo::common::Header* mutable_header();
  void set_allocated_header(::apollo::common::Header* header);
  private:
  const ::apollo::common::Header& _internal_header() const;
  ::apollo::common::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::apollo::common::Header* header);
  ::apollo::common::Header* unsafe_arena_release_header();

  // optional int32 num_obstacles = 2;
  bool has_num_obstacles() const;
  private:
  bool _internal_has_num_obstacles() const;
  public:
  void clear_num_obstacles();
  int32_t num_obstacles() const;
  void set_num_obstacles(int32_t value);
  private:
  int32_t _internal_num_obstacles() const;
  void _internal_set_num_obstacles(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.SmartereyeObstacles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SmartereyeObstacles_OutputObstaclesEntry_DoNotUse,
        uint32_t, ::apollo::drivers::OutputObstacle,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> output_obstacles_;
    ::apollo::common::Header* header_;
    int32_t num_obstacles_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fproto_2fsmartereye_2eproto;
};
// -------------------------------------------------------------------

class SmartereyeLanemark final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.SmartereyeLanemark) */ {
 public:
  inline SmartereyeLanemark() : SmartereyeLanemark(nullptr) {}
  ~SmartereyeLanemark() override;
  explicit PROTOBUF_CONSTEXPR SmartereyeLanemark(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartereyeLanemark(const SmartereyeLanemark& from);
  SmartereyeLanemark(SmartereyeLanemark&& from) noexcept
    : SmartereyeLanemark() {
    *this = ::std::move(from);
  }

  inline SmartereyeLanemark& operator=(const SmartereyeLanemark& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartereyeLanemark& operator=(SmartereyeLanemark&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartereyeLanemark& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartereyeLanemark* internal_default_instance() {
    return reinterpret_cast<const SmartereyeLanemark*>(
               &_SmartereyeLanemark_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SmartereyeLanemark& a, SmartereyeLanemark& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartereyeLanemark* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartereyeLanemark* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartereyeLanemark* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartereyeLanemark>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmartereyeLanemark& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SmartereyeLanemark& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartereyeLanemark* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.SmartereyeLanemark";
  }
  protected:
  explicit SmartereyeLanemark(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneRoadDataFieldNumber = 4,
  };
  // optional .apollo.drivers.LdwDataPacks lane_road_data = 4;
  bool has_lane_road_data() const;
  private:
  bool _internal_has_lane_road_data() const;
  public:
  void clear_lane_road_data();
  const ::apollo::drivers::LdwDataPacks& lane_road_data() const;
  PROTOBUF_NODISCARD ::apollo::drivers::LdwDataPacks* release_lane_road_data();
  ::apollo::drivers::LdwDataPacks* mutable_lane_road_data();
  void set_allocated_lane_road_data(::apollo::drivers::LdwDataPacks* lane_road_data);
  private:
  const ::apollo::drivers::LdwDataPacks& _internal_lane_road_data() const;
  ::apollo::drivers::LdwDataPacks* _internal_mutable_lane_road_data();
  public:
  void unsafe_arena_set_allocated_lane_road_data(
      ::apollo::drivers::LdwDataPacks* lane_road_data);
  ::apollo::drivers::LdwDataPacks* unsafe_arena_release_lane_road_data();

  // @@protoc_insertion_point(class_scope:apollo.drivers.SmartereyeLanemark)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::drivers::LdwDataPacks* lane_road_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdrivers_2fproto_2fsmartereye_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LdwLaneBoundary

// optional int32 degree = 1;
inline bool LdwLaneBoundary::_internal_has_degree() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LdwLaneBoundary::has_degree() const {
  return _internal_has_degree();
}
inline void LdwLaneBoundary::clear_degree() {
  _impl_.degree_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t LdwLaneBoundary::_internal_degree() const {
  return _impl_.degree_;
}
inline int32_t LdwLaneBoundary::degree() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLaneBoundary.degree)
  return _internal_degree();
}
inline void LdwLaneBoundary::_internal_set_degree(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.degree_ = value;
}
inline void LdwLaneBoundary::set_degree(int32_t value) {
  _internal_set_degree(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLaneBoundary.degree)
}

// optional double c0_position = 2;
inline bool LdwLaneBoundary::_internal_has_c0_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LdwLaneBoundary::has_c0_position() const {
  return _internal_has_c0_position();
}
inline void LdwLaneBoundary::clear_c0_position() {
  _impl_.c0_position_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double LdwLaneBoundary::_internal_c0_position() const {
  return _impl_.c0_position_;
}
inline double LdwLaneBoundary::c0_position() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLaneBoundary.c0_position)
  return _internal_c0_position();
}
inline void LdwLaneBoundary::_internal_set_c0_position(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.c0_position_ = value;
}
inline void LdwLaneBoundary::set_c0_position(double value) {
  _internal_set_c0_position(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLaneBoundary.c0_position)
}

// optional double c1_heading_angle = 3;
inline bool LdwLaneBoundary::_internal_has_c1_heading_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LdwLaneBoundary::has_c1_heading_angle() const {
  return _internal_has_c1_heading_angle();
}
inline void LdwLaneBoundary::clear_c1_heading_angle() {
  _impl_.c1_heading_angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double LdwLaneBoundary::_internal_c1_heading_angle() const {
  return _impl_.c1_heading_angle_;
}
inline double LdwLaneBoundary::c1_heading_angle() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLaneBoundary.c1_heading_angle)
  return _internal_c1_heading_angle();
}
inline void LdwLaneBoundary::_internal_set_c1_heading_angle(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.c1_heading_angle_ = value;
}
inline void LdwLaneBoundary::set_c1_heading_angle(double value) {
  _internal_set_c1_heading_angle(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLaneBoundary.c1_heading_angle)
}

// optional double c2_curvature = 4;
inline bool LdwLaneBoundary::_internal_has_c2_curvature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LdwLaneBoundary::has_c2_curvature() const {
  return _internal_has_c2_curvature();
}
inline void LdwLaneBoundary::clear_c2_curvature() {
  _impl_.c2_curvature_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double LdwLaneBoundary::_internal_c2_curvature() const {
  return _impl_.c2_curvature_;
}
inline double LdwLaneBoundary::c2_curvature() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLaneBoundary.c2_curvature)
  return _internal_c2_curvature();
}
inline void LdwLaneBoundary::_internal_set_c2_curvature(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.c2_curvature_ = value;
}
inline void LdwLaneBoundary::set_c2_curvature(double value) {
  _internal_set_c2_curvature(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLaneBoundary.c2_curvature)
}

// optional double c3_curvature_derivative = 5;
inline bool LdwLaneBoundary::_internal_has_c3_curvature_derivative() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LdwLaneBoundary::has_c3_curvature_derivative() const {
  return _internal_has_c3_curvature_derivative();
}
inline void LdwLaneBoundary::clear_c3_curvature_derivative() {
  _impl_.c3_curvature_derivative_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double LdwLaneBoundary::_internal_c3_curvature_derivative() const {
  return _impl_.c3_curvature_derivative_;
}
inline double LdwLaneBoundary::c3_curvature_derivative() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLaneBoundary.c3_curvature_derivative)
  return _internal_c3_curvature_derivative();
}
inline void LdwLaneBoundary::_internal_set_c3_curvature_derivative(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.c3_curvature_derivative_ = value;
}
inline void LdwLaneBoundary::set_c3_curvature_derivative(double value) {
  _internal_set_c3_curvature_derivative(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLaneBoundary.c3_curvature_derivative)
}

// -------------------------------------------------------------------

// LdwLane

// optional int32 width = 1;
inline bool LdwLane::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LdwLane::has_width() const {
  return _internal_has_width();
}
inline void LdwLane::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t LdwLane::_internal_width() const {
  return _impl_.width_;
}
inline int32_t LdwLane::width() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLane.width)
  return _internal_width();
}
inline void LdwLane::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.width_ = value;
}
inline void LdwLane::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLane.width)
}

// optional int32 quality = 2;
inline bool LdwLane::_internal_has_quality() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LdwLane::has_quality() const {
  return _internal_has_quality();
}
inline void LdwLane::clear_quality() {
  _impl_.quality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t LdwLane::_internal_quality() const {
  return _impl_.quality_;
}
inline int32_t LdwLane::quality() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLane.quality)
  return _internal_quality();
}
inline void LdwLane::_internal_set_quality(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.quality_ = value;
}
inline void LdwLane::set_quality(int32_t value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLane.quality)
}

// optional .apollo.drivers.LdwLaneStyle style = 3;
inline bool LdwLane::_internal_has_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LdwLane::has_style() const {
  return _internal_has_style();
}
inline void LdwLane::clear_style() {
  _impl_.style_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::apollo::drivers::LdwLaneStyle LdwLane::_internal_style() const {
  return static_cast< ::apollo::drivers::LdwLaneStyle >(_impl_.style_);
}
inline ::apollo::drivers::LdwLaneStyle LdwLane::style() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLane.style)
  return _internal_style();
}
inline void LdwLane::_internal_set_style(::apollo::drivers::LdwLaneStyle value) {
  assert(::apollo::drivers::LdwLaneStyle_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.style_ = value;
}
inline void LdwLane::set_style(::apollo::drivers::LdwLaneStyle value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLane.style)
}

// optional .apollo.drivers.LdwLaneBoundary left_boundary = 4;
inline bool LdwLane::_internal_has_left_boundary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_boundary_ != nullptr);
  return value;
}
inline bool LdwLane::has_left_boundary() const {
  return _internal_has_left_boundary();
}
inline void LdwLane::clear_left_boundary() {
  if (_impl_.left_boundary_ != nullptr) _impl_.left_boundary_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::drivers::LdwLaneBoundary& LdwLane::_internal_left_boundary() const {
  const ::apollo::drivers::LdwLaneBoundary* p = _impl_.left_boundary_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::LdwLaneBoundary&>(
      ::apollo::drivers::_LdwLaneBoundary_default_instance_);
}
inline const ::apollo::drivers::LdwLaneBoundary& LdwLane::left_boundary() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLane.left_boundary)
  return _internal_left_boundary();
}
inline void LdwLane::unsafe_arena_set_allocated_left_boundary(
    ::apollo::drivers::LdwLaneBoundary* left_boundary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_boundary_);
  }
  _impl_.left_boundary_ = left_boundary;
  if (left_boundary) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.LdwLane.left_boundary)
}
inline ::apollo::drivers::LdwLaneBoundary* LdwLane::release_left_boundary() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::drivers::LdwLaneBoundary* temp = _impl_.left_boundary_;
  _impl_.left_boundary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::LdwLaneBoundary* LdwLane::unsafe_arena_release_left_boundary() {
  // @@protoc_insertion_point(field_release:apollo.drivers.LdwLane.left_boundary)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::drivers::LdwLaneBoundary* temp = _impl_.left_boundary_;
  _impl_.left_boundary_ = nullptr;
  return temp;
}
inline ::apollo::drivers::LdwLaneBoundary* LdwLane::_internal_mutable_left_boundary() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.left_boundary_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::LdwLaneBoundary>(GetArenaForAllocation());
    _impl_.left_boundary_ = p;
  }
  return _impl_.left_boundary_;
}
inline ::apollo::drivers::LdwLaneBoundary* LdwLane::mutable_left_boundary() {
  ::apollo::drivers::LdwLaneBoundary* _msg = _internal_mutable_left_boundary();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.LdwLane.left_boundary)
  return _msg;
}
inline void LdwLane::set_allocated_left_boundary(::apollo::drivers::LdwLaneBoundary* left_boundary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_boundary_;
  }
  if (left_boundary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_boundary);
    if (message_arena != submessage_arena) {
      left_boundary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_boundary, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.left_boundary_ = left_boundary;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.LdwLane.left_boundary)
}

// optional .apollo.drivers.LdwLaneBoundary right_boundary = 5;
inline bool LdwLane::_internal_has_right_boundary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_boundary_ != nullptr);
  return value;
}
inline bool LdwLane::has_right_boundary() const {
  return _internal_has_right_boundary();
}
inline void LdwLane::clear_right_boundary() {
  if (_impl_.right_boundary_ != nullptr) _impl_.right_boundary_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::drivers::LdwLaneBoundary& LdwLane::_internal_right_boundary() const {
  const ::apollo::drivers::LdwLaneBoundary* p = _impl_.right_boundary_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::LdwLaneBoundary&>(
      ::apollo::drivers::_LdwLaneBoundary_default_instance_);
}
inline const ::apollo::drivers::LdwLaneBoundary& LdwLane::right_boundary() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLane.right_boundary)
  return _internal_right_boundary();
}
inline void LdwLane::unsafe_arena_set_allocated_right_boundary(
    ::apollo::drivers::LdwLaneBoundary* right_boundary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_boundary_);
  }
  _impl_.right_boundary_ = right_boundary;
  if (right_boundary) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.LdwLane.right_boundary)
}
inline ::apollo::drivers::LdwLaneBoundary* LdwLane::release_right_boundary() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::drivers::LdwLaneBoundary* temp = _impl_.right_boundary_;
  _impl_.right_boundary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::LdwLaneBoundary* LdwLane::unsafe_arena_release_right_boundary() {
  // @@protoc_insertion_point(field_release:apollo.drivers.LdwLane.right_boundary)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::drivers::LdwLaneBoundary* temp = _impl_.right_boundary_;
  _impl_.right_boundary_ = nullptr;
  return temp;
}
inline ::apollo::drivers::LdwLaneBoundary* LdwLane::_internal_mutable_right_boundary() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_boundary_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::LdwLaneBoundary>(GetArenaForAllocation());
    _impl_.right_boundary_ = p;
  }
  return _impl_.right_boundary_;
}
inline ::apollo::drivers::LdwLaneBoundary* LdwLane::mutable_right_boundary() {
  ::apollo::drivers::LdwLaneBoundary* _msg = _internal_mutable_right_boundary();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.LdwLane.right_boundary)
  return _msg;
}
inline void LdwLane::set_allocated_right_boundary(::apollo::drivers::LdwLaneBoundary* right_boundary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_boundary_;
  }
  if (right_boundary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_boundary);
    if (message_arena != submessage_arena) {
      right_boundary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_boundary, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.right_boundary_ = right_boundary;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.LdwLane.right_boundary)
}

// -------------------------------------------------------------------

// LdwRoadway

// optional int32 width_0 = 1;
inline bool LdwRoadway::_internal_has_width_0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LdwRoadway::has_width_0() const {
  return _internal_has_width_0();
}
inline void LdwRoadway::clear_width_0() {
  _impl_.width_0_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t LdwRoadway::_internal_width_0() const {
  return _impl_.width_0_;
}
inline int32_t LdwRoadway::width_0() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwRoadway.width_0)
  return _internal_width_0();
}
inline void LdwRoadway::_internal_set_width_0(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.width_0_ = value;
}
inline void LdwRoadway::set_width_0(int32_t value) {
  _internal_set_width_0(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwRoadway.width_0)
}

// optional int32 width_1 = 2;
inline bool LdwRoadway::_internal_has_width_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LdwRoadway::has_width_1() const {
  return _internal_has_width_1();
}
inline void LdwRoadway::clear_width_1() {
  _impl_.width_1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t LdwRoadway::_internal_width_1() const {
  return _impl_.width_1_;
}
inline int32_t LdwRoadway::width_1() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwRoadway.width_1)
  return _internal_width_1();
}
inline void LdwRoadway::_internal_set_width_1(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.width_1_ = value;
}
inline void LdwRoadway::set_width_1(int32_t value) {
  _internal_set_width_1(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwRoadway.width_1)
}

// optional int32 width_2 = 3;
inline bool LdwRoadway::_internal_has_width_2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LdwRoadway::has_width_2() const {
  return _internal_has_width_2();
}
inline void LdwRoadway::clear_width_2() {
  _impl_.width_2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t LdwRoadway::_internal_width_2() const {
  return _impl_.width_2_;
}
inline int32_t LdwRoadway::width_2() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwRoadway.width_2)
  return _internal_width_2();
}
inline void LdwRoadway::_internal_set_width_2(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.width_2_ = value;
}
inline void LdwRoadway::set_width_2(int32_t value) {
  _internal_set_width_2(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwRoadway.width_2)
}

// optional bool is_tracking = 4;
inline bool LdwRoadway::_internal_has_is_tracking() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LdwRoadway::has_is_tracking() const {
  return _internal_has_is_tracking();
}
inline void LdwRoadway::clear_is_tracking() {
  _impl_.is_tracking_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool LdwRoadway::_internal_is_tracking() const {
  return _impl_.is_tracking_;
}
inline bool LdwRoadway::is_tracking() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwRoadway.is_tracking)
  return _internal_is_tracking();
}
inline void LdwRoadway::_internal_set_is_tracking(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.is_tracking_ = value;
}
inline void LdwRoadway::set_is_tracking(bool value) {
  _internal_set_is_tracking(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwRoadway.is_tracking)
}

// optional .apollo.drivers.LdwLane left_lane = 5;
inline bool LdwRoadway::_internal_has_left_lane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_lane_ != nullptr);
  return value;
}
inline bool LdwRoadway::has_left_lane() const {
  return _internal_has_left_lane();
}
inline void LdwRoadway::clear_left_lane() {
  if (_impl_.left_lane_ != nullptr) _impl_.left_lane_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::drivers::LdwLane& LdwRoadway::_internal_left_lane() const {
  const ::apollo::drivers::LdwLane* p = _impl_.left_lane_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::LdwLane&>(
      ::apollo::drivers::_LdwLane_default_instance_);
}
inline const ::apollo::drivers::LdwLane& LdwRoadway::left_lane() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwRoadway.left_lane)
  return _internal_left_lane();
}
inline void LdwRoadway::unsafe_arena_set_allocated_left_lane(
    ::apollo::drivers::LdwLane* left_lane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_lane_);
  }
  _impl_.left_lane_ = left_lane;
  if (left_lane) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.LdwRoadway.left_lane)
}
inline ::apollo::drivers::LdwLane* LdwRoadway::release_left_lane() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::drivers::LdwLane* temp = _impl_.left_lane_;
  _impl_.left_lane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::unsafe_arena_release_left_lane() {
  // @@protoc_insertion_point(field_release:apollo.drivers.LdwRoadway.left_lane)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::drivers::LdwLane* temp = _impl_.left_lane_;
  _impl_.left_lane_ = nullptr;
  return temp;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::_internal_mutable_left_lane() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.left_lane_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::LdwLane>(GetArenaForAllocation());
    _impl_.left_lane_ = p;
  }
  return _impl_.left_lane_;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::mutable_left_lane() {
  ::apollo::drivers::LdwLane* _msg = _internal_mutable_left_lane();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.LdwRoadway.left_lane)
  return _msg;
}
inline void LdwRoadway::set_allocated_left_lane(::apollo::drivers::LdwLane* left_lane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_lane_;
  }
  if (left_lane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_lane);
    if (message_arena != submessage_arena) {
      left_lane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_lane, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.left_lane_ = left_lane;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.LdwRoadway.left_lane)
}

// optional .apollo.drivers.LdwLane right_lane = 6;
inline bool LdwRoadway::_internal_has_right_lane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_lane_ != nullptr);
  return value;
}
inline bool LdwRoadway::has_right_lane() const {
  return _internal_has_right_lane();
}
inline void LdwRoadway::clear_right_lane() {
  if (_impl_.right_lane_ != nullptr) _impl_.right_lane_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::drivers::LdwLane& LdwRoadway::_internal_right_lane() const {
  const ::apollo::drivers::LdwLane* p = _impl_.right_lane_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::LdwLane&>(
      ::apollo::drivers::_LdwLane_default_instance_);
}
inline const ::apollo::drivers::LdwLane& LdwRoadway::right_lane() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwRoadway.right_lane)
  return _internal_right_lane();
}
inline void LdwRoadway::unsafe_arena_set_allocated_right_lane(
    ::apollo::drivers::LdwLane* right_lane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_lane_);
  }
  _impl_.right_lane_ = right_lane;
  if (right_lane) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.LdwRoadway.right_lane)
}
inline ::apollo::drivers::LdwLane* LdwRoadway::release_right_lane() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::drivers::LdwLane* temp = _impl_.right_lane_;
  _impl_.right_lane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::unsafe_arena_release_right_lane() {
  // @@protoc_insertion_point(field_release:apollo.drivers.LdwRoadway.right_lane)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::drivers::LdwLane* temp = _impl_.right_lane_;
  _impl_.right_lane_ = nullptr;
  return temp;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::_internal_mutable_right_lane() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_lane_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::LdwLane>(GetArenaForAllocation());
    _impl_.right_lane_ = p;
  }
  return _impl_.right_lane_;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::mutable_right_lane() {
  ::apollo::drivers::LdwLane* _msg = _internal_mutable_right_lane();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.LdwRoadway.right_lane)
  return _msg;
}
inline void LdwRoadway::set_allocated_right_lane(::apollo::drivers::LdwLane* right_lane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_lane_;
  }
  if (right_lane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_lane);
    if (message_arena != submessage_arena) {
      right_lane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_lane, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.right_lane_ = right_lane;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.LdwRoadway.right_lane)
}

// optional .apollo.drivers.LdwLane adj_left_lane = 7;
inline bool LdwRoadway::_internal_has_adj_left_lane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.adj_left_lane_ != nullptr);
  return value;
}
inline bool LdwRoadway::has_adj_left_lane() const {
  return _internal_has_adj_left_lane();
}
inline void LdwRoadway::clear_adj_left_lane() {
  if (_impl_.adj_left_lane_ != nullptr) _impl_.adj_left_lane_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::drivers::LdwLane& LdwRoadway::_internal_adj_left_lane() const {
  const ::apollo::drivers::LdwLane* p = _impl_.adj_left_lane_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::LdwLane&>(
      ::apollo::drivers::_LdwLane_default_instance_);
}
inline const ::apollo::drivers::LdwLane& LdwRoadway::adj_left_lane() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwRoadway.adj_left_lane)
  return _internal_adj_left_lane();
}
inline void LdwRoadway::unsafe_arena_set_allocated_adj_left_lane(
    ::apollo::drivers::LdwLane* adj_left_lane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adj_left_lane_);
  }
  _impl_.adj_left_lane_ = adj_left_lane;
  if (adj_left_lane) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.LdwRoadway.adj_left_lane)
}
inline ::apollo::drivers::LdwLane* LdwRoadway::release_adj_left_lane() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::drivers::LdwLane* temp = _impl_.adj_left_lane_;
  _impl_.adj_left_lane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::unsafe_arena_release_adj_left_lane() {
  // @@protoc_insertion_point(field_release:apollo.drivers.LdwRoadway.adj_left_lane)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::drivers::LdwLane* temp = _impl_.adj_left_lane_;
  _impl_.adj_left_lane_ = nullptr;
  return temp;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::_internal_mutable_adj_left_lane() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.adj_left_lane_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::LdwLane>(GetArenaForAllocation());
    _impl_.adj_left_lane_ = p;
  }
  return _impl_.adj_left_lane_;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::mutable_adj_left_lane() {
  ::apollo::drivers::LdwLane* _msg = _internal_mutable_adj_left_lane();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.LdwRoadway.adj_left_lane)
  return _msg;
}
inline void LdwRoadway::set_allocated_adj_left_lane(::apollo::drivers::LdwLane* adj_left_lane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.adj_left_lane_;
  }
  if (adj_left_lane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(adj_left_lane);
    if (message_arena != submessage_arena) {
      adj_left_lane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adj_left_lane, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.adj_left_lane_ = adj_left_lane;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.LdwRoadway.adj_left_lane)
}

// optional .apollo.drivers.LdwLane adj_right_lane = 8;
inline bool LdwRoadway::_internal_has_adj_right_lane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.adj_right_lane_ != nullptr);
  return value;
}
inline bool LdwRoadway::has_adj_right_lane() const {
  return _internal_has_adj_right_lane();
}
inline void LdwRoadway::clear_adj_right_lane() {
  if (_impl_.adj_right_lane_ != nullptr) _impl_.adj_right_lane_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::drivers::LdwLane& LdwRoadway::_internal_adj_right_lane() const {
  const ::apollo::drivers::LdwLane* p = _impl_.adj_right_lane_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::LdwLane&>(
      ::apollo::drivers::_LdwLane_default_instance_);
}
inline const ::apollo::drivers::LdwLane& LdwRoadway::adj_right_lane() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwRoadway.adj_right_lane)
  return _internal_adj_right_lane();
}
inline void LdwRoadway::unsafe_arena_set_allocated_adj_right_lane(
    ::apollo::drivers::LdwLane* adj_right_lane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adj_right_lane_);
  }
  _impl_.adj_right_lane_ = adj_right_lane;
  if (adj_right_lane) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.LdwRoadway.adj_right_lane)
}
inline ::apollo::drivers::LdwLane* LdwRoadway::release_adj_right_lane() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::drivers::LdwLane* temp = _impl_.adj_right_lane_;
  _impl_.adj_right_lane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::unsafe_arena_release_adj_right_lane() {
  // @@protoc_insertion_point(field_release:apollo.drivers.LdwRoadway.adj_right_lane)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::drivers::LdwLane* temp = _impl_.adj_right_lane_;
  _impl_.adj_right_lane_ = nullptr;
  return temp;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::_internal_mutable_adj_right_lane() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.adj_right_lane_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::LdwLane>(GetArenaForAllocation());
    _impl_.adj_right_lane_ = p;
  }
  return _impl_.adj_right_lane_;
}
inline ::apollo::drivers::LdwLane* LdwRoadway::mutable_adj_right_lane() {
  ::apollo::drivers::LdwLane* _msg = _internal_mutable_adj_right_lane();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.LdwRoadway.adj_right_lane)
  return _msg;
}
inline void LdwRoadway::set_allocated_adj_right_lane(::apollo::drivers::LdwLane* adj_right_lane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.adj_right_lane_;
  }
  if (adj_right_lane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(adj_right_lane);
    if (message_arena != submessage_arena) {
      adj_right_lane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adj_right_lane, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.adj_right_lane_ = adj_right_lane;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.LdwRoadway.adj_right_lane)
}

// -------------------------------------------------------------------

// LdwLensInfo

// optional float x_image_focal = 1;
inline bool LdwLensInfo::_internal_has_x_image_focal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LdwLensInfo::has_x_image_focal() const {
  return _internal_has_x_image_focal();
}
inline void LdwLensInfo::clear_x_image_focal() {
  _impl_.x_image_focal_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float LdwLensInfo::_internal_x_image_focal() const {
  return _impl_.x_image_focal_;
}
inline float LdwLensInfo::x_image_focal() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLensInfo.x_image_focal)
  return _internal_x_image_focal();
}
inline void LdwLensInfo::_internal_set_x_image_focal(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_image_focal_ = value;
}
inline void LdwLensInfo::set_x_image_focal(float value) {
  _internal_set_x_image_focal(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLensInfo.x_image_focal)
}

// optional float y_image_focal = 2;
inline bool LdwLensInfo::_internal_has_y_image_focal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LdwLensInfo::has_y_image_focal() const {
  return _internal_has_y_image_focal();
}
inline void LdwLensInfo::clear_y_image_focal() {
  _impl_.y_image_focal_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float LdwLensInfo::_internal_y_image_focal() const {
  return _impl_.y_image_focal_;
}
inline float LdwLensInfo::y_image_focal() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLensInfo.y_image_focal)
  return _internal_y_image_focal();
}
inline void LdwLensInfo::_internal_set_y_image_focal(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_image_focal_ = value;
}
inline void LdwLensInfo::set_y_image_focal(float value) {
  _internal_set_y_image_focal(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLensInfo.y_image_focal)
}

// optional float xratio_focal_pixel = 3;
inline bool LdwLensInfo::_internal_has_xratio_focal_pixel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LdwLensInfo::has_xratio_focal_pixel() const {
  return _internal_has_xratio_focal_pixel();
}
inline void LdwLensInfo::clear_xratio_focal_pixel() {
  _impl_.xratio_focal_pixel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float LdwLensInfo::_internal_xratio_focal_pixel() const {
  return _impl_.xratio_focal_pixel_;
}
inline float LdwLensInfo::xratio_focal_pixel() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLensInfo.xratio_focal_pixel)
  return _internal_xratio_focal_pixel();
}
inline void LdwLensInfo::_internal_set_xratio_focal_pixel(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.xratio_focal_pixel_ = value;
}
inline void LdwLensInfo::set_xratio_focal_pixel(float value) {
  _internal_set_xratio_focal_pixel(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLensInfo.xratio_focal_pixel)
}

// optional float yratio_focal_pixel = 4;
inline bool LdwLensInfo::_internal_has_yratio_focal_pixel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LdwLensInfo::has_yratio_focal_pixel() const {
  return _internal_has_yratio_focal_pixel();
}
inline void LdwLensInfo::clear_yratio_focal_pixel() {
  _impl_.yratio_focal_pixel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float LdwLensInfo::_internal_yratio_focal_pixel() const {
  return _impl_.yratio_focal_pixel_;
}
inline float LdwLensInfo::yratio_focal_pixel() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLensInfo.yratio_focal_pixel)
  return _internal_yratio_focal_pixel();
}
inline void LdwLensInfo::_internal_set_yratio_focal_pixel(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.yratio_focal_pixel_ = value;
}
inline void LdwLensInfo::set_yratio_focal_pixel(float value) {
  _internal_set_yratio_focal_pixel(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLensInfo.yratio_focal_pixel)
}

// optional float mountingheight = 5;
inline bool LdwLensInfo::_internal_has_mountingheight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LdwLensInfo::has_mountingheight() const {
  return _internal_has_mountingheight();
}
inline void LdwLensInfo::clear_mountingheight() {
  _impl_.mountingheight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float LdwLensInfo::_internal_mountingheight() const {
  return _impl_.mountingheight_;
}
inline float LdwLensInfo::mountingheight() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLensInfo.mountingheight)
  return _internal_mountingheight();
}
inline void LdwLensInfo::_internal_set_mountingheight(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mountingheight_ = value;
}
inline void LdwLensInfo::set_mountingheight(float value) {
  _internal_set_mountingheight(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLensInfo.mountingheight)
}

// optional float mcosrx = 6;
inline bool LdwLensInfo::_internal_has_mcosrx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LdwLensInfo::has_mcosrx() const {
  return _internal_has_mcosrx();
}
inline void LdwLensInfo::clear_mcosrx() {
  _impl_.mcosrx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float LdwLensInfo::_internal_mcosrx() const {
  return _impl_.mcosrx_;
}
inline float LdwLensInfo::mcosrx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLensInfo.mcosrx)
  return _internal_mcosrx();
}
inline void LdwLensInfo::_internal_set_mcosrx(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.mcosrx_ = value;
}
inline void LdwLensInfo::set_mcosrx(float value) {
  _internal_set_mcosrx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLensInfo.mcosrx)
}

// optional float msinrx = 7;
inline bool LdwLensInfo::_internal_has_msinrx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LdwLensInfo::has_msinrx() const {
  return _internal_has_msinrx();
}
inline void LdwLensInfo::clear_msinrx() {
  _impl_.msinrx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float LdwLensInfo::_internal_msinrx() const {
  return _impl_.msinrx_;
}
inline float LdwLensInfo::msinrx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLensInfo.msinrx)
  return _internal_msinrx();
}
inline void LdwLensInfo::_internal_set_msinrx(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.msinrx_ = value;
}
inline void LdwLensInfo::set_msinrx(float value) {
  _internal_set_msinrx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLensInfo.msinrx)
}

// optional float mcosry = 8;
inline bool LdwLensInfo::_internal_has_mcosry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LdwLensInfo::has_mcosry() const {
  return _internal_has_mcosry();
}
inline void LdwLensInfo::clear_mcosry() {
  _impl_.mcosry_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float LdwLensInfo::_internal_mcosry() const {
  return _impl_.mcosry_;
}
inline float LdwLensInfo::mcosry() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLensInfo.mcosry)
  return _internal_mcosry();
}
inline void LdwLensInfo::_internal_set_mcosry(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.mcosry_ = value;
}
inline void LdwLensInfo::set_mcosry(float value) {
  _internal_set_mcosry(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLensInfo.mcosry)
}

// optional float msinry = 9;
inline bool LdwLensInfo::_internal_has_msinry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LdwLensInfo::has_msinry() const {
  return _internal_has_msinry();
}
inline void LdwLensInfo::clear_msinry() {
  _impl_.msinry_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float LdwLensInfo::_internal_msinry() const {
  return _impl_.msinry_;
}
inline float LdwLensInfo::msinry() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwLensInfo.msinry)
  return _internal_msinry();
}
inline void LdwLensInfo::_internal_set_msinry(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.msinry_ = value;
}
inline void LdwLensInfo::set_msinry(float value) {
  _internal_set_msinry(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwLensInfo.msinry)
}

// -------------------------------------------------------------------

// LdwDataPacks

// optional .apollo.drivers.LdwRoadway roadway = 1;
inline bool LdwDataPacks::_internal_has_roadway() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roadway_ != nullptr);
  return value;
}
inline bool LdwDataPacks::has_roadway() const {
  return _internal_has_roadway();
}
inline void LdwDataPacks::clear_roadway() {
  if (_impl_.roadway_ != nullptr) _impl_.roadway_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::drivers::LdwRoadway& LdwDataPacks::_internal_roadway() const {
  const ::apollo::drivers::LdwRoadway* p = _impl_.roadway_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::LdwRoadway&>(
      ::apollo::drivers::_LdwRoadway_default_instance_);
}
inline const ::apollo::drivers::LdwRoadway& LdwDataPacks::roadway() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwDataPacks.roadway)
  return _internal_roadway();
}
inline void LdwDataPacks::unsafe_arena_set_allocated_roadway(
    ::apollo::drivers::LdwRoadway* roadway) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.roadway_);
  }
  _impl_.roadway_ = roadway;
  if (roadway) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.LdwDataPacks.roadway)
}
inline ::apollo::drivers::LdwRoadway* LdwDataPacks::release_roadway() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::drivers::LdwRoadway* temp = _impl_.roadway_;
  _impl_.roadway_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::LdwRoadway* LdwDataPacks::unsafe_arena_release_roadway() {
  // @@protoc_insertion_point(field_release:apollo.drivers.LdwDataPacks.roadway)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::drivers::LdwRoadway* temp = _impl_.roadway_;
  _impl_.roadway_ = nullptr;
  return temp;
}
inline ::apollo::drivers::LdwRoadway* LdwDataPacks::_internal_mutable_roadway() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.roadway_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::LdwRoadway>(GetArenaForAllocation());
    _impl_.roadway_ = p;
  }
  return _impl_.roadway_;
}
inline ::apollo::drivers::LdwRoadway* LdwDataPacks::mutable_roadway() {
  ::apollo::drivers::LdwRoadway* _msg = _internal_mutable_roadway();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.LdwDataPacks.roadway)
  return _msg;
}
inline void LdwDataPacks::set_allocated_roadway(::apollo::drivers::LdwRoadway* roadway) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.roadway_;
  }
  if (roadway) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(roadway);
    if (message_arena != submessage_arena) {
      roadway = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roadway, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.roadway_ = roadway;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.LdwDataPacks.roadway)
}

// optional .apollo.drivers.LdwSoftStatus softstatus = 2;
inline bool LdwDataPacks::_internal_has_softstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LdwDataPacks::has_softstatus() const {
  return _internal_has_softstatus();
}
inline void LdwDataPacks::clear_softstatus() {
  _impl_.softstatus_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::drivers::LdwSoftStatus LdwDataPacks::_internal_softstatus() const {
  return static_cast< ::apollo::drivers::LdwSoftStatus >(_impl_.softstatus_);
}
inline ::apollo::drivers::LdwSoftStatus LdwDataPacks::softstatus() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwDataPacks.softstatus)
  return _internal_softstatus();
}
inline void LdwDataPacks::_internal_set_softstatus(::apollo::drivers::LdwSoftStatus value) {
  assert(::apollo::drivers::LdwSoftStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.softstatus_ = value;
}
inline void LdwDataPacks::set_softstatus(::apollo::drivers::LdwSoftStatus value) {
  _internal_set_softstatus(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwDataPacks.softstatus)
}

// optional .apollo.drivers.LdwSteerStatus steerstatus = 3;
inline bool LdwDataPacks::_internal_has_steerstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LdwDataPacks::has_steerstatus() const {
  return _internal_has_steerstatus();
}
inline void LdwDataPacks::clear_steerstatus() {
  _impl_.steerstatus_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::apollo::drivers::LdwSteerStatus LdwDataPacks::_internal_steerstatus() const {
  return static_cast< ::apollo::drivers::LdwSteerStatus >(_impl_.steerstatus_);
}
inline ::apollo::drivers::LdwSteerStatus LdwDataPacks::steerstatus() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwDataPacks.steerstatus)
  return _internal_steerstatus();
}
inline void LdwDataPacks::_internal_set_steerstatus(::apollo::drivers::LdwSteerStatus value) {
  assert(::apollo::drivers::LdwSteerStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.steerstatus_ = value;
}
inline void LdwDataPacks::set_steerstatus(::apollo::drivers::LdwSteerStatus value) {
  _internal_set_steerstatus(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.LdwDataPacks.steerstatus)
}

// optional .apollo.drivers.LdwLensInfo lens = 4;
inline bool LdwDataPacks::_internal_has_lens() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lens_ != nullptr);
  return value;
}
inline bool LdwDataPacks::has_lens() const {
  return _internal_has_lens();
}
inline void LdwDataPacks::clear_lens() {
  if (_impl_.lens_ != nullptr) _impl_.lens_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::drivers::LdwLensInfo& LdwDataPacks::_internal_lens() const {
  const ::apollo::drivers::LdwLensInfo* p = _impl_.lens_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::LdwLensInfo&>(
      ::apollo::drivers::_LdwLensInfo_default_instance_);
}
inline const ::apollo::drivers::LdwLensInfo& LdwDataPacks::lens() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.LdwDataPacks.lens)
  return _internal_lens();
}
inline void LdwDataPacks::unsafe_arena_set_allocated_lens(
    ::apollo::drivers::LdwLensInfo* lens) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lens_);
  }
  _impl_.lens_ = lens;
  if (lens) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.LdwDataPacks.lens)
}
inline ::apollo::drivers::LdwLensInfo* LdwDataPacks::release_lens() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::drivers::LdwLensInfo* temp = _impl_.lens_;
  _impl_.lens_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::LdwLensInfo* LdwDataPacks::unsafe_arena_release_lens() {
  // @@protoc_insertion_point(field_release:apollo.drivers.LdwDataPacks.lens)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::drivers::LdwLensInfo* temp = _impl_.lens_;
  _impl_.lens_ = nullptr;
  return temp;
}
inline ::apollo::drivers::LdwLensInfo* LdwDataPacks::_internal_mutable_lens() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lens_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::LdwLensInfo>(GetArenaForAllocation());
    _impl_.lens_ = p;
  }
  return _impl_.lens_;
}
inline ::apollo::drivers::LdwLensInfo* LdwDataPacks::mutable_lens() {
  ::apollo::drivers::LdwLensInfo* _msg = _internal_mutable_lens();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.LdwDataPacks.lens)
  return _msg;
}
inline void LdwDataPacks::set_allocated_lens(::apollo::drivers::LdwLensInfo* lens) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lens_;
  }
  if (lens) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lens);
    if (message_arena != submessage_arena) {
      lens = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lens, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.lens_ = lens;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.LdwDataPacks.lens)
}

// -------------------------------------------------------------------

// OutputObstacle

// optional float currentspeed = 1;
inline bool OutputObstacle::_internal_has_currentspeed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OutputObstacle::has_currentspeed() const {
  return _internal_has_currentspeed();
}
inline void OutputObstacle::clear_currentspeed() {
  _impl_.currentspeed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float OutputObstacle::_internal_currentspeed() const {
  return _impl_.currentspeed_;
}
inline float OutputObstacle::currentspeed() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.currentspeed)
  return _internal_currentspeed();
}
inline void OutputObstacle::_internal_set_currentspeed(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currentspeed_ = value;
}
inline void OutputObstacle::set_currentspeed(float value) {
  _internal_set_currentspeed(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.currentspeed)
}

// optional float framerate = 2;
inline bool OutputObstacle::_internal_has_framerate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OutputObstacle::has_framerate() const {
  return _internal_has_framerate();
}
inline void OutputObstacle::clear_framerate() {
  _impl_.framerate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float OutputObstacle::_internal_framerate() const {
  return _impl_.framerate_;
}
inline float OutputObstacle::framerate() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.framerate)
  return _internal_framerate();
}
inline void OutputObstacle::_internal_set_framerate(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.framerate_ = value;
}
inline void OutputObstacle::set_framerate(float value) {
  _internal_set_framerate(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.framerate)
}

// optional uint32 trackid = 3;
inline bool OutputObstacle::_internal_has_trackid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OutputObstacle::has_trackid() const {
  return _internal_has_trackid();
}
inline void OutputObstacle::clear_trackid() {
  _impl_.trackid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t OutputObstacle::_internal_trackid() const {
  return _impl_.trackid_;
}
inline uint32_t OutputObstacle::trackid() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.trackid)
  return _internal_trackid();
}
inline void OutputObstacle::_internal_set_trackid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.trackid_ = value;
}
inline void OutputObstacle::set_trackid(uint32_t value) {
  _internal_set_trackid(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.trackid)
}

// optional uint32 trackframenum = 4;
inline bool OutputObstacle::_internal_has_trackframenum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OutputObstacle::has_trackframenum() const {
  return _internal_has_trackframenum();
}
inline void OutputObstacle::clear_trackframenum() {
  _impl_.trackframenum_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t OutputObstacle::_internal_trackframenum() const {
  return _impl_.trackframenum_;
}
inline uint32_t OutputObstacle::trackframenum() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.trackframenum)
  return _internal_trackframenum();
}
inline void OutputObstacle::_internal_set_trackframenum(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.trackframenum_ = value;
}
inline void OutputObstacle::set_trackframenum(uint32_t value) {
  _internal_set_trackframenum(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.trackframenum)
}

// optional uint32 statelabel = 5;
inline bool OutputObstacle::_internal_has_statelabel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OutputObstacle::has_statelabel() const {
  return _internal_has_statelabel();
}
inline void OutputObstacle::clear_statelabel() {
  _impl_.statelabel_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t OutputObstacle::_internal_statelabel() const {
  return _impl_.statelabel_;
}
inline uint32_t OutputObstacle::statelabel() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.statelabel)
  return _internal_statelabel();
}
inline void OutputObstacle::_internal_set_statelabel(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.statelabel_ = value;
}
inline void OutputObstacle::set_statelabel(uint32_t value) {
  _internal_set_statelabel(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.statelabel)
}

// optional uint32 classlabel = 6;
inline bool OutputObstacle::_internal_has_classlabel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OutputObstacle::has_classlabel() const {
  return _internal_has_classlabel();
}
inline void OutputObstacle::clear_classlabel() {
  _impl_.classlabel_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t OutputObstacle::_internal_classlabel() const {
  return _impl_.classlabel_;
}
inline uint32_t OutputObstacle::classlabel() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.classlabel)
  return _internal_classlabel();
}
inline void OutputObstacle::_internal_set_classlabel(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.classlabel_ = value;
}
inline void OutputObstacle::set_classlabel(uint32_t value) {
  _internal_set_classlabel(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.classlabel)
}

// optional uint32 continuouslabel = 7;
inline bool OutputObstacle::_internal_has_continuouslabel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OutputObstacle::has_continuouslabel() const {
  return _internal_has_continuouslabel();
}
inline void OutputObstacle::clear_continuouslabel() {
  _impl_.continuouslabel_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t OutputObstacle::_internal_continuouslabel() const {
  return _impl_.continuouslabel_;
}
inline uint32_t OutputObstacle::continuouslabel() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.continuouslabel)
  return _internal_continuouslabel();
}
inline void OutputObstacle::_internal_set_continuouslabel(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.continuouslabel_ = value;
}
inline void OutputObstacle::set_continuouslabel(uint32_t value) {
  _internal_set_continuouslabel(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.continuouslabel)
}

// optional uint32 fuzzyestimationvalid = 8;
inline bool OutputObstacle::_internal_has_fuzzyestimationvalid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzyestimationvalid() const {
  return _internal_has_fuzzyestimationvalid();
}
inline void OutputObstacle::clear_fuzzyestimationvalid() {
  _impl_.fuzzyestimationvalid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t OutputObstacle::_internal_fuzzyestimationvalid() const {
  return _impl_.fuzzyestimationvalid_;
}
inline uint32_t OutputObstacle::fuzzyestimationvalid() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzyestimationvalid)
  return _internal_fuzzyestimationvalid();
}
inline void OutputObstacle::_internal_set_fuzzyestimationvalid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.fuzzyestimationvalid_ = value;
}
inline void OutputObstacle::set_fuzzyestimationvalid(uint32_t value) {
  _internal_set_fuzzyestimationvalid(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzyestimationvalid)
}

// optional .apollo.drivers.OutputObstacle.RecognitionType obstacletype = 9;
inline bool OutputObstacle::_internal_has_obstacletype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool OutputObstacle::has_obstacletype() const {
  return _internal_has_obstacletype();
}
inline void OutputObstacle::clear_obstacletype() {
  _impl_.obstacletype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::apollo::drivers::OutputObstacle_RecognitionType OutputObstacle::_internal_obstacletype() const {
  return static_cast< ::apollo::drivers::OutputObstacle_RecognitionType >(_impl_.obstacletype_);
}
inline ::apollo::drivers::OutputObstacle_RecognitionType OutputObstacle::obstacletype() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.obstacletype)
  return _internal_obstacletype();
}
inline void OutputObstacle::_internal_set_obstacletype(::apollo::drivers::OutputObstacle_RecognitionType value) {
  assert(::apollo::drivers::OutputObstacle_RecognitionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.obstacletype_ = value;
}
inline void OutputObstacle::set_obstacletype(::apollo::drivers::OutputObstacle_RecognitionType value) {
  _internal_set_obstacletype(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.obstacletype)
}

// optional float avgdisp = 10;
inline bool OutputObstacle::_internal_has_avgdisp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool OutputObstacle::has_avgdisp() const {
  return _internal_has_avgdisp();
}
inline void OutputObstacle::clear_avgdisp() {
  _impl_.avgdisp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float OutputObstacle::_internal_avgdisp() const {
  return _impl_.avgdisp_;
}
inline float OutputObstacle::avgdisp() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.avgdisp)
  return _internal_avgdisp();
}
inline void OutputObstacle::_internal_set_avgdisp(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.avgdisp_ = value;
}
inline void OutputObstacle::set_avgdisp(float value) {
  _internal_set_avgdisp(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.avgdisp)
}

// optional float avgdistancez = 11;
inline bool OutputObstacle::_internal_has_avgdistancez() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool OutputObstacle::has_avgdistancez() const {
  return _internal_has_avgdistancez();
}
inline void OutputObstacle::clear_avgdistancez() {
  _impl_.avgdistancez_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float OutputObstacle::_internal_avgdistancez() const {
  return _impl_.avgdistancez_;
}
inline float OutputObstacle::avgdistancez() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.avgdistancez)
  return _internal_avgdistancez();
}
inline void OutputObstacle::_internal_set_avgdistancez(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.avgdistancez_ = value;
}
inline void OutputObstacle::set_avgdistancez(float value) {
  _internal_set_avgdistancez(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.avgdistancez)
}

// optional float neardistancez = 12;
inline bool OutputObstacle::_internal_has_neardistancez() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool OutputObstacle::has_neardistancez() const {
  return _internal_has_neardistancez();
}
inline void OutputObstacle::clear_neardistancez() {
  _impl_.neardistancez_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float OutputObstacle::_internal_neardistancez() const {
  return _impl_.neardistancez_;
}
inline float OutputObstacle::neardistancez() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.neardistancez)
  return _internal_neardistancez();
}
inline void OutputObstacle::_internal_set_neardistancez(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.neardistancez_ = value;
}
inline void OutputObstacle::set_neardistancez(float value) {
  _internal_set_neardistancez(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.neardistancez)
}

// optional float fardistancez = 13;
inline bool OutputObstacle::_internal_has_fardistancez() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool OutputObstacle::has_fardistancez() const {
  return _internal_has_fardistancez();
}
inline void OutputObstacle::clear_fardistancez() {
  _impl_.fardistancez_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float OutputObstacle::_internal_fardistancez() const {
  return _impl_.fardistancez_;
}
inline float OutputObstacle::fardistancez() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fardistancez)
  return _internal_fardistancez();
}
inline void OutputObstacle::_internal_set_fardistancez(float value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.fardistancez_ = value;
}
inline void OutputObstacle::set_fardistancez(float value) {
  _internal_set_fardistancez(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fardistancez)
}

// optional float real3dleftx = 14;
inline bool OutputObstacle::_internal_has_real3dleftx() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool OutputObstacle::has_real3dleftx() const {
  return _internal_has_real3dleftx();
}
inline void OutputObstacle::clear_real3dleftx() {
  _impl_.real3dleftx_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float OutputObstacle::_internal_real3dleftx() const {
  return _impl_.real3dleftx_;
}
inline float OutputObstacle::real3dleftx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.real3dleftx)
  return _internal_real3dleftx();
}
inline void OutputObstacle::_internal_set_real3dleftx(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.real3dleftx_ = value;
}
inline void OutputObstacle::set_real3dleftx(float value) {
  _internal_set_real3dleftx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.real3dleftx)
}

// optional float real3drightx = 15;
inline bool OutputObstacle::_internal_has_real3drightx() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool OutputObstacle::has_real3drightx() const {
  return _internal_has_real3drightx();
}
inline void OutputObstacle::clear_real3drightx() {
  _impl_.real3drightx_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float OutputObstacle::_internal_real3drightx() const {
  return _impl_.real3drightx_;
}
inline float OutputObstacle::real3drightx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.real3drightx)
  return _internal_real3drightx();
}
inline void OutputObstacle::_internal_set_real3drightx(float value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.real3drightx_ = value;
}
inline void OutputObstacle::set_real3drightx(float value) {
  _internal_set_real3drightx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.real3drightx)
}

// optional float real3dcenterx = 16;
inline bool OutputObstacle::_internal_has_real3dcenterx() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool OutputObstacle::has_real3dcenterx() const {
  return _internal_has_real3dcenterx();
}
inline void OutputObstacle::clear_real3dcenterx() {
  _impl_.real3dcenterx_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float OutputObstacle::_internal_real3dcenterx() const {
  return _impl_.real3dcenterx_;
}
inline float OutputObstacle::real3dcenterx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.real3dcenterx)
  return _internal_real3dcenterx();
}
inline void OutputObstacle::_internal_set_real3dcenterx(float value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.real3dcenterx_ = value;
}
inline void OutputObstacle::set_real3dcenterx(float value) {
  _internal_set_real3dcenterx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.real3dcenterx)
}

// optional float real3dupy = 17;
inline bool OutputObstacle::_internal_has_real3dupy() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool OutputObstacle::has_real3dupy() const {
  return _internal_has_real3dupy();
}
inline void OutputObstacle::clear_real3dupy() {
  _impl_.real3dupy_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline float OutputObstacle::_internal_real3dupy() const {
  return _impl_.real3dupy_;
}
inline float OutputObstacle::real3dupy() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.real3dupy)
  return _internal_real3dupy();
}
inline void OutputObstacle::_internal_set_real3dupy(float value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.real3dupy_ = value;
}
inline void OutputObstacle::set_real3dupy(float value) {
  _internal_set_real3dupy(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.real3dupy)
}

// optional float real3dlowy = 18;
inline bool OutputObstacle::_internal_has_real3dlowy() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool OutputObstacle::has_real3dlowy() const {
  return _internal_has_real3dlowy();
}
inline void OutputObstacle::clear_real3dlowy() {
  _impl_.real3dlowy_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline float OutputObstacle::_internal_real3dlowy() const {
  return _impl_.real3dlowy_;
}
inline float OutputObstacle::real3dlowy() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.real3dlowy)
  return _internal_real3dlowy();
}
inline void OutputObstacle::_internal_set_real3dlowy(float value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.real3dlowy_ = value;
}
inline void OutputObstacle::set_real3dlowy(float value) {
  _internal_set_real3dlowy(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.real3dlowy)
}

// optional uint32 firstpointx = 19;
inline bool OutputObstacle::_internal_has_firstpointx() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool OutputObstacle::has_firstpointx() const {
  return _internal_has_firstpointx();
}
inline void OutputObstacle::clear_firstpointx() {
  _impl_.firstpointx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint32_t OutputObstacle::_internal_firstpointx() const {
  return _impl_.firstpointx_;
}
inline uint32_t OutputObstacle::firstpointx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.firstpointx)
  return _internal_firstpointx();
}
inline void OutputObstacle::_internal_set_firstpointx(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.firstpointx_ = value;
}
inline void OutputObstacle::set_firstpointx(uint32_t value) {
  _internal_set_firstpointx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.firstpointx)
}

// optional uint32 firstpointy = 20;
inline bool OutputObstacle::_internal_has_firstpointy() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool OutputObstacle::has_firstpointy() const {
  return _internal_has_firstpointy();
}
inline void OutputObstacle::clear_firstpointy() {
  _impl_.firstpointy_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline uint32_t OutputObstacle::_internal_firstpointy() const {
  return _impl_.firstpointy_;
}
inline uint32_t OutputObstacle::firstpointy() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.firstpointy)
  return _internal_firstpointy();
}
inline void OutputObstacle::_internal_set_firstpointy(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.firstpointy_ = value;
}
inline void OutputObstacle::set_firstpointy(uint32_t value) {
  _internal_set_firstpointy(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.firstpointy)
}

// optional uint32 secondpointx = 21;
inline bool OutputObstacle::_internal_has_secondpointx() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool OutputObstacle::has_secondpointx() const {
  return _internal_has_secondpointx();
}
inline void OutputObstacle::clear_secondpointx() {
  _impl_.secondpointx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline uint32_t OutputObstacle::_internal_secondpointx() const {
  return _impl_.secondpointx_;
}
inline uint32_t OutputObstacle::secondpointx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.secondpointx)
  return _internal_secondpointx();
}
inline void OutputObstacle::_internal_set_secondpointx(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.secondpointx_ = value;
}
inline void OutputObstacle::set_secondpointx(uint32_t value) {
  _internal_set_secondpointx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.secondpointx)
}

// optional uint32 secondpointy = 22;
inline bool OutputObstacle::_internal_has_secondpointy() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool OutputObstacle::has_secondpointy() const {
  return _internal_has_secondpointy();
}
inline void OutputObstacle::clear_secondpointy() {
  _impl_.secondpointy_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t OutputObstacle::_internal_secondpointy() const {
  return _impl_.secondpointy_;
}
inline uint32_t OutputObstacle::secondpointy() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.secondpointy)
  return _internal_secondpointy();
}
inline void OutputObstacle::_internal_set_secondpointy(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.secondpointy_ = value;
}
inline void OutputObstacle::set_secondpointy(uint32_t value) {
  _internal_set_secondpointy(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.secondpointy)
}

// optional uint32 thirdpointx = 23;
inline bool OutputObstacle::_internal_has_thirdpointx() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool OutputObstacle::has_thirdpointx() const {
  return _internal_has_thirdpointx();
}
inline void OutputObstacle::clear_thirdpointx() {
  _impl_.thirdpointx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline uint32_t OutputObstacle::_internal_thirdpointx() const {
  return _impl_.thirdpointx_;
}
inline uint32_t OutputObstacle::thirdpointx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.thirdpointx)
  return _internal_thirdpointx();
}
inline void OutputObstacle::_internal_set_thirdpointx(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.thirdpointx_ = value;
}
inline void OutputObstacle::set_thirdpointx(uint32_t value) {
  _internal_set_thirdpointx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.thirdpointx)
}

// optional uint32 thirdpointy = 24;
inline bool OutputObstacle::_internal_has_thirdpointy() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool OutputObstacle::has_thirdpointy() const {
  return _internal_has_thirdpointy();
}
inline void OutputObstacle::clear_thirdpointy() {
  _impl_.thirdpointy_ = 0u;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline uint32_t OutputObstacle::_internal_thirdpointy() const {
  return _impl_.thirdpointy_;
}
inline uint32_t OutputObstacle::thirdpointy() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.thirdpointy)
  return _internal_thirdpointy();
}
inline void OutputObstacle::_internal_set_thirdpointy(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.thirdpointy_ = value;
}
inline void OutputObstacle::set_thirdpointy(uint32_t value) {
  _internal_set_thirdpointy(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.thirdpointy)
}

// optional uint32 fourthpointx = 25;
inline bool OutputObstacle::_internal_has_fourthpointx() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool OutputObstacle::has_fourthpointx() const {
  return _internal_has_fourthpointx();
}
inline void OutputObstacle::clear_fourthpointx() {
  _impl_.fourthpointx_ = 0u;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline uint32_t OutputObstacle::_internal_fourthpointx() const {
  return _impl_.fourthpointx_;
}
inline uint32_t OutputObstacle::fourthpointx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fourthpointx)
  return _internal_fourthpointx();
}
inline void OutputObstacle::_internal_set_fourthpointx(uint32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.fourthpointx_ = value;
}
inline void OutputObstacle::set_fourthpointx(uint32_t value) {
  _internal_set_fourthpointx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fourthpointx)
}

// optional uint32 fourthpointy = 26;
inline bool OutputObstacle::_internal_has_fourthpointy() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool OutputObstacle::has_fourthpointy() const {
  return _internal_has_fourthpointy();
}
inline void OutputObstacle::clear_fourthpointy() {
  _impl_.fourthpointy_ = 0u;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline uint32_t OutputObstacle::_internal_fourthpointy() const {
  return _impl_.fourthpointy_;
}
inline uint32_t OutputObstacle::fourthpointy() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fourthpointy)
  return _internal_fourthpointy();
}
inline void OutputObstacle::_internal_set_fourthpointy(uint32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.fourthpointy_ = value;
}
inline void OutputObstacle::set_fourthpointy(uint32_t value) {
  _internal_set_fourthpointy(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fourthpointy)
}

// optional float fuzzyrelativedistancez = 27;
inline bool OutputObstacle::_internal_has_fuzzyrelativedistancez() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzyrelativedistancez() const {
  return _internal_has_fuzzyrelativedistancez();
}
inline void OutputObstacle::clear_fuzzyrelativedistancez() {
  _impl_.fuzzyrelativedistancez_ = 0;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline float OutputObstacle::_internal_fuzzyrelativedistancez() const {
  return _impl_.fuzzyrelativedistancez_;
}
inline float OutputObstacle::fuzzyrelativedistancez() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzyrelativedistancez)
  return _internal_fuzzyrelativedistancez();
}
inline void OutputObstacle::_internal_set_fuzzyrelativedistancez(float value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.fuzzyrelativedistancez_ = value;
}
inline void OutputObstacle::set_fuzzyrelativedistancez(float value) {
  _internal_set_fuzzyrelativedistancez(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzyrelativedistancez)
}

// optional float fuzzyrelativespeedz = 28;
inline bool OutputObstacle::_internal_has_fuzzyrelativespeedz() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzyrelativespeedz() const {
  return _internal_has_fuzzyrelativespeedz();
}
inline void OutputObstacle::clear_fuzzyrelativespeedz() {
  _impl_.fuzzyrelativespeedz_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline float OutputObstacle::_internal_fuzzyrelativespeedz() const {
  return _impl_.fuzzyrelativespeedz_;
}
inline float OutputObstacle::fuzzyrelativespeedz() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzyrelativespeedz)
  return _internal_fuzzyrelativespeedz();
}
inline void OutputObstacle::_internal_set_fuzzyrelativespeedz(float value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.fuzzyrelativespeedz_ = value;
}
inline void OutputObstacle::set_fuzzyrelativespeedz(float value) {
  _internal_set_fuzzyrelativespeedz(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzyrelativespeedz)
}

// optional float fuzzycollisiontimez = 29;
inline bool OutputObstacle::_internal_has_fuzzycollisiontimez() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzycollisiontimez() const {
  return _internal_has_fuzzycollisiontimez();
}
inline void OutputObstacle::clear_fuzzycollisiontimez() {
  _impl_.fuzzycollisiontimez_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline float OutputObstacle::_internal_fuzzycollisiontimez() const {
  return _impl_.fuzzycollisiontimez_;
}
inline float OutputObstacle::fuzzycollisiontimez() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzycollisiontimez)
  return _internal_fuzzycollisiontimez();
}
inline void OutputObstacle::_internal_set_fuzzycollisiontimez(float value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.fuzzycollisiontimez_ = value;
}
inline void OutputObstacle::set_fuzzycollisiontimez(float value) {
  _internal_set_fuzzycollisiontimez(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzycollisiontimez)
}

// optional uint32 fuzzycollisionx = 30;
inline bool OutputObstacle::_internal_has_fuzzycollisionx() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzycollisionx() const {
  return _internal_has_fuzzycollisionx();
}
inline void OutputObstacle::clear_fuzzycollisionx() {
  _impl_.fuzzycollisionx_ = 0u;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline uint32_t OutputObstacle::_internal_fuzzycollisionx() const {
  return _impl_.fuzzycollisionx_;
}
inline uint32_t OutputObstacle::fuzzycollisionx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzycollisionx)
  return _internal_fuzzycollisionx();
}
inline void OutputObstacle::_internal_set_fuzzycollisionx(uint32_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.fuzzycollisionx_ = value;
}
inline void OutputObstacle::set_fuzzycollisionx(uint32_t value) {
  _internal_set_fuzzycollisionx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzycollisionx)
}

// optional float fuzzy3dwidth = 31;
inline bool OutputObstacle::_internal_has_fuzzy3dwidth() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzy3dwidth() const {
  return _internal_has_fuzzy3dwidth();
}
inline void OutputObstacle::clear_fuzzy3dwidth() {
  _impl_.fuzzy3dwidth_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline float OutputObstacle::_internal_fuzzy3dwidth() const {
  return _impl_.fuzzy3dwidth_;
}
inline float OutputObstacle::fuzzy3dwidth() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzy3dwidth)
  return _internal_fuzzy3dwidth();
}
inline void OutputObstacle::_internal_set_fuzzy3dwidth(float value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.fuzzy3dwidth_ = value;
}
inline void OutputObstacle::set_fuzzy3dwidth(float value) {
  _internal_set_fuzzy3dwidth(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzy3dwidth)
}

// optional float fuzzy3dcenterx = 32;
inline bool OutputObstacle::_internal_has_fuzzy3dcenterx() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzy3dcenterx() const {
  return _internal_has_fuzzy3dcenterx();
}
inline void OutputObstacle::clear_fuzzy3dcenterx() {
  _impl_.fuzzy3dcenterx_ = 0;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline float OutputObstacle::_internal_fuzzy3dcenterx() const {
  return _impl_.fuzzy3dcenterx_;
}
inline float OutputObstacle::fuzzy3dcenterx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzy3dcenterx)
  return _internal_fuzzy3dcenterx();
}
inline void OutputObstacle::_internal_set_fuzzy3dcenterx(float value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.fuzzy3dcenterx_ = value;
}
inline void OutputObstacle::set_fuzzy3dcenterx(float value) {
  _internal_set_fuzzy3dcenterx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzy3dcenterx)
}

// optional float fuzzy3dleftx = 33;
inline bool OutputObstacle::_internal_has_fuzzy3dleftx() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzy3dleftx() const {
  return _internal_has_fuzzy3dleftx();
}
inline void OutputObstacle::clear_fuzzy3dleftx() {
  _impl_.fuzzy3dleftx_ = 0;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline float OutputObstacle::_internal_fuzzy3dleftx() const {
  return _impl_.fuzzy3dleftx_;
}
inline float OutputObstacle::fuzzy3dleftx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzy3dleftx)
  return _internal_fuzzy3dleftx();
}
inline void OutputObstacle::_internal_set_fuzzy3dleftx(float value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.fuzzy3dleftx_ = value;
}
inline void OutputObstacle::set_fuzzy3dleftx(float value) {
  _internal_set_fuzzy3dleftx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzy3dleftx)
}

// optional float fuzzy3drightx = 34;
inline bool OutputObstacle::_internal_has_fuzzy3drightx() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzy3drightx() const {
  return _internal_has_fuzzy3drightx();
}
inline void OutputObstacle::clear_fuzzy3drightx() {
  _impl_.fuzzy3drightx_ = 0;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline float OutputObstacle::_internal_fuzzy3drightx() const {
  return _impl_.fuzzy3drightx_;
}
inline float OutputObstacle::fuzzy3drightx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzy3drightx)
  return _internal_fuzzy3drightx();
}
inline void OutputObstacle::_internal_set_fuzzy3drightx(float value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.fuzzy3drightx_ = value;
}
inline void OutputObstacle::set_fuzzy3drightx(float value) {
  _internal_set_fuzzy3drightx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzy3drightx)
}

// optional float fuzzy3dheight = 35;
inline bool OutputObstacle::_internal_has_fuzzy3dheight() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzy3dheight() const {
  return _internal_has_fuzzy3dheight();
}
inline void OutputObstacle::clear_fuzzy3dheight() {
  _impl_.fuzzy3dheight_ = 0;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline float OutputObstacle::_internal_fuzzy3dheight() const {
  return _impl_.fuzzy3dheight_;
}
inline float OutputObstacle::fuzzy3dheight() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzy3dheight)
  return _internal_fuzzy3dheight();
}
inline void OutputObstacle::_internal_set_fuzzy3dheight(float value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.fuzzy3dheight_ = value;
}
inline void OutputObstacle::set_fuzzy3dheight(float value) {
  _internal_set_fuzzy3dheight(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzy3dheight)
}

// optional float fuzzy3dupy = 36;
inline bool OutputObstacle::_internal_has_fuzzy3dupy() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzy3dupy() const {
  return _internal_has_fuzzy3dupy();
}
inline void OutputObstacle::clear_fuzzy3dupy() {
  _impl_.fuzzy3dupy_ = 0;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline float OutputObstacle::_internal_fuzzy3dupy() const {
  return _impl_.fuzzy3dupy_;
}
inline float OutputObstacle::fuzzy3dupy() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzy3dupy)
  return _internal_fuzzy3dupy();
}
inline void OutputObstacle::_internal_set_fuzzy3dupy(float value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.fuzzy3dupy_ = value;
}
inline void OutputObstacle::set_fuzzy3dupy(float value) {
  _internal_set_fuzzy3dupy(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzy3dupy)
}

// optional float fuzzy3dlowy = 37;
inline bool OutputObstacle::_internal_has_fuzzy3dlowy() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzy3dlowy() const {
  return _internal_has_fuzzy3dlowy();
}
inline void OutputObstacle::clear_fuzzy3dlowy() {
  _impl_.fuzzy3dlowy_ = 0;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline float OutputObstacle::_internal_fuzzy3dlowy() const {
  return _impl_.fuzzy3dlowy_;
}
inline float OutputObstacle::fuzzy3dlowy() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzy3dlowy)
  return _internal_fuzzy3dlowy();
}
inline void OutputObstacle::_internal_set_fuzzy3dlowy(float value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.fuzzy3dlowy_ = value;
}
inline void OutputObstacle::set_fuzzy3dlowy(float value) {
  _internal_set_fuzzy3dlowy(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzy3dlowy)
}

// optional float fuzzyrelativespeedcenterx = 38;
inline bool OutputObstacle::_internal_has_fuzzyrelativespeedcenterx() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzyrelativespeedcenterx() const {
  return _internal_has_fuzzyrelativespeedcenterx();
}
inline void OutputObstacle::clear_fuzzyrelativespeedcenterx() {
  _impl_.fuzzyrelativespeedcenterx_ = 0;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline float OutputObstacle::_internal_fuzzyrelativespeedcenterx() const {
  return _impl_.fuzzyrelativespeedcenterx_;
}
inline float OutputObstacle::fuzzyrelativespeedcenterx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzyrelativespeedcenterx)
  return _internal_fuzzyrelativespeedcenterx();
}
inline void OutputObstacle::_internal_set_fuzzyrelativespeedcenterx(float value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.fuzzyrelativespeedcenterx_ = value;
}
inline void OutputObstacle::set_fuzzyrelativespeedcenterx(float value) {
  _internal_set_fuzzyrelativespeedcenterx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzyrelativespeedcenterx)
}

// optional float fuzzyrelativespeedleftx = 39;
inline bool OutputObstacle::_internal_has_fuzzyrelativespeedleftx() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzyrelativespeedleftx() const {
  return _internal_has_fuzzyrelativespeedleftx();
}
inline void OutputObstacle::clear_fuzzyrelativespeedleftx() {
  _impl_.fuzzyrelativespeedleftx_ = 0;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline float OutputObstacle::_internal_fuzzyrelativespeedleftx() const {
  return _impl_.fuzzyrelativespeedleftx_;
}
inline float OutputObstacle::fuzzyrelativespeedleftx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzyrelativespeedleftx)
  return _internal_fuzzyrelativespeedleftx();
}
inline void OutputObstacle::_internal_set_fuzzyrelativespeedleftx(float value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.fuzzyrelativespeedleftx_ = value;
}
inline void OutputObstacle::set_fuzzyrelativespeedleftx(float value) {
  _internal_set_fuzzyrelativespeedleftx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzyrelativespeedleftx)
}

// optional float fuzzyrelativespeedrightx = 40;
inline bool OutputObstacle::_internal_has_fuzzyrelativespeedrightx() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool OutputObstacle::has_fuzzyrelativespeedrightx() const {
  return _internal_has_fuzzyrelativespeedrightx();
}
inline void OutputObstacle::clear_fuzzyrelativespeedrightx() {
  _impl_.fuzzyrelativespeedrightx_ = 0;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline float OutputObstacle::_internal_fuzzyrelativespeedrightx() const {
  return _impl_.fuzzyrelativespeedrightx_;
}
inline float OutputObstacle::fuzzyrelativespeedrightx() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.OutputObstacle.fuzzyrelativespeedrightx)
  return _internal_fuzzyrelativespeedrightx();
}
inline void OutputObstacle::_internal_set_fuzzyrelativespeedrightx(float value) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.fuzzyrelativespeedrightx_ = value;
}
inline void OutputObstacle::set_fuzzyrelativespeedrightx(float value) {
  _internal_set_fuzzyrelativespeedrightx(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.OutputObstacle.fuzzyrelativespeedrightx)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SmartereyeObstacles

// optional .apollo.common.Header header = 1;
inline bool SmartereyeObstacles::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool SmartereyeObstacles::has_header() const {
  return _internal_has_header();
}
inline const ::apollo::common::Header& SmartereyeObstacles::_internal_header() const {
  const ::apollo::common::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::Header&>(
      ::apollo::common::_Header_default_instance_);
}
inline const ::apollo::common::Header& SmartereyeObstacles::header() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.SmartereyeObstacles.header)
  return _internal_header();
}
inline void SmartereyeObstacles::unsafe_arena_set_allocated_header(
    ::apollo::common::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.SmartereyeObstacles.header)
}
inline ::apollo::common::Header* SmartereyeObstacles::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::Header* SmartereyeObstacles::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:apollo.drivers.SmartereyeObstacles.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::apollo::common::Header* SmartereyeObstacles::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::apollo::common::Header* SmartereyeObstacles::mutable_header() {
  ::apollo::common::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.SmartereyeObstacles.header)
  return _msg;
}
inline void SmartereyeObstacles::set_allocated_header(::apollo::common::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.SmartereyeObstacles.header)
}

// optional int32 num_obstacles = 2;
inline bool SmartereyeObstacles::_internal_has_num_obstacles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SmartereyeObstacles::has_num_obstacles() const {
  return _internal_has_num_obstacles();
}
inline void SmartereyeObstacles::clear_num_obstacles() {
  _impl_.num_obstacles_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SmartereyeObstacles::_internal_num_obstacles() const {
  return _impl_.num_obstacles_;
}
inline int32_t SmartereyeObstacles::num_obstacles() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.SmartereyeObstacles.num_obstacles)
  return _internal_num_obstacles();
}
inline void SmartereyeObstacles::_internal_set_num_obstacles(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_obstacles_ = value;
}
inline void SmartereyeObstacles::set_num_obstacles(int32_t value) {
  _internal_set_num_obstacles(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.SmartereyeObstacles.num_obstacles)
}

// map<uint32, .apollo.drivers.OutputObstacle> output_obstacles = 3;
inline int SmartereyeObstacles::_internal_output_obstacles_size() const {
  return _impl_.output_obstacles_.size();
}
inline int SmartereyeObstacles::output_obstacles_size() const {
  return _internal_output_obstacles_size();
}
inline void SmartereyeObstacles::clear_output_obstacles() {
  _impl_.output_obstacles_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::apollo::drivers::OutputObstacle >&
SmartereyeObstacles::_internal_output_obstacles() const {
  return _impl_.output_obstacles_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::apollo::drivers::OutputObstacle >&
SmartereyeObstacles::output_obstacles() const {
  // @@protoc_insertion_point(field_map:apollo.drivers.SmartereyeObstacles.output_obstacles)
  return _internal_output_obstacles();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::apollo::drivers::OutputObstacle >*
SmartereyeObstacles::_internal_mutable_output_obstacles() {
  return _impl_.output_obstacles_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::apollo::drivers::OutputObstacle >*
SmartereyeObstacles::mutable_output_obstacles() {
  // @@protoc_insertion_point(field_mutable_map:apollo.drivers.SmartereyeObstacles.output_obstacles)
  return _internal_mutable_output_obstacles();
}

// -------------------------------------------------------------------

// SmartereyeLanemark

// optional .apollo.drivers.LdwDataPacks lane_road_data = 4;
inline bool SmartereyeLanemark::_internal_has_lane_road_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lane_road_data_ != nullptr);
  return value;
}
inline bool SmartereyeLanemark::has_lane_road_data() const {
  return _internal_has_lane_road_data();
}
inline void SmartereyeLanemark::clear_lane_road_data() {
  if (_impl_.lane_road_data_ != nullptr) _impl_.lane_road_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::drivers::LdwDataPacks& SmartereyeLanemark::_internal_lane_road_data() const {
  const ::apollo::drivers::LdwDataPacks* p = _impl_.lane_road_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::LdwDataPacks&>(
      ::apollo::drivers::_LdwDataPacks_default_instance_);
}
inline const ::apollo::drivers::LdwDataPacks& SmartereyeLanemark::lane_road_data() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.SmartereyeLanemark.lane_road_data)
  return _internal_lane_road_data();
}
inline void SmartereyeLanemark::unsafe_arena_set_allocated_lane_road_data(
    ::apollo::drivers::LdwDataPacks* lane_road_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lane_road_data_);
  }
  _impl_.lane_road_data_ = lane_road_data;
  if (lane_road_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.SmartereyeLanemark.lane_road_data)
}
inline ::apollo::drivers::LdwDataPacks* SmartereyeLanemark::release_lane_road_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::drivers::LdwDataPacks* temp = _impl_.lane_road_data_;
  _impl_.lane_road_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::LdwDataPacks* SmartereyeLanemark::unsafe_arena_release_lane_road_data() {
  // @@protoc_insertion_point(field_release:apollo.drivers.SmartereyeLanemark.lane_road_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::drivers::LdwDataPacks* temp = _impl_.lane_road_data_;
  _impl_.lane_road_data_ = nullptr;
  return temp;
}
inline ::apollo::drivers::LdwDataPacks* SmartereyeLanemark::_internal_mutable_lane_road_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lane_road_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::LdwDataPacks>(GetArenaForAllocation());
    _impl_.lane_road_data_ = p;
  }
  return _impl_.lane_road_data_;
}
inline ::apollo::drivers::LdwDataPacks* SmartereyeLanemark::mutable_lane_road_data() {
  ::apollo::drivers::LdwDataPacks* _msg = _internal_mutable_lane_road_data();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.SmartereyeLanemark.lane_road_data)
  return _msg;
}
inline void SmartereyeLanemark::set_allocated_lane_road_data(::apollo::drivers::LdwDataPacks* lane_road_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lane_road_data_;
  }
  if (lane_road_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lane_road_data);
    if (message_arena != submessage_arena) {
      lane_road_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lane_road_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lane_road_data_ = lane_road_data;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.SmartereyeLanemark.lane_road_data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace drivers
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::drivers::OutputObstacle_RecognitionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::OutputObstacle_RecognitionType>() {
  return ::apollo::drivers::OutputObstacle_RecognitionType_descriptor();
}
template <> struct is_proto_enum< ::apollo::drivers::LdwVersions> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::LdwVersions>() {
  return ::apollo::drivers::LdwVersions_descriptor();
}
template <> struct is_proto_enum< ::apollo::drivers::LdwLaneStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::LdwLaneStyle>() {
  return ::apollo::drivers::LdwLaneStyle_descriptor();
}
template <> struct is_proto_enum< ::apollo::drivers::LdwSteerStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::LdwSteerStatus>() {
  return ::apollo::drivers::LdwSteerStatus_descriptor();
}
template <> struct is_proto_enum< ::apollo::drivers::LdwSoftStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::LdwSoftStatus>() {
  return ::apollo::drivers::LdwSoftStatus_descriptor();
}
template <> struct is_proto_enum< ::apollo::drivers::LdwWarningGrade> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::LdwWarningGrade>() {
  return ::apollo::drivers::LdwWarningGrade_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fdrivers_2fproto_2fsmartereye_2eproto
