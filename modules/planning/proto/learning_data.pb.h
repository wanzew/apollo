// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/learning_data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2flearning_5fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2flearning_5fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "modules/canbus/proto/chassis.pb.h"
#include "modules/common/proto/geometry.pb.h"
#include "modules/common/proto/header.pb.h"
#include "modules/common/proto/pnc_point.pb.h"
#include "modules/map/proto/map_lane.pb.h"
#include "modules/perception/proto/perception_obstacle.pb.h"
#include "modules/prediction/proto/feature.pb.h"
#include "modules/prediction/proto/prediction_obstacle.pb.h"
#include "modules/perception/proto/traffic_light_detection.pb.h"
#include "modules/routing/proto/routing.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fplanning_2fproto_2flearning_5fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
namespace apollo {
namespace planning {
class ADCTrajectoryPoint;
struct ADCTrajectoryPointDefaultTypeInternal;
extern ADCTrajectoryPointDefaultTypeInternal _ADCTrajectoryPoint_default_instance_;
class ChassisFeature;
struct ChassisFeatureDefaultTypeInternal;
extern ChassisFeatureDefaultTypeInternal _ChassisFeature_default_instance_;
class CommonPathPointFeature;
struct CommonPathPointFeatureDefaultTypeInternal;
extern CommonPathPointFeatureDefaultTypeInternal _CommonPathPointFeature_default_instance_;
class CommonTrajectoryPointFeature;
struct CommonTrajectoryPointFeatureDefaultTypeInternal;
extern CommonTrajectoryPointFeatureDefaultTypeInternal _CommonTrajectoryPointFeature_default_instance_;
class LearningData;
struct LearningDataDefaultTypeInternal;
extern LearningDataDefaultTypeInternal _LearningData_default_instance_;
class LearningDataFrame;
struct LearningDataFrameDefaultTypeInternal;
extern LearningDataFrameDefaultTypeInternal _LearningDataFrame_default_instance_;
class LearningOutput;
struct LearningOutputDefaultTypeInternal;
extern LearningOutputDefaultTypeInternal _LearningOutput_default_instance_;
class LocalizationFeature;
struct LocalizationFeatureDefaultTypeInternal;
extern LocalizationFeatureDefaultTypeInternal _LocalizationFeature_default_instance_;
class ObstacleFeature;
struct ObstacleFeatureDefaultTypeInternal;
extern ObstacleFeatureDefaultTypeInternal _ObstacleFeature_default_instance_;
class ObstacleTrajectoryFeature;
struct ObstacleTrajectoryFeatureDefaultTypeInternal;
extern ObstacleTrajectoryFeatureDefaultTypeInternal _ObstacleTrajectoryFeature_default_instance_;
class OverlapFeature;
struct OverlapFeatureDefaultTypeInternal;
extern OverlapFeatureDefaultTypeInternal _OverlapFeature_default_instance_;
class PerceptionObstacleFeature;
struct PerceptionObstacleFeatureDefaultTypeInternal;
extern PerceptionObstacleFeatureDefaultTypeInternal _PerceptionObstacleFeature_default_instance_;
class PlanningLearningData;
struct PlanningLearningDataDefaultTypeInternal;
extern PlanningLearningDataDefaultTypeInternal _PlanningLearningData_default_instance_;
class PlanningTag;
struct PlanningTagDefaultTypeInternal;
extern PlanningTagDefaultTypeInternal _PlanningTag_default_instance_;
class PredictionObstacleFeature;
struct PredictionObstacleFeatureDefaultTypeInternal;
extern PredictionObstacleFeatureDefaultTypeInternal _PredictionObstacleFeature_default_instance_;
class PredictionTrajectoryFeature;
struct PredictionTrajectoryFeatureDefaultTypeInternal;
extern PredictionTrajectoryFeatureDefaultTypeInternal _PredictionTrajectoryFeature_default_instance_;
class RoutingFeature;
struct RoutingFeatureDefaultTypeInternal;
extern RoutingFeatureDefaultTypeInternal _RoutingFeature_default_instance_;
class RoutingResponseFeature;
struct RoutingResponseFeatureDefaultTypeInternal;
extern RoutingResponseFeatureDefaultTypeInternal _RoutingResponseFeature_default_instance_;
class TrafficLightDetectionFeature;
struct TrafficLightDetectionFeatureDefaultTypeInternal;
extern TrafficLightDetectionFeatureDefaultTypeInternal _TrafficLightDetectionFeature_default_instance_;
class TrafficLightFeature;
struct TrafficLightFeatureDefaultTypeInternal;
extern TrafficLightFeatureDefaultTypeInternal _TrafficLightFeature_default_instance_;
class TrajectoryPointFeature;
struct TrajectoryPointFeatureDefaultTypeInternal;
extern TrajectoryPointFeatureDefaultTypeInternal _TrajectoryPointFeature_default_instance_;
}  // namespace planning
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::planning::ADCTrajectoryPoint* Arena::CreateMaybeMessage<::apollo::planning::ADCTrajectoryPoint>(Arena*);
template<> ::apollo::planning::ChassisFeature* Arena::CreateMaybeMessage<::apollo::planning::ChassisFeature>(Arena*);
template<> ::apollo::planning::CommonPathPointFeature* Arena::CreateMaybeMessage<::apollo::planning::CommonPathPointFeature>(Arena*);
template<> ::apollo::planning::CommonTrajectoryPointFeature* Arena::CreateMaybeMessage<::apollo::planning::CommonTrajectoryPointFeature>(Arena*);
template<> ::apollo::planning::LearningData* Arena::CreateMaybeMessage<::apollo::planning::LearningData>(Arena*);
template<> ::apollo::planning::LearningDataFrame* Arena::CreateMaybeMessage<::apollo::planning::LearningDataFrame>(Arena*);
template<> ::apollo::planning::LearningOutput* Arena::CreateMaybeMessage<::apollo::planning::LearningOutput>(Arena*);
template<> ::apollo::planning::LocalizationFeature* Arena::CreateMaybeMessage<::apollo::planning::LocalizationFeature>(Arena*);
template<> ::apollo::planning::ObstacleFeature* Arena::CreateMaybeMessage<::apollo::planning::ObstacleFeature>(Arena*);
template<> ::apollo::planning::ObstacleTrajectoryFeature* Arena::CreateMaybeMessage<::apollo::planning::ObstacleTrajectoryFeature>(Arena*);
template<> ::apollo::planning::OverlapFeature* Arena::CreateMaybeMessage<::apollo::planning::OverlapFeature>(Arena*);
template<> ::apollo::planning::PerceptionObstacleFeature* Arena::CreateMaybeMessage<::apollo::planning::PerceptionObstacleFeature>(Arena*);
template<> ::apollo::planning::PlanningLearningData* Arena::CreateMaybeMessage<::apollo::planning::PlanningLearningData>(Arena*);
template<> ::apollo::planning::PlanningTag* Arena::CreateMaybeMessage<::apollo::planning::PlanningTag>(Arena*);
template<> ::apollo::planning::PredictionObstacleFeature* Arena::CreateMaybeMessage<::apollo::planning::PredictionObstacleFeature>(Arena*);
template<> ::apollo::planning::PredictionTrajectoryFeature* Arena::CreateMaybeMessage<::apollo::planning::PredictionTrajectoryFeature>(Arena*);
template<> ::apollo::planning::RoutingFeature* Arena::CreateMaybeMessage<::apollo::planning::RoutingFeature>(Arena*);
template<> ::apollo::planning::RoutingResponseFeature* Arena::CreateMaybeMessage<::apollo::planning::RoutingResponseFeature>(Arena*);
template<> ::apollo::planning::TrafficLightDetectionFeature* Arena::CreateMaybeMessage<::apollo::planning::TrafficLightDetectionFeature>(Arena*);
template<> ::apollo::planning::TrafficLightFeature* Arena::CreateMaybeMessage<::apollo::planning::TrafficLightFeature>(Arena*);
template<> ::apollo::planning::TrajectoryPointFeature* Arena::CreateMaybeMessage<::apollo::planning::TrajectoryPointFeature>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace planning {

// ===================================================================

class OverlapFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.OverlapFeature) */ {
 public:
  inline OverlapFeature() : OverlapFeature(nullptr) {}
  ~OverlapFeature() override;
  explicit PROTOBUF_CONSTEXPR OverlapFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverlapFeature(const OverlapFeature& from);
  OverlapFeature(OverlapFeature&& from) noexcept
    : OverlapFeature() {
    *this = ::std::move(from);
  }

  inline OverlapFeature& operator=(const OverlapFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverlapFeature& operator=(OverlapFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverlapFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverlapFeature* internal_default_instance() {
    return reinterpret_cast<const OverlapFeature*>(
               &_OverlapFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OverlapFeature& a, OverlapFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(OverlapFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverlapFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverlapFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OverlapFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OverlapFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OverlapFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverlapFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.OverlapFeature";
  }
  protected:
  explicit OverlapFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDistanceFieldNumber = 2,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional double distance = 2;
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  double distance() const;
  void set_distance(double value);
  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.OverlapFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    double distance_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PlanningTag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningTag) */ {
 public:
  inline PlanningTag() : PlanningTag(nullptr) {}
  ~PlanningTag() override;
  explicit PROTOBUF_CONSTEXPR PlanningTag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanningTag(const PlanningTag& from);
  PlanningTag(PlanningTag&& from) noexcept
    : PlanningTag() {
    *this = ::std::move(from);
  }

  inline PlanningTag& operator=(const PlanningTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanningTag& operator=(PlanningTag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanningTag& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanningTag* internal_default_instance() {
    return reinterpret_cast<const PlanningTag*>(
               &_PlanningTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PlanningTag& a, PlanningTag& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanningTag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanningTag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanningTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanningTag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanningTag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlanningTag& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanningTag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PlanningTag";
  }
  protected:
  explicit PlanningTag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClearAreaFieldNumber = 2,
    kCrosswalkFieldNumber = 3,
    kPncJunctionFieldNumber = 4,
    kSignalFieldNumber = 5,
    kStopSignFieldNumber = 6,
    kYieldSignFieldNumber = 7,
    kLaneTurnFieldNumber = 1,
  };
  // optional .apollo.planning.OverlapFeature clear_area = 2;
  bool has_clear_area() const;
  private:
  bool _internal_has_clear_area() const;
  public:
  void clear_clear_area();
  const ::apollo::planning::OverlapFeature& clear_area() const;
  PROTOBUF_NODISCARD ::apollo::planning::OverlapFeature* release_clear_area();
  ::apollo::planning::OverlapFeature* mutable_clear_area();
  void set_allocated_clear_area(::apollo::planning::OverlapFeature* clear_area);
  private:
  const ::apollo::planning::OverlapFeature& _internal_clear_area() const;
  ::apollo::planning::OverlapFeature* _internal_mutable_clear_area();
  public:
  void unsafe_arena_set_allocated_clear_area(
      ::apollo::planning::OverlapFeature* clear_area);
  ::apollo::planning::OverlapFeature* unsafe_arena_release_clear_area();

  // optional .apollo.planning.OverlapFeature crosswalk = 3;
  bool has_crosswalk() const;
  private:
  bool _internal_has_crosswalk() const;
  public:
  void clear_crosswalk();
  const ::apollo::planning::OverlapFeature& crosswalk() const;
  PROTOBUF_NODISCARD ::apollo::planning::OverlapFeature* release_crosswalk();
  ::apollo::planning::OverlapFeature* mutable_crosswalk();
  void set_allocated_crosswalk(::apollo::planning::OverlapFeature* crosswalk);
  private:
  const ::apollo::planning::OverlapFeature& _internal_crosswalk() const;
  ::apollo::planning::OverlapFeature* _internal_mutable_crosswalk();
  public:
  void unsafe_arena_set_allocated_crosswalk(
      ::apollo::planning::OverlapFeature* crosswalk);
  ::apollo::planning::OverlapFeature* unsafe_arena_release_crosswalk();

  // optional .apollo.planning.OverlapFeature pnc_junction = 4;
  bool has_pnc_junction() const;
  private:
  bool _internal_has_pnc_junction() const;
  public:
  void clear_pnc_junction();
  const ::apollo::planning::OverlapFeature& pnc_junction() const;
  PROTOBUF_NODISCARD ::apollo::planning::OverlapFeature* release_pnc_junction();
  ::apollo::planning::OverlapFeature* mutable_pnc_junction();
  void set_allocated_pnc_junction(::apollo::planning::OverlapFeature* pnc_junction);
  private:
  const ::apollo::planning::OverlapFeature& _internal_pnc_junction() const;
  ::apollo::planning::OverlapFeature* _internal_mutable_pnc_junction();
  public:
  void unsafe_arena_set_allocated_pnc_junction(
      ::apollo::planning::OverlapFeature* pnc_junction);
  ::apollo::planning::OverlapFeature* unsafe_arena_release_pnc_junction();

  // optional .apollo.planning.OverlapFeature signal = 5;
  bool has_signal() const;
  private:
  bool _internal_has_signal() const;
  public:
  void clear_signal();
  const ::apollo::planning::OverlapFeature& signal() const;
  PROTOBUF_NODISCARD ::apollo::planning::OverlapFeature* release_signal();
  ::apollo::planning::OverlapFeature* mutable_signal();
  void set_allocated_signal(::apollo::planning::OverlapFeature* signal);
  private:
  const ::apollo::planning::OverlapFeature& _internal_signal() const;
  ::apollo::planning::OverlapFeature* _internal_mutable_signal();
  public:
  void unsafe_arena_set_allocated_signal(
      ::apollo::planning::OverlapFeature* signal);
  ::apollo::planning::OverlapFeature* unsafe_arena_release_signal();

  // optional .apollo.planning.OverlapFeature stop_sign = 6;
  bool has_stop_sign() const;
  private:
  bool _internal_has_stop_sign() const;
  public:
  void clear_stop_sign();
  const ::apollo::planning::OverlapFeature& stop_sign() const;
  PROTOBUF_NODISCARD ::apollo::planning::OverlapFeature* release_stop_sign();
  ::apollo::planning::OverlapFeature* mutable_stop_sign();
  void set_allocated_stop_sign(::apollo::planning::OverlapFeature* stop_sign);
  private:
  const ::apollo::planning::OverlapFeature& _internal_stop_sign() const;
  ::apollo::planning::OverlapFeature* _internal_mutable_stop_sign();
  public:
  void unsafe_arena_set_allocated_stop_sign(
      ::apollo::planning::OverlapFeature* stop_sign);
  ::apollo::planning::OverlapFeature* unsafe_arena_release_stop_sign();

  // optional .apollo.planning.OverlapFeature yield_sign = 7;
  bool has_yield_sign() const;
  private:
  bool _internal_has_yield_sign() const;
  public:
  void clear_yield_sign();
  const ::apollo::planning::OverlapFeature& yield_sign() const;
  PROTOBUF_NODISCARD ::apollo::planning::OverlapFeature* release_yield_sign();
  ::apollo::planning::OverlapFeature* mutable_yield_sign();
  void set_allocated_yield_sign(::apollo::planning::OverlapFeature* yield_sign);
  private:
  const ::apollo::planning::OverlapFeature& _internal_yield_sign() const;
  ::apollo::planning::OverlapFeature* _internal_mutable_yield_sign();
  public:
  void unsafe_arena_set_allocated_yield_sign(
      ::apollo::planning::OverlapFeature* yield_sign);
  ::apollo::planning::OverlapFeature* unsafe_arena_release_yield_sign();

  // optional .apollo.hdmap.Lane.LaneTurn lane_turn = 1;
  bool has_lane_turn() const;
  private:
  bool _internal_has_lane_turn() const;
  public:
  void clear_lane_turn();
  ::apollo::hdmap::Lane_LaneTurn lane_turn() const;
  void set_lane_turn(::apollo::hdmap::Lane_LaneTurn value);
  private:
  ::apollo::hdmap::Lane_LaneTurn _internal_lane_turn() const;
  void _internal_set_lane_turn(::apollo::hdmap::Lane_LaneTurn value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningTag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::planning::OverlapFeature* clear_area_;
    ::apollo::planning::OverlapFeature* crosswalk_;
    ::apollo::planning::OverlapFeature* pnc_junction_;
    ::apollo::planning::OverlapFeature* signal_;
    ::apollo::planning::OverlapFeature* stop_sign_;
    ::apollo::planning::OverlapFeature* yield_sign_;
    int lane_turn_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ChassisFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ChassisFeature) */ {
 public:
  inline ChassisFeature() : ChassisFeature(nullptr) {}
  ~ChassisFeature() override;
  explicit PROTOBUF_CONSTEXPR ChassisFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChassisFeature(const ChassisFeature& from);
  ChassisFeature(ChassisFeature&& from) noexcept
    : ChassisFeature() {
    *this = ::std::move(from);
  }

  inline ChassisFeature& operator=(const ChassisFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChassisFeature& operator=(ChassisFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChassisFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChassisFeature* internal_default_instance() {
    return reinterpret_cast<const ChassisFeature*>(
               &_ChassisFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChassisFeature& a, ChassisFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(ChassisFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChassisFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChassisFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChassisFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChassisFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChassisFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChassisFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ChassisFeature";
  }
  protected:
  explicit ChassisFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTimestampSecFieldNumber = 1,
    kSpeedMpsFieldNumber = 2,
    kThrottlePercentageFieldNumber = 3,
    kBrakePercentageFieldNumber = 4,
    kSteeringPercentageFieldNumber = 5,
    kGearLocationFieldNumber = 6,
  };
  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  private:
  bool _internal_has_message_timestamp_sec() const;
  public:
  void clear_message_timestamp_sec();
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);
  private:
  double _internal_message_timestamp_sec() const;
  void _internal_set_message_timestamp_sec(double value);
  public:

  // optional float speed_mps = 2;
  bool has_speed_mps() const;
  private:
  bool _internal_has_speed_mps() const;
  public:
  void clear_speed_mps();
  float speed_mps() const;
  void set_speed_mps(float value);
  private:
  float _internal_speed_mps() const;
  void _internal_set_speed_mps(float value);
  public:

  // optional float throttle_percentage = 3;
  bool has_throttle_percentage() const;
  private:
  bool _internal_has_throttle_percentage() const;
  public:
  void clear_throttle_percentage();
  float throttle_percentage() const;
  void set_throttle_percentage(float value);
  private:
  float _internal_throttle_percentage() const;
  void _internal_set_throttle_percentage(float value);
  public:

  // optional float brake_percentage = 4;
  bool has_brake_percentage() const;
  private:
  bool _internal_has_brake_percentage() const;
  public:
  void clear_brake_percentage();
  float brake_percentage() const;
  void set_brake_percentage(float value);
  private:
  float _internal_brake_percentage() const;
  void _internal_set_brake_percentage(float value);
  public:

  // optional float steering_percentage = 5;
  bool has_steering_percentage() const;
  private:
  bool _internal_has_steering_percentage() const;
  public:
  void clear_steering_percentage();
  float steering_percentage() const;
  void set_steering_percentage(float value);
  private:
  float _internal_steering_percentage() const;
  void _internal_set_steering_percentage(float value);
  public:

  // optional .apollo.canbus.Chassis.GearPosition gear_location = 6;
  bool has_gear_location() const;
  private:
  bool _internal_has_gear_location() const;
  public:
  void clear_gear_location();
  ::apollo::canbus::Chassis_GearPosition gear_location() const;
  void set_gear_location(::apollo::canbus::Chassis_GearPosition value);
  private:
  ::apollo::canbus::Chassis_GearPosition _internal_gear_location() const;
  void _internal_set_gear_location(::apollo::canbus::Chassis_GearPosition value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ChassisFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double message_timestamp_sec_;
    float speed_mps_;
    float throttle_percentage_;
    float brake_percentage_;
    float steering_percentage_;
    int gear_location_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class LocalizationFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LocalizationFeature) */ {
 public:
  inline LocalizationFeature() : LocalizationFeature(nullptr) {}
  ~LocalizationFeature() override;
  explicit PROTOBUF_CONSTEXPR LocalizationFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalizationFeature(const LocalizationFeature& from);
  LocalizationFeature(LocalizationFeature&& from) noexcept
    : LocalizationFeature() {
    *this = ::std::move(from);
  }

  inline LocalizationFeature& operator=(const LocalizationFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalizationFeature& operator=(LocalizationFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalizationFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalizationFeature* internal_default_instance() {
    return reinterpret_cast<const LocalizationFeature*>(
               &_LocalizationFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LocalizationFeature& a, LocalizationFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalizationFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalizationFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalizationFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalizationFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalizationFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocalizationFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalizationFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.LocalizationFeature";
  }
  protected:
  explicit LocalizationFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kLinearVelocityFieldNumber = 4,
    kLinearAccelerationFieldNumber = 5,
    kAngularVelocityFieldNumber = 6,
    kMessageTimestampSecFieldNumber = 1,
    kHeadingFieldNumber = 3,
  };
  // optional .apollo.common.PointENU position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::apollo::common::PointENU& position() const;
  PROTOBUF_NODISCARD ::apollo::common::PointENU* release_position();
  ::apollo::common::PointENU* mutable_position();
  void set_allocated_position(::apollo::common::PointENU* position);
  private:
  const ::apollo::common::PointENU& _internal_position() const;
  ::apollo::common::PointENU* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::apollo::common::PointENU* position);
  ::apollo::common::PointENU* unsafe_arena_release_position();

  // optional .apollo.common.Point3D linear_velocity = 4;
  bool has_linear_velocity() const;
  private:
  bool _internal_has_linear_velocity() const;
  public:
  void clear_linear_velocity();
  const ::apollo::common::Point3D& linear_velocity() const;
  PROTOBUF_NODISCARD ::apollo::common::Point3D* release_linear_velocity();
  ::apollo::common::Point3D* mutable_linear_velocity();
  void set_allocated_linear_velocity(::apollo::common::Point3D* linear_velocity);
  private:
  const ::apollo::common::Point3D& _internal_linear_velocity() const;
  ::apollo::common::Point3D* _internal_mutable_linear_velocity();
  public:
  void unsafe_arena_set_allocated_linear_velocity(
      ::apollo::common::Point3D* linear_velocity);
  ::apollo::common::Point3D* unsafe_arena_release_linear_velocity();

  // optional .apollo.common.Point3D linear_acceleration = 5;
  bool has_linear_acceleration() const;
  private:
  bool _internal_has_linear_acceleration() const;
  public:
  void clear_linear_acceleration();
  const ::apollo::common::Point3D& linear_acceleration() const;
  PROTOBUF_NODISCARD ::apollo::common::Point3D* release_linear_acceleration();
  ::apollo::common::Point3D* mutable_linear_acceleration();
  void set_allocated_linear_acceleration(::apollo::common::Point3D* linear_acceleration);
  private:
  const ::apollo::common::Point3D& _internal_linear_acceleration() const;
  ::apollo::common::Point3D* _internal_mutable_linear_acceleration();
  public:
  void unsafe_arena_set_allocated_linear_acceleration(
      ::apollo::common::Point3D* linear_acceleration);
  ::apollo::common::Point3D* unsafe_arena_release_linear_acceleration();

  // optional .apollo.common.Point3D angular_velocity = 6;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  const ::apollo::common::Point3D& angular_velocity() const;
  PROTOBUF_NODISCARD ::apollo::common::Point3D* release_angular_velocity();
  ::apollo::common::Point3D* mutable_angular_velocity();
  void set_allocated_angular_velocity(::apollo::common::Point3D* angular_velocity);
  private:
  const ::apollo::common::Point3D& _internal_angular_velocity() const;
  ::apollo::common::Point3D* _internal_mutable_angular_velocity();
  public:
  void unsafe_arena_set_allocated_angular_velocity(
      ::apollo::common::Point3D* angular_velocity);
  ::apollo::common::Point3D* unsafe_arena_release_angular_velocity();

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  private:
  bool _internal_has_message_timestamp_sec() const;
  public:
  void clear_message_timestamp_sec();
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);
  private:
  double _internal_message_timestamp_sec() const;
  void _internal_set_message_timestamp_sec(double value);
  public:

  // optional double heading = 3;
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  double heading() const;
  void set_heading(double value);
  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.LocalizationFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::common::PointENU* position_;
    ::apollo::common::Point3D* linear_velocity_;
    ::apollo::common::Point3D* linear_acceleration_;
    ::apollo::common::Point3D* angular_velocity_;
    double message_timestamp_sec_;
    double heading_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class CommonPathPointFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CommonPathPointFeature) */ {
 public:
  inline CommonPathPointFeature() : CommonPathPointFeature(nullptr) {}
  ~CommonPathPointFeature() override;
  explicit PROTOBUF_CONSTEXPR CommonPathPointFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonPathPointFeature(const CommonPathPointFeature& from);
  CommonPathPointFeature(CommonPathPointFeature&& from) noexcept
    : CommonPathPointFeature() {
    *this = ::std::move(from);
  }

  inline CommonPathPointFeature& operator=(const CommonPathPointFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonPathPointFeature& operator=(CommonPathPointFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonPathPointFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonPathPointFeature* internal_default_instance() {
    return reinterpret_cast<const CommonPathPointFeature*>(
               &_CommonPathPointFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CommonPathPointFeature& a, CommonPathPointFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonPathPointFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonPathPointFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonPathPointFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonPathPointFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommonPathPointFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommonPathPointFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonPathPointFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CommonPathPointFeature";
  }
  protected:
  explicit CommonPathPointFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneIdFieldNumber = 6,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kThetaFieldNumber = 4,
    kSFieldNumber = 5,
  };
  // optional string lane_id = 6;
  bool has_lane_id() const;
  private:
  bool _internal_has_lane_id() const;
  public:
  void clear_lane_id();
  const std::string& lane_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lane_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lane_id();
  PROTOBUF_NODISCARD std::string* release_lane_id();
  void set_allocated_lane_id(std::string* lane_id);
  private:
  const std::string& _internal_lane_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lane_id(const std::string& value);
  std::string* _internal_mutable_lane_id();
  public:

  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // optional double theta = 4;
  bool has_theta() const;
  private:
  bool _internal_has_theta() const;
  public:
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // optional double s = 5;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  double s() const;
  void set_s(double value);
  private:
  double _internal_s() const;
  void _internal_set_s(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CommonPathPointFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lane_id_;
    double x_;
    double y_;
    double z_;
    double theta_;
    double s_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class CommonTrajectoryPointFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CommonTrajectoryPointFeature) */ {
 public:
  inline CommonTrajectoryPointFeature() : CommonTrajectoryPointFeature(nullptr) {}
  ~CommonTrajectoryPointFeature() override;
  explicit PROTOBUF_CONSTEXPR CommonTrajectoryPointFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonTrajectoryPointFeature(const CommonTrajectoryPointFeature& from);
  CommonTrajectoryPointFeature(CommonTrajectoryPointFeature&& from) noexcept
    : CommonTrajectoryPointFeature() {
    *this = ::std::move(from);
  }

  inline CommonTrajectoryPointFeature& operator=(const CommonTrajectoryPointFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonTrajectoryPointFeature& operator=(CommonTrajectoryPointFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonTrajectoryPointFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonTrajectoryPointFeature* internal_default_instance() {
    return reinterpret_cast<const CommonTrajectoryPointFeature*>(
               &_CommonTrajectoryPointFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CommonTrajectoryPointFeature& a, CommonTrajectoryPointFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonTrajectoryPointFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonTrajectoryPointFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonTrajectoryPointFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonTrajectoryPointFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommonTrajectoryPointFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommonTrajectoryPointFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonTrajectoryPointFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CommonTrajectoryPointFeature";
  }
  protected:
  explicit CommonTrajectoryPointFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathPointFieldNumber = 1,
    kGaussianInfoFieldNumber = 5,
    kVFieldNumber = 2,
    kAFieldNumber = 3,
    kRelativeTimeFieldNumber = 4,
  };
  // optional .apollo.planning.CommonPathPointFeature path_point = 1;
  bool has_path_point() const;
  private:
  bool _internal_has_path_point() const;
  public:
  void clear_path_point();
  const ::apollo::planning::CommonPathPointFeature& path_point() const;
  PROTOBUF_NODISCARD ::apollo::planning::CommonPathPointFeature* release_path_point();
  ::apollo::planning::CommonPathPointFeature* mutable_path_point();
  void set_allocated_path_point(::apollo::planning::CommonPathPointFeature* path_point);
  private:
  const ::apollo::planning::CommonPathPointFeature& _internal_path_point() const;
  ::apollo::planning::CommonPathPointFeature* _internal_mutable_path_point();
  public:
  void unsafe_arena_set_allocated_path_point(
      ::apollo::planning::CommonPathPointFeature* path_point);
  ::apollo::planning::CommonPathPointFeature* unsafe_arena_release_path_point();

  // optional .apollo.common.GaussianInfo gaussian_info = 5;
  bool has_gaussian_info() const;
  private:
  bool _internal_has_gaussian_info() const;
  public:
  void clear_gaussian_info();
  const ::apollo::common::GaussianInfo& gaussian_info() const;
  PROTOBUF_NODISCARD ::apollo::common::GaussianInfo* release_gaussian_info();
  ::apollo::common::GaussianInfo* mutable_gaussian_info();
  void set_allocated_gaussian_info(::apollo::common::GaussianInfo* gaussian_info);
  private:
  const ::apollo::common::GaussianInfo& _internal_gaussian_info() const;
  ::apollo::common::GaussianInfo* _internal_mutable_gaussian_info();
  public:
  void unsafe_arena_set_allocated_gaussian_info(
      ::apollo::common::GaussianInfo* gaussian_info);
  ::apollo::common::GaussianInfo* unsafe_arena_release_gaussian_info();

  // optional double v = 2;
  bool has_v() const;
  private:
  bool _internal_has_v() const;
  public:
  void clear_v();
  double v() const;
  void set_v(double value);
  private:
  double _internal_v() const;
  void _internal_set_v(double value);
  public:

  // optional double a = 3;
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  double a() const;
  void set_a(double value);
  private:
  double _internal_a() const;
  void _internal_set_a(double value);
  public:

  // optional double relative_time = 4;
  bool has_relative_time() const;
  private:
  bool _internal_has_relative_time() const;
  public:
  void clear_relative_time();
  double relative_time() const;
  void set_relative_time(double value);
  private:
  double _internal_relative_time() const;
  void _internal_set_relative_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CommonTrajectoryPointFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::planning::CommonPathPointFeature* path_point_;
    ::apollo::common::GaussianInfo* gaussian_info_;
    double v_;
    double a_;
    double relative_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class TrajectoryPointFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrajectoryPointFeature) */ {
 public:
  inline TrajectoryPointFeature() : TrajectoryPointFeature(nullptr) {}
  ~TrajectoryPointFeature() override;
  explicit PROTOBUF_CONSTEXPR TrajectoryPointFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrajectoryPointFeature(const TrajectoryPointFeature& from);
  TrajectoryPointFeature(TrajectoryPointFeature&& from) noexcept
    : TrajectoryPointFeature() {
    *this = ::std::move(from);
  }

  inline TrajectoryPointFeature& operator=(const TrajectoryPointFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrajectoryPointFeature& operator=(TrajectoryPointFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrajectoryPointFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrajectoryPointFeature* internal_default_instance() {
    return reinterpret_cast<const TrajectoryPointFeature*>(
               &_TrajectoryPointFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TrajectoryPointFeature& a, TrajectoryPointFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(TrajectoryPointFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrajectoryPointFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrajectoryPointFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrajectoryPointFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrajectoryPointFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrajectoryPointFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryPointFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrajectoryPointFeature";
  }
  protected:
  explicit TrajectoryPointFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryPointFieldNumber = 2,
    kTimestampSecFieldNumber = 1,
  };
  // optional .apollo.planning.CommonTrajectoryPointFeature trajectory_point = 2;
  bool has_trajectory_point() const;
  private:
  bool _internal_has_trajectory_point() const;
  public:
  void clear_trajectory_point();
  const ::apollo::planning::CommonTrajectoryPointFeature& trajectory_point() const;
  PROTOBUF_NODISCARD ::apollo::planning::CommonTrajectoryPointFeature* release_trajectory_point();
  ::apollo::planning::CommonTrajectoryPointFeature* mutable_trajectory_point();
  void set_allocated_trajectory_point(::apollo::planning::CommonTrajectoryPointFeature* trajectory_point);
  private:
  const ::apollo::planning::CommonTrajectoryPointFeature& _internal_trajectory_point() const;
  ::apollo::planning::CommonTrajectoryPointFeature* _internal_mutable_trajectory_point();
  public:
  void unsafe_arena_set_allocated_trajectory_point(
      ::apollo::planning::CommonTrajectoryPointFeature* trajectory_point);
  ::apollo::planning::CommonTrajectoryPointFeature* unsafe_arena_release_trajectory_point();

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  private:
  bool _internal_has_timestamp_sec() const;
  public:
  void clear_timestamp_sec();
  double timestamp_sec() const;
  void set_timestamp_sec(double value);
  private:
  double _internal_timestamp_sec() const;
  void _internal_set_timestamp_sec(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.TrajectoryPointFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::planning::CommonTrajectoryPointFeature* trajectory_point_;
    double timestamp_sec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PerceptionObstacleFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PerceptionObstacleFeature) */ {
 public:
  inline PerceptionObstacleFeature() : PerceptionObstacleFeature(nullptr) {}
  ~PerceptionObstacleFeature() override;
  explicit PROTOBUF_CONSTEXPR PerceptionObstacleFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerceptionObstacleFeature(const PerceptionObstacleFeature& from);
  PerceptionObstacleFeature(PerceptionObstacleFeature&& from) noexcept
    : PerceptionObstacleFeature() {
    *this = ::std::move(from);
  }

  inline PerceptionObstacleFeature& operator=(const PerceptionObstacleFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerceptionObstacleFeature& operator=(PerceptionObstacleFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerceptionObstacleFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerceptionObstacleFeature* internal_default_instance() {
    return reinterpret_cast<const PerceptionObstacleFeature*>(
               &_PerceptionObstacleFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PerceptionObstacleFeature& a, PerceptionObstacleFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(PerceptionObstacleFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerceptionObstacleFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerceptionObstacleFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerceptionObstacleFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerceptionObstacleFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PerceptionObstacleFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceptionObstacleFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PerceptionObstacleFeature";
  }
  protected:
  explicit PerceptionObstacleFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonPointFieldNumber = 6,
    kPositionFieldNumber = 2,
    kVelocityFieldNumber = 4,
    kAccelerationFieldNumber = 5,
    kTimestampSecFieldNumber = 1,
    kThetaFieldNumber = 3,
  };
  // repeated .apollo.common.Point3D polygon_point = 6;
  int polygon_point_size() const;
  private:
  int _internal_polygon_point_size() const;
  public:
  void clear_polygon_point();
  ::apollo::common::Point3D* mutable_polygon_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::common::Point3D >*
      mutable_polygon_point();
  private:
  const ::apollo::common::Point3D& _internal_polygon_point(int index) const;
  ::apollo::common::Point3D* _internal_add_polygon_point();
  public:
  const ::apollo::common::Point3D& polygon_point(int index) const;
  ::apollo::common::Point3D* add_polygon_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::common::Point3D >&
      polygon_point() const;

  // optional .apollo.common.Point3D position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::apollo::common::Point3D& position() const;
  PROTOBUF_NODISCARD ::apollo::common::Point3D* release_position();
  ::apollo::common::Point3D* mutable_position();
  void set_allocated_position(::apollo::common::Point3D* position);
  private:
  const ::apollo::common::Point3D& _internal_position() const;
  ::apollo::common::Point3D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::apollo::common::Point3D* position);
  ::apollo::common::Point3D* unsafe_arena_release_position();

  // optional .apollo.common.Point3D velocity = 4;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::apollo::common::Point3D& velocity() const;
  PROTOBUF_NODISCARD ::apollo::common::Point3D* release_velocity();
  ::apollo::common::Point3D* mutable_velocity();
  void set_allocated_velocity(::apollo::common::Point3D* velocity);
  private:
  const ::apollo::common::Point3D& _internal_velocity() const;
  ::apollo::common::Point3D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::apollo::common::Point3D* velocity);
  ::apollo::common::Point3D* unsafe_arena_release_velocity();

  // optional .apollo.common.Point3D acceleration = 5;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::apollo::common::Point3D& acceleration() const;
  PROTOBUF_NODISCARD ::apollo::common::Point3D* release_acceleration();
  ::apollo::common::Point3D* mutable_acceleration();
  void set_allocated_acceleration(::apollo::common::Point3D* acceleration);
  private:
  const ::apollo::common::Point3D& _internal_acceleration() const;
  ::apollo::common::Point3D* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::apollo::common::Point3D* acceleration);
  ::apollo::common::Point3D* unsafe_arena_release_acceleration();

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  private:
  bool _internal_has_timestamp_sec() const;
  public:
  void clear_timestamp_sec();
  double timestamp_sec() const;
  void set_timestamp_sec(double value);
  private:
  double _internal_timestamp_sec() const;
  void _internal_set_timestamp_sec(double value);
  public:

  // optional double theta = 3;
  bool has_theta() const;
  private:
  bool _internal_has_theta() const;
  public:
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PerceptionObstacleFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::common::Point3D > polygon_point_;
    ::apollo::common::Point3D* position_;
    ::apollo::common::Point3D* velocity_;
    ::apollo::common::Point3D* acceleration_;
    double timestamp_sec_;
    double theta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ObstacleTrajectoryFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ObstacleTrajectoryFeature) */ {
 public:
  inline ObstacleTrajectoryFeature() : ObstacleTrajectoryFeature(nullptr) {}
  ~ObstacleTrajectoryFeature() override;
  explicit PROTOBUF_CONSTEXPR ObstacleTrajectoryFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleTrajectoryFeature(const ObstacleTrajectoryFeature& from);
  ObstacleTrajectoryFeature(ObstacleTrajectoryFeature&& from) noexcept
    : ObstacleTrajectoryFeature() {
    *this = ::std::move(from);
  }

  inline ObstacleTrajectoryFeature& operator=(const ObstacleTrajectoryFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleTrajectoryFeature& operator=(ObstacleTrajectoryFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleTrajectoryFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleTrajectoryFeature* internal_default_instance() {
    return reinterpret_cast<const ObstacleTrajectoryFeature*>(
               &_ObstacleTrajectoryFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ObstacleTrajectoryFeature& a, ObstacleTrajectoryFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleTrajectoryFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleTrajectoryFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleTrajectoryFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleTrajectoryFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleTrajectoryFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleTrajectoryFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleTrajectoryFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ObstacleTrajectoryFeature";
  }
  protected:
  explicit ObstacleTrajectoryFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerceptionObstacleHistoryFieldNumber = 1,
    kEvaluatedTrajectoryPointFieldNumber = 2,
  };
  // repeated .apollo.planning.PerceptionObstacleFeature perception_obstacle_history = 1;
  int perception_obstacle_history_size() const;
  private:
  int _internal_perception_obstacle_history_size() const;
  public:
  void clear_perception_obstacle_history();
  ::apollo::planning::PerceptionObstacleFeature* mutable_perception_obstacle_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::PerceptionObstacleFeature >*
      mutable_perception_obstacle_history();
  private:
  const ::apollo::planning::PerceptionObstacleFeature& _internal_perception_obstacle_history(int index) const;
  ::apollo::planning::PerceptionObstacleFeature* _internal_add_perception_obstacle_history();
  public:
  const ::apollo::planning::PerceptionObstacleFeature& perception_obstacle_history(int index) const;
  ::apollo::planning::PerceptionObstacleFeature* add_perception_obstacle_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::PerceptionObstacleFeature >&
      perception_obstacle_history() const;

  // repeated .apollo.planning.TrajectoryPointFeature evaluated_trajectory_point = 2;
  int evaluated_trajectory_point_size() const;
  private:
  int _internal_evaluated_trajectory_point_size() const;
  public:
  void clear_evaluated_trajectory_point();
  ::apollo::planning::TrajectoryPointFeature* mutable_evaluated_trajectory_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
      mutable_evaluated_trajectory_point();
  private:
  const ::apollo::planning::TrajectoryPointFeature& _internal_evaluated_trajectory_point(int index) const;
  ::apollo::planning::TrajectoryPointFeature* _internal_add_evaluated_trajectory_point();
  public:
  const ::apollo::planning::TrajectoryPointFeature& evaluated_trajectory_point(int index) const;
  ::apollo::planning::TrajectoryPointFeature* add_evaluated_trajectory_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
      evaluated_trajectory_point() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.ObstacleTrajectoryFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::PerceptionObstacleFeature > perception_obstacle_history_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature > evaluated_trajectory_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PredictionTrajectoryFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PredictionTrajectoryFeature) */ {
 public:
  inline PredictionTrajectoryFeature() : PredictionTrajectoryFeature(nullptr) {}
  ~PredictionTrajectoryFeature() override;
  explicit PROTOBUF_CONSTEXPR PredictionTrajectoryFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PredictionTrajectoryFeature(const PredictionTrajectoryFeature& from);
  PredictionTrajectoryFeature(PredictionTrajectoryFeature&& from) noexcept
    : PredictionTrajectoryFeature() {
    *this = ::std::move(from);
  }

  inline PredictionTrajectoryFeature& operator=(const PredictionTrajectoryFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictionTrajectoryFeature& operator=(PredictionTrajectoryFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PredictionTrajectoryFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const PredictionTrajectoryFeature* internal_default_instance() {
    return reinterpret_cast<const PredictionTrajectoryFeature*>(
               &_PredictionTrajectoryFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PredictionTrajectoryFeature& a, PredictionTrajectoryFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictionTrajectoryFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictionTrajectoryFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PredictionTrajectoryFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PredictionTrajectoryFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PredictionTrajectoryFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PredictionTrajectoryFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictionTrajectoryFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PredictionTrajectoryFeature";
  }
  protected:
  explicit PredictionTrajectoryFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryPointFieldNumber = 2,
    kProbabilityFieldNumber = 1,
  };
  // repeated .apollo.planning.TrajectoryPointFeature trajectory_point = 2;
  int trajectory_point_size() const;
  private:
  int _internal_trajectory_point_size() const;
  public:
  void clear_trajectory_point();
  ::apollo::planning::TrajectoryPointFeature* mutable_trajectory_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
      mutable_trajectory_point();
  private:
  const ::apollo::planning::TrajectoryPointFeature& _internal_trajectory_point(int index) const;
  ::apollo::planning::TrajectoryPointFeature* _internal_add_trajectory_point();
  public:
  const ::apollo::planning::TrajectoryPointFeature& trajectory_point(int index) const;
  ::apollo::planning::TrajectoryPointFeature* add_trajectory_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
      trajectory_point() const;

  // optional double probability = 1;
  bool has_probability() const;
  private:
  bool _internal_has_probability() const;
  public:
  void clear_probability();
  double probability() const;
  void set_probability(double value);
  private:
  double _internal_probability() const;
  void _internal_set_probability(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PredictionTrajectoryFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature > trajectory_point_;
    double probability_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PredictionObstacleFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PredictionObstacleFeature) */ {
 public:
  inline PredictionObstacleFeature() : PredictionObstacleFeature(nullptr) {}
  ~PredictionObstacleFeature() override;
  explicit PROTOBUF_CONSTEXPR PredictionObstacleFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PredictionObstacleFeature(const PredictionObstacleFeature& from);
  PredictionObstacleFeature(PredictionObstacleFeature&& from) noexcept
    : PredictionObstacleFeature() {
    *this = ::std::move(from);
  }

  inline PredictionObstacleFeature& operator=(const PredictionObstacleFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictionObstacleFeature& operator=(PredictionObstacleFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PredictionObstacleFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const PredictionObstacleFeature* internal_default_instance() {
    return reinterpret_cast<const PredictionObstacleFeature*>(
               &_PredictionObstacleFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PredictionObstacleFeature& a, PredictionObstacleFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictionObstacleFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictionObstacleFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PredictionObstacleFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PredictionObstacleFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PredictionObstacleFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PredictionObstacleFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictionObstacleFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PredictionObstacleFeature";
  }
  protected:
  explicit PredictionObstacleFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryFieldNumber = 6,
    kIntentFieldNumber = 3,
    kPriorityFieldNumber = 4,
    kTimestampSecFieldNumber = 1,
    kPredictedPeriodFieldNumber = 2,
    kIsStaticFieldNumber = 5,
  };
  // repeated .apollo.planning.PredictionTrajectoryFeature trajectory = 6;
  int trajectory_size() const;
  private:
  int _internal_trajectory_size() const;
  public:
  void clear_trajectory();
  ::apollo::planning::PredictionTrajectoryFeature* mutable_trajectory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::PredictionTrajectoryFeature >*
      mutable_trajectory();
  private:
  const ::apollo::planning::PredictionTrajectoryFeature& _internal_trajectory(int index) const;
  ::apollo::planning::PredictionTrajectoryFeature* _internal_add_trajectory();
  public:
  const ::apollo::planning::PredictionTrajectoryFeature& trajectory(int index) const;
  ::apollo::planning::PredictionTrajectoryFeature* add_trajectory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::PredictionTrajectoryFeature >&
      trajectory() const;

  // optional .apollo.prediction.ObstacleIntent intent = 3;
  bool has_intent() const;
  private:
  bool _internal_has_intent() const;
  public:
  void clear_intent();
  const ::apollo::prediction::ObstacleIntent& intent() const;
  PROTOBUF_NODISCARD ::apollo::prediction::ObstacleIntent* release_intent();
  ::apollo::prediction::ObstacleIntent* mutable_intent();
  void set_allocated_intent(::apollo::prediction::ObstacleIntent* intent);
  private:
  const ::apollo::prediction::ObstacleIntent& _internal_intent() const;
  ::apollo::prediction::ObstacleIntent* _internal_mutable_intent();
  public:
  void unsafe_arena_set_allocated_intent(
      ::apollo::prediction::ObstacleIntent* intent);
  ::apollo::prediction::ObstacleIntent* unsafe_arena_release_intent();

  // optional .apollo.prediction.ObstaclePriority priority = 4;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  const ::apollo::prediction::ObstaclePriority& priority() const;
  PROTOBUF_NODISCARD ::apollo::prediction::ObstaclePriority* release_priority();
  ::apollo::prediction::ObstaclePriority* mutable_priority();
  void set_allocated_priority(::apollo::prediction::ObstaclePriority* priority);
  private:
  const ::apollo::prediction::ObstaclePriority& _internal_priority() const;
  ::apollo::prediction::ObstaclePriority* _internal_mutable_priority();
  public:
  void unsafe_arena_set_allocated_priority(
      ::apollo::prediction::ObstaclePriority* priority);
  ::apollo::prediction::ObstaclePriority* unsafe_arena_release_priority();

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  private:
  bool _internal_has_timestamp_sec() const;
  public:
  void clear_timestamp_sec();
  double timestamp_sec() const;
  void set_timestamp_sec(double value);
  private:
  double _internal_timestamp_sec() const;
  void _internal_set_timestamp_sec(double value);
  public:

  // optional double predicted_period = 2;
  bool has_predicted_period() const;
  private:
  bool _internal_has_predicted_period() const;
  public:
  void clear_predicted_period();
  double predicted_period() const;
  void set_predicted_period(double value);
  private:
  double _internal_predicted_period() const;
  void _internal_set_predicted_period(double value);
  public:

  // optional bool is_static = 5 [default = false];
  bool has_is_static() const;
  private:
  bool _internal_has_is_static() const;
  public:
  void clear_is_static();
  bool is_static() const;
  void set_is_static(bool value);
  private:
  bool _internal_is_static() const;
  void _internal_set_is_static(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PredictionObstacleFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::PredictionTrajectoryFeature > trajectory_;
    ::apollo::prediction::ObstacleIntent* intent_;
    ::apollo::prediction::ObstaclePriority* priority_;
    double timestamp_sec_;
    double predicted_period_;
    bool is_static_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ObstacleFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ObstacleFeature) */ {
 public:
  inline ObstacleFeature() : ObstacleFeature(nullptr) {}
  ~ObstacleFeature() override;
  explicit PROTOBUF_CONSTEXPR ObstacleFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleFeature(const ObstacleFeature& from);
  ObstacleFeature(ObstacleFeature&& from) noexcept
    : ObstacleFeature() {
    *this = ::std::move(from);
  }

  inline ObstacleFeature& operator=(const ObstacleFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleFeature& operator=(ObstacleFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleFeature* internal_default_instance() {
    return reinterpret_cast<const ObstacleFeature*>(
               &_ObstacleFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ObstacleFeature& a, ObstacleFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ObstacleFeature";
  }
  protected:
  explicit ObstacleFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstacleTrajectoryFieldNumber = 6,
    kObstaclePredictionFieldNumber = 7,
    kLengthFieldNumber = 2,
    kWidthFieldNumber = 3,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 5,
    kHeightFieldNumber = 4,
  };
  // optional .apollo.planning.ObstacleTrajectoryFeature obstacle_trajectory = 6;
  bool has_obstacle_trajectory() const;
  private:
  bool _internal_has_obstacle_trajectory() const;
  public:
  void clear_obstacle_trajectory();
  const ::apollo::planning::ObstacleTrajectoryFeature& obstacle_trajectory() const;
  PROTOBUF_NODISCARD ::apollo::planning::ObstacleTrajectoryFeature* release_obstacle_trajectory();
  ::apollo::planning::ObstacleTrajectoryFeature* mutable_obstacle_trajectory();
  void set_allocated_obstacle_trajectory(::apollo::planning::ObstacleTrajectoryFeature* obstacle_trajectory);
  private:
  const ::apollo::planning::ObstacleTrajectoryFeature& _internal_obstacle_trajectory() const;
  ::apollo::planning::ObstacleTrajectoryFeature* _internal_mutable_obstacle_trajectory();
  public:
  void unsafe_arena_set_allocated_obstacle_trajectory(
      ::apollo::planning::ObstacleTrajectoryFeature* obstacle_trajectory);
  ::apollo::planning::ObstacleTrajectoryFeature* unsafe_arena_release_obstacle_trajectory();

  // optional .apollo.planning.PredictionObstacleFeature obstacle_prediction = 7;
  bool has_obstacle_prediction() const;
  private:
  bool _internal_has_obstacle_prediction() const;
  public:
  void clear_obstacle_prediction();
  const ::apollo::planning::PredictionObstacleFeature& obstacle_prediction() const;
  PROTOBUF_NODISCARD ::apollo::planning::PredictionObstacleFeature* release_obstacle_prediction();
  ::apollo::planning::PredictionObstacleFeature* mutable_obstacle_prediction();
  void set_allocated_obstacle_prediction(::apollo::planning::PredictionObstacleFeature* obstacle_prediction);
  private:
  const ::apollo::planning::PredictionObstacleFeature& _internal_obstacle_prediction() const;
  ::apollo::planning::PredictionObstacleFeature* _internal_mutable_obstacle_prediction();
  public:
  void unsafe_arena_set_allocated_obstacle_prediction(
      ::apollo::planning::PredictionObstacleFeature* obstacle_prediction);
  ::apollo::planning::PredictionObstacleFeature* unsafe_arena_release_obstacle_prediction();

  // optional double length = 2;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // optional double width = 3;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional .apollo.perception.PerceptionObstacle.Type type = 5;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::apollo::perception::PerceptionObstacle_Type type() const;
  void set_type(::apollo::perception::PerceptionObstacle_Type value);
  private:
  ::apollo::perception::PerceptionObstacle_Type _internal_type() const;
  void _internal_set_type(::apollo::perception::PerceptionObstacle_Type value);
  public:

  // optional double height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  double height() const;
  void set_height(double value);
  private:
  double _internal_height() const;
  void _internal_set_height(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ObstacleFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::planning::ObstacleTrajectoryFeature* obstacle_trajectory_;
    ::apollo::planning::PredictionObstacleFeature* obstacle_prediction_;
    double length_;
    double width_;
    int32_t id_;
    int type_;
    double height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class RoutingResponseFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.RoutingResponseFeature) */ {
 public:
  inline RoutingResponseFeature() : RoutingResponseFeature(nullptr) {}
  ~RoutingResponseFeature() override;
  explicit PROTOBUF_CONSTEXPR RoutingResponseFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingResponseFeature(const RoutingResponseFeature& from);
  RoutingResponseFeature(RoutingResponseFeature&& from) noexcept
    : RoutingResponseFeature() {
    *this = ::std::move(from);
  }

  inline RoutingResponseFeature& operator=(const RoutingResponseFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingResponseFeature& operator=(RoutingResponseFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingResponseFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingResponseFeature* internal_default_instance() {
    return reinterpret_cast<const RoutingResponseFeature*>(
               &_RoutingResponseFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RoutingResponseFeature& a, RoutingResponseFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingResponseFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingResponseFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingResponseFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingResponseFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingResponseFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingResponseFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingResponseFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.RoutingResponseFeature";
  }
  protected:
  explicit RoutingResponseFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoadFieldNumber = 1,
    kMeasurementFieldNumber = 2,
  };
  // repeated .apollo.routing.RoadSegment road = 1;
  int road_size() const;
  private:
  int _internal_road_size() const;
  public:
  void clear_road();
  ::apollo::routing::RoadSegment* mutable_road(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::routing::RoadSegment >*
      mutable_road();
  private:
  const ::apollo::routing::RoadSegment& _internal_road(int index) const;
  ::apollo::routing::RoadSegment* _internal_add_road();
  public:
  const ::apollo::routing::RoadSegment& road(int index) const;
  ::apollo::routing::RoadSegment* add_road();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::routing::RoadSegment >&
      road() const;

  // optional .apollo.routing.Measurement measurement = 2;
  bool has_measurement() const;
  private:
  bool _internal_has_measurement() const;
  public:
  void clear_measurement();
  const ::apollo::routing::Measurement& measurement() const;
  PROTOBUF_NODISCARD ::apollo::routing::Measurement* release_measurement();
  ::apollo::routing::Measurement* mutable_measurement();
  void set_allocated_measurement(::apollo::routing::Measurement* measurement);
  private:
  const ::apollo::routing::Measurement& _internal_measurement() const;
  ::apollo::routing::Measurement* _internal_mutable_measurement();
  public:
  void unsafe_arena_set_allocated_measurement(
      ::apollo::routing::Measurement* measurement);
  ::apollo::routing::Measurement* unsafe_arena_release_measurement();

  // @@protoc_insertion_point(class_scope:apollo.planning.RoutingResponseFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::routing::RoadSegment > road_;
    ::apollo::routing::Measurement* measurement_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class RoutingFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.RoutingFeature) */ {
 public:
  inline RoutingFeature() : RoutingFeature(nullptr) {}
  ~RoutingFeature() override;
  explicit PROTOBUF_CONSTEXPR RoutingFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingFeature(const RoutingFeature& from);
  RoutingFeature(RoutingFeature&& from) noexcept
    : RoutingFeature() {
    *this = ::std::move(from);
  }

  inline RoutingFeature& operator=(const RoutingFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingFeature& operator=(RoutingFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingFeature* internal_default_instance() {
    return reinterpret_cast<const RoutingFeature*>(
               &_RoutingFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RoutingFeature& a, RoutingFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.RoutingFeature";
  }
  protected:
  explicit RoutingFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalRoutingLaneIdFieldNumber = 2,
    kRoutingResponseFieldNumber = 1,
    kLocalRoutingFieldNumber = 3,
  };
  // repeated string local_routing_lane_id = 2;
  int local_routing_lane_id_size() const;
  private:
  int _internal_local_routing_lane_id_size() const;
  public:
  void clear_local_routing_lane_id();
  const std::string& local_routing_lane_id(int index) const;
  std::string* mutable_local_routing_lane_id(int index);
  void set_local_routing_lane_id(int index, const std::string& value);
  void set_local_routing_lane_id(int index, std::string&& value);
  void set_local_routing_lane_id(int index, const char* value);
  void set_local_routing_lane_id(int index, const char* value, size_t size);
  std::string* add_local_routing_lane_id();
  void add_local_routing_lane_id(const std::string& value);
  void add_local_routing_lane_id(std::string&& value);
  void add_local_routing_lane_id(const char* value);
  void add_local_routing_lane_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& local_routing_lane_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_local_routing_lane_id();
  private:
  const std::string& _internal_local_routing_lane_id(int index) const;
  std::string* _internal_add_local_routing_lane_id();
  public:

  // optional .apollo.planning.RoutingResponseFeature routing_response = 1;
  bool has_routing_response() const;
  private:
  bool _internal_has_routing_response() const;
  public:
  void clear_routing_response();
  const ::apollo::planning::RoutingResponseFeature& routing_response() const;
  PROTOBUF_NODISCARD ::apollo::planning::RoutingResponseFeature* release_routing_response();
  ::apollo::planning::RoutingResponseFeature* mutable_routing_response();
  void set_allocated_routing_response(::apollo::planning::RoutingResponseFeature* routing_response);
  private:
  const ::apollo::planning::RoutingResponseFeature& _internal_routing_response() const;
  ::apollo::planning::RoutingResponseFeature* _internal_mutable_routing_response();
  public:
  void unsafe_arena_set_allocated_routing_response(
      ::apollo::planning::RoutingResponseFeature* routing_response);
  ::apollo::planning::RoutingResponseFeature* unsafe_arena_release_routing_response();

  // optional .apollo.planning.RoutingResponseFeature local_routing = 3;
  bool has_local_routing() const;
  private:
  bool _internal_has_local_routing() const;
  public:
  void clear_local_routing();
  const ::apollo::planning::RoutingResponseFeature& local_routing() const;
  PROTOBUF_NODISCARD ::apollo::planning::RoutingResponseFeature* release_local_routing();
  ::apollo::planning::RoutingResponseFeature* mutable_local_routing();
  void set_allocated_local_routing(::apollo::planning::RoutingResponseFeature* local_routing);
  private:
  const ::apollo::planning::RoutingResponseFeature& _internal_local_routing() const;
  ::apollo::planning::RoutingResponseFeature* _internal_mutable_local_routing();
  public:
  void unsafe_arena_set_allocated_local_routing(
      ::apollo::planning::RoutingResponseFeature* local_routing);
  ::apollo::planning::RoutingResponseFeature* unsafe_arena_release_local_routing();

  // @@protoc_insertion_point(class_scope:apollo.planning.RoutingFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> local_routing_lane_id_;
    ::apollo::planning::RoutingResponseFeature* routing_response_;
    ::apollo::planning::RoutingResponseFeature* local_routing_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class TrafficLightFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficLightFeature) */ {
 public:
  inline TrafficLightFeature() : TrafficLightFeature(nullptr) {}
  ~TrafficLightFeature() override;
  explicit PROTOBUF_CONSTEXPR TrafficLightFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficLightFeature(const TrafficLightFeature& from);
  TrafficLightFeature(TrafficLightFeature&& from) noexcept
    : TrafficLightFeature() {
    *this = ::std::move(from);
  }

  inline TrafficLightFeature& operator=(const TrafficLightFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficLightFeature& operator=(TrafficLightFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficLightFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficLightFeature* internal_default_instance() {
    return reinterpret_cast<const TrafficLightFeature*>(
               &_TrafficLightFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TrafficLightFeature& a, TrafficLightFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficLightFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficLightFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficLightFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficLightFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficLightFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrafficLightFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLightFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficLightFeature";
  }
  protected:
  explicit TrafficLightFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kColorFieldNumber = 1,
    kBlinkFieldNumber = 5,
    kTrackingTimeFieldNumber = 4,
    kRemainingTimeFieldNumber = 6,
    kConfidenceFieldNumber = 3,
  };
  // optional string id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional .apollo.perception.TrafficLight.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  ::apollo::perception::TrafficLight_Color color() const;
  void set_color(::apollo::perception::TrafficLight_Color value);
  private:
  ::apollo::perception::TrafficLight_Color _internal_color() const;
  void _internal_set_color(::apollo::perception::TrafficLight_Color value);
  public:

  // optional bool blink = 5;
  bool has_blink() const;
  private:
  bool _internal_has_blink() const;
  public:
  void clear_blink();
  bool blink() const;
  void set_blink(bool value);
  private:
  bool _internal_blink() const;
  void _internal_set_blink(bool value);
  public:

  // optional double tracking_time = 4;
  bool has_tracking_time() const;
  private:
  bool _internal_has_tracking_time() const;
  public:
  void clear_tracking_time();
  double tracking_time() const;
  void set_tracking_time(double value);
  private:
  double _internal_tracking_time() const;
  void _internal_set_tracking_time(double value);
  public:

  // optional double remaining_time = 6;
  bool has_remaining_time() const;
  private:
  bool _internal_has_remaining_time() const;
  public:
  void clear_remaining_time();
  double remaining_time() const;
  void set_remaining_time(double value);
  private:
  double _internal_remaining_time() const;
  void _internal_set_remaining_time(double value);
  public:

  // optional double confidence = 3 [default = 1];
  bool has_confidence() const;
  private:
  bool _internal_has_confidence() const;
  public:
  void clear_confidence();
  double confidence() const;
  void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficLightFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int color_;
    bool blink_;
    double tracking_time_;
    double remaining_time_;
    double confidence_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class TrafficLightDetectionFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficLightDetectionFeature) */ {
 public:
  inline TrafficLightDetectionFeature() : TrafficLightDetectionFeature(nullptr) {}
  ~TrafficLightDetectionFeature() override;
  explicit PROTOBUF_CONSTEXPR TrafficLightDetectionFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficLightDetectionFeature(const TrafficLightDetectionFeature& from);
  TrafficLightDetectionFeature(TrafficLightDetectionFeature&& from) noexcept
    : TrafficLightDetectionFeature() {
    *this = ::std::move(from);
  }

  inline TrafficLightDetectionFeature& operator=(const TrafficLightDetectionFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficLightDetectionFeature& operator=(TrafficLightDetectionFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficLightDetectionFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficLightDetectionFeature* internal_default_instance() {
    return reinterpret_cast<const TrafficLightDetectionFeature*>(
               &_TrafficLightDetectionFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TrafficLightDetectionFeature& a, TrafficLightDetectionFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficLightDetectionFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficLightDetectionFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficLightDetectionFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficLightDetectionFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficLightDetectionFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrafficLightDetectionFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLightDetectionFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficLightDetectionFeature";
  }
  protected:
  explicit TrafficLightDetectionFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrafficLightFieldNumber = 2,
    kMessageTimestampSecFieldNumber = 1,
  };
  // repeated .apollo.planning.TrafficLightFeature traffic_light = 2;
  int traffic_light_size() const;
  private:
  int _internal_traffic_light_size() const;
  public:
  void clear_traffic_light();
  ::apollo::planning::TrafficLightFeature* mutable_traffic_light(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficLightFeature >*
      mutable_traffic_light();
  private:
  const ::apollo::planning::TrafficLightFeature& _internal_traffic_light(int index) const;
  ::apollo::planning::TrafficLightFeature* _internal_add_traffic_light();
  public:
  const ::apollo::planning::TrafficLightFeature& traffic_light(int index) const;
  ::apollo::planning::TrafficLightFeature* add_traffic_light();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficLightFeature >&
      traffic_light() const;

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  private:
  bool _internal_has_message_timestamp_sec() const;
  public:
  void clear_message_timestamp_sec();
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);
  private:
  double _internal_message_timestamp_sec() const;
  void _internal_set_message_timestamp_sec(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficLightDetectionFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficLightFeature > traffic_light_;
    double message_timestamp_sec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ADCTrajectoryPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ADCTrajectoryPoint) */ {
 public:
  inline ADCTrajectoryPoint() : ADCTrajectoryPoint(nullptr) {}
  ~ADCTrajectoryPoint() override;
  explicit PROTOBUF_CONSTEXPR ADCTrajectoryPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ADCTrajectoryPoint(const ADCTrajectoryPoint& from);
  ADCTrajectoryPoint(ADCTrajectoryPoint&& from) noexcept
    : ADCTrajectoryPoint() {
    *this = ::std::move(from);
  }

  inline ADCTrajectoryPoint& operator=(const ADCTrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ADCTrajectoryPoint& operator=(ADCTrajectoryPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ADCTrajectoryPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const ADCTrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const ADCTrajectoryPoint*>(
               &_ADCTrajectoryPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ADCTrajectoryPoint& a, ADCTrajectoryPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(ADCTrajectoryPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ADCTrajectoryPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ADCTrajectoryPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ADCTrajectoryPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ADCTrajectoryPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ADCTrajectoryPoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ADCTrajectoryPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ADCTrajectoryPoint";
  }
  protected:
  explicit ADCTrajectoryPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlanningTagFieldNumber = 2,
    kTrajectoryPointFieldNumber = 3,
    kTimestampSecFieldNumber = 1,
  };
  // optional .apollo.planning.PlanningTag planning_tag = 2;
  bool has_planning_tag() const;
  private:
  bool _internal_has_planning_tag() const;
  public:
  void clear_planning_tag();
  const ::apollo::planning::PlanningTag& planning_tag() const;
  PROTOBUF_NODISCARD ::apollo::planning::PlanningTag* release_planning_tag();
  ::apollo::planning::PlanningTag* mutable_planning_tag();
  void set_allocated_planning_tag(::apollo::planning::PlanningTag* planning_tag);
  private:
  const ::apollo::planning::PlanningTag& _internal_planning_tag() const;
  ::apollo::planning::PlanningTag* _internal_mutable_planning_tag();
  public:
  void unsafe_arena_set_allocated_planning_tag(
      ::apollo::planning::PlanningTag* planning_tag);
  ::apollo::planning::PlanningTag* unsafe_arena_release_planning_tag();

  // optional .apollo.planning.CommonTrajectoryPointFeature trajectory_point = 3;
  bool has_trajectory_point() const;
  private:
  bool _internal_has_trajectory_point() const;
  public:
  void clear_trajectory_point();
  const ::apollo::planning::CommonTrajectoryPointFeature& trajectory_point() const;
  PROTOBUF_NODISCARD ::apollo::planning::CommonTrajectoryPointFeature* release_trajectory_point();
  ::apollo::planning::CommonTrajectoryPointFeature* mutable_trajectory_point();
  void set_allocated_trajectory_point(::apollo::planning::CommonTrajectoryPointFeature* trajectory_point);
  private:
  const ::apollo::planning::CommonTrajectoryPointFeature& _internal_trajectory_point() const;
  ::apollo::planning::CommonTrajectoryPointFeature* _internal_mutable_trajectory_point();
  public:
  void unsafe_arena_set_allocated_trajectory_point(
      ::apollo::planning::CommonTrajectoryPointFeature* trajectory_point);
  ::apollo::planning::CommonTrajectoryPointFeature* unsafe_arena_release_trajectory_point();

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  private:
  bool _internal_has_timestamp_sec() const;
  public:
  void clear_timestamp_sec();
  double timestamp_sec() const;
  void set_timestamp_sec(double value);
  private:
  double _internal_timestamp_sec() const;
  void _internal_set_timestamp_sec(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ADCTrajectoryPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::planning::PlanningTag* planning_tag_;
    ::apollo::planning::CommonTrajectoryPointFeature* trajectory_point_;
    double timestamp_sec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class LearningOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LearningOutput) */ {
 public:
  inline LearningOutput() : LearningOutput(nullptr) {}
  ~LearningOutput() override;
  explicit PROTOBUF_CONSTEXPR LearningOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LearningOutput(const LearningOutput& from);
  LearningOutput(LearningOutput&& from) noexcept
    : LearningOutput() {
    *this = ::std::move(from);
  }

  inline LearningOutput& operator=(const LearningOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline LearningOutput& operator=(LearningOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LearningOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const LearningOutput* internal_default_instance() {
    return reinterpret_cast<const LearningOutput*>(
               &_LearningOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LearningOutput& a, LearningOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(LearningOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LearningOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LearningOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LearningOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LearningOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LearningOutput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.LearningOutput";
  }
  protected:
  explicit LearningOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdcFutureTrajectoryPointFieldNumber = 1,
  };
  // repeated .apollo.planning.TrajectoryPointFeature adc_future_trajectory_point = 1;
  int adc_future_trajectory_point_size() const;
  private:
  int _internal_adc_future_trajectory_point_size() const;
  public:
  void clear_adc_future_trajectory_point();
  ::apollo::planning::TrajectoryPointFeature* mutable_adc_future_trajectory_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
      mutable_adc_future_trajectory_point();
  private:
  const ::apollo::planning::TrajectoryPointFeature& _internal_adc_future_trajectory_point(int index) const;
  ::apollo::planning::TrajectoryPointFeature* _internal_add_adc_future_trajectory_point();
  public:
  const ::apollo::planning::TrajectoryPointFeature& adc_future_trajectory_point(int index) const;
  ::apollo::planning::TrajectoryPointFeature* add_adc_future_trajectory_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
      adc_future_trajectory_point() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.LearningOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature > adc_future_trajectory_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class LearningDataFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LearningDataFrame) */ {
 public:
  inline LearningDataFrame() : LearningDataFrame(nullptr) {}
  ~LearningDataFrame() override;
  explicit PROTOBUF_CONSTEXPR LearningDataFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LearningDataFrame(const LearningDataFrame& from);
  LearningDataFrame(LearningDataFrame&& from) noexcept
    : LearningDataFrame() {
    *this = ::std::move(from);
  }

  inline LearningDataFrame& operator=(const LearningDataFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline LearningDataFrame& operator=(LearningDataFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LearningDataFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const LearningDataFrame* internal_default_instance() {
    return reinterpret_cast<const LearningDataFrame*>(
               &_LearningDataFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LearningDataFrame& a, LearningDataFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(LearningDataFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LearningDataFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LearningDataFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LearningDataFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LearningDataFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LearningDataFrame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningDataFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.LearningDataFrame";
  }
  protected:
  explicit LearningDataFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstacleFieldNumber = 7,
    kAdcTrajectoryPointFieldNumber = 10,
    kMapNameFieldNumber = 3,
    kPlanningTagFieldNumber = 4,
    kChassisFieldNumber = 5,
    kLocalizationFieldNumber = 6,
    kRoutingFieldNumber = 8,
    kTrafficLightDetectionFieldNumber = 9,
    kOutputFieldNumber = 11,
    kMessageTimestampSecFieldNumber = 1,
    kFrameNumFieldNumber = 2,
  };
  // repeated .apollo.planning.ObstacleFeature obstacle = 7;
  int obstacle_size() const;
  private:
  int _internal_obstacle_size() const;
  public:
  void clear_obstacle();
  ::apollo::planning::ObstacleFeature* mutable_obstacle(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ObstacleFeature >*
      mutable_obstacle();
  private:
  const ::apollo::planning::ObstacleFeature& _internal_obstacle(int index) const;
  ::apollo::planning::ObstacleFeature* _internal_add_obstacle();
  public:
  const ::apollo::planning::ObstacleFeature& obstacle(int index) const;
  ::apollo::planning::ObstacleFeature* add_obstacle();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ObstacleFeature >&
      obstacle() const;

  // repeated .apollo.planning.ADCTrajectoryPoint adc_trajectory_point = 10;
  int adc_trajectory_point_size() const;
  private:
  int _internal_adc_trajectory_point_size() const;
  public:
  void clear_adc_trajectory_point();
  ::apollo::planning::ADCTrajectoryPoint* mutable_adc_trajectory_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ADCTrajectoryPoint >*
      mutable_adc_trajectory_point();
  private:
  const ::apollo::planning::ADCTrajectoryPoint& _internal_adc_trajectory_point(int index) const;
  ::apollo::planning::ADCTrajectoryPoint* _internal_add_adc_trajectory_point();
  public:
  const ::apollo::planning::ADCTrajectoryPoint& adc_trajectory_point(int index) const;
  ::apollo::planning::ADCTrajectoryPoint* add_adc_trajectory_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ADCTrajectoryPoint >&
      adc_trajectory_point() const;

  // optional string map_name = 3;
  bool has_map_name() const;
  private:
  bool _internal_has_map_name() const;
  public:
  void clear_map_name();
  const std::string& map_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_name();
  PROTOBUF_NODISCARD std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // optional .apollo.planning.PlanningTag planning_tag = 4;
  bool has_planning_tag() const;
  private:
  bool _internal_has_planning_tag() const;
  public:
  void clear_planning_tag();
  const ::apollo::planning::PlanningTag& planning_tag() const;
  PROTOBUF_NODISCARD ::apollo::planning::PlanningTag* release_planning_tag();
  ::apollo::planning::PlanningTag* mutable_planning_tag();
  void set_allocated_planning_tag(::apollo::planning::PlanningTag* planning_tag);
  private:
  const ::apollo::planning::PlanningTag& _internal_planning_tag() const;
  ::apollo::planning::PlanningTag* _internal_mutable_planning_tag();
  public:
  void unsafe_arena_set_allocated_planning_tag(
      ::apollo::planning::PlanningTag* planning_tag);
  ::apollo::planning::PlanningTag* unsafe_arena_release_planning_tag();

  // optional .apollo.planning.ChassisFeature chassis = 5;
  bool has_chassis() const;
  private:
  bool _internal_has_chassis() const;
  public:
  void clear_chassis();
  const ::apollo::planning::ChassisFeature& chassis() const;
  PROTOBUF_NODISCARD ::apollo::planning::ChassisFeature* release_chassis();
  ::apollo::planning::ChassisFeature* mutable_chassis();
  void set_allocated_chassis(::apollo::planning::ChassisFeature* chassis);
  private:
  const ::apollo::planning::ChassisFeature& _internal_chassis() const;
  ::apollo::planning::ChassisFeature* _internal_mutable_chassis();
  public:
  void unsafe_arena_set_allocated_chassis(
      ::apollo::planning::ChassisFeature* chassis);
  ::apollo::planning::ChassisFeature* unsafe_arena_release_chassis();

  // optional .apollo.planning.LocalizationFeature localization = 6;
  bool has_localization() const;
  private:
  bool _internal_has_localization() const;
  public:
  void clear_localization();
  const ::apollo::planning::LocalizationFeature& localization() const;
  PROTOBUF_NODISCARD ::apollo::planning::LocalizationFeature* release_localization();
  ::apollo::planning::LocalizationFeature* mutable_localization();
  void set_allocated_localization(::apollo::planning::LocalizationFeature* localization);
  private:
  const ::apollo::planning::LocalizationFeature& _internal_localization() const;
  ::apollo::planning::LocalizationFeature* _internal_mutable_localization();
  public:
  void unsafe_arena_set_allocated_localization(
      ::apollo::planning::LocalizationFeature* localization);
  ::apollo::planning::LocalizationFeature* unsafe_arena_release_localization();

  // optional .apollo.planning.RoutingFeature routing = 8;
  bool has_routing() const;
  private:
  bool _internal_has_routing() const;
  public:
  void clear_routing();
  const ::apollo::planning::RoutingFeature& routing() const;
  PROTOBUF_NODISCARD ::apollo::planning::RoutingFeature* release_routing();
  ::apollo::planning::RoutingFeature* mutable_routing();
  void set_allocated_routing(::apollo::planning::RoutingFeature* routing);
  private:
  const ::apollo::planning::RoutingFeature& _internal_routing() const;
  ::apollo::planning::RoutingFeature* _internal_mutable_routing();
  public:
  void unsafe_arena_set_allocated_routing(
      ::apollo::planning::RoutingFeature* routing);
  ::apollo::planning::RoutingFeature* unsafe_arena_release_routing();

  // optional .apollo.planning.TrafficLightDetectionFeature traffic_light_detection = 9;
  bool has_traffic_light_detection() const;
  private:
  bool _internal_has_traffic_light_detection() const;
  public:
  void clear_traffic_light_detection();
  const ::apollo::planning::TrafficLightDetectionFeature& traffic_light_detection() const;
  PROTOBUF_NODISCARD ::apollo::planning::TrafficLightDetectionFeature* release_traffic_light_detection();
  ::apollo::planning::TrafficLightDetectionFeature* mutable_traffic_light_detection();
  void set_allocated_traffic_light_detection(::apollo::planning::TrafficLightDetectionFeature* traffic_light_detection);
  private:
  const ::apollo::planning::TrafficLightDetectionFeature& _internal_traffic_light_detection() const;
  ::apollo::planning::TrafficLightDetectionFeature* _internal_mutable_traffic_light_detection();
  public:
  void unsafe_arena_set_allocated_traffic_light_detection(
      ::apollo::planning::TrafficLightDetectionFeature* traffic_light_detection);
  ::apollo::planning::TrafficLightDetectionFeature* unsafe_arena_release_traffic_light_detection();

  // optional .apollo.planning.LearningOutput output = 11;
  bool has_output() const;
  private:
  bool _internal_has_output() const;
  public:
  void clear_output();
  const ::apollo::planning::LearningOutput& output() const;
  PROTOBUF_NODISCARD ::apollo::planning::LearningOutput* release_output();
  ::apollo::planning::LearningOutput* mutable_output();
  void set_allocated_output(::apollo::planning::LearningOutput* output);
  private:
  const ::apollo::planning::LearningOutput& _internal_output() const;
  ::apollo::planning::LearningOutput* _internal_mutable_output();
  public:
  void unsafe_arena_set_allocated_output(
      ::apollo::planning::LearningOutput* output);
  ::apollo::planning::LearningOutput* unsafe_arena_release_output();

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  private:
  bool _internal_has_message_timestamp_sec() const;
  public:
  void clear_message_timestamp_sec();
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);
  private:
  double _internal_message_timestamp_sec() const;
  void _internal_set_message_timestamp_sec(double value);
  public:

  // optional uint32 frame_num = 2;
  bool has_frame_num() const;
  private:
  bool _internal_has_frame_num() const;
  public:
  void clear_frame_num();
  uint32_t frame_num() const;
  void set_frame_num(uint32_t value);
  private:
  uint32_t _internal_frame_num() const;
  void _internal_set_frame_num(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.LearningDataFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ObstacleFeature > obstacle_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ADCTrajectoryPoint > adc_trajectory_point_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
    ::apollo::planning::PlanningTag* planning_tag_;
    ::apollo::planning::ChassisFeature* chassis_;
    ::apollo::planning::LocalizationFeature* localization_;
    ::apollo::planning::RoutingFeature* routing_;
    ::apollo::planning::TrafficLightDetectionFeature* traffic_light_detection_;
    ::apollo::planning::LearningOutput* output_;
    double message_timestamp_sec_;
    uint32_t frame_num_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class LearningData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LearningData) */ {
 public:
  inline LearningData() : LearningData(nullptr) {}
  ~LearningData() override;
  explicit PROTOBUF_CONSTEXPR LearningData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LearningData(const LearningData& from);
  LearningData(LearningData&& from) noexcept
    : LearningData() {
    *this = ::std::move(from);
  }

  inline LearningData& operator=(const LearningData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LearningData& operator=(LearningData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LearningData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LearningData* internal_default_instance() {
    return reinterpret_cast<const LearningData*>(
               &_LearningData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LearningData& a, LearningData& b) {
    a.Swap(&b);
  }
  inline void Swap(LearningData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LearningData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LearningData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LearningData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LearningData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LearningData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.LearningData";
  }
  protected:
  explicit LearningData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLearningDataFrameFieldNumber = 1,
  };
  // repeated .apollo.planning.LearningDataFrame learning_data_frame = 1;
  int learning_data_frame_size() const;
  private:
  int _internal_learning_data_frame_size() const;
  public:
  void clear_learning_data_frame();
  ::apollo::planning::LearningDataFrame* mutable_learning_data_frame(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::LearningDataFrame >*
      mutable_learning_data_frame();
  private:
  const ::apollo::planning::LearningDataFrame& _internal_learning_data_frame(int index) const;
  ::apollo::planning::LearningDataFrame* _internal_add_learning_data_frame();
  public:
  const ::apollo::planning::LearningDataFrame& learning_data_frame(int index) const;
  ::apollo::planning::LearningDataFrame* add_learning_data_frame();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::LearningDataFrame >&
      learning_data_frame() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.LearningData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::LearningDataFrame > learning_data_frame_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PlanningLearningData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningLearningData) */ {
 public:
  inline PlanningLearningData() : PlanningLearningData(nullptr) {}
  ~PlanningLearningData() override;
  explicit PROTOBUF_CONSTEXPR PlanningLearningData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanningLearningData(const PlanningLearningData& from);
  PlanningLearningData(PlanningLearningData&& from) noexcept
    : PlanningLearningData() {
    *this = ::std::move(from);
  }

  inline PlanningLearningData& operator=(const PlanningLearningData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanningLearningData& operator=(PlanningLearningData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanningLearningData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanningLearningData* internal_default_instance() {
    return reinterpret_cast<const PlanningLearningData*>(
               &_PlanningLearningData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PlanningLearningData& a, PlanningLearningData& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanningLearningData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanningLearningData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanningLearningData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanningLearningData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanningLearningData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlanningLearningData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanningLearningData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PlanningLearningData";
  }
  protected:
  explicit PlanningLearningData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLearningDataFrameFieldNumber = 2,
  };
  // optional .apollo.common.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::apollo::common::Header& header() const;
  PROTOBUF_NODISCARD ::apollo::common::Header* release_header();
  ::apollo::common::Header* mutable_header();
  void set_allocated_header(::apollo::common::Header* header);
  private:
  const ::apollo::common::Header& _internal_header() const;
  ::apollo::common::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::apollo::common::Header* header);
  ::apollo::common::Header* unsafe_arena_release_header();

  // optional .apollo.planning.LearningDataFrame learning_data_frame = 2;
  bool has_learning_data_frame() const;
  private:
  bool _internal_has_learning_data_frame() const;
  public:
  void clear_learning_data_frame();
  const ::apollo::planning::LearningDataFrame& learning_data_frame() const;
  PROTOBUF_NODISCARD ::apollo::planning::LearningDataFrame* release_learning_data_frame();
  ::apollo::planning::LearningDataFrame* mutable_learning_data_frame();
  void set_allocated_learning_data_frame(::apollo::planning::LearningDataFrame* learning_data_frame);
  private:
  const ::apollo::planning::LearningDataFrame& _internal_learning_data_frame() const;
  ::apollo::planning::LearningDataFrame* _internal_mutable_learning_data_frame();
  public:
  void unsafe_arena_set_allocated_learning_data_frame(
      ::apollo::planning::LearningDataFrame* learning_data_frame);
  ::apollo::planning::LearningDataFrame* unsafe_arena_release_learning_data_frame();

  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningLearningData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::common::Header* header_;
    ::apollo::planning::LearningDataFrame* learning_data_frame_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2flearning_5fdata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OverlapFeature

// optional string id = 1;
inline bool OverlapFeature::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OverlapFeature::has_id() const {
  return _internal_has_id();
}
inline void OverlapFeature::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OverlapFeature::id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.OverlapFeature.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverlapFeature::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.OverlapFeature.id)
}
inline std::string* OverlapFeature::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.OverlapFeature.id)
  return _s;
}
inline const std::string& OverlapFeature::_internal_id() const {
  return _impl_.id_.Get();
}
inline void OverlapFeature::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* OverlapFeature::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* OverlapFeature::release_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.OverlapFeature.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OverlapFeature::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.OverlapFeature.id)
}

// optional double distance = 2;
inline bool OverlapFeature::_internal_has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OverlapFeature::has_distance() const {
  return _internal_has_distance();
}
inline void OverlapFeature::clear_distance() {
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double OverlapFeature::_internal_distance() const {
  return _impl_.distance_;
}
inline double OverlapFeature::distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.OverlapFeature.distance)
  return _internal_distance();
}
inline void OverlapFeature::_internal_set_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.distance_ = value;
}
inline void OverlapFeature::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.OverlapFeature.distance)
}

// -------------------------------------------------------------------

// PlanningTag

// optional .apollo.hdmap.Lane.LaneTurn lane_turn = 1;
inline bool PlanningTag::_internal_has_lane_turn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PlanningTag::has_lane_turn() const {
  return _internal_has_lane_turn();
}
inline void PlanningTag::clear_lane_turn() {
  _impl_.lane_turn_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::apollo::hdmap::Lane_LaneTurn PlanningTag::_internal_lane_turn() const {
  return static_cast< ::apollo::hdmap::Lane_LaneTurn >(_impl_.lane_turn_);
}
inline ::apollo::hdmap::Lane_LaneTurn PlanningTag::lane_turn() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.lane_turn)
  return _internal_lane_turn();
}
inline void PlanningTag::_internal_set_lane_turn(::apollo::hdmap::Lane_LaneTurn value) {
  assert(::apollo::hdmap::Lane_LaneTurn_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.lane_turn_ = value;
}
inline void PlanningTag::set_lane_turn(::apollo::hdmap::Lane_LaneTurn value) {
  _internal_set_lane_turn(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PlanningTag.lane_turn)
}

// optional .apollo.planning.OverlapFeature clear_area = 2;
inline bool PlanningTag::_internal_has_clear_area() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.clear_area_ != nullptr);
  return value;
}
inline bool PlanningTag::has_clear_area() const {
  return _internal_has_clear_area();
}
inline void PlanningTag::clear_clear_area() {
  if (_impl_.clear_area_ != nullptr) _impl_.clear_area_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_clear_area() const {
  const ::apollo::planning::OverlapFeature* p = _impl_.clear_area_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::OverlapFeature&>(
      ::apollo::planning::_OverlapFeature_default_instance_);
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::clear_area() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.clear_area)
  return _internal_clear_area();
}
inline void PlanningTag::unsafe_arena_set_allocated_clear_area(
    ::apollo::planning::OverlapFeature* clear_area) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clear_area_);
  }
  _impl_.clear_area_ = clear_area;
  if (clear_area) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningTag.clear_area)
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_clear_area() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::OverlapFeature* temp = _impl_.clear_area_;
  _impl_.clear_area_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::unsafe_arena_release_clear_area() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.clear_area)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::OverlapFeature* temp = _impl_.clear_area_;
  _impl_.clear_area_ = nullptr;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::_internal_mutable_clear_area() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.clear_area_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaForAllocation());
    _impl_.clear_area_ = p;
  }
  return _impl_.clear_area_;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_clear_area() {
  ::apollo::planning::OverlapFeature* _msg = _internal_mutable_clear_area();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.clear_area)
  return _msg;
}
inline void PlanningTag::set_allocated_clear_area(::apollo::planning::OverlapFeature* clear_area) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clear_area_;
  }
  if (clear_area) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clear_area);
    if (message_arena != submessage_arena) {
      clear_area = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clear_area, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.clear_area_ = clear_area;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.clear_area)
}

// optional .apollo.planning.OverlapFeature crosswalk = 3;
inline bool PlanningTag::_internal_has_crosswalk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.crosswalk_ != nullptr);
  return value;
}
inline bool PlanningTag::has_crosswalk() const {
  return _internal_has_crosswalk();
}
inline void PlanningTag::clear_crosswalk() {
  if (_impl_.crosswalk_ != nullptr) _impl_.crosswalk_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_crosswalk() const {
  const ::apollo::planning::OverlapFeature* p = _impl_.crosswalk_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::OverlapFeature&>(
      ::apollo::planning::_OverlapFeature_default_instance_);
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::crosswalk() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.crosswalk)
  return _internal_crosswalk();
}
inline void PlanningTag::unsafe_arena_set_allocated_crosswalk(
    ::apollo::planning::OverlapFeature* crosswalk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.crosswalk_);
  }
  _impl_.crosswalk_ = crosswalk;
  if (crosswalk) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningTag.crosswalk)
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_crosswalk() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::OverlapFeature* temp = _impl_.crosswalk_;
  _impl_.crosswalk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::unsafe_arena_release_crosswalk() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.crosswalk)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::OverlapFeature* temp = _impl_.crosswalk_;
  _impl_.crosswalk_ = nullptr;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::_internal_mutable_crosswalk() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.crosswalk_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaForAllocation());
    _impl_.crosswalk_ = p;
  }
  return _impl_.crosswalk_;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_crosswalk() {
  ::apollo::planning::OverlapFeature* _msg = _internal_mutable_crosswalk();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.crosswalk)
  return _msg;
}
inline void PlanningTag::set_allocated_crosswalk(::apollo::planning::OverlapFeature* crosswalk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.crosswalk_;
  }
  if (crosswalk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(crosswalk);
    if (message_arena != submessage_arena) {
      crosswalk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crosswalk, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.crosswalk_ = crosswalk;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.crosswalk)
}

// optional .apollo.planning.OverlapFeature pnc_junction = 4;
inline bool PlanningTag::_internal_has_pnc_junction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pnc_junction_ != nullptr);
  return value;
}
inline bool PlanningTag::has_pnc_junction() const {
  return _internal_has_pnc_junction();
}
inline void PlanningTag::clear_pnc_junction() {
  if (_impl_.pnc_junction_ != nullptr) _impl_.pnc_junction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_pnc_junction() const {
  const ::apollo::planning::OverlapFeature* p = _impl_.pnc_junction_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::OverlapFeature&>(
      ::apollo::planning::_OverlapFeature_default_instance_);
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::pnc_junction() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.pnc_junction)
  return _internal_pnc_junction();
}
inline void PlanningTag::unsafe_arena_set_allocated_pnc_junction(
    ::apollo::planning::OverlapFeature* pnc_junction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pnc_junction_);
  }
  _impl_.pnc_junction_ = pnc_junction;
  if (pnc_junction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningTag.pnc_junction)
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_pnc_junction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::planning::OverlapFeature* temp = _impl_.pnc_junction_;
  _impl_.pnc_junction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::unsafe_arena_release_pnc_junction() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.pnc_junction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::planning::OverlapFeature* temp = _impl_.pnc_junction_;
  _impl_.pnc_junction_ = nullptr;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::_internal_mutable_pnc_junction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.pnc_junction_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaForAllocation());
    _impl_.pnc_junction_ = p;
  }
  return _impl_.pnc_junction_;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_pnc_junction() {
  ::apollo::planning::OverlapFeature* _msg = _internal_mutable_pnc_junction();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.pnc_junction)
  return _msg;
}
inline void PlanningTag::set_allocated_pnc_junction(::apollo::planning::OverlapFeature* pnc_junction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pnc_junction_;
  }
  if (pnc_junction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pnc_junction);
    if (message_arena != submessage_arena) {
      pnc_junction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pnc_junction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.pnc_junction_ = pnc_junction;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.pnc_junction)
}

// optional .apollo.planning.OverlapFeature signal = 5;
inline bool PlanningTag::_internal_has_signal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.signal_ != nullptr);
  return value;
}
inline bool PlanningTag::has_signal() const {
  return _internal_has_signal();
}
inline void PlanningTag::clear_signal() {
  if (_impl_.signal_ != nullptr) _impl_.signal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_signal() const {
  const ::apollo::planning::OverlapFeature* p = _impl_.signal_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::OverlapFeature&>(
      ::apollo::planning::_OverlapFeature_default_instance_);
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::signal() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.signal)
  return _internal_signal();
}
inline void PlanningTag::unsafe_arena_set_allocated_signal(
    ::apollo::planning::OverlapFeature* signal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_);
  }
  _impl_.signal_ = signal;
  if (signal) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningTag.signal)
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_signal() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::planning::OverlapFeature* temp = _impl_.signal_;
  _impl_.signal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::unsafe_arena_release_signal() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.signal)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::planning::OverlapFeature* temp = _impl_.signal_;
  _impl_.signal_ = nullptr;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::_internal_mutable_signal() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.signal_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaForAllocation());
    _impl_.signal_ = p;
  }
  return _impl_.signal_;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_signal() {
  ::apollo::planning::OverlapFeature* _msg = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.signal)
  return _msg;
}
inline void PlanningTag::set_allocated_signal(::apollo::planning::OverlapFeature* signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.signal_;
  }
  if (signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(signal);
    if (message_arena != submessage_arena) {
      signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.signal_ = signal;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.signal)
}

// optional .apollo.planning.OverlapFeature stop_sign = 6;
inline bool PlanningTag::_internal_has_stop_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_sign_ != nullptr);
  return value;
}
inline bool PlanningTag::has_stop_sign() const {
  return _internal_has_stop_sign();
}
inline void PlanningTag::clear_stop_sign() {
  if (_impl_.stop_sign_ != nullptr) _impl_.stop_sign_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_stop_sign() const {
  const ::apollo::planning::OverlapFeature* p = _impl_.stop_sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::OverlapFeature&>(
      ::apollo::planning::_OverlapFeature_default_instance_);
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::stop_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.stop_sign)
  return _internal_stop_sign();
}
inline void PlanningTag::unsafe_arena_set_allocated_stop_sign(
    ::apollo::planning::OverlapFeature* stop_sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stop_sign_);
  }
  _impl_.stop_sign_ = stop_sign;
  if (stop_sign) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningTag.stop_sign)
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_stop_sign() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::planning::OverlapFeature* temp = _impl_.stop_sign_;
  _impl_.stop_sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::unsafe_arena_release_stop_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.stop_sign)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::planning::OverlapFeature* temp = _impl_.stop_sign_;
  _impl_.stop_sign_ = nullptr;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::_internal_mutable_stop_sign() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.stop_sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaForAllocation());
    _impl_.stop_sign_ = p;
  }
  return _impl_.stop_sign_;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_stop_sign() {
  ::apollo::planning::OverlapFeature* _msg = _internal_mutable_stop_sign();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.stop_sign)
  return _msg;
}
inline void PlanningTag::set_allocated_stop_sign(::apollo::planning::OverlapFeature* stop_sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stop_sign_;
  }
  if (stop_sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stop_sign);
    if (message_arena != submessage_arena) {
      stop_sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_sign, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.stop_sign_ = stop_sign;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.stop_sign)
}

// optional .apollo.planning.OverlapFeature yield_sign = 7;
inline bool PlanningTag::_internal_has_yield_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.yield_sign_ != nullptr);
  return value;
}
inline bool PlanningTag::has_yield_sign() const {
  return _internal_has_yield_sign();
}
inline void PlanningTag::clear_yield_sign() {
  if (_impl_.yield_sign_ != nullptr) _impl_.yield_sign_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_yield_sign() const {
  const ::apollo::planning::OverlapFeature* p = _impl_.yield_sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::OverlapFeature&>(
      ::apollo::planning::_OverlapFeature_default_instance_);
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::yield_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.yield_sign)
  return _internal_yield_sign();
}
inline void PlanningTag::unsafe_arena_set_allocated_yield_sign(
    ::apollo::planning::OverlapFeature* yield_sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.yield_sign_);
  }
  _impl_.yield_sign_ = yield_sign;
  if (yield_sign) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningTag.yield_sign)
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_yield_sign() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::apollo::planning::OverlapFeature* temp = _impl_.yield_sign_;
  _impl_.yield_sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::unsafe_arena_release_yield_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.yield_sign)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::apollo::planning::OverlapFeature* temp = _impl_.yield_sign_;
  _impl_.yield_sign_ = nullptr;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::_internal_mutable_yield_sign() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.yield_sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaForAllocation());
    _impl_.yield_sign_ = p;
  }
  return _impl_.yield_sign_;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_yield_sign() {
  ::apollo::planning::OverlapFeature* _msg = _internal_mutable_yield_sign();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.yield_sign)
  return _msg;
}
inline void PlanningTag::set_allocated_yield_sign(::apollo::planning::OverlapFeature* yield_sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.yield_sign_;
  }
  if (yield_sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(yield_sign);
    if (message_arena != submessage_arena) {
      yield_sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yield_sign, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.yield_sign_ = yield_sign;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.yield_sign)
}

// -------------------------------------------------------------------

// ChassisFeature

// optional double message_timestamp_sec = 1;
inline bool ChassisFeature::_internal_has_message_timestamp_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChassisFeature::has_message_timestamp_sec() const {
  return _internal_has_message_timestamp_sec();
}
inline void ChassisFeature::clear_message_timestamp_sec() {
  _impl_.message_timestamp_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ChassisFeature::_internal_message_timestamp_sec() const {
  return _impl_.message_timestamp_sec_;
}
inline double ChassisFeature::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.message_timestamp_sec)
  return _internal_message_timestamp_sec();
}
inline void ChassisFeature::_internal_set_message_timestamp_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_timestamp_sec_ = value;
}
inline void ChassisFeature::set_message_timestamp_sec(double value) {
  _internal_set_message_timestamp_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.message_timestamp_sec)
}

// optional float speed_mps = 2;
inline bool ChassisFeature::_internal_has_speed_mps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChassisFeature::has_speed_mps() const {
  return _internal_has_speed_mps();
}
inline void ChassisFeature::clear_speed_mps() {
  _impl_.speed_mps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ChassisFeature::_internal_speed_mps() const {
  return _impl_.speed_mps_;
}
inline float ChassisFeature::speed_mps() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.speed_mps)
  return _internal_speed_mps();
}
inline void ChassisFeature::_internal_set_speed_mps(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.speed_mps_ = value;
}
inline void ChassisFeature::set_speed_mps(float value) {
  _internal_set_speed_mps(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.speed_mps)
}

// optional float throttle_percentage = 3;
inline bool ChassisFeature::_internal_has_throttle_percentage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChassisFeature::has_throttle_percentage() const {
  return _internal_has_throttle_percentage();
}
inline void ChassisFeature::clear_throttle_percentage() {
  _impl_.throttle_percentage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float ChassisFeature::_internal_throttle_percentage() const {
  return _impl_.throttle_percentage_;
}
inline float ChassisFeature::throttle_percentage() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.throttle_percentage)
  return _internal_throttle_percentage();
}
inline void ChassisFeature::_internal_set_throttle_percentage(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.throttle_percentage_ = value;
}
inline void ChassisFeature::set_throttle_percentage(float value) {
  _internal_set_throttle_percentage(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.throttle_percentage)
}

// optional float brake_percentage = 4;
inline bool ChassisFeature::_internal_has_brake_percentage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChassisFeature::has_brake_percentage() const {
  return _internal_has_brake_percentage();
}
inline void ChassisFeature::clear_brake_percentage() {
  _impl_.brake_percentage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float ChassisFeature::_internal_brake_percentage() const {
  return _impl_.brake_percentage_;
}
inline float ChassisFeature::brake_percentage() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.brake_percentage)
  return _internal_brake_percentage();
}
inline void ChassisFeature::_internal_set_brake_percentage(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.brake_percentage_ = value;
}
inline void ChassisFeature::set_brake_percentage(float value) {
  _internal_set_brake_percentage(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.brake_percentage)
}

// optional float steering_percentage = 5;
inline bool ChassisFeature::_internal_has_steering_percentage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChassisFeature::has_steering_percentage() const {
  return _internal_has_steering_percentage();
}
inline void ChassisFeature::clear_steering_percentage() {
  _impl_.steering_percentage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float ChassisFeature::_internal_steering_percentage() const {
  return _impl_.steering_percentage_;
}
inline float ChassisFeature::steering_percentage() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.steering_percentage)
  return _internal_steering_percentage();
}
inline void ChassisFeature::_internal_set_steering_percentage(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.steering_percentage_ = value;
}
inline void ChassisFeature::set_steering_percentage(float value) {
  _internal_set_steering_percentage(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.steering_percentage)
}

// optional .apollo.canbus.Chassis.GearPosition gear_location = 6;
inline bool ChassisFeature::_internal_has_gear_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ChassisFeature::has_gear_location() const {
  return _internal_has_gear_location();
}
inline void ChassisFeature::clear_gear_location() {
  _impl_.gear_location_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::apollo::canbus::Chassis_GearPosition ChassisFeature::_internal_gear_location() const {
  return static_cast< ::apollo::canbus::Chassis_GearPosition >(_impl_.gear_location_);
}
inline ::apollo::canbus::Chassis_GearPosition ChassisFeature::gear_location() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.gear_location)
  return _internal_gear_location();
}
inline void ChassisFeature::_internal_set_gear_location(::apollo::canbus::Chassis_GearPosition value) {
  assert(::apollo::canbus::Chassis_GearPosition_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.gear_location_ = value;
}
inline void ChassisFeature::set_gear_location(::apollo::canbus::Chassis_GearPosition value) {
  _internal_set_gear_location(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.gear_location)
}

// -------------------------------------------------------------------

// LocalizationFeature

// optional double message_timestamp_sec = 1;
inline bool LocalizationFeature::_internal_has_message_timestamp_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LocalizationFeature::has_message_timestamp_sec() const {
  return _internal_has_message_timestamp_sec();
}
inline void LocalizationFeature::clear_message_timestamp_sec() {
  _impl_.message_timestamp_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double LocalizationFeature::_internal_message_timestamp_sec() const {
  return _impl_.message_timestamp_sec_;
}
inline double LocalizationFeature::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.message_timestamp_sec)
  return _internal_message_timestamp_sec();
}
inline void LocalizationFeature::_internal_set_message_timestamp_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.message_timestamp_sec_ = value;
}
inline void LocalizationFeature::set_message_timestamp_sec(double value) {
  _internal_set_message_timestamp_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.LocalizationFeature.message_timestamp_sec)
}

// optional .apollo.common.PointENU position = 2;
inline bool LocalizationFeature::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool LocalizationFeature::has_position() const {
  return _internal_has_position();
}
inline const ::apollo::common::PointENU& LocalizationFeature::_internal_position() const {
  const ::apollo::common::PointENU* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::PointENU&>(
      ::apollo::common::_PointENU_default_instance_);
}
inline const ::apollo::common::PointENU& LocalizationFeature::position() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.position)
  return _internal_position();
}
inline void LocalizationFeature::unsafe_arena_set_allocated_position(
    ::apollo::common::PointENU* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.LocalizationFeature.position)
}
inline ::apollo::common::PointENU* LocalizationFeature::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::PointENU* LocalizationFeature::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:apollo.planning.LocalizationFeature.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::apollo::common::PointENU* LocalizationFeature::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::PointENU>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::apollo::common::PointENU* LocalizationFeature::mutable_position() {
  ::apollo::common::PointENU* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LocalizationFeature.position)
  return _msg;
}
inline void LocalizationFeature::set_allocated_position(::apollo::common::PointENU* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LocalizationFeature.position)
}

// optional double heading = 3;
inline bool LocalizationFeature::_internal_has_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LocalizationFeature::has_heading() const {
  return _internal_has_heading();
}
inline void LocalizationFeature::clear_heading() {
  _impl_.heading_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double LocalizationFeature::_internal_heading() const {
  return _impl_.heading_;
}
inline double LocalizationFeature::heading() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.heading)
  return _internal_heading();
}
inline void LocalizationFeature::_internal_set_heading(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.heading_ = value;
}
inline void LocalizationFeature::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:apollo.planning.LocalizationFeature.heading)
}

// optional .apollo.common.Point3D linear_velocity = 4;
inline bool LocalizationFeature::_internal_has_linear_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_velocity_ != nullptr);
  return value;
}
inline bool LocalizationFeature::has_linear_velocity() const {
  return _internal_has_linear_velocity();
}
inline const ::apollo::common::Point3D& LocalizationFeature::_internal_linear_velocity() const {
  const ::apollo::common::Point3D* p = _impl_.linear_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::Point3D&>(
      ::apollo::common::_Point3D_default_instance_);
}
inline const ::apollo::common::Point3D& LocalizationFeature::linear_velocity() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.linear_velocity)
  return _internal_linear_velocity();
}
inline void LocalizationFeature::unsafe_arena_set_allocated_linear_velocity(
    ::apollo::common::Point3D* linear_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_velocity_);
  }
  _impl_.linear_velocity_ = linear_velocity;
  if (linear_velocity) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.LocalizationFeature.linear_velocity)
}
inline ::apollo::common::Point3D* LocalizationFeature::release_linear_velocity() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::Point3D* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::Point3D* LocalizationFeature::unsafe_arena_release_linear_velocity() {
  // @@protoc_insertion_point(field_release:apollo.planning.LocalizationFeature.linear_velocity)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::Point3D* temp = _impl_.linear_velocity_;
  _impl_.linear_velocity_ = nullptr;
  return temp;
}
inline ::apollo::common::Point3D* LocalizationFeature::_internal_mutable_linear_velocity() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.linear_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaForAllocation());
    _impl_.linear_velocity_ = p;
  }
  return _impl_.linear_velocity_;
}
inline ::apollo::common::Point3D* LocalizationFeature::mutable_linear_velocity() {
  ::apollo::common::Point3D* _msg = _internal_mutable_linear_velocity();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LocalizationFeature.linear_velocity)
  return _msg;
}
inline void LocalizationFeature::set_allocated_linear_velocity(::apollo::common::Point3D* linear_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_velocity_);
  }
  if (linear_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_velocity));
    if (message_arena != submessage_arena) {
      linear_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LocalizationFeature.linear_velocity)
}

// optional .apollo.common.Point3D linear_acceleration = 5;
inline bool LocalizationFeature::_internal_has_linear_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_acceleration_ != nullptr);
  return value;
}
inline bool LocalizationFeature::has_linear_acceleration() const {
  return _internal_has_linear_acceleration();
}
inline const ::apollo::common::Point3D& LocalizationFeature::_internal_linear_acceleration() const {
  const ::apollo::common::Point3D* p = _impl_.linear_acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::Point3D&>(
      ::apollo::common::_Point3D_default_instance_);
}
inline const ::apollo::common::Point3D& LocalizationFeature::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.linear_acceleration)
  return _internal_linear_acceleration();
}
inline void LocalizationFeature::unsafe_arena_set_allocated_linear_acceleration(
    ::apollo::common::Point3D* linear_acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_acceleration_);
  }
  _impl_.linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.LocalizationFeature.linear_acceleration)
}
inline ::apollo::common::Point3D* LocalizationFeature::release_linear_acceleration() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::common::Point3D* temp = _impl_.linear_acceleration_;
  _impl_.linear_acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::Point3D* LocalizationFeature::unsafe_arena_release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:apollo.planning.LocalizationFeature.linear_acceleration)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::common::Point3D* temp = _impl_.linear_acceleration_;
  _impl_.linear_acceleration_ = nullptr;
  return temp;
}
inline ::apollo::common::Point3D* LocalizationFeature::_internal_mutable_linear_acceleration() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.linear_acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaForAllocation());
    _impl_.linear_acceleration_ = p;
  }
  return _impl_.linear_acceleration_;
}
inline ::apollo::common::Point3D* LocalizationFeature::mutable_linear_acceleration() {
  ::apollo::common::Point3D* _msg = _internal_mutable_linear_acceleration();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LocalizationFeature.linear_acceleration)
  return _msg;
}
inline void LocalizationFeature::set_allocated_linear_acceleration(::apollo::common::Point3D* linear_acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_acceleration_);
  }
  if (linear_acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_acceleration));
    if (message_arena != submessage_arena) {
      linear_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_acceleration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.linear_acceleration_ = linear_acceleration;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LocalizationFeature.linear_acceleration)
}

// optional .apollo.common.Point3D angular_velocity = 6;
inline bool LocalizationFeature::_internal_has_angular_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.angular_velocity_ != nullptr);
  return value;
}
inline bool LocalizationFeature::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline const ::apollo::common::Point3D& LocalizationFeature::_internal_angular_velocity() const {
  const ::apollo::common::Point3D* p = _impl_.angular_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::Point3D&>(
      ::apollo::common::_Point3D_default_instance_);
}
inline const ::apollo::common::Point3D& LocalizationFeature::angular_velocity() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.angular_velocity)
  return _internal_angular_velocity();
}
inline void LocalizationFeature::unsafe_arena_set_allocated_angular_velocity(
    ::apollo::common::Point3D* angular_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_velocity_);
  }
  _impl_.angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.LocalizationFeature.angular_velocity)
}
inline ::apollo::common::Point3D* LocalizationFeature::release_angular_velocity() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::common::Point3D* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::Point3D* LocalizationFeature::unsafe_arena_release_angular_velocity() {
  // @@protoc_insertion_point(field_release:apollo.planning.LocalizationFeature.angular_velocity)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::common::Point3D* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
  return temp;
}
inline ::apollo::common::Point3D* LocalizationFeature::_internal_mutable_angular_velocity() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaForAllocation());
    _impl_.angular_velocity_ = p;
  }
  return _impl_.angular_velocity_;
}
inline ::apollo::common::Point3D* LocalizationFeature::mutable_angular_velocity() {
  ::apollo::common::Point3D* _msg = _internal_mutable_angular_velocity();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LocalizationFeature.angular_velocity)
  return _msg;
}
inline void LocalizationFeature::set_allocated_angular_velocity(::apollo::common::Point3D* angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angular_velocity_);
  }
  if (angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_velocity));
    if (message_arena != submessage_arena) {
      angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LocalizationFeature.angular_velocity)
}

// -------------------------------------------------------------------

// CommonPathPointFeature

// optional double x = 1;
inline bool CommonPathPointFeature::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommonPathPointFeature::has_x() const {
  return _internal_has_x();
}
inline void CommonPathPointFeature::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double CommonPathPointFeature::_internal_x() const {
  return _impl_.x_;
}
inline double CommonPathPointFeature::x() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.x)
  return _internal_x();
}
inline void CommonPathPointFeature::_internal_set_x(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}
inline void CommonPathPointFeature::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.x)
}

// optional double y = 2;
inline bool CommonPathPointFeature::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommonPathPointFeature::has_y() const {
  return _internal_has_y();
}
inline void CommonPathPointFeature::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double CommonPathPointFeature::_internal_y() const {
  return _impl_.y_;
}
inline double CommonPathPointFeature::y() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.y)
  return _internal_y();
}
inline void CommonPathPointFeature::_internal_set_y(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}
inline void CommonPathPointFeature::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.y)
}

// optional double z = 3;
inline bool CommonPathPointFeature::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommonPathPointFeature::has_z() const {
  return _internal_has_z();
}
inline void CommonPathPointFeature::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double CommonPathPointFeature::_internal_z() const {
  return _impl_.z_;
}
inline double CommonPathPointFeature::z() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.z)
  return _internal_z();
}
inline void CommonPathPointFeature::_internal_set_z(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.z_ = value;
}
inline void CommonPathPointFeature::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.z)
}

// optional double theta = 4;
inline bool CommonPathPointFeature::_internal_has_theta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommonPathPointFeature::has_theta() const {
  return _internal_has_theta();
}
inline void CommonPathPointFeature::clear_theta() {
  _impl_.theta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double CommonPathPointFeature::_internal_theta() const {
  return _impl_.theta_;
}
inline double CommonPathPointFeature::theta() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.theta)
  return _internal_theta();
}
inline void CommonPathPointFeature::_internal_set_theta(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.theta_ = value;
}
inline void CommonPathPointFeature::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.theta)
}

// optional double s = 5;
inline bool CommonPathPointFeature::_internal_has_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommonPathPointFeature::has_s() const {
  return _internal_has_s();
}
inline void CommonPathPointFeature::clear_s() {
  _impl_.s_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double CommonPathPointFeature::_internal_s() const {
  return _impl_.s_;
}
inline double CommonPathPointFeature::s() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.s)
  return _internal_s();
}
inline void CommonPathPointFeature::_internal_set_s(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.s_ = value;
}
inline void CommonPathPointFeature::set_s(double value) {
  _internal_set_s(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.s)
}

// optional string lane_id = 6;
inline bool CommonPathPointFeature::_internal_has_lane_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommonPathPointFeature::has_lane_id() const {
  return _internal_has_lane_id();
}
inline void CommonPathPointFeature::clear_lane_id() {
  _impl_.lane_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonPathPointFeature::lane_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.lane_id)
  return _internal_lane_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonPathPointFeature::set_lane_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.lane_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.lane_id)
}
inline std::string* CommonPathPointFeature::mutable_lane_id() {
  std::string* _s = _internal_mutable_lane_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.CommonPathPointFeature.lane_id)
  return _s;
}
inline const std::string& CommonPathPointFeature::_internal_lane_id() const {
  return _impl_.lane_id_.Get();
}
inline void CommonPathPointFeature::_internal_set_lane_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lane_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CommonPathPointFeature::_internal_mutable_lane_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.lane_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CommonPathPointFeature::release_lane_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.CommonPathPointFeature.lane_id)
  if (!_internal_has_lane_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.lane_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lane_id_.IsDefault()) {
    _impl_.lane_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonPathPointFeature::set_allocated_lane_id(std::string* lane_id) {
  if (lane_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lane_id_.SetAllocated(lane_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lane_id_.IsDefault()) {
    _impl_.lane_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.CommonPathPointFeature.lane_id)
}

// -------------------------------------------------------------------

// CommonTrajectoryPointFeature

// optional .apollo.planning.CommonPathPointFeature path_point = 1;
inline bool CommonTrajectoryPointFeature::_internal_has_path_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.path_point_ != nullptr);
  return value;
}
inline bool CommonTrajectoryPointFeature::has_path_point() const {
  return _internal_has_path_point();
}
inline void CommonTrajectoryPointFeature::clear_path_point() {
  if (_impl_.path_point_ != nullptr) _impl_.path_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::CommonPathPointFeature& CommonTrajectoryPointFeature::_internal_path_point() const {
  const ::apollo::planning::CommonPathPointFeature* p = _impl_.path_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::CommonPathPointFeature&>(
      ::apollo::planning::_CommonPathPointFeature_default_instance_);
}
inline const ::apollo::planning::CommonPathPointFeature& CommonTrajectoryPointFeature::path_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonTrajectoryPointFeature.path_point)
  return _internal_path_point();
}
inline void CommonTrajectoryPointFeature::unsafe_arena_set_allocated_path_point(
    ::apollo::planning::CommonPathPointFeature* path_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_point_);
  }
  _impl_.path_point_ = path_point;
  if (path_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.CommonTrajectoryPointFeature.path_point)
}
inline ::apollo::planning::CommonPathPointFeature* CommonTrajectoryPointFeature::release_path_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::CommonPathPointFeature* temp = _impl_.path_point_;
  _impl_.path_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::CommonPathPointFeature* CommonTrajectoryPointFeature::unsafe_arena_release_path_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.CommonTrajectoryPointFeature.path_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::CommonPathPointFeature* temp = _impl_.path_point_;
  _impl_.path_point_ = nullptr;
  return temp;
}
inline ::apollo::planning::CommonPathPointFeature* CommonTrajectoryPointFeature::_internal_mutable_path_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.path_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::CommonPathPointFeature>(GetArenaForAllocation());
    _impl_.path_point_ = p;
  }
  return _impl_.path_point_;
}
inline ::apollo::planning::CommonPathPointFeature* CommonTrajectoryPointFeature::mutable_path_point() {
  ::apollo::planning::CommonPathPointFeature* _msg = _internal_mutable_path_point();
  // @@protoc_insertion_point(field_mutable:apollo.planning.CommonTrajectoryPointFeature.path_point)
  return _msg;
}
inline void CommonTrajectoryPointFeature::set_allocated_path_point(::apollo::planning::CommonPathPointFeature* path_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.path_point_;
  }
  if (path_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(path_point);
    if (message_arena != submessage_arena) {
      path_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_point_ = path_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.CommonTrajectoryPointFeature.path_point)
}

// optional double v = 2;
inline bool CommonTrajectoryPointFeature::_internal_has_v() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommonTrajectoryPointFeature::has_v() const {
  return _internal_has_v();
}
inline void CommonTrajectoryPointFeature::clear_v() {
  _impl_.v_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double CommonTrajectoryPointFeature::_internal_v() const {
  return _impl_.v_;
}
inline double CommonTrajectoryPointFeature::v() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonTrajectoryPointFeature.v)
  return _internal_v();
}
inline void CommonTrajectoryPointFeature::_internal_set_v(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.v_ = value;
}
inline void CommonTrajectoryPointFeature::set_v(double value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CommonTrajectoryPointFeature.v)
}

// optional double a = 3;
inline bool CommonTrajectoryPointFeature::_internal_has_a() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommonTrajectoryPointFeature::has_a() const {
  return _internal_has_a();
}
inline void CommonTrajectoryPointFeature::clear_a() {
  _impl_.a_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double CommonTrajectoryPointFeature::_internal_a() const {
  return _impl_.a_;
}
inline double CommonTrajectoryPointFeature::a() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonTrajectoryPointFeature.a)
  return _internal_a();
}
inline void CommonTrajectoryPointFeature::_internal_set_a(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.a_ = value;
}
inline void CommonTrajectoryPointFeature::set_a(double value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CommonTrajectoryPointFeature.a)
}

// optional double relative_time = 4;
inline bool CommonTrajectoryPointFeature::_internal_has_relative_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommonTrajectoryPointFeature::has_relative_time() const {
  return _internal_has_relative_time();
}
inline void CommonTrajectoryPointFeature::clear_relative_time() {
  _impl_.relative_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double CommonTrajectoryPointFeature::_internal_relative_time() const {
  return _impl_.relative_time_;
}
inline double CommonTrajectoryPointFeature::relative_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonTrajectoryPointFeature.relative_time)
  return _internal_relative_time();
}
inline void CommonTrajectoryPointFeature::_internal_set_relative_time(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.relative_time_ = value;
}
inline void CommonTrajectoryPointFeature::set_relative_time(double value) {
  _internal_set_relative_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CommonTrajectoryPointFeature.relative_time)
}

// optional .apollo.common.GaussianInfo gaussian_info = 5;
inline bool CommonTrajectoryPointFeature::_internal_has_gaussian_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gaussian_info_ != nullptr);
  return value;
}
inline bool CommonTrajectoryPointFeature::has_gaussian_info() const {
  return _internal_has_gaussian_info();
}
inline const ::apollo::common::GaussianInfo& CommonTrajectoryPointFeature::_internal_gaussian_info() const {
  const ::apollo::common::GaussianInfo* p = _impl_.gaussian_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::GaussianInfo&>(
      ::apollo::common::_GaussianInfo_default_instance_);
}
inline const ::apollo::common::GaussianInfo& CommonTrajectoryPointFeature::gaussian_info() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonTrajectoryPointFeature.gaussian_info)
  return _internal_gaussian_info();
}
inline void CommonTrajectoryPointFeature::unsafe_arena_set_allocated_gaussian_info(
    ::apollo::common::GaussianInfo* gaussian_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gaussian_info_);
  }
  _impl_.gaussian_info_ = gaussian_info;
  if (gaussian_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.CommonTrajectoryPointFeature.gaussian_info)
}
inline ::apollo::common::GaussianInfo* CommonTrajectoryPointFeature::release_gaussian_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::GaussianInfo* temp = _impl_.gaussian_info_;
  _impl_.gaussian_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::GaussianInfo* CommonTrajectoryPointFeature::unsafe_arena_release_gaussian_info() {
  // @@protoc_insertion_point(field_release:apollo.planning.CommonTrajectoryPointFeature.gaussian_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::GaussianInfo* temp = _impl_.gaussian_info_;
  _impl_.gaussian_info_ = nullptr;
  return temp;
}
inline ::apollo::common::GaussianInfo* CommonTrajectoryPointFeature::_internal_mutable_gaussian_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.gaussian_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::GaussianInfo>(GetArenaForAllocation());
    _impl_.gaussian_info_ = p;
  }
  return _impl_.gaussian_info_;
}
inline ::apollo::common::GaussianInfo* CommonTrajectoryPointFeature::mutable_gaussian_info() {
  ::apollo::common::GaussianInfo* _msg = _internal_mutable_gaussian_info();
  // @@protoc_insertion_point(field_mutable:apollo.planning.CommonTrajectoryPointFeature.gaussian_info)
  return _msg;
}
inline void CommonTrajectoryPointFeature::set_allocated_gaussian_info(::apollo::common::GaussianInfo* gaussian_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gaussian_info_);
  }
  if (gaussian_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gaussian_info));
    if (message_arena != submessage_arena) {
      gaussian_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gaussian_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.gaussian_info_ = gaussian_info;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.CommonTrajectoryPointFeature.gaussian_info)
}

// -------------------------------------------------------------------

// TrajectoryPointFeature

// optional double timestamp_sec = 1;
inline bool TrajectoryPointFeature::_internal_has_timestamp_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrajectoryPointFeature::has_timestamp_sec() const {
  return _internal_has_timestamp_sec();
}
inline void TrajectoryPointFeature::clear_timestamp_sec() {
  _impl_.timestamp_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double TrajectoryPointFeature::_internal_timestamp_sec() const {
  return _impl_.timestamp_sec_;
}
inline double TrajectoryPointFeature::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrajectoryPointFeature.timestamp_sec)
  return _internal_timestamp_sec();
}
inline void TrajectoryPointFeature::_internal_set_timestamp_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_sec_ = value;
}
inline void TrajectoryPointFeature::set_timestamp_sec(double value) {
  _internal_set_timestamp_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrajectoryPointFeature.timestamp_sec)
}

// optional .apollo.planning.CommonTrajectoryPointFeature trajectory_point = 2;
inline bool TrajectoryPointFeature::_internal_has_trajectory_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trajectory_point_ != nullptr);
  return value;
}
inline bool TrajectoryPointFeature::has_trajectory_point() const {
  return _internal_has_trajectory_point();
}
inline void TrajectoryPointFeature::clear_trajectory_point() {
  if (_impl_.trajectory_point_ != nullptr) _impl_.trajectory_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::CommonTrajectoryPointFeature& TrajectoryPointFeature::_internal_trajectory_point() const {
  const ::apollo::planning::CommonTrajectoryPointFeature* p = _impl_.trajectory_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::CommonTrajectoryPointFeature&>(
      ::apollo::planning::_CommonTrajectoryPointFeature_default_instance_);
}
inline const ::apollo::planning::CommonTrajectoryPointFeature& TrajectoryPointFeature::trajectory_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrajectoryPointFeature.trajectory_point)
  return _internal_trajectory_point();
}
inline void TrajectoryPointFeature::unsafe_arena_set_allocated_trajectory_point(
    ::apollo::planning::CommonTrajectoryPointFeature* trajectory_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trajectory_point_);
  }
  _impl_.trajectory_point_ = trajectory_point;
  if (trajectory_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrajectoryPointFeature.trajectory_point)
}
inline ::apollo::planning::CommonTrajectoryPointFeature* TrajectoryPointFeature::release_trajectory_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::CommonTrajectoryPointFeature* temp = _impl_.trajectory_point_;
  _impl_.trajectory_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::CommonTrajectoryPointFeature* TrajectoryPointFeature::unsafe_arena_release_trajectory_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrajectoryPointFeature.trajectory_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::CommonTrajectoryPointFeature* temp = _impl_.trajectory_point_;
  _impl_.trajectory_point_ = nullptr;
  return temp;
}
inline ::apollo::planning::CommonTrajectoryPointFeature* TrajectoryPointFeature::_internal_mutable_trajectory_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.trajectory_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::CommonTrajectoryPointFeature>(GetArenaForAllocation());
    _impl_.trajectory_point_ = p;
  }
  return _impl_.trajectory_point_;
}
inline ::apollo::planning::CommonTrajectoryPointFeature* TrajectoryPointFeature::mutable_trajectory_point() {
  ::apollo::planning::CommonTrajectoryPointFeature* _msg = _internal_mutable_trajectory_point();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrajectoryPointFeature.trajectory_point)
  return _msg;
}
inline void TrajectoryPointFeature::set_allocated_trajectory_point(::apollo::planning::CommonTrajectoryPointFeature* trajectory_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trajectory_point_;
  }
  if (trajectory_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trajectory_point);
    if (message_arena != submessage_arena) {
      trajectory_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trajectory_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trajectory_point_ = trajectory_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrajectoryPointFeature.trajectory_point)
}

// -------------------------------------------------------------------

// PerceptionObstacleFeature

// optional double timestamp_sec = 1;
inline bool PerceptionObstacleFeature::_internal_has_timestamp_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PerceptionObstacleFeature::has_timestamp_sec() const {
  return _internal_has_timestamp_sec();
}
inline void PerceptionObstacleFeature::clear_timestamp_sec() {
  _impl_.timestamp_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double PerceptionObstacleFeature::_internal_timestamp_sec() const {
  return _impl_.timestamp_sec_;
}
inline double PerceptionObstacleFeature::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.timestamp_sec)
  return _internal_timestamp_sec();
}
inline void PerceptionObstacleFeature::_internal_set_timestamp_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_sec_ = value;
}
inline void PerceptionObstacleFeature::set_timestamp_sec(double value) {
  _internal_set_timestamp_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PerceptionObstacleFeature.timestamp_sec)
}

// optional .apollo.common.Point3D position = 2;
inline bool PerceptionObstacleFeature::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool PerceptionObstacleFeature::has_position() const {
  return _internal_has_position();
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::_internal_position() const {
  const ::apollo::common::Point3D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::Point3D&>(
      ::apollo::common::_Point3D_default_instance_);
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::position() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.position)
  return _internal_position();
}
inline void PerceptionObstacleFeature::unsafe_arena_set_allocated_position(
    ::apollo::common::Point3D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PerceptionObstacleFeature.position)
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::Point3D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:apollo.planning.PerceptionObstacleFeature.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::Point3D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::mutable_position() {
  ::apollo::common::Point3D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PerceptionObstacleFeature.position)
  return _msg;
}
inline void PerceptionObstacleFeature::set_allocated_position(::apollo::common::Point3D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PerceptionObstacleFeature.position)
}

// optional double theta = 3;
inline bool PerceptionObstacleFeature::_internal_has_theta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PerceptionObstacleFeature::has_theta() const {
  return _internal_has_theta();
}
inline void PerceptionObstacleFeature::clear_theta() {
  _impl_.theta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double PerceptionObstacleFeature::_internal_theta() const {
  return _impl_.theta_;
}
inline double PerceptionObstacleFeature::theta() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.theta)
  return _internal_theta();
}
inline void PerceptionObstacleFeature::_internal_set_theta(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.theta_ = value;
}
inline void PerceptionObstacleFeature::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PerceptionObstacleFeature.theta)
}

// optional .apollo.common.Point3D velocity = 4;
inline bool PerceptionObstacleFeature::_internal_has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline bool PerceptionObstacleFeature::has_velocity() const {
  return _internal_has_velocity();
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::_internal_velocity() const {
  const ::apollo::common::Point3D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::Point3D&>(
      ::apollo::common::_Point3D_default_instance_);
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::velocity() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.velocity)
  return _internal_velocity();
}
inline void PerceptionObstacleFeature::unsafe_arena_set_allocated_velocity(
    ::apollo::common::Point3D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PerceptionObstacleFeature.velocity)
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::Point3D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:apollo.planning.PerceptionObstacleFeature.velocity)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::Point3D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::mutable_velocity() {
  ::apollo::common::Point3D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PerceptionObstacleFeature.velocity)
  return _msg;
}
inline void PerceptionObstacleFeature::set_allocated_velocity(::apollo::common::Point3D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity));
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PerceptionObstacleFeature.velocity)
}

// optional .apollo.common.Point3D acceleration = 5;
inline bool PerceptionObstacleFeature::_internal_has_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceleration_ != nullptr);
  return value;
}
inline bool PerceptionObstacleFeature::has_acceleration() const {
  return _internal_has_acceleration();
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::_internal_acceleration() const {
  const ::apollo::common::Point3D* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::Point3D&>(
      ::apollo::common::_Point3D_default_instance_);
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::acceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.acceleration)
  return _internal_acceleration();
}
inline void PerceptionObstacleFeature::unsafe_arena_set_allocated_acceleration(
    ::apollo::common::Point3D* acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = acceleration;
  if (acceleration) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PerceptionObstacleFeature.acceleration)
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::release_acceleration() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::common::Point3D* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:apollo.planning.PerceptionObstacleFeature.acceleration)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::common::Point3D* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::_internal_mutable_acceleration() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaForAllocation());
    _impl_.acceleration_ = p;
  }
  return _impl_.acceleration_;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::mutable_acceleration() {
  ::apollo::common::Point3D* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PerceptionObstacleFeature.acceleration)
  return _msg;
}
inline void PerceptionObstacleFeature::set_allocated_acceleration(::apollo::common::Point3D* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acceleration_);
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration));
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PerceptionObstacleFeature.acceleration)
}

// repeated .apollo.common.Point3D polygon_point = 6;
inline int PerceptionObstacleFeature::_internal_polygon_point_size() const {
  return _impl_.polygon_point_.size();
}
inline int PerceptionObstacleFeature::polygon_point_size() const {
  return _internal_polygon_point_size();
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::mutable_polygon_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PerceptionObstacleFeature.polygon_point)
  return _impl_.polygon_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::common::Point3D >*
PerceptionObstacleFeature::mutable_polygon_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PerceptionObstacleFeature.polygon_point)
  return &_impl_.polygon_point_;
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::_internal_polygon_point(int index) const {
  return _impl_.polygon_point_.Get(index);
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::polygon_point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.polygon_point)
  return _internal_polygon_point(index);
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::_internal_add_polygon_point() {
  return _impl_.polygon_point_.Add();
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::add_polygon_point() {
  ::apollo::common::Point3D* _add = _internal_add_polygon_point();
  // @@protoc_insertion_point(field_add:apollo.planning.PerceptionObstacleFeature.polygon_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::common::Point3D >&
PerceptionObstacleFeature::polygon_point() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PerceptionObstacleFeature.polygon_point)
  return _impl_.polygon_point_;
}

// -------------------------------------------------------------------

// ObstacleTrajectoryFeature

// repeated .apollo.planning.PerceptionObstacleFeature perception_obstacle_history = 1;
inline int ObstacleTrajectoryFeature::_internal_perception_obstacle_history_size() const {
  return _impl_.perception_obstacle_history_.size();
}
inline int ObstacleTrajectoryFeature::perception_obstacle_history_size() const {
  return _internal_perception_obstacle_history_size();
}
inline void ObstacleTrajectoryFeature::clear_perception_obstacle_history() {
  _impl_.perception_obstacle_history_.Clear();
}
inline ::apollo::planning::PerceptionObstacleFeature* ObstacleTrajectoryFeature::mutable_perception_obstacle_history(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return _impl_.perception_obstacle_history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::PerceptionObstacleFeature >*
ObstacleTrajectoryFeature::mutable_perception_obstacle_history() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return &_impl_.perception_obstacle_history_;
}
inline const ::apollo::planning::PerceptionObstacleFeature& ObstacleTrajectoryFeature::_internal_perception_obstacle_history(int index) const {
  return _impl_.perception_obstacle_history_.Get(index);
}
inline const ::apollo::planning::PerceptionObstacleFeature& ObstacleTrajectoryFeature::perception_obstacle_history(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return _internal_perception_obstacle_history(index);
}
inline ::apollo::planning::PerceptionObstacleFeature* ObstacleTrajectoryFeature::_internal_add_perception_obstacle_history() {
  return _impl_.perception_obstacle_history_.Add();
}
inline ::apollo::planning::PerceptionObstacleFeature* ObstacleTrajectoryFeature::add_perception_obstacle_history() {
  ::apollo::planning::PerceptionObstacleFeature* _add = _internal_add_perception_obstacle_history();
  // @@protoc_insertion_point(field_add:apollo.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::PerceptionObstacleFeature >&
ObstacleTrajectoryFeature::perception_obstacle_history() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return _impl_.perception_obstacle_history_;
}

// repeated .apollo.planning.TrajectoryPointFeature evaluated_trajectory_point = 2;
inline int ObstacleTrajectoryFeature::_internal_evaluated_trajectory_point_size() const {
  return _impl_.evaluated_trajectory_point_.size();
}
inline int ObstacleTrajectoryFeature::evaluated_trajectory_point_size() const {
  return _internal_evaluated_trajectory_point_size();
}
inline void ObstacleTrajectoryFeature::clear_evaluated_trajectory_point() {
  _impl_.evaluated_trajectory_point_.Clear();
}
inline ::apollo::planning::TrajectoryPointFeature* ObstacleTrajectoryFeature::mutable_evaluated_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return _impl_.evaluated_trajectory_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
ObstacleTrajectoryFeature::mutable_evaluated_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return &_impl_.evaluated_trajectory_point_;
}
inline const ::apollo::planning::TrajectoryPointFeature& ObstacleTrajectoryFeature::_internal_evaluated_trajectory_point(int index) const {
  return _impl_.evaluated_trajectory_point_.Get(index);
}
inline const ::apollo::planning::TrajectoryPointFeature& ObstacleTrajectoryFeature::evaluated_trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return _internal_evaluated_trajectory_point(index);
}
inline ::apollo::planning::TrajectoryPointFeature* ObstacleTrajectoryFeature::_internal_add_evaluated_trajectory_point() {
  return _impl_.evaluated_trajectory_point_.Add();
}
inline ::apollo::planning::TrajectoryPointFeature* ObstacleTrajectoryFeature::add_evaluated_trajectory_point() {
  ::apollo::planning::TrajectoryPointFeature* _add = _internal_add_evaluated_trajectory_point();
  // @@protoc_insertion_point(field_add:apollo.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
ObstacleTrajectoryFeature::evaluated_trajectory_point() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return _impl_.evaluated_trajectory_point_;
}

// -------------------------------------------------------------------

// PredictionTrajectoryFeature

// optional double probability = 1;
inline bool PredictionTrajectoryFeature::_internal_has_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PredictionTrajectoryFeature::has_probability() const {
  return _internal_has_probability();
}
inline void PredictionTrajectoryFeature::clear_probability() {
  _impl_.probability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double PredictionTrajectoryFeature::_internal_probability() const {
  return _impl_.probability_;
}
inline double PredictionTrajectoryFeature::probability() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionTrajectoryFeature.probability)
  return _internal_probability();
}
inline void PredictionTrajectoryFeature::_internal_set_probability(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.probability_ = value;
}
inline void PredictionTrajectoryFeature::set_probability(double value) {
  _internal_set_probability(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PredictionTrajectoryFeature.probability)
}

// repeated .apollo.planning.TrajectoryPointFeature trajectory_point = 2;
inline int PredictionTrajectoryFeature::_internal_trajectory_point_size() const {
  return _impl_.trajectory_point_.size();
}
inline int PredictionTrajectoryFeature::trajectory_point_size() const {
  return _internal_trajectory_point_size();
}
inline void PredictionTrajectoryFeature::clear_trajectory_point() {
  _impl_.trajectory_point_.Clear();
}
inline ::apollo::planning::TrajectoryPointFeature* PredictionTrajectoryFeature::mutable_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PredictionTrajectoryFeature.trajectory_point)
  return _impl_.trajectory_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
PredictionTrajectoryFeature::mutable_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PredictionTrajectoryFeature.trajectory_point)
  return &_impl_.trajectory_point_;
}
inline const ::apollo::planning::TrajectoryPointFeature& PredictionTrajectoryFeature::_internal_trajectory_point(int index) const {
  return _impl_.trajectory_point_.Get(index);
}
inline const ::apollo::planning::TrajectoryPointFeature& PredictionTrajectoryFeature::trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionTrajectoryFeature.trajectory_point)
  return _internal_trajectory_point(index);
}
inline ::apollo::planning::TrajectoryPointFeature* PredictionTrajectoryFeature::_internal_add_trajectory_point() {
  return _impl_.trajectory_point_.Add();
}
inline ::apollo::planning::TrajectoryPointFeature* PredictionTrajectoryFeature::add_trajectory_point() {
  ::apollo::planning::TrajectoryPointFeature* _add = _internal_add_trajectory_point();
  // @@protoc_insertion_point(field_add:apollo.planning.PredictionTrajectoryFeature.trajectory_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
PredictionTrajectoryFeature::trajectory_point() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PredictionTrajectoryFeature.trajectory_point)
  return _impl_.trajectory_point_;
}

// -------------------------------------------------------------------

// PredictionObstacleFeature

// optional double timestamp_sec = 1;
inline bool PredictionObstacleFeature::_internal_has_timestamp_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PredictionObstacleFeature::has_timestamp_sec() const {
  return _internal_has_timestamp_sec();
}
inline void PredictionObstacleFeature::clear_timestamp_sec() {
  _impl_.timestamp_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double PredictionObstacleFeature::_internal_timestamp_sec() const {
  return _impl_.timestamp_sec_;
}
inline double PredictionObstacleFeature::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.timestamp_sec)
  return _internal_timestamp_sec();
}
inline void PredictionObstacleFeature::_internal_set_timestamp_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_sec_ = value;
}
inline void PredictionObstacleFeature::set_timestamp_sec(double value) {
  _internal_set_timestamp_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PredictionObstacleFeature.timestamp_sec)
}

// optional double predicted_period = 2;
inline bool PredictionObstacleFeature::_internal_has_predicted_period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PredictionObstacleFeature::has_predicted_period() const {
  return _internal_has_predicted_period();
}
inline void PredictionObstacleFeature::clear_predicted_period() {
  _impl_.predicted_period_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double PredictionObstacleFeature::_internal_predicted_period() const {
  return _impl_.predicted_period_;
}
inline double PredictionObstacleFeature::predicted_period() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.predicted_period)
  return _internal_predicted_period();
}
inline void PredictionObstacleFeature::_internal_set_predicted_period(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.predicted_period_ = value;
}
inline void PredictionObstacleFeature::set_predicted_period(double value) {
  _internal_set_predicted_period(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PredictionObstacleFeature.predicted_period)
}

// optional .apollo.prediction.ObstacleIntent intent = 3;
inline bool PredictionObstacleFeature::_internal_has_intent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.intent_ != nullptr);
  return value;
}
inline bool PredictionObstacleFeature::has_intent() const {
  return _internal_has_intent();
}
inline const ::apollo::prediction::ObstacleIntent& PredictionObstacleFeature::_internal_intent() const {
  const ::apollo::prediction::ObstacleIntent* p = _impl_.intent_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::prediction::ObstacleIntent&>(
      ::apollo::prediction::_ObstacleIntent_default_instance_);
}
inline const ::apollo::prediction::ObstacleIntent& PredictionObstacleFeature::intent() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.intent)
  return _internal_intent();
}
inline void PredictionObstacleFeature::unsafe_arena_set_allocated_intent(
    ::apollo::prediction::ObstacleIntent* intent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intent_);
  }
  _impl_.intent_ = intent;
  if (intent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PredictionObstacleFeature.intent)
}
inline ::apollo::prediction::ObstacleIntent* PredictionObstacleFeature::release_intent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::prediction::ObstacleIntent* temp = _impl_.intent_;
  _impl_.intent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::prediction::ObstacleIntent* PredictionObstacleFeature::unsafe_arena_release_intent() {
  // @@protoc_insertion_point(field_release:apollo.planning.PredictionObstacleFeature.intent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::prediction::ObstacleIntent* temp = _impl_.intent_;
  _impl_.intent_ = nullptr;
  return temp;
}
inline ::apollo::prediction::ObstacleIntent* PredictionObstacleFeature::_internal_mutable_intent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.intent_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::prediction::ObstacleIntent>(GetArenaForAllocation());
    _impl_.intent_ = p;
  }
  return _impl_.intent_;
}
inline ::apollo::prediction::ObstacleIntent* PredictionObstacleFeature::mutable_intent() {
  ::apollo::prediction::ObstacleIntent* _msg = _internal_mutable_intent();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PredictionObstacleFeature.intent)
  return _msg;
}
inline void PredictionObstacleFeature::set_allocated_intent(::apollo::prediction::ObstacleIntent* intent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intent_);
  }
  if (intent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(intent));
    if (message_arena != submessage_arena) {
      intent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.intent_ = intent;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PredictionObstacleFeature.intent)
}

// optional .apollo.prediction.ObstaclePriority priority = 4;
inline bool PredictionObstacleFeature::_internal_has_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.priority_ != nullptr);
  return value;
}
inline bool PredictionObstacleFeature::has_priority() const {
  return _internal_has_priority();
}
inline const ::apollo::prediction::ObstaclePriority& PredictionObstacleFeature::_internal_priority() const {
  const ::apollo::prediction::ObstaclePriority* p = _impl_.priority_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::prediction::ObstaclePriority&>(
      ::apollo::prediction::_ObstaclePriority_default_instance_);
}
inline const ::apollo::prediction::ObstaclePriority& PredictionObstacleFeature::priority() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.priority)
  return _internal_priority();
}
inline void PredictionObstacleFeature::unsafe_arena_set_allocated_priority(
    ::apollo::prediction::ObstaclePriority* priority) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.priority_);
  }
  _impl_.priority_ = priority;
  if (priority) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PredictionObstacleFeature.priority)
}
inline ::apollo::prediction::ObstaclePriority* PredictionObstacleFeature::release_priority() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::prediction::ObstaclePriority* temp = _impl_.priority_;
  _impl_.priority_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::prediction::ObstaclePriority* PredictionObstacleFeature::unsafe_arena_release_priority() {
  // @@protoc_insertion_point(field_release:apollo.planning.PredictionObstacleFeature.priority)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::prediction::ObstaclePriority* temp = _impl_.priority_;
  _impl_.priority_ = nullptr;
  return temp;
}
inline ::apollo::prediction::ObstaclePriority* PredictionObstacleFeature::_internal_mutable_priority() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.priority_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::prediction::ObstaclePriority>(GetArenaForAllocation());
    _impl_.priority_ = p;
  }
  return _impl_.priority_;
}
inline ::apollo::prediction::ObstaclePriority* PredictionObstacleFeature::mutable_priority() {
  ::apollo::prediction::ObstaclePriority* _msg = _internal_mutable_priority();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PredictionObstacleFeature.priority)
  return _msg;
}
inline void PredictionObstacleFeature::set_allocated_priority(::apollo::prediction::ObstaclePriority* priority) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.priority_);
  }
  if (priority) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(priority));
    if (message_arena != submessage_arena) {
      priority = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, priority, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.priority_ = priority;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PredictionObstacleFeature.priority)
}

// optional bool is_static = 5 [default = false];
inline bool PredictionObstacleFeature::_internal_has_is_static() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PredictionObstacleFeature::has_is_static() const {
  return _internal_has_is_static();
}
inline void PredictionObstacleFeature::clear_is_static() {
  _impl_.is_static_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool PredictionObstacleFeature::_internal_is_static() const {
  return _impl_.is_static_;
}
inline bool PredictionObstacleFeature::is_static() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.is_static)
  return _internal_is_static();
}
inline void PredictionObstacleFeature::_internal_set_is_static(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_static_ = value;
}
inline void PredictionObstacleFeature::set_is_static(bool value) {
  _internal_set_is_static(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PredictionObstacleFeature.is_static)
}

// repeated .apollo.planning.PredictionTrajectoryFeature trajectory = 6;
inline int PredictionObstacleFeature::_internal_trajectory_size() const {
  return _impl_.trajectory_.size();
}
inline int PredictionObstacleFeature::trajectory_size() const {
  return _internal_trajectory_size();
}
inline void PredictionObstacleFeature::clear_trajectory() {
  _impl_.trajectory_.Clear();
}
inline ::apollo::planning::PredictionTrajectoryFeature* PredictionObstacleFeature::mutable_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PredictionObstacleFeature.trajectory)
  return _impl_.trajectory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::PredictionTrajectoryFeature >*
PredictionObstacleFeature::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PredictionObstacleFeature.trajectory)
  return &_impl_.trajectory_;
}
inline const ::apollo::planning::PredictionTrajectoryFeature& PredictionObstacleFeature::_internal_trajectory(int index) const {
  return _impl_.trajectory_.Get(index);
}
inline const ::apollo::planning::PredictionTrajectoryFeature& PredictionObstacleFeature::trajectory(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.trajectory)
  return _internal_trajectory(index);
}
inline ::apollo::planning::PredictionTrajectoryFeature* PredictionObstacleFeature::_internal_add_trajectory() {
  return _impl_.trajectory_.Add();
}
inline ::apollo::planning::PredictionTrajectoryFeature* PredictionObstacleFeature::add_trajectory() {
  ::apollo::planning::PredictionTrajectoryFeature* _add = _internal_add_trajectory();
  // @@protoc_insertion_point(field_add:apollo.planning.PredictionObstacleFeature.trajectory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::PredictionTrajectoryFeature >&
PredictionObstacleFeature::trajectory() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PredictionObstacleFeature.trajectory)
  return _impl_.trajectory_;
}

// -------------------------------------------------------------------

// ObstacleFeature

// optional int32 id = 1;
inline bool ObstacleFeature::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ObstacleFeature::has_id() const {
  return _internal_has_id();
}
inline void ObstacleFeature::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t ObstacleFeature::_internal_id() const {
  return _impl_.id_;
}
inline int32_t ObstacleFeature::id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.id)
  return _internal_id();
}
inline void ObstacleFeature::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.id_ = value;
}
inline void ObstacleFeature::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ObstacleFeature.id)
}

// optional double length = 2;
inline bool ObstacleFeature::_internal_has_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ObstacleFeature::has_length() const {
  return _internal_has_length();
}
inline void ObstacleFeature::clear_length() {
  _impl_.length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ObstacleFeature::_internal_length() const {
  return _impl_.length_;
}
inline double ObstacleFeature::length() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.length)
  return _internal_length();
}
inline void ObstacleFeature::_internal_set_length(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.length_ = value;
}
inline void ObstacleFeature::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ObstacleFeature.length)
}

// optional double width = 3;
inline bool ObstacleFeature::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ObstacleFeature::has_width() const {
  return _internal_has_width();
}
inline void ObstacleFeature::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ObstacleFeature::_internal_width() const {
  return _impl_.width_;
}
inline double ObstacleFeature::width() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.width)
  return _internal_width();
}
inline void ObstacleFeature::_internal_set_width(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.width_ = value;
}
inline void ObstacleFeature::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ObstacleFeature.width)
}

// optional double height = 4;
inline bool ObstacleFeature::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ObstacleFeature::has_height() const {
  return _internal_has_height();
}
inline void ObstacleFeature::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double ObstacleFeature::_internal_height() const {
  return _impl_.height_;
}
inline double ObstacleFeature::height() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.height)
  return _internal_height();
}
inline void ObstacleFeature::_internal_set_height(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.height_ = value;
}
inline void ObstacleFeature::set_height(double value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ObstacleFeature.height)
}

// optional .apollo.perception.PerceptionObstacle.Type type = 5;
inline bool ObstacleFeature::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ObstacleFeature::has_type() const {
  return _internal_has_type();
}
inline void ObstacleFeature::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::apollo::perception::PerceptionObstacle_Type ObstacleFeature::_internal_type() const {
  return static_cast< ::apollo::perception::PerceptionObstacle_Type >(_impl_.type_);
}
inline ::apollo::perception::PerceptionObstacle_Type ObstacleFeature::type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.type)
  return _internal_type();
}
inline void ObstacleFeature::_internal_set_type(::apollo::perception::PerceptionObstacle_Type value) {
  assert(::apollo::perception::PerceptionObstacle_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.type_ = value;
}
inline void ObstacleFeature::set_type(::apollo::perception::PerceptionObstacle_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ObstacleFeature.type)
}

// optional .apollo.planning.ObstacleTrajectoryFeature obstacle_trajectory = 6;
inline bool ObstacleFeature::_internal_has_obstacle_trajectory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obstacle_trajectory_ != nullptr);
  return value;
}
inline bool ObstacleFeature::has_obstacle_trajectory() const {
  return _internal_has_obstacle_trajectory();
}
inline void ObstacleFeature::clear_obstacle_trajectory() {
  if (_impl_.obstacle_trajectory_ != nullptr) _impl_.obstacle_trajectory_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::ObstacleTrajectoryFeature& ObstacleFeature::_internal_obstacle_trajectory() const {
  const ::apollo::planning::ObstacleTrajectoryFeature* p = _impl_.obstacle_trajectory_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::ObstacleTrajectoryFeature&>(
      ::apollo::planning::_ObstacleTrajectoryFeature_default_instance_);
}
inline const ::apollo::planning::ObstacleTrajectoryFeature& ObstacleFeature::obstacle_trajectory() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.obstacle_trajectory)
  return _internal_obstacle_trajectory();
}
inline void ObstacleFeature::unsafe_arena_set_allocated_obstacle_trajectory(
    ::apollo::planning::ObstacleTrajectoryFeature* obstacle_trajectory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obstacle_trajectory_);
  }
  _impl_.obstacle_trajectory_ = obstacle_trajectory;
  if (obstacle_trajectory) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.ObstacleFeature.obstacle_trajectory)
}
inline ::apollo::planning::ObstacleTrajectoryFeature* ObstacleFeature::release_obstacle_trajectory() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::ObstacleTrajectoryFeature* temp = _impl_.obstacle_trajectory_;
  _impl_.obstacle_trajectory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::ObstacleTrajectoryFeature* ObstacleFeature::unsafe_arena_release_obstacle_trajectory() {
  // @@protoc_insertion_point(field_release:apollo.planning.ObstacleFeature.obstacle_trajectory)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::ObstacleTrajectoryFeature* temp = _impl_.obstacle_trajectory_;
  _impl_.obstacle_trajectory_ = nullptr;
  return temp;
}
inline ::apollo::planning::ObstacleTrajectoryFeature* ObstacleFeature::_internal_mutable_obstacle_trajectory() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.obstacle_trajectory_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ObstacleTrajectoryFeature>(GetArenaForAllocation());
    _impl_.obstacle_trajectory_ = p;
  }
  return _impl_.obstacle_trajectory_;
}
inline ::apollo::planning::ObstacleTrajectoryFeature* ObstacleFeature::mutable_obstacle_trajectory() {
  ::apollo::planning::ObstacleTrajectoryFeature* _msg = _internal_mutable_obstacle_trajectory();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ObstacleFeature.obstacle_trajectory)
  return _msg;
}
inline void ObstacleFeature::set_allocated_obstacle_trajectory(::apollo::planning::ObstacleTrajectoryFeature* obstacle_trajectory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obstacle_trajectory_;
  }
  if (obstacle_trajectory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obstacle_trajectory);
    if (message_arena != submessage_arena) {
      obstacle_trajectory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obstacle_trajectory, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.obstacle_trajectory_ = obstacle_trajectory;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ObstacleFeature.obstacle_trajectory)
}

// optional .apollo.planning.PredictionObstacleFeature obstacle_prediction = 7;
inline bool ObstacleFeature::_internal_has_obstacle_prediction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obstacle_prediction_ != nullptr);
  return value;
}
inline bool ObstacleFeature::has_obstacle_prediction() const {
  return _internal_has_obstacle_prediction();
}
inline void ObstacleFeature::clear_obstacle_prediction() {
  if (_impl_.obstacle_prediction_ != nullptr) _impl_.obstacle_prediction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::planning::PredictionObstacleFeature& ObstacleFeature::_internal_obstacle_prediction() const {
  const ::apollo::planning::PredictionObstacleFeature* p = _impl_.obstacle_prediction_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::PredictionObstacleFeature&>(
      ::apollo::planning::_PredictionObstacleFeature_default_instance_);
}
inline const ::apollo::planning::PredictionObstacleFeature& ObstacleFeature::obstacle_prediction() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.obstacle_prediction)
  return _internal_obstacle_prediction();
}
inline void ObstacleFeature::unsafe_arena_set_allocated_obstacle_prediction(
    ::apollo::planning::PredictionObstacleFeature* obstacle_prediction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obstacle_prediction_);
  }
  _impl_.obstacle_prediction_ = obstacle_prediction;
  if (obstacle_prediction) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.ObstacleFeature.obstacle_prediction)
}
inline ::apollo::planning::PredictionObstacleFeature* ObstacleFeature::release_obstacle_prediction() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::PredictionObstacleFeature* temp = _impl_.obstacle_prediction_;
  _impl_.obstacle_prediction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::PredictionObstacleFeature* ObstacleFeature::unsafe_arena_release_obstacle_prediction() {
  // @@protoc_insertion_point(field_release:apollo.planning.ObstacleFeature.obstacle_prediction)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::PredictionObstacleFeature* temp = _impl_.obstacle_prediction_;
  _impl_.obstacle_prediction_ = nullptr;
  return temp;
}
inline ::apollo::planning::PredictionObstacleFeature* ObstacleFeature::_internal_mutable_obstacle_prediction() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.obstacle_prediction_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::PredictionObstacleFeature>(GetArenaForAllocation());
    _impl_.obstacle_prediction_ = p;
  }
  return _impl_.obstacle_prediction_;
}
inline ::apollo::planning::PredictionObstacleFeature* ObstacleFeature::mutable_obstacle_prediction() {
  ::apollo::planning::PredictionObstacleFeature* _msg = _internal_mutable_obstacle_prediction();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ObstacleFeature.obstacle_prediction)
  return _msg;
}
inline void ObstacleFeature::set_allocated_obstacle_prediction(::apollo::planning::PredictionObstacleFeature* obstacle_prediction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obstacle_prediction_;
  }
  if (obstacle_prediction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obstacle_prediction);
    if (message_arena != submessage_arena) {
      obstacle_prediction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obstacle_prediction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.obstacle_prediction_ = obstacle_prediction;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ObstacleFeature.obstacle_prediction)
}

// -------------------------------------------------------------------

// RoutingResponseFeature

// repeated .apollo.routing.RoadSegment road = 1;
inline int RoutingResponseFeature::_internal_road_size() const {
  return _impl_.road_.size();
}
inline int RoutingResponseFeature::road_size() const {
  return _internal_road_size();
}
inline ::apollo::routing::RoadSegment* RoutingResponseFeature::mutable_road(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.RoutingResponseFeature.road)
  return _impl_.road_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::routing::RoadSegment >*
RoutingResponseFeature::mutable_road() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.RoutingResponseFeature.road)
  return &_impl_.road_;
}
inline const ::apollo::routing::RoadSegment& RoutingResponseFeature::_internal_road(int index) const {
  return _impl_.road_.Get(index);
}
inline const ::apollo::routing::RoadSegment& RoutingResponseFeature::road(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.RoutingResponseFeature.road)
  return _internal_road(index);
}
inline ::apollo::routing::RoadSegment* RoutingResponseFeature::_internal_add_road() {
  return _impl_.road_.Add();
}
inline ::apollo::routing::RoadSegment* RoutingResponseFeature::add_road() {
  ::apollo::routing::RoadSegment* _add = _internal_add_road();
  // @@protoc_insertion_point(field_add:apollo.planning.RoutingResponseFeature.road)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::routing::RoadSegment >&
RoutingResponseFeature::road() const {
  // @@protoc_insertion_point(field_list:apollo.planning.RoutingResponseFeature.road)
  return _impl_.road_;
}

// optional .apollo.routing.Measurement measurement = 2;
inline bool RoutingResponseFeature::_internal_has_measurement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.measurement_ != nullptr);
  return value;
}
inline bool RoutingResponseFeature::has_measurement() const {
  return _internal_has_measurement();
}
inline const ::apollo::routing::Measurement& RoutingResponseFeature::_internal_measurement() const {
  const ::apollo::routing::Measurement* p = _impl_.measurement_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::routing::Measurement&>(
      ::apollo::routing::_Measurement_default_instance_);
}
inline const ::apollo::routing::Measurement& RoutingResponseFeature::measurement() const {
  // @@protoc_insertion_point(field_get:apollo.planning.RoutingResponseFeature.measurement)
  return _internal_measurement();
}
inline void RoutingResponseFeature::unsafe_arena_set_allocated_measurement(
    ::apollo::routing::Measurement* measurement) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.measurement_);
  }
  _impl_.measurement_ = measurement;
  if (measurement) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.RoutingResponseFeature.measurement)
}
inline ::apollo::routing::Measurement* RoutingResponseFeature::release_measurement() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::routing::Measurement* temp = _impl_.measurement_;
  _impl_.measurement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::routing::Measurement* RoutingResponseFeature::unsafe_arena_release_measurement() {
  // @@protoc_insertion_point(field_release:apollo.planning.RoutingResponseFeature.measurement)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::routing::Measurement* temp = _impl_.measurement_;
  _impl_.measurement_ = nullptr;
  return temp;
}
inline ::apollo::routing::Measurement* RoutingResponseFeature::_internal_mutable_measurement() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.measurement_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::routing::Measurement>(GetArenaForAllocation());
    _impl_.measurement_ = p;
  }
  return _impl_.measurement_;
}
inline ::apollo::routing::Measurement* RoutingResponseFeature::mutable_measurement() {
  ::apollo::routing::Measurement* _msg = _internal_mutable_measurement();
  // @@protoc_insertion_point(field_mutable:apollo.planning.RoutingResponseFeature.measurement)
  return _msg;
}
inline void RoutingResponseFeature::set_allocated_measurement(::apollo::routing::Measurement* measurement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.measurement_);
  }
  if (measurement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(measurement));
    if (message_arena != submessage_arena) {
      measurement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, measurement, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.measurement_ = measurement;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.RoutingResponseFeature.measurement)
}

// -------------------------------------------------------------------

// RoutingFeature

// optional .apollo.planning.RoutingResponseFeature routing_response = 1;
inline bool RoutingFeature::_internal_has_routing_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.routing_response_ != nullptr);
  return value;
}
inline bool RoutingFeature::has_routing_response() const {
  return _internal_has_routing_response();
}
inline void RoutingFeature::clear_routing_response() {
  if (_impl_.routing_response_ != nullptr) _impl_.routing_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::RoutingResponseFeature& RoutingFeature::_internal_routing_response() const {
  const ::apollo::planning::RoutingResponseFeature* p = _impl_.routing_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::RoutingResponseFeature&>(
      ::apollo::planning::_RoutingResponseFeature_default_instance_);
}
inline const ::apollo::planning::RoutingResponseFeature& RoutingFeature::routing_response() const {
  // @@protoc_insertion_point(field_get:apollo.planning.RoutingFeature.routing_response)
  return _internal_routing_response();
}
inline void RoutingFeature::unsafe_arena_set_allocated_routing_response(
    ::apollo::planning::RoutingResponseFeature* routing_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.routing_response_);
  }
  _impl_.routing_response_ = routing_response;
  if (routing_response) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.RoutingFeature.routing_response)
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::release_routing_response() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::RoutingResponseFeature* temp = _impl_.routing_response_;
  _impl_.routing_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::unsafe_arena_release_routing_response() {
  // @@protoc_insertion_point(field_release:apollo.planning.RoutingFeature.routing_response)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::RoutingResponseFeature* temp = _impl_.routing_response_;
  _impl_.routing_response_ = nullptr;
  return temp;
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::_internal_mutable_routing_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.routing_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::RoutingResponseFeature>(GetArenaForAllocation());
    _impl_.routing_response_ = p;
  }
  return _impl_.routing_response_;
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::mutable_routing_response() {
  ::apollo::planning::RoutingResponseFeature* _msg = _internal_mutable_routing_response();
  // @@protoc_insertion_point(field_mutable:apollo.planning.RoutingFeature.routing_response)
  return _msg;
}
inline void RoutingFeature::set_allocated_routing_response(::apollo::planning::RoutingResponseFeature* routing_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.routing_response_;
  }
  if (routing_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(routing_response);
    if (message_arena != submessage_arena) {
      routing_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.routing_response_ = routing_response;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.RoutingFeature.routing_response)
}

// repeated string local_routing_lane_id = 2;
inline int RoutingFeature::_internal_local_routing_lane_id_size() const {
  return _impl_.local_routing_lane_id_.size();
}
inline int RoutingFeature::local_routing_lane_id_size() const {
  return _internal_local_routing_lane_id_size();
}
inline void RoutingFeature::clear_local_routing_lane_id() {
  _impl_.local_routing_lane_id_.Clear();
}
inline std::string* RoutingFeature::add_local_routing_lane_id() {
  std::string* _s = _internal_add_local_routing_lane_id();
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.RoutingFeature.local_routing_lane_id)
  return _s;
}
inline const std::string& RoutingFeature::_internal_local_routing_lane_id(int index) const {
  return _impl_.local_routing_lane_id_.Get(index);
}
inline const std::string& RoutingFeature::local_routing_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.RoutingFeature.local_routing_lane_id)
  return _internal_local_routing_lane_id(index);
}
inline std::string* RoutingFeature::mutable_local_routing_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.RoutingFeature.local_routing_lane_id)
  return _impl_.local_routing_lane_id_.Mutable(index);
}
inline void RoutingFeature::set_local_routing_lane_id(int index, const std::string& value) {
  _impl_.local_routing_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline void RoutingFeature::set_local_routing_lane_id(int index, std::string&& value) {
  _impl_.local_routing_lane_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline void RoutingFeature::set_local_routing_lane_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.local_routing_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline void RoutingFeature::set_local_routing_lane_id(int index, const char* value, size_t size) {
  _impl_.local_routing_lane_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline std::string* RoutingFeature::_internal_add_local_routing_lane_id() {
  return _impl_.local_routing_lane_id_.Add();
}
inline void RoutingFeature::add_local_routing_lane_id(const std::string& value) {
  _impl_.local_routing_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline void RoutingFeature::add_local_routing_lane_id(std::string&& value) {
  _impl_.local_routing_lane_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline void RoutingFeature::add_local_routing_lane_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.local_routing_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline void RoutingFeature::add_local_routing_lane_id(const char* value, size_t size) {
  _impl_.local_routing_lane_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RoutingFeature::local_routing_lane_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.RoutingFeature.local_routing_lane_id)
  return _impl_.local_routing_lane_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RoutingFeature::mutable_local_routing_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.RoutingFeature.local_routing_lane_id)
  return &_impl_.local_routing_lane_id_;
}

// optional .apollo.planning.RoutingResponseFeature local_routing = 3;
inline bool RoutingFeature::_internal_has_local_routing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.local_routing_ != nullptr);
  return value;
}
inline bool RoutingFeature::has_local_routing() const {
  return _internal_has_local_routing();
}
inline void RoutingFeature::clear_local_routing() {
  if (_impl_.local_routing_ != nullptr) _impl_.local_routing_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::planning::RoutingResponseFeature& RoutingFeature::_internal_local_routing() const {
  const ::apollo::planning::RoutingResponseFeature* p = _impl_.local_routing_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::RoutingResponseFeature&>(
      ::apollo::planning::_RoutingResponseFeature_default_instance_);
}
inline const ::apollo::planning::RoutingResponseFeature& RoutingFeature::local_routing() const {
  // @@protoc_insertion_point(field_get:apollo.planning.RoutingFeature.local_routing)
  return _internal_local_routing();
}
inline void RoutingFeature::unsafe_arena_set_allocated_local_routing(
    ::apollo::planning::RoutingResponseFeature* local_routing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_routing_);
  }
  _impl_.local_routing_ = local_routing;
  if (local_routing) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.RoutingFeature.local_routing)
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::release_local_routing() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::RoutingResponseFeature* temp = _impl_.local_routing_;
  _impl_.local_routing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::unsafe_arena_release_local_routing() {
  // @@protoc_insertion_point(field_release:apollo.planning.RoutingFeature.local_routing)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::RoutingResponseFeature* temp = _impl_.local_routing_;
  _impl_.local_routing_ = nullptr;
  return temp;
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::_internal_mutable_local_routing() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.local_routing_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::RoutingResponseFeature>(GetArenaForAllocation());
    _impl_.local_routing_ = p;
  }
  return _impl_.local_routing_;
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::mutable_local_routing() {
  ::apollo::planning::RoutingResponseFeature* _msg = _internal_mutable_local_routing();
  // @@protoc_insertion_point(field_mutable:apollo.planning.RoutingFeature.local_routing)
  return _msg;
}
inline void RoutingFeature::set_allocated_local_routing(::apollo::planning::RoutingResponseFeature* local_routing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_routing_;
  }
  if (local_routing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_routing);
    if (message_arena != submessage_arena) {
      local_routing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_routing, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.local_routing_ = local_routing;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.RoutingFeature.local_routing)
}

// -------------------------------------------------------------------

// TrafficLightFeature

// optional .apollo.perception.TrafficLight.Color color = 1;
inline bool TrafficLightFeature::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficLightFeature::has_color() const {
  return _internal_has_color();
}
inline void TrafficLightFeature::clear_color() {
  _impl_.color_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::perception::TrafficLight_Color TrafficLightFeature::_internal_color() const {
  return static_cast< ::apollo::perception::TrafficLight_Color >(_impl_.color_);
}
inline ::apollo::perception::TrafficLight_Color TrafficLightFeature::color() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.color)
  return _internal_color();
}
inline void TrafficLightFeature::_internal_set_color(::apollo::perception::TrafficLight_Color value) {
  assert(::apollo::perception::TrafficLight_Color_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.color_ = value;
}
inline void TrafficLightFeature::set_color(::apollo::perception::TrafficLight_Color value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.color)
}

// optional string id = 2;
inline bool TrafficLightFeature::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficLightFeature::has_id() const {
  return _internal_has_id();
}
inline void TrafficLightFeature::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficLightFeature::id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrafficLightFeature::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.id)
}
inline std::string* TrafficLightFeature::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficLightFeature.id)
  return _s;
}
inline const std::string& TrafficLightFeature::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TrafficLightFeature::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrafficLightFeature::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrafficLightFeature::release_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficLightFeature.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrafficLightFeature::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficLightFeature.id)
}

// optional double confidence = 3 [default = 1];
inline bool TrafficLightFeature::_internal_has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TrafficLightFeature::has_confidence() const {
  return _internal_has_confidence();
}
inline void TrafficLightFeature::clear_confidence() {
  _impl_.confidence_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double TrafficLightFeature::_internal_confidence() const {
  return _impl_.confidence_;
}
inline double TrafficLightFeature::confidence() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.confidence)
  return _internal_confidence();
}
inline void TrafficLightFeature::_internal_set_confidence(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.confidence_ = value;
}
inline void TrafficLightFeature::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.confidence)
}

// optional double tracking_time = 4;
inline bool TrafficLightFeature::_internal_has_tracking_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TrafficLightFeature::has_tracking_time() const {
  return _internal_has_tracking_time();
}
inline void TrafficLightFeature::clear_tracking_time() {
  _impl_.tracking_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double TrafficLightFeature::_internal_tracking_time() const {
  return _impl_.tracking_time_;
}
inline double TrafficLightFeature::tracking_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.tracking_time)
  return _internal_tracking_time();
}
inline void TrafficLightFeature::_internal_set_tracking_time(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tracking_time_ = value;
}
inline void TrafficLightFeature::set_tracking_time(double value) {
  _internal_set_tracking_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.tracking_time)
}

// optional bool blink = 5;
inline bool TrafficLightFeature::_internal_has_blink() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrafficLightFeature::has_blink() const {
  return _internal_has_blink();
}
inline void TrafficLightFeature::clear_blink() {
  _impl_.blink_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TrafficLightFeature::_internal_blink() const {
  return _impl_.blink_;
}
inline bool TrafficLightFeature::blink() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.blink)
  return _internal_blink();
}
inline void TrafficLightFeature::_internal_set_blink(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.blink_ = value;
}
inline void TrafficLightFeature::set_blink(bool value) {
  _internal_set_blink(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.blink)
}

// optional double remaining_time = 6;
inline bool TrafficLightFeature::_internal_has_remaining_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TrafficLightFeature::has_remaining_time() const {
  return _internal_has_remaining_time();
}
inline void TrafficLightFeature::clear_remaining_time() {
  _impl_.remaining_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double TrafficLightFeature::_internal_remaining_time() const {
  return _impl_.remaining_time_;
}
inline double TrafficLightFeature::remaining_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.remaining_time)
  return _internal_remaining_time();
}
inline void TrafficLightFeature::_internal_set_remaining_time(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.remaining_time_ = value;
}
inline void TrafficLightFeature::set_remaining_time(double value) {
  _internal_set_remaining_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.remaining_time)
}

// -------------------------------------------------------------------

// TrafficLightDetectionFeature

// optional double message_timestamp_sec = 1;
inline bool TrafficLightDetectionFeature::_internal_has_message_timestamp_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficLightDetectionFeature::has_message_timestamp_sec() const {
  return _internal_has_message_timestamp_sec();
}
inline void TrafficLightDetectionFeature::clear_message_timestamp_sec() {
  _impl_.message_timestamp_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double TrafficLightDetectionFeature::_internal_message_timestamp_sec() const {
  return _impl_.message_timestamp_sec_;
}
inline double TrafficLightDetectionFeature::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightDetectionFeature.message_timestamp_sec)
  return _internal_message_timestamp_sec();
}
inline void TrafficLightDetectionFeature::_internal_set_message_timestamp_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_timestamp_sec_ = value;
}
inline void TrafficLightDetectionFeature::set_message_timestamp_sec(double value) {
  _internal_set_message_timestamp_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightDetectionFeature.message_timestamp_sec)
}

// repeated .apollo.planning.TrafficLightFeature traffic_light = 2;
inline int TrafficLightDetectionFeature::_internal_traffic_light_size() const {
  return _impl_.traffic_light_.size();
}
inline int TrafficLightDetectionFeature::traffic_light_size() const {
  return _internal_traffic_light_size();
}
inline void TrafficLightDetectionFeature::clear_traffic_light() {
  _impl_.traffic_light_.Clear();
}
inline ::apollo::planning::TrafficLightFeature* TrafficLightDetectionFeature::mutable_traffic_light(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficLightDetectionFeature.traffic_light)
  return _impl_.traffic_light_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficLightFeature >*
TrafficLightDetectionFeature::mutable_traffic_light() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TrafficLightDetectionFeature.traffic_light)
  return &_impl_.traffic_light_;
}
inline const ::apollo::planning::TrafficLightFeature& TrafficLightDetectionFeature::_internal_traffic_light(int index) const {
  return _impl_.traffic_light_.Get(index);
}
inline const ::apollo::planning::TrafficLightFeature& TrafficLightDetectionFeature::traffic_light(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightDetectionFeature.traffic_light)
  return _internal_traffic_light(index);
}
inline ::apollo::planning::TrafficLightFeature* TrafficLightDetectionFeature::_internal_add_traffic_light() {
  return _impl_.traffic_light_.Add();
}
inline ::apollo::planning::TrafficLightFeature* TrafficLightDetectionFeature::add_traffic_light() {
  ::apollo::planning::TrafficLightFeature* _add = _internal_add_traffic_light();
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficLightDetectionFeature.traffic_light)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficLightFeature >&
TrafficLightDetectionFeature::traffic_light() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TrafficLightDetectionFeature.traffic_light)
  return _impl_.traffic_light_;
}

// -------------------------------------------------------------------

// ADCTrajectoryPoint

// optional double timestamp_sec = 1;
inline bool ADCTrajectoryPoint::_internal_has_timestamp_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ADCTrajectoryPoint::has_timestamp_sec() const {
  return _internal_has_timestamp_sec();
}
inline void ADCTrajectoryPoint::clear_timestamp_sec() {
  _impl_.timestamp_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ADCTrajectoryPoint::_internal_timestamp_sec() const {
  return _impl_.timestamp_sec_;
}
inline double ADCTrajectoryPoint::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ADCTrajectoryPoint.timestamp_sec)
  return _internal_timestamp_sec();
}
inline void ADCTrajectoryPoint::_internal_set_timestamp_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_sec_ = value;
}
inline void ADCTrajectoryPoint::set_timestamp_sec(double value) {
  _internal_set_timestamp_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ADCTrajectoryPoint.timestamp_sec)
}

// optional .apollo.planning.PlanningTag planning_tag = 2;
inline bool ADCTrajectoryPoint::_internal_has_planning_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.planning_tag_ != nullptr);
  return value;
}
inline bool ADCTrajectoryPoint::has_planning_tag() const {
  return _internal_has_planning_tag();
}
inline void ADCTrajectoryPoint::clear_planning_tag() {
  if (_impl_.planning_tag_ != nullptr) _impl_.planning_tag_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::PlanningTag& ADCTrajectoryPoint::_internal_planning_tag() const {
  const ::apollo::planning::PlanningTag* p = _impl_.planning_tag_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::PlanningTag&>(
      ::apollo::planning::_PlanningTag_default_instance_);
}
inline const ::apollo::planning::PlanningTag& ADCTrajectoryPoint::planning_tag() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ADCTrajectoryPoint.planning_tag)
  return _internal_planning_tag();
}
inline void ADCTrajectoryPoint::unsafe_arena_set_allocated_planning_tag(
    ::apollo::planning::PlanningTag* planning_tag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.planning_tag_);
  }
  _impl_.planning_tag_ = planning_tag;
  if (planning_tag) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.ADCTrajectoryPoint.planning_tag)
}
inline ::apollo::planning::PlanningTag* ADCTrajectoryPoint::release_planning_tag() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::PlanningTag* temp = _impl_.planning_tag_;
  _impl_.planning_tag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::PlanningTag* ADCTrajectoryPoint::unsafe_arena_release_planning_tag() {
  // @@protoc_insertion_point(field_release:apollo.planning.ADCTrajectoryPoint.planning_tag)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::PlanningTag* temp = _impl_.planning_tag_;
  _impl_.planning_tag_ = nullptr;
  return temp;
}
inline ::apollo::planning::PlanningTag* ADCTrajectoryPoint::_internal_mutable_planning_tag() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.planning_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::PlanningTag>(GetArenaForAllocation());
    _impl_.planning_tag_ = p;
  }
  return _impl_.planning_tag_;
}
inline ::apollo::planning::PlanningTag* ADCTrajectoryPoint::mutable_planning_tag() {
  ::apollo::planning::PlanningTag* _msg = _internal_mutable_planning_tag();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ADCTrajectoryPoint.planning_tag)
  return _msg;
}
inline void ADCTrajectoryPoint::set_allocated_planning_tag(::apollo::planning::PlanningTag* planning_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.planning_tag_;
  }
  if (planning_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(planning_tag);
    if (message_arena != submessage_arena) {
      planning_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planning_tag, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.planning_tag_ = planning_tag;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ADCTrajectoryPoint.planning_tag)
}

// optional .apollo.planning.CommonTrajectoryPointFeature trajectory_point = 3;
inline bool ADCTrajectoryPoint::_internal_has_trajectory_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trajectory_point_ != nullptr);
  return value;
}
inline bool ADCTrajectoryPoint::has_trajectory_point() const {
  return _internal_has_trajectory_point();
}
inline void ADCTrajectoryPoint::clear_trajectory_point() {
  if (_impl_.trajectory_point_ != nullptr) _impl_.trajectory_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::planning::CommonTrajectoryPointFeature& ADCTrajectoryPoint::_internal_trajectory_point() const {
  const ::apollo::planning::CommonTrajectoryPointFeature* p = _impl_.trajectory_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::CommonTrajectoryPointFeature&>(
      ::apollo::planning::_CommonTrajectoryPointFeature_default_instance_);
}
inline const ::apollo::planning::CommonTrajectoryPointFeature& ADCTrajectoryPoint::trajectory_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ADCTrajectoryPoint.trajectory_point)
  return _internal_trajectory_point();
}
inline void ADCTrajectoryPoint::unsafe_arena_set_allocated_trajectory_point(
    ::apollo::planning::CommonTrajectoryPointFeature* trajectory_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trajectory_point_);
  }
  _impl_.trajectory_point_ = trajectory_point;
  if (trajectory_point) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.ADCTrajectoryPoint.trajectory_point)
}
inline ::apollo::planning::CommonTrajectoryPointFeature* ADCTrajectoryPoint::release_trajectory_point() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::CommonTrajectoryPointFeature* temp = _impl_.trajectory_point_;
  _impl_.trajectory_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::CommonTrajectoryPointFeature* ADCTrajectoryPoint::unsafe_arena_release_trajectory_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.ADCTrajectoryPoint.trajectory_point)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::CommonTrajectoryPointFeature* temp = _impl_.trajectory_point_;
  _impl_.trajectory_point_ = nullptr;
  return temp;
}
inline ::apollo::planning::CommonTrajectoryPointFeature* ADCTrajectoryPoint::_internal_mutable_trajectory_point() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.trajectory_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::CommonTrajectoryPointFeature>(GetArenaForAllocation());
    _impl_.trajectory_point_ = p;
  }
  return _impl_.trajectory_point_;
}
inline ::apollo::planning::CommonTrajectoryPointFeature* ADCTrajectoryPoint::mutable_trajectory_point() {
  ::apollo::planning::CommonTrajectoryPointFeature* _msg = _internal_mutable_trajectory_point();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ADCTrajectoryPoint.trajectory_point)
  return _msg;
}
inline void ADCTrajectoryPoint::set_allocated_trajectory_point(::apollo::planning::CommonTrajectoryPointFeature* trajectory_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trajectory_point_;
  }
  if (trajectory_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trajectory_point);
    if (message_arena != submessage_arena) {
      trajectory_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trajectory_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.trajectory_point_ = trajectory_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ADCTrajectoryPoint.trajectory_point)
}

// -------------------------------------------------------------------

// LearningOutput

// repeated .apollo.planning.TrajectoryPointFeature adc_future_trajectory_point = 1;
inline int LearningOutput::_internal_adc_future_trajectory_point_size() const {
  return _impl_.adc_future_trajectory_point_.size();
}
inline int LearningOutput::adc_future_trajectory_point_size() const {
  return _internal_adc_future_trajectory_point_size();
}
inline void LearningOutput::clear_adc_future_trajectory_point() {
  _impl_.adc_future_trajectory_point_.Clear();
}
inline ::apollo::planning::TrajectoryPointFeature* LearningOutput::mutable_adc_future_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningOutput.adc_future_trajectory_point)
  return _impl_.adc_future_trajectory_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
LearningOutput::mutable_adc_future_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.LearningOutput.adc_future_trajectory_point)
  return &_impl_.adc_future_trajectory_point_;
}
inline const ::apollo::planning::TrajectoryPointFeature& LearningOutput::_internal_adc_future_trajectory_point(int index) const {
  return _impl_.adc_future_trajectory_point_.Get(index);
}
inline const ::apollo::planning::TrajectoryPointFeature& LearningOutput::adc_future_trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningOutput.adc_future_trajectory_point)
  return _internal_adc_future_trajectory_point(index);
}
inline ::apollo::planning::TrajectoryPointFeature* LearningOutput::_internal_add_adc_future_trajectory_point() {
  return _impl_.adc_future_trajectory_point_.Add();
}
inline ::apollo::planning::TrajectoryPointFeature* LearningOutput::add_adc_future_trajectory_point() {
  ::apollo::planning::TrajectoryPointFeature* _add = _internal_add_adc_future_trajectory_point();
  // @@protoc_insertion_point(field_add:apollo.planning.LearningOutput.adc_future_trajectory_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
LearningOutput::adc_future_trajectory_point() const {
  // @@protoc_insertion_point(field_list:apollo.planning.LearningOutput.adc_future_trajectory_point)
  return _impl_.adc_future_trajectory_point_;
}

// -------------------------------------------------------------------

// LearningDataFrame

// optional double message_timestamp_sec = 1;
inline bool LearningDataFrame::_internal_has_message_timestamp_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LearningDataFrame::has_message_timestamp_sec() const {
  return _internal_has_message_timestamp_sec();
}
inline void LearningDataFrame::clear_message_timestamp_sec() {
  _impl_.message_timestamp_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double LearningDataFrame::_internal_message_timestamp_sec() const {
  return _impl_.message_timestamp_sec_;
}
inline double LearningDataFrame::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.message_timestamp_sec)
  return _internal_message_timestamp_sec();
}
inline void LearningDataFrame::_internal_set_message_timestamp_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.message_timestamp_sec_ = value;
}
inline void LearningDataFrame::set_message_timestamp_sec(double value) {
  _internal_set_message_timestamp_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.LearningDataFrame.message_timestamp_sec)
}

// optional uint32 frame_num = 2;
inline bool LearningDataFrame::_internal_has_frame_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LearningDataFrame::has_frame_num() const {
  return _internal_has_frame_num();
}
inline void LearningDataFrame::clear_frame_num() {
  _impl_.frame_num_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t LearningDataFrame::_internal_frame_num() const {
  return _impl_.frame_num_;
}
inline uint32_t LearningDataFrame::frame_num() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.frame_num)
  return _internal_frame_num();
}
inline void LearningDataFrame::_internal_set_frame_num(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.frame_num_ = value;
}
inline void LearningDataFrame::set_frame_num(uint32_t value) {
  _internal_set_frame_num(value);
  // @@protoc_insertion_point(field_set:apollo.planning.LearningDataFrame.frame_num)
}

// optional string map_name = 3;
inline bool LearningDataFrame::_internal_has_map_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LearningDataFrame::has_map_name() const {
  return _internal_has_map_name();
}
inline void LearningDataFrame::clear_map_name() {
  _impl_.map_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LearningDataFrame::map_name() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.map_name)
  return _internal_map_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LearningDataFrame::set_map_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.map_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.LearningDataFrame.map_name)
}
inline std::string* LearningDataFrame::mutable_map_name() {
  std::string* _s = _internal_mutable_map_name();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.map_name)
  return _s;
}
inline const std::string& LearningDataFrame::_internal_map_name() const {
  return _impl_.map_name_.Get();
}
inline void LearningDataFrame::_internal_set_map_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LearningDataFrame::_internal_mutable_map_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.map_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LearningDataFrame::release_map_name() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.map_name)
  if (!_internal_has_map_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.map_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_name_.IsDefault()) {
    _impl_.map_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LearningDataFrame::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.map_name_.SetAllocated(map_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_name_.IsDefault()) {
    _impl_.map_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.map_name)
}

// optional .apollo.planning.PlanningTag planning_tag = 4;
inline bool LearningDataFrame::_internal_has_planning_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.planning_tag_ != nullptr);
  return value;
}
inline bool LearningDataFrame::has_planning_tag() const {
  return _internal_has_planning_tag();
}
inline void LearningDataFrame::clear_planning_tag() {
  if (_impl_.planning_tag_ != nullptr) _impl_.planning_tag_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::planning::PlanningTag& LearningDataFrame::_internal_planning_tag() const {
  const ::apollo::planning::PlanningTag* p = _impl_.planning_tag_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::PlanningTag&>(
      ::apollo::planning::_PlanningTag_default_instance_);
}
inline const ::apollo::planning::PlanningTag& LearningDataFrame::planning_tag() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.planning_tag)
  return _internal_planning_tag();
}
inline void LearningDataFrame::unsafe_arena_set_allocated_planning_tag(
    ::apollo::planning::PlanningTag* planning_tag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.planning_tag_);
  }
  _impl_.planning_tag_ = planning_tag;
  if (planning_tag) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.LearningDataFrame.planning_tag)
}
inline ::apollo::planning::PlanningTag* LearningDataFrame::release_planning_tag() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::PlanningTag* temp = _impl_.planning_tag_;
  _impl_.planning_tag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::PlanningTag* LearningDataFrame::unsafe_arena_release_planning_tag() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.planning_tag)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::PlanningTag* temp = _impl_.planning_tag_;
  _impl_.planning_tag_ = nullptr;
  return temp;
}
inline ::apollo::planning::PlanningTag* LearningDataFrame::_internal_mutable_planning_tag() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.planning_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::PlanningTag>(GetArenaForAllocation());
    _impl_.planning_tag_ = p;
  }
  return _impl_.planning_tag_;
}
inline ::apollo::planning::PlanningTag* LearningDataFrame::mutable_planning_tag() {
  ::apollo::planning::PlanningTag* _msg = _internal_mutable_planning_tag();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.planning_tag)
  return _msg;
}
inline void LearningDataFrame::set_allocated_planning_tag(::apollo::planning::PlanningTag* planning_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.planning_tag_;
  }
  if (planning_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(planning_tag);
    if (message_arena != submessage_arena) {
      planning_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planning_tag, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.planning_tag_ = planning_tag;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.planning_tag)
}

// optional .apollo.planning.ChassisFeature chassis = 5;
inline bool LearningDataFrame::_internal_has_chassis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chassis_ != nullptr);
  return value;
}
inline bool LearningDataFrame::has_chassis() const {
  return _internal_has_chassis();
}
inline void LearningDataFrame::clear_chassis() {
  if (_impl_.chassis_ != nullptr) _impl_.chassis_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::planning::ChassisFeature& LearningDataFrame::_internal_chassis() const {
  const ::apollo::planning::ChassisFeature* p = _impl_.chassis_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::ChassisFeature&>(
      ::apollo::planning::_ChassisFeature_default_instance_);
}
inline const ::apollo::planning::ChassisFeature& LearningDataFrame::chassis() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.chassis)
  return _internal_chassis();
}
inline void LearningDataFrame::unsafe_arena_set_allocated_chassis(
    ::apollo::planning::ChassisFeature* chassis) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chassis_);
  }
  _impl_.chassis_ = chassis;
  if (chassis) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.LearningDataFrame.chassis)
}
inline ::apollo::planning::ChassisFeature* LearningDataFrame::release_chassis() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::planning::ChassisFeature* temp = _impl_.chassis_;
  _impl_.chassis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::ChassisFeature* LearningDataFrame::unsafe_arena_release_chassis() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.chassis)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::planning::ChassisFeature* temp = _impl_.chassis_;
  _impl_.chassis_ = nullptr;
  return temp;
}
inline ::apollo::planning::ChassisFeature* LearningDataFrame::_internal_mutable_chassis() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.chassis_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ChassisFeature>(GetArenaForAllocation());
    _impl_.chassis_ = p;
  }
  return _impl_.chassis_;
}
inline ::apollo::planning::ChassisFeature* LearningDataFrame::mutable_chassis() {
  ::apollo::planning::ChassisFeature* _msg = _internal_mutable_chassis();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.chassis)
  return _msg;
}
inline void LearningDataFrame::set_allocated_chassis(::apollo::planning::ChassisFeature* chassis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chassis_;
  }
  if (chassis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chassis);
    if (message_arena != submessage_arena) {
      chassis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chassis, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.chassis_ = chassis;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.chassis)
}

// optional .apollo.planning.LocalizationFeature localization = 6;
inline bool LearningDataFrame::_internal_has_localization() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.localization_ != nullptr);
  return value;
}
inline bool LearningDataFrame::has_localization() const {
  return _internal_has_localization();
}
inline void LearningDataFrame::clear_localization() {
  if (_impl_.localization_ != nullptr) _impl_.localization_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::planning::LocalizationFeature& LearningDataFrame::_internal_localization() const {
  const ::apollo::planning::LocalizationFeature* p = _impl_.localization_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::LocalizationFeature&>(
      ::apollo::planning::_LocalizationFeature_default_instance_);
}
inline const ::apollo::planning::LocalizationFeature& LearningDataFrame::localization() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.localization)
  return _internal_localization();
}
inline void LearningDataFrame::unsafe_arena_set_allocated_localization(
    ::apollo::planning::LocalizationFeature* localization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.localization_);
  }
  _impl_.localization_ = localization;
  if (localization) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.LearningDataFrame.localization)
}
inline ::apollo::planning::LocalizationFeature* LearningDataFrame::release_localization() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::planning::LocalizationFeature* temp = _impl_.localization_;
  _impl_.localization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::LocalizationFeature* LearningDataFrame::unsafe_arena_release_localization() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.localization)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::planning::LocalizationFeature* temp = _impl_.localization_;
  _impl_.localization_ = nullptr;
  return temp;
}
inline ::apollo::planning::LocalizationFeature* LearningDataFrame::_internal_mutable_localization() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.localization_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::LocalizationFeature>(GetArenaForAllocation());
    _impl_.localization_ = p;
  }
  return _impl_.localization_;
}
inline ::apollo::planning::LocalizationFeature* LearningDataFrame::mutable_localization() {
  ::apollo::planning::LocalizationFeature* _msg = _internal_mutable_localization();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.localization)
  return _msg;
}
inline void LearningDataFrame::set_allocated_localization(::apollo::planning::LocalizationFeature* localization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.localization_;
  }
  if (localization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(localization);
    if (message_arena != submessage_arena) {
      localization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localization, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.localization_ = localization;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.localization)
}

// repeated .apollo.planning.ObstacleFeature obstacle = 7;
inline int LearningDataFrame::_internal_obstacle_size() const {
  return _impl_.obstacle_.size();
}
inline int LearningDataFrame::obstacle_size() const {
  return _internal_obstacle_size();
}
inline void LearningDataFrame::clear_obstacle() {
  _impl_.obstacle_.Clear();
}
inline ::apollo::planning::ObstacleFeature* LearningDataFrame::mutable_obstacle(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.obstacle)
  return _impl_.obstacle_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ObstacleFeature >*
LearningDataFrame::mutable_obstacle() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.LearningDataFrame.obstacle)
  return &_impl_.obstacle_;
}
inline const ::apollo::planning::ObstacleFeature& LearningDataFrame::_internal_obstacle(int index) const {
  return _impl_.obstacle_.Get(index);
}
inline const ::apollo::planning::ObstacleFeature& LearningDataFrame::obstacle(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.obstacle)
  return _internal_obstacle(index);
}
inline ::apollo::planning::ObstacleFeature* LearningDataFrame::_internal_add_obstacle() {
  return _impl_.obstacle_.Add();
}
inline ::apollo::planning::ObstacleFeature* LearningDataFrame::add_obstacle() {
  ::apollo::planning::ObstacleFeature* _add = _internal_add_obstacle();
  // @@protoc_insertion_point(field_add:apollo.planning.LearningDataFrame.obstacle)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ObstacleFeature >&
LearningDataFrame::obstacle() const {
  // @@protoc_insertion_point(field_list:apollo.planning.LearningDataFrame.obstacle)
  return _impl_.obstacle_;
}

// optional .apollo.planning.RoutingFeature routing = 8;
inline bool LearningDataFrame::_internal_has_routing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.routing_ != nullptr);
  return value;
}
inline bool LearningDataFrame::has_routing() const {
  return _internal_has_routing();
}
inline void LearningDataFrame::clear_routing() {
  if (_impl_.routing_ != nullptr) _impl_.routing_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::planning::RoutingFeature& LearningDataFrame::_internal_routing() const {
  const ::apollo::planning::RoutingFeature* p = _impl_.routing_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::RoutingFeature&>(
      ::apollo::planning::_RoutingFeature_default_instance_);
}
inline const ::apollo::planning::RoutingFeature& LearningDataFrame::routing() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.routing)
  return _internal_routing();
}
inline void LearningDataFrame::unsafe_arena_set_allocated_routing(
    ::apollo::planning::RoutingFeature* routing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.routing_);
  }
  _impl_.routing_ = routing;
  if (routing) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.LearningDataFrame.routing)
}
inline ::apollo::planning::RoutingFeature* LearningDataFrame::release_routing() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::planning::RoutingFeature* temp = _impl_.routing_;
  _impl_.routing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::RoutingFeature* LearningDataFrame::unsafe_arena_release_routing() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.routing)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::planning::RoutingFeature* temp = _impl_.routing_;
  _impl_.routing_ = nullptr;
  return temp;
}
inline ::apollo::planning::RoutingFeature* LearningDataFrame::_internal_mutable_routing() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.routing_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::RoutingFeature>(GetArenaForAllocation());
    _impl_.routing_ = p;
  }
  return _impl_.routing_;
}
inline ::apollo::planning::RoutingFeature* LearningDataFrame::mutable_routing() {
  ::apollo::planning::RoutingFeature* _msg = _internal_mutable_routing();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.routing)
  return _msg;
}
inline void LearningDataFrame::set_allocated_routing(::apollo::planning::RoutingFeature* routing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.routing_;
  }
  if (routing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(routing);
    if (message_arena != submessage_arena) {
      routing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.routing_ = routing;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.routing)
}

// optional .apollo.planning.TrafficLightDetectionFeature traffic_light_detection = 9;
inline bool LearningDataFrame::_internal_has_traffic_light_detection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.traffic_light_detection_ != nullptr);
  return value;
}
inline bool LearningDataFrame::has_traffic_light_detection() const {
  return _internal_has_traffic_light_detection();
}
inline void LearningDataFrame::clear_traffic_light_detection() {
  if (_impl_.traffic_light_detection_ != nullptr) _impl_.traffic_light_detection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::apollo::planning::TrafficLightDetectionFeature& LearningDataFrame::_internal_traffic_light_detection() const {
  const ::apollo::planning::TrafficLightDetectionFeature* p = _impl_.traffic_light_detection_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::TrafficLightDetectionFeature&>(
      ::apollo::planning::_TrafficLightDetectionFeature_default_instance_);
}
inline const ::apollo::planning::TrafficLightDetectionFeature& LearningDataFrame::traffic_light_detection() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.traffic_light_detection)
  return _internal_traffic_light_detection();
}
inline void LearningDataFrame::unsafe_arena_set_allocated_traffic_light_detection(
    ::apollo::planning::TrafficLightDetectionFeature* traffic_light_detection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.traffic_light_detection_);
  }
  _impl_.traffic_light_detection_ = traffic_light_detection;
  if (traffic_light_detection) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.LearningDataFrame.traffic_light_detection)
}
inline ::apollo::planning::TrafficLightDetectionFeature* LearningDataFrame::release_traffic_light_detection() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::apollo::planning::TrafficLightDetectionFeature* temp = _impl_.traffic_light_detection_;
  _impl_.traffic_light_detection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::TrafficLightDetectionFeature* LearningDataFrame::unsafe_arena_release_traffic_light_detection() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.traffic_light_detection)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::apollo::planning::TrafficLightDetectionFeature* temp = _impl_.traffic_light_detection_;
  _impl_.traffic_light_detection_ = nullptr;
  return temp;
}
inline ::apollo::planning::TrafficLightDetectionFeature* LearningDataFrame::_internal_mutable_traffic_light_detection() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.traffic_light_detection_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::TrafficLightDetectionFeature>(GetArenaForAllocation());
    _impl_.traffic_light_detection_ = p;
  }
  return _impl_.traffic_light_detection_;
}
inline ::apollo::planning::TrafficLightDetectionFeature* LearningDataFrame::mutable_traffic_light_detection() {
  ::apollo::planning::TrafficLightDetectionFeature* _msg = _internal_mutable_traffic_light_detection();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.traffic_light_detection)
  return _msg;
}
inline void LearningDataFrame::set_allocated_traffic_light_detection(::apollo::planning::TrafficLightDetectionFeature* traffic_light_detection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.traffic_light_detection_;
  }
  if (traffic_light_detection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(traffic_light_detection);
    if (message_arena != submessage_arena) {
      traffic_light_detection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traffic_light_detection, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.traffic_light_detection_ = traffic_light_detection;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.traffic_light_detection)
}

// repeated .apollo.planning.ADCTrajectoryPoint adc_trajectory_point = 10;
inline int LearningDataFrame::_internal_adc_trajectory_point_size() const {
  return _impl_.adc_trajectory_point_.size();
}
inline int LearningDataFrame::adc_trajectory_point_size() const {
  return _internal_adc_trajectory_point_size();
}
inline void LearningDataFrame::clear_adc_trajectory_point() {
  _impl_.adc_trajectory_point_.Clear();
}
inline ::apollo::planning::ADCTrajectoryPoint* LearningDataFrame::mutable_adc_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.adc_trajectory_point)
  return _impl_.adc_trajectory_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ADCTrajectoryPoint >*
LearningDataFrame::mutable_adc_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.LearningDataFrame.adc_trajectory_point)
  return &_impl_.adc_trajectory_point_;
}
inline const ::apollo::planning::ADCTrajectoryPoint& LearningDataFrame::_internal_adc_trajectory_point(int index) const {
  return _impl_.adc_trajectory_point_.Get(index);
}
inline const ::apollo::planning::ADCTrajectoryPoint& LearningDataFrame::adc_trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.adc_trajectory_point)
  return _internal_adc_trajectory_point(index);
}
inline ::apollo::planning::ADCTrajectoryPoint* LearningDataFrame::_internal_add_adc_trajectory_point() {
  return _impl_.adc_trajectory_point_.Add();
}
inline ::apollo::planning::ADCTrajectoryPoint* LearningDataFrame::add_adc_trajectory_point() {
  ::apollo::planning::ADCTrajectoryPoint* _add = _internal_add_adc_trajectory_point();
  // @@protoc_insertion_point(field_add:apollo.planning.LearningDataFrame.adc_trajectory_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::ADCTrajectoryPoint >&
LearningDataFrame::adc_trajectory_point() const {
  // @@protoc_insertion_point(field_list:apollo.planning.LearningDataFrame.adc_trajectory_point)
  return _impl_.adc_trajectory_point_;
}

// optional .apollo.planning.LearningOutput output = 11;
inline bool LearningDataFrame::_internal_has_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_ != nullptr);
  return value;
}
inline bool LearningDataFrame::has_output() const {
  return _internal_has_output();
}
inline void LearningDataFrame::clear_output() {
  if (_impl_.output_ != nullptr) _impl_.output_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::apollo::planning::LearningOutput& LearningDataFrame::_internal_output() const {
  const ::apollo::planning::LearningOutput* p = _impl_.output_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::LearningOutput&>(
      ::apollo::planning::_LearningOutput_default_instance_);
}
inline const ::apollo::planning::LearningOutput& LearningDataFrame::output() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.output)
  return _internal_output();
}
inline void LearningDataFrame::unsafe_arena_set_allocated_output(
    ::apollo::planning::LearningOutput* output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_);
  }
  _impl_.output_ = output;
  if (output) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.LearningDataFrame.output)
}
inline ::apollo::planning::LearningOutput* LearningDataFrame::release_output() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::apollo::planning::LearningOutput* temp = _impl_.output_;
  _impl_.output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::LearningOutput* LearningDataFrame::unsafe_arena_release_output() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.output)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::apollo::planning::LearningOutput* temp = _impl_.output_;
  _impl_.output_ = nullptr;
  return temp;
}
inline ::apollo::planning::LearningOutput* LearningDataFrame::_internal_mutable_output() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.output_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::LearningOutput>(GetArenaForAllocation());
    _impl_.output_ = p;
  }
  return _impl_.output_;
}
inline ::apollo::planning::LearningOutput* LearningDataFrame::mutable_output() {
  ::apollo::planning::LearningOutput* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.output)
  return _msg;
}
inline void LearningDataFrame::set_allocated_output(::apollo::planning::LearningOutput* output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_;
  }
  if (output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output);
    if (message_arena != submessage_arena) {
      output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.output_ = output;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.output)
}

// -------------------------------------------------------------------

// LearningData

// repeated .apollo.planning.LearningDataFrame learning_data_frame = 1;
inline int LearningData::_internal_learning_data_frame_size() const {
  return _impl_.learning_data_frame_.size();
}
inline int LearningData::learning_data_frame_size() const {
  return _internal_learning_data_frame_size();
}
inline void LearningData::clear_learning_data_frame() {
  _impl_.learning_data_frame_.Clear();
}
inline ::apollo::planning::LearningDataFrame* LearningData::mutable_learning_data_frame(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningData.learning_data_frame)
  return _impl_.learning_data_frame_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::LearningDataFrame >*
LearningData::mutable_learning_data_frame() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.LearningData.learning_data_frame)
  return &_impl_.learning_data_frame_;
}
inline const ::apollo::planning::LearningDataFrame& LearningData::_internal_learning_data_frame(int index) const {
  return _impl_.learning_data_frame_.Get(index);
}
inline const ::apollo::planning::LearningDataFrame& LearningData::learning_data_frame(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningData.learning_data_frame)
  return _internal_learning_data_frame(index);
}
inline ::apollo::planning::LearningDataFrame* LearningData::_internal_add_learning_data_frame() {
  return _impl_.learning_data_frame_.Add();
}
inline ::apollo::planning::LearningDataFrame* LearningData::add_learning_data_frame() {
  ::apollo::planning::LearningDataFrame* _add = _internal_add_learning_data_frame();
  // @@protoc_insertion_point(field_add:apollo.planning.LearningData.learning_data_frame)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::LearningDataFrame >&
LearningData::learning_data_frame() const {
  // @@protoc_insertion_point(field_list:apollo.planning.LearningData.learning_data_frame)
  return _impl_.learning_data_frame_;
}

// -------------------------------------------------------------------

// PlanningLearningData

// optional .apollo.common.Header header = 1;
inline bool PlanningLearningData::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool PlanningLearningData::has_header() const {
  return _internal_has_header();
}
inline const ::apollo::common::Header& PlanningLearningData::_internal_header() const {
  const ::apollo::common::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::Header&>(
      ::apollo::common::_Header_default_instance_);
}
inline const ::apollo::common::Header& PlanningLearningData::header() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningLearningData.header)
  return _internal_header();
}
inline void PlanningLearningData::unsafe_arena_set_allocated_header(
    ::apollo::common::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningLearningData.header)
}
inline ::apollo::common::Header* PlanningLearningData::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::Header* PlanningLearningData::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningLearningData.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::apollo::common::Header* PlanningLearningData::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::apollo::common::Header* PlanningLearningData::mutable_header() {
  ::apollo::common::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningLearningData.header)
  return _msg;
}
inline void PlanningLearningData::set_allocated_header(::apollo::common::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningLearningData.header)
}

// optional .apollo.planning.LearningDataFrame learning_data_frame = 2;
inline bool PlanningLearningData::_internal_has_learning_data_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.learning_data_frame_ != nullptr);
  return value;
}
inline bool PlanningLearningData::has_learning_data_frame() const {
  return _internal_has_learning_data_frame();
}
inline void PlanningLearningData::clear_learning_data_frame() {
  if (_impl_.learning_data_frame_ != nullptr) _impl_.learning_data_frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::planning::LearningDataFrame& PlanningLearningData::_internal_learning_data_frame() const {
  const ::apollo::planning::LearningDataFrame* p = _impl_.learning_data_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::LearningDataFrame&>(
      ::apollo::planning::_LearningDataFrame_default_instance_);
}
inline const ::apollo::planning::LearningDataFrame& PlanningLearningData::learning_data_frame() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningLearningData.learning_data_frame)
  return _internal_learning_data_frame();
}
inline void PlanningLearningData::unsafe_arena_set_allocated_learning_data_frame(
    ::apollo::planning::LearningDataFrame* learning_data_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.learning_data_frame_);
  }
  _impl_.learning_data_frame_ = learning_data_frame;
  if (learning_data_frame) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningLearningData.learning_data_frame)
}
inline ::apollo::planning::LearningDataFrame* PlanningLearningData::release_learning_data_frame() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::LearningDataFrame* temp = _impl_.learning_data_frame_;
  _impl_.learning_data_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::LearningDataFrame* PlanningLearningData::unsafe_arena_release_learning_data_frame() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningLearningData.learning_data_frame)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::LearningDataFrame* temp = _impl_.learning_data_frame_;
  _impl_.learning_data_frame_ = nullptr;
  return temp;
}
inline ::apollo::planning::LearningDataFrame* PlanningLearningData::_internal_mutable_learning_data_frame() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.learning_data_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::LearningDataFrame>(GetArenaForAllocation());
    _impl_.learning_data_frame_ = p;
  }
  return _impl_.learning_data_frame_;
}
inline ::apollo::planning::LearningDataFrame* PlanningLearningData::mutable_learning_data_frame() {
  ::apollo::planning::LearningDataFrame* _msg = _internal_mutable_learning_data_frame();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningLearningData.learning_data_frame)
  return _msg;
}
inline void PlanningLearningData::set_allocated_learning_data_frame(::apollo::planning::LearningDataFrame* learning_data_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.learning_data_frame_;
  }
  if (learning_data_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(learning_data_frame);
    if (message_arena != submessage_arena) {
      learning_data_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, learning_data_frame, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.learning_data_frame_ = learning_data_frame;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningLearningData.learning_data_frame)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2flearning_5fdata_2eproto
