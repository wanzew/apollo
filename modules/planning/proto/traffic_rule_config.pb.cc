// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/traffic_rule_config.proto

#include "modules/planning/proto/traffic_rule_config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace apollo {
namespace planning {
PROTOBUF_CONSTEXPR BacksideVehicleConfig::BacksideVehicleConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.backside_lane_width_)*/4} {}
struct BacksideVehicleConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BacksideVehicleConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BacksideVehicleConfigDefaultTypeInternal() {}
  union {
    BacksideVehicleConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BacksideVehicleConfigDefaultTypeInternal _BacksideVehicleConfig_default_instance_;
PROTOBUF_CONSTEXPR ChangeLaneConfig::ChangeLaneConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enable_guard_obstacle_)*/false
  , /*decltype(_impl_.min_overtake_distance_)*/10
  , /*decltype(_impl_.min_overtake_time_)*/2
  , /*decltype(_impl_.guard_distance_)*/100
  , /*decltype(_impl_.min_guard_speed_)*/1} {}
struct ChangeLaneConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeLaneConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeLaneConfigDefaultTypeInternal() {}
  union {
    ChangeLaneConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeLaneConfigDefaultTypeInternal _ChangeLaneConfig_default_instance_;
PROTOBUF_CONSTEXPR CreepConfig::CreepConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.creep_distance_to_stop_line_)*/1
  , /*decltype(_impl_.stop_distance_)*/0.5
  , /*decltype(_impl_.speed_limit_)*/1
  , /*decltype(_impl_.max_valid_stop_distance_)*/0.3
  , /*decltype(_impl_.min_boundary_t_)*/6
  , /*decltype(_impl_.min_boundary_s_)*/3} {}
struct CreepConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreepConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreepConfigDefaultTypeInternal() {}
  union {
    CreepConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreepConfigDefaultTypeInternal _CreepConfig_default_instance_;
PROTOBUF_CONSTEXPR CrosswalkConfig::CrosswalkConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stop_distance_)*/1
  , /*decltype(_impl_.max_stop_deceleration_)*/6
  , /*decltype(_impl_.min_pass_s_distance_)*/1
  , /*decltype(_impl_.max_stop_speed_)*/0.3
  , /*decltype(_impl_.max_valid_stop_distance_)*/3
  , /*decltype(_impl_.expand_s_distance_)*/2
  , /*decltype(_impl_.stop_strick_l_distance_)*/4
  , /*decltype(_impl_.stop_loose_l_distance_)*/5
  , /*decltype(_impl_.stop_timeout_)*/10} {}
struct CrosswalkConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CrosswalkConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CrosswalkConfigDefaultTypeInternal() {}
  union {
    CrosswalkConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CrosswalkConfigDefaultTypeInternal _CrosswalkConfig_default_instance_;
PROTOBUF_CONSTEXPR DestinationConfig::DestinationConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enable_pull_over_)*/false
  , /*decltype(_impl_.stop_distance_)*/0.5
  , /*decltype(_impl_.pull_over_plan_distance_)*/35} {}
struct DestinationConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DestinationConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DestinationConfigDefaultTypeInternal() {}
  union {
    DestinationConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DestinationConfigDefaultTypeInternal _DestinationConfig_default_instance_;
PROTOBUF_CONSTEXPR FrontVehicleConfig::FrontVehicleConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enable_side_pass_)*/true
  , /*decltype(_impl_.side_pass_s_threshold_)*/15
  , /*decltype(_impl_.side_pass_l_threshold_)*/1
  , /*decltype(_impl_.side_pass_wait_time_)*/30
  , /*decltype(_impl_.nudge_l_buffer_)*/0.5} {}
struct FrontVehicleConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrontVehicleConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrontVehicleConfigDefaultTypeInternal() {}
  union {
    FrontVehicleConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrontVehicleConfigDefaultTypeInternal _FrontVehicleConfig_default_instance_;
PROTOBUF_CONSTEXPR KeepClearConfig::KeepClearConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enable_keep_clear_zone_)*/true
  , /*decltype(_impl_.enable_junction_)*/true
  , /*decltype(_impl_.min_pass_s_distance_)*/2} {}
struct KeepClearConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeepClearConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeepClearConfigDefaultTypeInternal() {}
  union {
    KeepClearConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeepClearConfigDefaultTypeInternal _KeepClearConfig_default_instance_;
PROTOBUF_CONSTEXPR PullOverConfig::PullOverConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.max_failure_count_)*/10u
  , /*decltype(_impl_.stop_distance_)*/0.5
  , /*decltype(_impl_.max_stop_speed_)*/0.3
  , /*decltype(_impl_.max_valid_stop_distance_)*/3
  , /*decltype(_impl_.buffer_to_boundary_)*/0.5
  , /*decltype(_impl_.plan_distance_)*/35
  , /*decltype(_impl_.operation_length_)*/30
  , /*decltype(_impl_.max_check_distance_)*/60} {}
struct PullOverConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PullOverConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PullOverConfigDefaultTypeInternal() {}
  union {
    PullOverConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PullOverConfigDefaultTypeInternal _PullOverConfig_default_instance_;
PROTOBUF_CONSTEXPR ReferenceLineEndConfig::ReferenceLineEndConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stop_distance_)*/0.5
  , /*decltype(_impl_.min_reference_line_remain_length_)*/50} {}
struct ReferenceLineEndConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReferenceLineEndConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReferenceLineEndConfigDefaultTypeInternal() {}
  union {
    ReferenceLineEndConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferenceLineEndConfigDefaultTypeInternal _ReferenceLineEndConfig_default_instance_;
PROTOBUF_CONSTEXPR ReroutingConfig::ReroutingConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cooldown_time_)*/3
  , /*decltype(_impl_.prepare_rerouting_time_)*/2} {}
struct ReroutingConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReroutingConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReroutingConfigDefaultTypeInternal() {}
  union {
    ReroutingConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReroutingConfigDefaultTypeInternal _ReroutingConfig_default_instance_;
PROTOBUF_CONSTEXPR SignalLightConfig::SignalLightConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.righ_turn_creep_)*/nullptr
  , /*decltype(_impl_.stop_distance_)*/1
  , /*decltype(_impl_.max_stop_deceleration_)*/6
  , /*decltype(_impl_.min_pass_s_distance_)*/4
  , /*decltype(_impl_.max_stop_deacceleration_yellow_light_)*/3
  , /*decltype(_impl_.signal_expire_time_sec_)*/5} {}
struct SignalLightConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignalLightConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignalLightConfigDefaultTypeInternal() {}
  union {
    SignalLightConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignalLightConfigDefaultTypeInternal _SignalLightConfig_default_instance_;
PROTOBUF_CONSTEXPR StopSignConfig::StopSignConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.creep_)*/nullptr
  , /*decltype(_impl_.stop_distance_)*/1
  , /*decltype(_impl_.min_pass_s_distance_)*/1
  , /*decltype(_impl_.max_stop_speed_)*/0.3
  , /*decltype(_impl_.max_valid_stop_distance_)*/3
  , /*decltype(_impl_.stop_duration_)*/1
  , /*decltype(_impl_.watch_vehicle_max_valid_stop_speed_)*/0.5
  , /*decltype(_impl_.watch_vehicle_max_valid_stop_distance_)*/5
  , /*decltype(_impl_.wait_timeout_)*/8} {}
struct StopSignConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StopSignConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StopSignConfigDefaultTypeInternal() {}
  union {
    StopSignConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StopSignConfigDefaultTypeInternal _StopSignConfig_default_instance_;
PROTOBUF_CONSTEXPR TrafficRuleConfig::TrafficRuleConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.rule_id_)*/1
  , /*decltype(_impl_.config_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TrafficRuleConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrafficRuleConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrafficRuleConfigDefaultTypeInternal() {}
  union {
    TrafficRuleConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrafficRuleConfigDefaultTypeInternal _TrafficRuleConfig_default_instance_;
PROTOBUF_CONSTEXPR TrafficRuleConfigs::TrafficRuleConfigs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.config_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrafficRuleConfigsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrafficRuleConfigsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrafficRuleConfigsDefaultTypeInternal() {}
  union {
    TrafficRuleConfigs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrafficRuleConfigsDefaultTypeInternal _TrafficRuleConfigs_default_instance_;
}  // namespace planning
}  // namespace apollo
static ::_pb::Metadata file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[14];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto = nullptr;

const uint32_t TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::apollo::planning::BacksideVehicleConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::BacksideVehicleConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::BacksideVehicleConfig, _impl_.backside_lane_width_),
  0,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneConfig, _impl_.min_overtake_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneConfig, _impl_.min_overtake_time_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneConfig, _impl_.enable_guard_obstacle_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneConfig, _impl_.guard_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneConfig, _impl_.min_guard_speed_),
  1,
  2,
  0,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepConfig, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepConfig, _impl_.creep_distance_to_stop_line_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepConfig, _impl_.stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepConfig, _impl_.speed_limit_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepConfig, _impl_.max_valid_stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepConfig, _impl_.min_boundary_t_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepConfig, _impl_.min_boundary_s_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _impl_.stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _impl_.max_stop_deceleration_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _impl_.min_pass_s_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _impl_.max_stop_speed_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _impl_.max_valid_stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _impl_.expand_s_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _impl_.stop_strick_l_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _impl_.stop_loose_l_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkConfig, _impl_.stop_timeout_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::DestinationConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::DestinationConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::DestinationConfig, _impl_.enable_pull_over_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::DestinationConfig, _impl_.stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::DestinationConfig, _impl_.pull_over_plan_distance_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::FrontVehicleConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::FrontVehicleConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::FrontVehicleConfig, _impl_.enable_side_pass_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::FrontVehicleConfig, _impl_.side_pass_s_threshold_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::FrontVehicleConfig, _impl_.side_pass_l_threshold_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::FrontVehicleConfig, _impl_.side_pass_wait_time_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::FrontVehicleConfig, _impl_.nudge_l_buffer_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::KeepClearConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::KeepClearConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::KeepClearConfig, _impl_.enable_keep_clear_zone_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::KeepClearConfig, _impl_.enable_junction_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::KeepClearConfig, _impl_.min_pass_s_distance_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverConfig, _impl_.stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverConfig, _impl_.max_stop_speed_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverConfig, _impl_.max_valid_stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverConfig, _impl_.buffer_to_boundary_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverConfig, _impl_.plan_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverConfig, _impl_.operation_length_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverConfig, _impl_.max_check_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverConfig, _impl_.max_failure_count_),
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  0,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReferenceLineEndConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReferenceLineEndConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReferenceLineEndConfig, _impl_.stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReferenceLineEndConfig, _impl_.min_reference_line_remain_length_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReroutingConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReroutingConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReroutingConfig, _impl_.cooldown_time_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReroutingConfig, _impl_.prepare_rerouting_time_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::SignalLightConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::SignalLightConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::SignalLightConfig, _impl_.stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::SignalLightConfig, _impl_.max_stop_deceleration_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::SignalLightConfig, _impl_.min_pass_s_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::SignalLightConfig, _impl_.max_stop_deacceleration_yellow_light_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::SignalLightConfig, _impl_.signal_expire_time_sec_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::SignalLightConfig, _impl_.righ_turn_creep_),
  1,
  2,
  3,
  4,
  5,
  0,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _impl_.stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _impl_.min_pass_s_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _impl_.max_stop_speed_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _impl_.max_valid_stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _impl_.stop_duration_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _impl_.watch_vehicle_max_valid_stop_speed_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _impl_.watch_vehicle_max_valid_stop_distance_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _impl_.wait_timeout_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignConfig, _impl_.creep_),
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  0,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficRuleConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficRuleConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficRuleConfig, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficRuleConfig, _impl_.rule_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficRuleConfig, _impl_.enabled_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficRuleConfig, _impl_.config_),
  1,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficRuleConfigs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficRuleConfigs, _impl_.config_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::apollo::planning::BacksideVehicleConfig)},
  { 8, 19, -1, sizeof(::apollo::planning::ChangeLaneConfig)},
  { 24, 37, -1, sizeof(::apollo::planning::CreepConfig)},
  { 44, 59, -1, sizeof(::apollo::planning::CrosswalkConfig)},
  { 68, 77, -1, sizeof(::apollo::planning::DestinationConfig)},
  { 80, 91, -1, sizeof(::apollo::planning::FrontVehicleConfig)},
  { 96, 105, -1, sizeof(::apollo::planning::KeepClearConfig)},
  { 108, 122, -1, sizeof(::apollo::planning::PullOverConfig)},
  { 130, 138, -1, sizeof(::apollo::planning::ReferenceLineEndConfig)},
  { 140, 148, -1, sizeof(::apollo::planning::ReroutingConfig)},
  { 150, 162, -1, sizeof(::apollo::planning::SignalLightConfig)},
  { 168, 183, -1, sizeof(::apollo::planning::StopSignConfig)},
  { 192, 212, -1, sizeof(::apollo::planning::TrafficRuleConfig)},
  { 225, -1, -1, sizeof(::apollo::planning::TrafficRuleConfigs)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::apollo::planning::_BacksideVehicleConfig_default_instance_._instance,
  &::apollo::planning::_ChangeLaneConfig_default_instance_._instance,
  &::apollo::planning::_CreepConfig_default_instance_._instance,
  &::apollo::planning::_CrosswalkConfig_default_instance_._instance,
  &::apollo::planning::_DestinationConfig_default_instance_._instance,
  &::apollo::planning::_FrontVehicleConfig_default_instance_._instance,
  &::apollo::planning::_KeepClearConfig_default_instance_._instance,
  &::apollo::planning::_PullOverConfig_default_instance_._instance,
  &::apollo::planning::_ReferenceLineEndConfig_default_instance_._instance,
  &::apollo::planning::_ReroutingConfig_default_instance_._instance,
  &::apollo::planning::_SignalLightConfig_default_instance_._instance,
  &::apollo::planning::_StopSignConfig_default_instance_._instance,
  &::apollo::planning::_TrafficRuleConfig_default_instance_._instance,
  &::apollo::planning::_TrafficRuleConfigs_default_instance_._instance,
};

const char descriptor_table_protodef_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n0modules/planning/proto/traffic_rule_co"
  "nfig.proto\022\017apollo.planning\"7\n\025BacksideV"
  "ehicleConfig\022\036\n\023backside_lane_width\030\001 \001("
  "\001:\0014\"\262\001\n\020ChangeLaneConfig\022!\n\025min_overtak"
  "e_distance\030\001 \001(\001:\00210\022\034\n\021min_overtake_tim"
  "e\030\002 \001(\001:\0012\022$\n\025enable_guard_obstacle\030\003 \001("
  "\010:\005false\022\033\n\016guard_distance\030\004 \001(\001:\003100\022\032\n"
  "\017min_guard_speed\030\005 \001(\001:\0011\"\326\001\n\013CreepConfi"
  "g\022\017\n\007enabled\030\001 \001(\010\022&\n\033creep_distance_to_"
  "stop_line\030\002 \001(\001:\0011\022\032\n\rstop_distance\030\003 \001("
  "\001:\0030.5\022\026\n\013speed_limit\030\004 \001(\001:\0011\022$\n\027max_va"
  "lid_stop_distance\030\005 \001(\001:\0030.3\022\031\n\016min_boun"
  "dary_t\030\006 \001(\001:\0016\022\031\n\016min_boundary_s\030\007 \001(\001:"
  "\0013\"\253\002\n\017CrosswalkConfig\022\030\n\rstop_distance\030"
  "\001 \001(\001:\0011\022 \n\025max_stop_deceleration\030\002 \001(\001:"
  "\0016\022\036\n\023min_pass_s_distance\030\003 \001(\001:\0011\022\033\n\016ma"
  "x_stop_speed\030\004 \001(\001:\0030.3\022\"\n\027max_valid_sto"
  "p_distance\030\005 \001(\001:\0013\022\034\n\021expand_s_distance"
  "\030\006 \001(\001:\0012\022!\n\026stop_strick_l_distance\030\007 \001("
  "\001:\0014\022 \n\025stop_loose_l_distance\030\010 \001(\001:\0015\022\030"
  "\n\014stop_timeout\030\t \001(\001:\00210\"u\n\021DestinationC"
  "onfig\022\037\n\020enable_pull_over\030\001 \001(\010:\005false\022\032"
  "\n\rstop_distance\030\002 \001(\001:\0030.5\022#\n\027pull_over_"
  "plan_distance\030\003 \001(\001:\00235\"\267\001\n\022FrontVehicle"
  "Config\022\036\n\020enable_side_pass\030\001 \001(\010:\004true\022!"
  "\n\025side_pass_s_threshold\030\002 \001(\001:\00215\022 \n\025sid"
  "e_pass_l_threshold\030\003 \001(\001:\0011\022\037\n\023side_pass"
  "_wait_time\030\004 \001(\001:\00230\022\033\n\016nudge_l_buffer\030\005"
  " \001(\001:\0030.5\"v\n\017KeepClearConfig\022$\n\026enable_k"
  "eep_clear_zone\030\001 \001(\010:\004true\022\035\n\017enable_jun"
  "ction\030\002 \001(\010:\004true\022\036\n\023min_pass_s_distance"
  "\030\003 \001(\001:\0012\"\206\002\n\016PullOverConfig\022\032\n\rstop_dis"
  "tance\030\001 \001(\001:\0030.5\022\033\n\016max_stop_speed\030\002 \001(\001"
  ":\0030.3\022\"\n\027max_valid_stop_distance\030\003 \001(\001:\001"
  "3\022\037\n\022buffer_to_boundary\030\004 \001(\001:\0030.5\022\031\n\rpl"
  "an_distance\030\005 \001(\001:\00235\022\034\n\020operation_lengt"
  "h\030\006 \001(\001:\00230\022\036\n\022max_check_distance\030\007 \001(\001:"
  "\00260\022\035\n\021max_failure_count\030\010 \001(\r:\00210\"b\n\026Re"
  "ferenceLineEndConfig\022\032\n\rstop_distance\030\001 "
  "\001(\001:\0030.5\022,\n min_reference_line_remain_le"
  "ngth\030\002 \001(\001:\00250\"N\n\017ReroutingConfig\022\030\n\rcoo"
  "ldown_time\030\001 \001(\001:\0013\022!\n\026prepare_rerouting"
  "_time\030\002 \001(\001:\0012\"\372\001\n\021SignalLightConfig\022\030\n\r"
  "stop_distance\030\001 \001(\001:\0011\022 \n\025max_stop_decel"
  "eration\030\002 \001(\001:\0016\022\036\n\023min_pass_s_distance\030"
  "\003 \001(\001:\0014\022/\n$max_stop_deacceleration_yell"
  "ow_light\030\004 \001(\001:\0013\022!\n\026signal_expire_time_"
  "sec\030\005 \001(\001:\0015\0225\n\017righ_turn_creep\030\006 \001(\0132\034."
  "apollo.planning.CreepConfig\"\316\002\n\016StopSign"
  "Config\022\030\n\rstop_distance\030\001 \001(\001:\0011\022\036\n\023min_"
  "pass_s_distance\030\002 \001(\001:\0011\022\033\n\016max_stop_spe"
  "ed\030\003 \001(\001:\0030.3\022\"\n\027max_valid_stop_distance"
  "\030\004 \001(\001:\0013\022\030\n\rstop_duration\030\005 \001(\001:\0011\022/\n\"w"
  "atch_vehicle_max_valid_stop_speed\030\006 \001(\001:"
  "\0030.5\0220\n%watch_vehicle_max_valid_stop_dis"
  "tance\030\007 \001(\001:\0015\022\027\n\014wait_timeout\030\010 \001(\001:\0018\022"
  "+\n\005creep\030\t \001(\0132\034.apollo.planning.CreepCo"
  "nfig\"\302\007\n\021TrafficRuleConfig\022:\n\007rule_id\030\001 "
  "\001(\0162).apollo.planning.TrafficRuleConfig."
  "RuleId\022\017\n\007enabled\030\002 \001(\010\022B\n\020backside_vehi"
  "cle\030\003 \001(\0132&.apollo.planning.BacksideVehi"
  "cleConfigH\000\0228\n\013change_lane\030\004 \001(\0132!.apoll"
  "o.planning.ChangeLaneConfigH\000\0225\n\tcrosswa"
  "lk\030\005 \001(\0132 .apollo.planning.CrosswalkConf"
  "igH\000\0229\n\013destination\030\006 \001(\0132\".apollo.plann"
  "ing.DestinationConfigH\000\022<\n\rfront_vehicle"
  "\030\007 \001(\0132#.apollo.planning.FrontVehicleCon"
  "figH\000\0226\n\nkeep_clear\030\010 \001(\0132 .apollo.plann"
  "ing.KeepClearConfigH\000\0224\n\tpull_over\030\t \001(\013"
  "2\037.apollo.planning.PullOverConfigH\000\022E\n\022r"
  "eference_line_end\030\n \001(\0132\'.apollo.plannin"
  "g.ReferenceLineEndConfigH\000\0225\n\trerouting\030"
  "\013 \001(\0132 .apollo.planning.ReroutingConfigH"
  "\000\022:\n\014signal_light\030\014 \001(\0132\".apollo.plannin"
  "g.SignalLightConfigH\000\0224\n\tstop_sign\030\r \001(\013"
  "2\037.apollo.planning.StopSignConfigH\000\"\311\001\n\006"
  "RuleId\022\024\n\020BACKSIDE_VEHICLE\020\001\022\017\n\013CHANGE_L"
  "ANE\020\002\022\r\n\tCROSSWALK\020\003\022\017\n\013DESTINATION\020\004\022\021\n"
  "\rFRONT_VEHICLE\020\005\022\016\n\nKEEP_CLEAR\020\006\022\r\n\tPULL"
  "_OVER\020\007\022\026\n\022REFERENCE_LINE_END\020\010\022\r\n\tREROU"
  "TING\020\t\022\020\n\014SIGNAL_LIGHT\020\n\022\r\n\tSTOP_SIGN\020\013B"
  "\010\n\006config\"H\n\022TrafficRuleConfigs\0222\n\006confi"
  "g\030\001 \003(\0132\".apollo.planning.TrafficRuleCon"
  "fig"
  ;
static ::_pbi::once_flag descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto = {
    false, false, 3323, descriptor_table_protodef_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto,
    "modules/planning/proto/traffic_rule_config.proto",
    &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once, nullptr, 0, 14,
    schemas, file_default_instances, TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::offsets,
    file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto, file_level_enum_descriptors_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto,
    file_level_service_descriptors_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter() {
  return &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto(&descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
namespace apollo {
namespace planning {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficRuleConfig_RuleId_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
  return file_level_enum_descriptors_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[0];
}
bool TrafficRuleConfig_RuleId_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::BACKSIDE_VEHICLE;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::CHANGE_LANE;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::CROSSWALK;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::DESTINATION;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::FRONT_VEHICLE;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::KEEP_CLEAR;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::PULL_OVER;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::REFERENCE_LINE_END;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::REROUTING;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::SIGNAL_LIGHT;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::STOP_SIGN;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::RuleId_MIN;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig::RuleId_MAX;
constexpr int TrafficRuleConfig::RuleId_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class BacksideVehicleConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<BacksideVehicleConfig>()._impl_._has_bits_);
  static void set_has_backside_lane_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BacksideVehicleConfig::BacksideVehicleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.BacksideVehicleConfig)
}
BacksideVehicleConfig::BacksideVehicleConfig(const BacksideVehicleConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.backside_lane_width_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.backside_lane_width_ = from._impl_.backside_lane_width_;
  // @@protoc_insertion_point(copy_constructor:apollo.planning.BacksideVehicleConfig)
}

inline void BacksideVehicleConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.backside_lane_width_){4}
  };
}

BacksideVehicleConfig::~BacksideVehicleConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.BacksideVehicleConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BacksideVehicleConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BacksideVehicleConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BacksideVehicleConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.BacksideVehicleConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.backside_lane_width_ = 4;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BacksideVehicleConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double backside_lane_width = 1 [default = 4];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_backside_lane_width(&has_bits);
          _impl_.backside_lane_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BacksideVehicleConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.BacksideVehicleConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double backside_lane_width = 1 [default = 4];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_backside_lane_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.BacksideVehicleConfig)
  return target;
}

size_t BacksideVehicleConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.BacksideVehicleConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional double backside_lane_width = 1 [default = 4];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BacksideVehicleConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BacksideVehicleConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BacksideVehicleConfig::GetClassData() const { return &_class_data_; }

void BacksideVehicleConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BacksideVehicleConfig *>(to)->MergeFrom(
      static_cast<const BacksideVehicleConfig &>(from));
}


void BacksideVehicleConfig::MergeFrom(const BacksideVehicleConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.BacksideVehicleConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_backside_lane_width()) {
    _internal_set_backside_lane_width(from._internal_backside_lane_width());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BacksideVehicleConfig::CopyFrom(const BacksideVehicleConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.BacksideVehicleConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BacksideVehicleConfig::IsInitialized() const {
  return true;
}

void BacksideVehicleConfig::InternalSwap(BacksideVehicleConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.backside_lane_width_, other->_impl_.backside_lane_width_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BacksideVehicleConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[0]);
}

// ===================================================================

class ChangeLaneConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeLaneConfig>()._impl_._has_bits_);
  static void set_has_min_overtake_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_overtake_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enable_guard_obstacle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_guard_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_min_guard_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

ChangeLaneConfig::ChangeLaneConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.ChangeLaneConfig)
}
ChangeLaneConfig::ChangeLaneConfig(const ChangeLaneConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_guard_obstacle_){}
    , decltype(_impl_.min_overtake_distance_){}
    , decltype(_impl_.min_overtake_time_){}
    , decltype(_impl_.guard_distance_){}
    , decltype(_impl_.min_guard_speed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enable_guard_obstacle_, &from._impl_.enable_guard_obstacle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.min_guard_speed_) -
    reinterpret_cast<char*>(&_impl_.enable_guard_obstacle_)) + sizeof(_impl_.min_guard_speed_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.ChangeLaneConfig)
}

inline void ChangeLaneConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_guard_obstacle_){false}
    , decltype(_impl_.min_overtake_distance_){10}
    , decltype(_impl_.min_overtake_time_){2}
    , decltype(_impl_.guard_distance_){100}
    , decltype(_impl_.min_guard_speed_){1}
  };
}

ChangeLaneConfig::~ChangeLaneConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.ChangeLaneConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeLaneConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChangeLaneConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeLaneConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.ChangeLaneConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    _impl_.enable_guard_obstacle_ = false;
    _impl_.min_overtake_distance_ = 10;
    _impl_.min_overtake_time_ = 2;
    _impl_.guard_distance_ = 100;
    _impl_.min_guard_speed_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeLaneConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double min_overtake_distance = 1 [default = 10];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_min_overtake_distance(&has_bits);
          _impl_.min_overtake_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double min_overtake_time = 2 [default = 2];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_min_overtake_time(&has_bits);
          _impl_.min_overtake_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_guard_obstacle = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_enable_guard_obstacle(&has_bits);
          _impl_.enable_guard_obstacle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double guard_distance = 4 [default = 100];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_guard_distance(&has_bits);
          _impl_.guard_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double min_guard_speed = 5 [default = 1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_min_guard_speed(&has_bits);
          _impl_.min_guard_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeLaneConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.ChangeLaneConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double min_overtake_distance = 1 [default = 10];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_min_overtake_distance(), target);
  }

  // optional double min_overtake_time = 2 [default = 2];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_min_overtake_time(), target);
  }

  // optional bool enable_guard_obstacle = 3 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_enable_guard_obstacle(), target);
  }

  // optional double guard_distance = 4 [default = 100];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_guard_distance(), target);
  }

  // optional double min_guard_speed = 5 [default = 1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_min_guard_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.ChangeLaneConfig)
  return target;
}

size_t ChangeLaneConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.ChangeLaneConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bool enable_guard_obstacle = 3 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional double min_overtake_distance = 1 [default = 10];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double min_overtake_time = 2 [default = 2];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double guard_distance = 4 [default = 100];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double min_guard_speed = 5 [default = 1];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeLaneConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ChangeLaneConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeLaneConfig::GetClassData() const { return &_class_data_; }

void ChangeLaneConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ChangeLaneConfig *>(to)->MergeFrom(
      static_cast<const ChangeLaneConfig &>(from));
}


void ChangeLaneConfig::MergeFrom(const ChangeLaneConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.ChangeLaneConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.enable_guard_obstacle_ = from._impl_.enable_guard_obstacle_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.min_overtake_distance_ = from._impl_.min_overtake_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.min_overtake_time_ = from._impl_.min_overtake_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.guard_distance_ = from._impl_.guard_distance_;
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.min_guard_speed_ = from._impl_.min_guard_speed_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeLaneConfig::CopyFrom(const ChangeLaneConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.ChangeLaneConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeLaneConfig::IsInitialized() const {
  return true;
}

void ChangeLaneConfig::InternalSwap(ChangeLaneConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enable_guard_obstacle_, other->_impl_.enable_guard_obstacle_);
  swap(_impl_.min_overtake_distance_, other->_impl_.min_overtake_distance_);
  swap(_impl_.min_overtake_time_, other->_impl_.min_overtake_time_);
  swap(_impl_.guard_distance_, other->_impl_.guard_distance_);
  swap(_impl_.min_guard_speed_, other->_impl_.min_guard_speed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeLaneConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[1]);
}

// ===================================================================

class CreepConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<CreepConfig>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_creep_distance_to_stop_line(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_speed_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_valid_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_min_boundary_t(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_min_boundary_s(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CreepConfig::CreepConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.CreepConfig)
}
CreepConfig::CreepConfig(const CreepConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.creep_distance_to_stop_line_){}
    , decltype(_impl_.stop_distance_){}
    , decltype(_impl_.speed_limit_){}
    , decltype(_impl_.max_valid_stop_distance_){}
    , decltype(_impl_.min_boundary_t_){}
    , decltype(_impl_.min_boundary_s_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enabled_, &from._impl_.enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.min_boundary_s_) -
    reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.min_boundary_s_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.CreepConfig)
}

inline void CreepConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.creep_distance_to_stop_line_){1}
    , decltype(_impl_.stop_distance_){0.5}
    , decltype(_impl_.speed_limit_){1}
    , decltype(_impl_.max_valid_stop_distance_){0.3}
    , decltype(_impl_.min_boundary_t_){6}
    , decltype(_impl_.min_boundary_s_){3}
  };
}

CreepConfig::~CreepConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.CreepConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreepConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CreepConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreepConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.CreepConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    _impl_.enabled_ = false;
    _impl_.creep_distance_to_stop_line_ = 1;
    _impl_.stop_distance_ = 0.5;
    _impl_.speed_limit_ = 1;
    _impl_.max_valid_stop_distance_ = 0.3;
    _impl_.min_boundary_t_ = 6;
    _impl_.min_boundary_s_ = 3;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreepConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double creep_distance_to_stop_line = 2 [default = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_creep_distance_to_stop_line(&has_bits);
          _impl_.creep_distance_to_stop_line_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double stop_distance = 3 [default = 0.5];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_stop_distance(&has_bits);
          _impl_.stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double speed_limit = 4 [default = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_speed_limit(&has_bits);
          _impl_.speed_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_valid_stop_distance = 5 [default = 0.3];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_max_valid_stop_distance(&has_bits);
          _impl_.max_valid_stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double min_boundary_t = 6 [default = 6];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_min_boundary_t(&has_bits);
          _impl_.min_boundary_t_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double min_boundary_s = 7 [default = 3];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_min_boundary_s(&has_bits);
          _impl_.min_boundary_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreepConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.CreepConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // optional double creep_distance_to_stop_line = 2 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_creep_distance_to_stop_line(), target);
  }

  // optional double stop_distance = 3 [default = 0.5];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_stop_distance(), target);
  }

  // optional double speed_limit = 4 [default = 1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_speed_limit(), target);
  }

  // optional double max_valid_stop_distance = 5 [default = 0.3];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_max_valid_stop_distance(), target);
  }

  // optional double min_boundary_t = 6 [default = 6];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_min_boundary_t(), target);
  }

  // optional double min_boundary_s = 7 [default = 3];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_min_boundary_s(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.CreepConfig)
  return target;
}

size_t CreepConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.CreepConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bool enabled = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional double creep_distance_to_stop_line = 2 [default = 1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double stop_distance = 3 [default = 0.5];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double speed_limit = 4 [default = 1];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double max_valid_stop_distance = 5 [default = 0.3];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double min_boundary_t = 6 [default = 6];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double min_boundary_s = 7 [default = 3];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreepConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreepConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreepConfig::GetClassData() const { return &_class_data_; }

void CreepConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreepConfig *>(to)->MergeFrom(
      static_cast<const CreepConfig &>(from));
}


void CreepConfig::MergeFrom(const CreepConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.CreepConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.enabled_ = from._impl_.enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.creep_distance_to_stop_line_ = from._impl_.creep_distance_to_stop_line_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.stop_distance_ = from._impl_.stop_distance_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.speed_limit_ = from._impl_.speed_limit_;
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.max_valid_stop_distance_ = from._impl_.max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.min_boundary_t_ = from._impl_.min_boundary_t_;
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.min_boundary_s_ = from._impl_.min_boundary_s_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreepConfig::CopyFrom(const CreepConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.CreepConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreepConfig::IsInitialized() const {
  return true;
}

void CreepConfig::InternalSwap(CreepConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
  swap(_impl_.creep_distance_to_stop_line_, other->_impl_.creep_distance_to_stop_line_);
  swap(_impl_.stop_distance_, other->_impl_.stop_distance_);
  swap(_impl_.speed_limit_, other->_impl_.speed_limit_);
  swap(_impl_.max_valid_stop_distance_, other->_impl_.max_valid_stop_distance_);
  swap(_impl_.min_boundary_t_, other->_impl_.min_boundary_t_);
  swap(_impl_.min_boundary_s_, other->_impl_.min_boundary_s_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreepConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[2]);
}

// ===================================================================

class CrosswalkConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<CrosswalkConfig>()._impl_._has_bits_);
  static void set_has_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_stop_deceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_pass_s_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_stop_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_valid_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_expand_s_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_stop_strick_l_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_stop_loose_l_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_stop_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CrosswalkConfig::CrosswalkConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.CrosswalkConfig)
}
CrosswalkConfig::CrosswalkConfig(const CrosswalkConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_distance_){}
    , decltype(_impl_.max_stop_deceleration_){}
    , decltype(_impl_.min_pass_s_distance_){}
    , decltype(_impl_.max_stop_speed_){}
    , decltype(_impl_.max_valid_stop_distance_){}
    , decltype(_impl_.expand_s_distance_){}
    , decltype(_impl_.stop_strick_l_distance_){}
    , decltype(_impl_.stop_loose_l_distance_){}
    , decltype(_impl_.stop_timeout_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.stop_distance_, &from._impl_.stop_distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stop_timeout_) -
    reinterpret_cast<char*>(&_impl_.stop_distance_)) + sizeof(_impl_.stop_timeout_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.CrosswalkConfig)
}

inline void CrosswalkConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_distance_){1}
    , decltype(_impl_.max_stop_deceleration_){6}
    , decltype(_impl_.min_pass_s_distance_){1}
    , decltype(_impl_.max_stop_speed_){0.3}
    , decltype(_impl_.max_valid_stop_distance_){3}
    , decltype(_impl_.expand_s_distance_){2}
    , decltype(_impl_.stop_strick_l_distance_){4}
    , decltype(_impl_.stop_loose_l_distance_){5}
    , decltype(_impl_.stop_timeout_){10}
  };
}

CrosswalkConfig::~CrosswalkConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.CrosswalkConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CrosswalkConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CrosswalkConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CrosswalkConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.CrosswalkConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    _impl_.stop_distance_ = 1;
    _impl_.max_stop_deceleration_ = 6;
    _impl_.min_pass_s_distance_ = 1;
    _impl_.max_stop_speed_ = 0.3;
    _impl_.max_valid_stop_distance_ = 3;
    _impl_.expand_s_distance_ = 2;
    _impl_.stop_strick_l_distance_ = 4;
    _impl_.stop_loose_l_distance_ = 5;
  }
  _impl_.stop_timeout_ = 10;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CrosswalkConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double stop_distance = 1 [default = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_stop_distance(&has_bits);
          _impl_.stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_stop_deceleration = 2 [default = 6];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_max_stop_deceleration(&has_bits);
          _impl_.max_stop_deceleration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double min_pass_s_distance = 3 [default = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_min_pass_s_distance(&has_bits);
          _impl_.min_pass_s_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_stop_speed = 4 [default = 0.3];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_max_stop_speed(&has_bits);
          _impl_.max_stop_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_valid_stop_distance = 5 [default = 3];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_max_valid_stop_distance(&has_bits);
          _impl_.max_valid_stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double expand_s_distance = 6 [default = 2];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_expand_s_distance(&has_bits);
          _impl_.expand_s_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double stop_strick_l_distance = 7 [default = 4];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_stop_strick_l_distance(&has_bits);
          _impl_.stop_strick_l_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double stop_loose_l_distance = 8 [default = 5];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_stop_loose_l_distance(&has_bits);
          _impl_.stop_loose_l_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double stop_timeout = 9 [default = 10];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_stop_timeout(&has_bits);
          _impl_.stop_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CrosswalkConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.CrosswalkConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double stop_distance = 1 [default = 1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_stop_distance(), target);
  }

  // optional double max_stop_deceleration = 2 [default = 6];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_max_stop_deceleration(), target);
  }

  // optional double min_pass_s_distance = 3 [default = 1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_min_pass_s_distance(), target);
  }

  // optional double max_stop_speed = 4 [default = 0.3];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_max_stop_speed(), target);
  }

  // optional double max_valid_stop_distance = 5 [default = 3];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_max_valid_stop_distance(), target);
  }

  // optional double expand_s_distance = 6 [default = 2];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_expand_s_distance(), target);
  }

  // optional double stop_strick_l_distance = 7 [default = 4];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_stop_strick_l_distance(), target);
  }

  // optional double stop_loose_l_distance = 8 [default = 5];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_stop_loose_l_distance(), target);
  }

  // optional double stop_timeout = 9 [default = 10];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_stop_timeout(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.CrosswalkConfig)
  return target;
}

size_t CrosswalkConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.CrosswalkConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double stop_distance = 1 [default = 1];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double max_stop_deceleration = 2 [default = 6];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double min_pass_s_distance = 3 [default = 1];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double max_stop_speed = 4 [default = 0.3];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double max_valid_stop_distance = 5 [default = 3];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double expand_s_distance = 6 [default = 2];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double stop_strick_l_distance = 7 [default = 4];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double stop_loose_l_distance = 8 [default = 5];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  // optional double stop_timeout = 9 [default = 10];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CrosswalkConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CrosswalkConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CrosswalkConfig::GetClassData() const { return &_class_data_; }

void CrosswalkConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CrosswalkConfig *>(to)->MergeFrom(
      static_cast<const CrosswalkConfig &>(from));
}


void CrosswalkConfig::MergeFrom(const CrosswalkConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.CrosswalkConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stop_distance_ = from._impl_.stop_distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.max_stop_deceleration_ = from._impl_.max_stop_deceleration_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.min_pass_s_distance_ = from._impl_.min_pass_s_distance_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.max_stop_speed_ = from._impl_.max_stop_speed_;
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.max_valid_stop_distance_ = from._impl_.max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.expand_s_distance_ = from._impl_.expand_s_distance_;
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.stop_strick_l_distance_ = from._impl_.stop_strick_l_distance_;
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.stop_loose_l_distance_ = from._impl_.stop_loose_l_distance_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_stop_timeout(from._internal_stop_timeout());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CrosswalkConfig::CopyFrom(const CrosswalkConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.CrosswalkConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrosswalkConfig::IsInitialized() const {
  return true;
}

void CrosswalkConfig::InternalSwap(CrosswalkConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stop_distance_, other->_impl_.stop_distance_);
  swap(_impl_.max_stop_deceleration_, other->_impl_.max_stop_deceleration_);
  swap(_impl_.min_pass_s_distance_, other->_impl_.min_pass_s_distance_);
  swap(_impl_.max_stop_speed_, other->_impl_.max_stop_speed_);
  swap(_impl_.max_valid_stop_distance_, other->_impl_.max_valid_stop_distance_);
  swap(_impl_.expand_s_distance_, other->_impl_.expand_s_distance_);
  swap(_impl_.stop_strick_l_distance_, other->_impl_.stop_strick_l_distance_);
  swap(_impl_.stop_loose_l_distance_, other->_impl_.stop_loose_l_distance_);
  swap(_impl_.stop_timeout_, other->_impl_.stop_timeout_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CrosswalkConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[3]);
}

// ===================================================================

class DestinationConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<DestinationConfig>()._impl_._has_bits_);
  static void set_has_enable_pull_over(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pull_over_plan_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

DestinationConfig::DestinationConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.DestinationConfig)
}
DestinationConfig::DestinationConfig(const DestinationConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_pull_over_){}
    , decltype(_impl_.stop_distance_){}
    , decltype(_impl_.pull_over_plan_distance_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enable_pull_over_, &from._impl_.enable_pull_over_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pull_over_plan_distance_) -
    reinterpret_cast<char*>(&_impl_.enable_pull_over_)) + sizeof(_impl_.pull_over_plan_distance_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.DestinationConfig)
}

inline void DestinationConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_pull_over_){false}
    , decltype(_impl_.stop_distance_){0.5}
    , decltype(_impl_.pull_over_plan_distance_){35}
  };
}

DestinationConfig::~DestinationConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.DestinationConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DestinationConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DestinationConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DestinationConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.DestinationConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    _impl_.enable_pull_over_ = false;
    _impl_.stop_distance_ = 0.5;
    _impl_.pull_over_plan_distance_ = 35;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DestinationConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enable_pull_over = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enable_pull_over(&has_bits);
          _impl_.enable_pull_over_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double stop_distance = 2 [default = 0.5];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_stop_distance(&has_bits);
          _impl_.stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double pull_over_plan_distance = 3 [default = 35];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_pull_over_plan_distance(&has_bits);
          _impl_.pull_over_plan_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DestinationConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.DestinationConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enable_pull_over = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enable_pull_over(), target);
  }

  // optional double stop_distance = 2 [default = 0.5];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_stop_distance(), target);
  }

  // optional double pull_over_plan_distance = 3 [default = 35];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_pull_over_plan_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.DestinationConfig)
  return target;
}

size_t DestinationConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.DestinationConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool enable_pull_over = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional double stop_distance = 2 [default = 0.5];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double pull_over_plan_distance = 3 [default = 35];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DestinationConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DestinationConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DestinationConfig::GetClassData() const { return &_class_data_; }

void DestinationConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DestinationConfig *>(to)->MergeFrom(
      static_cast<const DestinationConfig &>(from));
}


void DestinationConfig::MergeFrom(const DestinationConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.DestinationConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.enable_pull_over_ = from._impl_.enable_pull_over_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.stop_distance_ = from._impl_.stop_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.pull_over_plan_distance_ = from._impl_.pull_over_plan_distance_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DestinationConfig::CopyFrom(const DestinationConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.DestinationConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DestinationConfig::IsInitialized() const {
  return true;
}

void DestinationConfig::InternalSwap(DestinationConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enable_pull_over_, other->_impl_.enable_pull_over_);
  swap(_impl_.stop_distance_, other->_impl_.stop_distance_);
  swap(_impl_.pull_over_plan_distance_, other->_impl_.pull_over_plan_distance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DestinationConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[4]);
}

// ===================================================================

class FrontVehicleConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<FrontVehicleConfig>()._impl_._has_bits_);
  static void set_has_enable_side_pass(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_side_pass_s_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_side_pass_l_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_side_pass_wait_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nudge_l_buffer(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

FrontVehicleConfig::FrontVehicleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.FrontVehicleConfig)
}
FrontVehicleConfig::FrontVehicleConfig(const FrontVehicleConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_side_pass_){}
    , decltype(_impl_.side_pass_s_threshold_){}
    , decltype(_impl_.side_pass_l_threshold_){}
    , decltype(_impl_.side_pass_wait_time_){}
    , decltype(_impl_.nudge_l_buffer_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enable_side_pass_, &from._impl_.enable_side_pass_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nudge_l_buffer_) -
    reinterpret_cast<char*>(&_impl_.enable_side_pass_)) + sizeof(_impl_.nudge_l_buffer_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.FrontVehicleConfig)
}

inline void FrontVehicleConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_side_pass_){true}
    , decltype(_impl_.side_pass_s_threshold_){15}
    , decltype(_impl_.side_pass_l_threshold_){1}
    , decltype(_impl_.side_pass_wait_time_){30}
    , decltype(_impl_.nudge_l_buffer_){0.5}
  };
}

FrontVehicleConfig::~FrontVehicleConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.FrontVehicleConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FrontVehicleConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FrontVehicleConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FrontVehicleConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.FrontVehicleConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    _impl_.enable_side_pass_ = true;
    _impl_.side_pass_s_threshold_ = 15;
    _impl_.side_pass_l_threshold_ = 1;
    _impl_.side_pass_wait_time_ = 30;
    _impl_.nudge_l_buffer_ = 0.5;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrontVehicleConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enable_side_pass = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enable_side_pass(&has_bits);
          _impl_.enable_side_pass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double side_pass_s_threshold = 2 [default = 15];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_side_pass_s_threshold(&has_bits);
          _impl_.side_pass_s_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double side_pass_l_threshold = 3 [default = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_side_pass_l_threshold(&has_bits);
          _impl_.side_pass_l_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double side_pass_wait_time = 4 [default = 30];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_side_pass_wait_time(&has_bits);
          _impl_.side_pass_wait_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double nudge_l_buffer = 5 [default = 0.5];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_nudge_l_buffer(&has_bits);
          _impl_.nudge_l_buffer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FrontVehicleConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.FrontVehicleConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enable_side_pass = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enable_side_pass(), target);
  }

  // optional double side_pass_s_threshold = 2 [default = 15];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_side_pass_s_threshold(), target);
  }

  // optional double side_pass_l_threshold = 3 [default = 1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_side_pass_l_threshold(), target);
  }

  // optional double side_pass_wait_time = 4 [default = 30];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_side_pass_wait_time(), target);
  }

  // optional double nudge_l_buffer = 5 [default = 0.5];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_nudge_l_buffer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.FrontVehicleConfig)
  return target;
}

size_t FrontVehicleConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.FrontVehicleConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bool enable_side_pass = 1 [default = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional double side_pass_s_threshold = 2 [default = 15];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double side_pass_l_threshold = 3 [default = 1];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double side_pass_wait_time = 4 [default = 30];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double nudge_l_buffer = 5 [default = 0.5];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrontVehicleConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FrontVehicleConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrontVehicleConfig::GetClassData() const { return &_class_data_; }

void FrontVehicleConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FrontVehicleConfig *>(to)->MergeFrom(
      static_cast<const FrontVehicleConfig &>(from));
}


void FrontVehicleConfig::MergeFrom(const FrontVehicleConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.FrontVehicleConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.enable_side_pass_ = from._impl_.enable_side_pass_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.side_pass_s_threshold_ = from._impl_.side_pass_s_threshold_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.side_pass_l_threshold_ = from._impl_.side_pass_l_threshold_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.side_pass_wait_time_ = from._impl_.side_pass_wait_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.nudge_l_buffer_ = from._impl_.nudge_l_buffer_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FrontVehicleConfig::CopyFrom(const FrontVehicleConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.FrontVehicleConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrontVehicleConfig::IsInitialized() const {
  return true;
}

void FrontVehicleConfig::InternalSwap(FrontVehicleConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enable_side_pass_, other->_impl_.enable_side_pass_);
  swap(_impl_.side_pass_s_threshold_, other->_impl_.side_pass_s_threshold_);
  swap(_impl_.side_pass_l_threshold_, other->_impl_.side_pass_l_threshold_);
  swap(_impl_.side_pass_wait_time_, other->_impl_.side_pass_wait_time_);
  swap(_impl_.nudge_l_buffer_, other->_impl_.nudge_l_buffer_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FrontVehicleConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[5]);
}

// ===================================================================

class KeepClearConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<KeepClearConfig>()._impl_._has_bits_);
  static void set_has_enable_keep_clear_zone(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enable_junction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_pass_s_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KeepClearConfig::KeepClearConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.KeepClearConfig)
}
KeepClearConfig::KeepClearConfig(const KeepClearConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_keep_clear_zone_){}
    , decltype(_impl_.enable_junction_){}
    , decltype(_impl_.min_pass_s_distance_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enable_keep_clear_zone_, &from._impl_.enable_keep_clear_zone_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.min_pass_s_distance_) -
    reinterpret_cast<char*>(&_impl_.enable_keep_clear_zone_)) + sizeof(_impl_.min_pass_s_distance_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.KeepClearConfig)
}

inline void KeepClearConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_keep_clear_zone_){true}
    , decltype(_impl_.enable_junction_){true}
    , decltype(_impl_.min_pass_s_distance_){2}
  };
}

KeepClearConfig::~KeepClearConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.KeepClearConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeepClearConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KeepClearConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeepClearConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.KeepClearConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    _impl_.enable_keep_clear_zone_ = true;
    _impl_.enable_junction_ = true;
    _impl_.min_pass_s_distance_ = 2;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeepClearConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enable_keep_clear_zone = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enable_keep_clear_zone(&has_bits);
          _impl_.enable_keep_clear_zone_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_junction = 2 [default = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_enable_junction(&has_bits);
          _impl_.enable_junction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double min_pass_s_distance = 3 [default = 2];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_min_pass_s_distance(&has_bits);
          _impl_.min_pass_s_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeepClearConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.KeepClearConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enable_keep_clear_zone = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enable_keep_clear_zone(), target);
  }

  // optional bool enable_junction = 2 [default = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_enable_junction(), target);
  }

  // optional double min_pass_s_distance = 3 [default = 2];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_min_pass_s_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.KeepClearConfig)
  return target;
}

size_t KeepClearConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.KeepClearConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool enable_keep_clear_zone = 1 [default = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool enable_junction = 2 [default = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional double min_pass_s_distance = 3 [default = 2];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeepClearConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KeepClearConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeepClearConfig::GetClassData() const { return &_class_data_; }

void KeepClearConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KeepClearConfig *>(to)->MergeFrom(
      static_cast<const KeepClearConfig &>(from));
}


void KeepClearConfig::MergeFrom(const KeepClearConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.KeepClearConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.enable_keep_clear_zone_ = from._impl_.enable_keep_clear_zone_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.enable_junction_ = from._impl_.enable_junction_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.min_pass_s_distance_ = from._impl_.min_pass_s_distance_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeepClearConfig::CopyFrom(const KeepClearConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.KeepClearConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeepClearConfig::IsInitialized() const {
  return true;
}

void KeepClearConfig::InternalSwap(KeepClearConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enable_keep_clear_zone_, other->_impl_.enable_keep_clear_zone_);
  swap(_impl_.enable_junction_, other->_impl_.enable_junction_);
  swap(_impl_.min_pass_s_distance_, other->_impl_.min_pass_s_distance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KeepClearConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[6]);
}

// ===================================================================

class PullOverConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<PullOverConfig>()._impl_._has_bits_);
  static void set_has_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_stop_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_valid_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_buffer_to_boundary(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_plan_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_operation_length(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_max_check_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_max_failure_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PullOverConfig::PullOverConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.PullOverConfig)
}
PullOverConfig::PullOverConfig(const PullOverConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.max_failure_count_){}
    , decltype(_impl_.stop_distance_){}
    , decltype(_impl_.max_stop_speed_){}
    , decltype(_impl_.max_valid_stop_distance_){}
    , decltype(_impl_.buffer_to_boundary_){}
    , decltype(_impl_.plan_distance_){}
    , decltype(_impl_.operation_length_){}
    , decltype(_impl_.max_check_distance_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.max_failure_count_, &from._impl_.max_failure_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_check_distance_) -
    reinterpret_cast<char*>(&_impl_.max_failure_count_)) + sizeof(_impl_.max_check_distance_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.PullOverConfig)
}

inline void PullOverConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.max_failure_count_){10u}
    , decltype(_impl_.stop_distance_){0.5}
    , decltype(_impl_.max_stop_speed_){0.3}
    , decltype(_impl_.max_valid_stop_distance_){3}
    , decltype(_impl_.buffer_to_boundary_){0.5}
    , decltype(_impl_.plan_distance_){35}
    , decltype(_impl_.operation_length_){30}
    , decltype(_impl_.max_check_distance_){60}
  };
}

PullOverConfig::~PullOverConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.PullOverConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PullOverConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PullOverConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PullOverConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.PullOverConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    _impl_.max_failure_count_ = 10u;
    _impl_.stop_distance_ = 0.5;
    _impl_.max_stop_speed_ = 0.3;
    _impl_.max_valid_stop_distance_ = 3;
    _impl_.buffer_to_boundary_ = 0.5;
    _impl_.plan_distance_ = 35;
    _impl_.operation_length_ = 30;
    _impl_.max_check_distance_ = 60;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PullOverConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double stop_distance = 1 [default = 0.5];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_stop_distance(&has_bits);
          _impl_.stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_stop_speed = 2 [default = 0.3];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_max_stop_speed(&has_bits);
          _impl_.max_stop_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_valid_stop_distance = 3 [default = 3];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_max_valid_stop_distance(&has_bits);
          _impl_.max_valid_stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double buffer_to_boundary = 4 [default = 0.5];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_buffer_to_boundary(&has_bits);
          _impl_.buffer_to_boundary_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double plan_distance = 5 [default = 35];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_plan_distance(&has_bits);
          _impl_.plan_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double operation_length = 6 [default = 30];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_operation_length(&has_bits);
          _impl_.operation_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_check_distance = 7 [default = 60];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_max_check_distance(&has_bits);
          _impl_.max_check_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_failure_count = 8 [default = 10];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_max_failure_count(&has_bits);
          _impl_.max_failure_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PullOverConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.PullOverConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double stop_distance = 1 [default = 0.5];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_stop_distance(), target);
  }

  // optional double max_stop_speed = 2 [default = 0.3];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_max_stop_speed(), target);
  }

  // optional double max_valid_stop_distance = 3 [default = 3];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_max_valid_stop_distance(), target);
  }

  // optional double buffer_to_boundary = 4 [default = 0.5];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_buffer_to_boundary(), target);
  }

  // optional double plan_distance = 5 [default = 35];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_plan_distance(), target);
  }

  // optional double operation_length = 6 [default = 30];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_operation_length(), target);
  }

  // optional double max_check_distance = 7 [default = 60];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_max_check_distance(), target);
  }

  // optional uint32 max_failure_count = 8 [default = 10];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_max_failure_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.PullOverConfig)
  return target;
}

size_t PullOverConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.PullOverConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 max_failure_count = 8 [default = 10];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_failure_count());
    }

    // optional double stop_distance = 1 [default = 0.5];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double max_stop_speed = 2 [default = 0.3];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double max_valid_stop_distance = 3 [default = 3];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double buffer_to_boundary = 4 [default = 0.5];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double plan_distance = 5 [default = 35];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double operation_length = 6 [default = 30];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double max_check_distance = 7 [default = 60];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PullOverConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PullOverConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PullOverConfig::GetClassData() const { return &_class_data_; }

void PullOverConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PullOverConfig *>(to)->MergeFrom(
      static_cast<const PullOverConfig &>(from));
}


void PullOverConfig::MergeFrom(const PullOverConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.PullOverConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.max_failure_count_ = from._impl_.max_failure_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.stop_distance_ = from._impl_.stop_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.max_stop_speed_ = from._impl_.max_stop_speed_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.max_valid_stop_distance_ = from._impl_.max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.buffer_to_boundary_ = from._impl_.buffer_to_boundary_;
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.plan_distance_ = from._impl_.plan_distance_;
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.operation_length_ = from._impl_.operation_length_;
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.max_check_distance_ = from._impl_.max_check_distance_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PullOverConfig::CopyFrom(const PullOverConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.PullOverConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PullOverConfig::IsInitialized() const {
  return true;
}

void PullOverConfig::InternalSwap(PullOverConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.max_failure_count_, other->_impl_.max_failure_count_);
  swap(_impl_.stop_distance_, other->_impl_.stop_distance_);
  swap(_impl_.max_stop_speed_, other->_impl_.max_stop_speed_);
  swap(_impl_.max_valid_stop_distance_, other->_impl_.max_valid_stop_distance_);
  swap(_impl_.buffer_to_boundary_, other->_impl_.buffer_to_boundary_);
  swap(_impl_.plan_distance_, other->_impl_.plan_distance_);
  swap(_impl_.operation_length_, other->_impl_.operation_length_);
  swap(_impl_.max_check_distance_, other->_impl_.max_check_distance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PullOverConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[7]);
}

// ===================================================================

class ReferenceLineEndConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<ReferenceLineEndConfig>()._impl_._has_bits_);
  static void set_has_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_min_reference_line_remain_length(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ReferenceLineEndConfig::ReferenceLineEndConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.ReferenceLineEndConfig)
}
ReferenceLineEndConfig::ReferenceLineEndConfig(const ReferenceLineEndConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_distance_){}
    , decltype(_impl_.min_reference_line_remain_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.stop_distance_, &from._impl_.stop_distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.min_reference_line_remain_length_) -
    reinterpret_cast<char*>(&_impl_.stop_distance_)) + sizeof(_impl_.min_reference_line_remain_length_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.ReferenceLineEndConfig)
}

inline void ReferenceLineEndConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_distance_){0.5}
    , decltype(_impl_.min_reference_line_remain_length_){50}
  };
}

ReferenceLineEndConfig::~ReferenceLineEndConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.ReferenceLineEndConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReferenceLineEndConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReferenceLineEndConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReferenceLineEndConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.ReferenceLineEndConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.stop_distance_ = 0.5;
    _impl_.min_reference_line_remain_length_ = 50;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReferenceLineEndConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double stop_distance = 1 [default = 0.5];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_stop_distance(&has_bits);
          _impl_.stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double min_reference_line_remain_length = 2 [default = 50];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_min_reference_line_remain_length(&has_bits);
          _impl_.min_reference_line_remain_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReferenceLineEndConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.ReferenceLineEndConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double stop_distance = 1 [default = 0.5];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_stop_distance(), target);
  }

  // optional double min_reference_line_remain_length = 2 [default = 50];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_min_reference_line_remain_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.ReferenceLineEndConfig)
  return target;
}

size_t ReferenceLineEndConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.ReferenceLineEndConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double stop_distance = 1 [default = 0.5];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double min_reference_line_remain_length = 2 [default = 50];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReferenceLineEndConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ReferenceLineEndConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReferenceLineEndConfig::GetClassData() const { return &_class_data_; }

void ReferenceLineEndConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ReferenceLineEndConfig *>(to)->MergeFrom(
      static_cast<const ReferenceLineEndConfig &>(from));
}


void ReferenceLineEndConfig::MergeFrom(const ReferenceLineEndConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.ReferenceLineEndConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stop_distance_ = from._impl_.stop_distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.min_reference_line_remain_length_ = from._impl_.min_reference_line_remain_length_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReferenceLineEndConfig::CopyFrom(const ReferenceLineEndConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.ReferenceLineEndConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReferenceLineEndConfig::IsInitialized() const {
  return true;
}

void ReferenceLineEndConfig::InternalSwap(ReferenceLineEndConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stop_distance_, other->_impl_.stop_distance_);
  swap(_impl_.min_reference_line_remain_length_, other->_impl_.min_reference_line_remain_length_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReferenceLineEndConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[8]);
}

// ===================================================================

class ReroutingConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<ReroutingConfig>()._impl_._has_bits_);
  static void set_has_cooldown_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prepare_rerouting_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ReroutingConfig::ReroutingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.ReroutingConfig)
}
ReroutingConfig::ReroutingConfig(const ReroutingConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cooldown_time_){}
    , decltype(_impl_.prepare_rerouting_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.cooldown_time_, &from._impl_.cooldown_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prepare_rerouting_time_) -
    reinterpret_cast<char*>(&_impl_.cooldown_time_)) + sizeof(_impl_.prepare_rerouting_time_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.ReroutingConfig)
}

inline void ReroutingConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cooldown_time_){3}
    , decltype(_impl_.prepare_rerouting_time_){2}
  };
}

ReroutingConfig::~ReroutingConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.ReroutingConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReroutingConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReroutingConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReroutingConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.ReroutingConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.cooldown_time_ = 3;
    _impl_.prepare_rerouting_time_ = 2;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReroutingConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double cooldown_time = 1 [default = 3];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_cooldown_time(&has_bits);
          _impl_.cooldown_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double prepare_rerouting_time = 2 [default = 2];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_prepare_rerouting_time(&has_bits);
          _impl_.prepare_rerouting_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReroutingConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.ReroutingConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double cooldown_time = 1 [default = 3];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_cooldown_time(), target);
  }

  // optional double prepare_rerouting_time = 2 [default = 2];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_prepare_rerouting_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.ReroutingConfig)
  return target;
}

size_t ReroutingConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.ReroutingConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double cooldown_time = 1 [default = 3];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double prepare_rerouting_time = 2 [default = 2];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReroutingConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ReroutingConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReroutingConfig::GetClassData() const { return &_class_data_; }

void ReroutingConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ReroutingConfig *>(to)->MergeFrom(
      static_cast<const ReroutingConfig &>(from));
}


void ReroutingConfig::MergeFrom(const ReroutingConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.ReroutingConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.cooldown_time_ = from._impl_.cooldown_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.prepare_rerouting_time_ = from._impl_.prepare_rerouting_time_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReroutingConfig::CopyFrom(const ReroutingConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.ReroutingConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReroutingConfig::IsInitialized() const {
  return true;
}

void ReroutingConfig::InternalSwap(ReroutingConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.cooldown_time_, other->_impl_.cooldown_time_);
  swap(_impl_.prepare_rerouting_time_, other->_impl_.prepare_rerouting_time_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReroutingConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[9]);
}

// ===================================================================

class SignalLightConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<SignalLightConfig>()._impl_._has_bits_);
  static void set_has_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_stop_deceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_min_pass_s_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_stop_deacceleration_yellow_light(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_signal_expire_time_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::apollo::planning::CreepConfig& righ_turn_creep(const SignalLightConfig* msg);
  static void set_has_righ_turn_creep(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::apollo::planning::CreepConfig&
SignalLightConfig::_Internal::righ_turn_creep(const SignalLightConfig* msg) {
  return *msg->_impl_.righ_turn_creep_;
}
SignalLightConfig::SignalLightConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.SignalLightConfig)
}
SignalLightConfig::SignalLightConfig(const SignalLightConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.righ_turn_creep_){nullptr}
    , decltype(_impl_.stop_distance_){}
    , decltype(_impl_.max_stop_deceleration_){}
    , decltype(_impl_.min_pass_s_distance_){}
    , decltype(_impl_.max_stop_deacceleration_yellow_light_){}
    , decltype(_impl_.signal_expire_time_sec_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_righ_turn_creep()) {
    _impl_.righ_turn_creep_ = new ::apollo::planning::CreepConfig(*from._impl_.righ_turn_creep_);
  }
  ::memcpy(&_impl_.stop_distance_, &from._impl_.stop_distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.signal_expire_time_sec_) -
    reinterpret_cast<char*>(&_impl_.stop_distance_)) + sizeof(_impl_.signal_expire_time_sec_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.SignalLightConfig)
}

inline void SignalLightConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.righ_turn_creep_){nullptr}
    , decltype(_impl_.stop_distance_){1}
    , decltype(_impl_.max_stop_deceleration_){6}
    , decltype(_impl_.min_pass_s_distance_){4}
    , decltype(_impl_.max_stop_deacceleration_yellow_light_){3}
    , decltype(_impl_.signal_expire_time_sec_){5}
  };
}

SignalLightConfig::~SignalLightConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.SignalLightConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignalLightConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.righ_turn_creep_;
}

void SignalLightConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignalLightConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.SignalLightConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.righ_turn_creep_ != nullptr);
      _impl_.righ_turn_creep_->Clear();
    }
    _impl_.stop_distance_ = 1;
    _impl_.max_stop_deceleration_ = 6;
    _impl_.min_pass_s_distance_ = 4;
    _impl_.max_stop_deacceleration_yellow_light_ = 3;
    _impl_.signal_expire_time_sec_ = 5;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignalLightConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double stop_distance = 1 [default = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_stop_distance(&has_bits);
          _impl_.stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_stop_deceleration = 2 [default = 6];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_max_stop_deceleration(&has_bits);
          _impl_.max_stop_deceleration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double min_pass_s_distance = 3 [default = 4];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_min_pass_s_distance(&has_bits);
          _impl_.min_pass_s_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_stop_deacceleration_yellow_light = 4 [default = 3];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_max_stop_deacceleration_yellow_light(&has_bits);
          _impl_.max_stop_deacceleration_yellow_light_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double signal_expire_time_sec = 5 [default = 5];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_signal_expire_time_sec(&has_bits);
          _impl_.signal_expire_time_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.CreepConfig righ_turn_creep = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_righ_turn_creep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignalLightConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.SignalLightConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double stop_distance = 1 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_stop_distance(), target);
  }

  // optional double max_stop_deceleration = 2 [default = 6];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_max_stop_deceleration(), target);
  }

  // optional double min_pass_s_distance = 3 [default = 4];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_min_pass_s_distance(), target);
  }

  // optional double max_stop_deacceleration_yellow_light = 4 [default = 3];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_max_stop_deacceleration_yellow_light(), target);
  }

  // optional double signal_expire_time_sec = 5 [default = 5];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_signal_expire_time_sec(), target);
  }

  // optional .apollo.planning.CreepConfig righ_turn_creep = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::righ_turn_creep(this),
        _Internal::righ_turn_creep(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.SignalLightConfig)
  return target;
}

size_t SignalLightConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.SignalLightConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .apollo.planning.CreepConfig righ_turn_creep = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.righ_turn_creep_);
    }

    // optional double stop_distance = 1 [default = 1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double max_stop_deceleration = 2 [default = 6];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double min_pass_s_distance = 3 [default = 4];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double max_stop_deacceleration_yellow_light = 4 [default = 3];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double signal_expire_time_sec = 5 [default = 5];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignalLightConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SignalLightConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignalLightConfig::GetClassData() const { return &_class_data_; }

void SignalLightConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SignalLightConfig *>(to)->MergeFrom(
      static_cast<const SignalLightConfig &>(from));
}


void SignalLightConfig::MergeFrom(const SignalLightConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.SignalLightConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_righ_turn_creep()->::apollo::planning::CreepConfig::MergeFrom(from._internal_righ_turn_creep());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.stop_distance_ = from._impl_.stop_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.max_stop_deceleration_ = from._impl_.max_stop_deceleration_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.min_pass_s_distance_ = from._impl_.min_pass_s_distance_;
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.max_stop_deacceleration_yellow_light_ = from._impl_.max_stop_deacceleration_yellow_light_;
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.signal_expire_time_sec_ = from._impl_.signal_expire_time_sec_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignalLightConfig::CopyFrom(const SignalLightConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.SignalLightConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignalLightConfig::IsInitialized() const {
  return true;
}

void SignalLightConfig::InternalSwap(SignalLightConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.righ_turn_creep_, other->_impl_.righ_turn_creep_);
  swap(_impl_.stop_distance_, other->_impl_.stop_distance_);
  swap(_impl_.max_stop_deceleration_, other->_impl_.max_stop_deceleration_);
  swap(_impl_.min_pass_s_distance_, other->_impl_.min_pass_s_distance_);
  swap(_impl_.max_stop_deacceleration_yellow_light_, other->_impl_.max_stop_deacceleration_yellow_light_);
  swap(_impl_.signal_expire_time_sec_, other->_impl_.signal_expire_time_sec_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SignalLightConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[10]);
}

// ===================================================================

class StopSignConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<StopSignConfig>()._impl_._has_bits_);
  static void set_has_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_pass_s_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_stop_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_valid_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_stop_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_watch_vehicle_max_valid_stop_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_watch_vehicle_max_valid_stop_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_wait_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::apollo::planning::CreepConfig& creep(const StopSignConfig* msg);
  static void set_has_creep(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::apollo::planning::CreepConfig&
StopSignConfig::_Internal::creep(const StopSignConfig* msg) {
  return *msg->_impl_.creep_;
}
StopSignConfig::StopSignConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.StopSignConfig)
}
StopSignConfig::StopSignConfig(const StopSignConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.creep_){nullptr}
    , decltype(_impl_.stop_distance_){}
    , decltype(_impl_.min_pass_s_distance_){}
    , decltype(_impl_.max_stop_speed_){}
    , decltype(_impl_.max_valid_stop_distance_){}
    , decltype(_impl_.stop_duration_){}
    , decltype(_impl_.watch_vehicle_max_valid_stop_speed_){}
    , decltype(_impl_.watch_vehicle_max_valid_stop_distance_){}
    , decltype(_impl_.wait_timeout_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_creep()) {
    _impl_.creep_ = new ::apollo::planning::CreepConfig(*from._impl_.creep_);
  }
  ::memcpy(&_impl_.stop_distance_, &from._impl_.stop_distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.wait_timeout_) -
    reinterpret_cast<char*>(&_impl_.stop_distance_)) + sizeof(_impl_.wait_timeout_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.StopSignConfig)
}

inline void StopSignConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.creep_){nullptr}
    , decltype(_impl_.stop_distance_){1}
    , decltype(_impl_.min_pass_s_distance_){1}
    , decltype(_impl_.max_stop_speed_){0.3}
    , decltype(_impl_.max_valid_stop_distance_){3}
    , decltype(_impl_.stop_duration_){1}
    , decltype(_impl_.watch_vehicle_max_valid_stop_speed_){0.5}
    , decltype(_impl_.watch_vehicle_max_valid_stop_distance_){5}
    , decltype(_impl_.wait_timeout_){8}
  };
}

StopSignConfig::~StopSignConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.StopSignConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StopSignConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.creep_;
}

void StopSignConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StopSignConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.StopSignConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.creep_ != nullptr);
      _impl_.creep_->Clear();
    }
    _impl_.stop_distance_ = 1;
    _impl_.min_pass_s_distance_ = 1;
    _impl_.max_stop_speed_ = 0.3;
    _impl_.max_valid_stop_distance_ = 3;
    _impl_.stop_duration_ = 1;
    _impl_.watch_vehicle_max_valid_stop_speed_ = 0.5;
    _impl_.watch_vehicle_max_valid_stop_distance_ = 5;
  }
  _impl_.wait_timeout_ = 8;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StopSignConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double stop_distance = 1 [default = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_stop_distance(&has_bits);
          _impl_.stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double min_pass_s_distance = 2 [default = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_min_pass_s_distance(&has_bits);
          _impl_.min_pass_s_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_stop_speed = 3 [default = 0.3];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_max_stop_speed(&has_bits);
          _impl_.max_stop_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_valid_stop_distance = 4 [default = 3];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_max_valid_stop_distance(&has_bits);
          _impl_.max_valid_stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double stop_duration = 5 [default = 1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_stop_duration(&has_bits);
          _impl_.stop_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double watch_vehicle_max_valid_stop_speed = 6 [default = 0.5];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_watch_vehicle_max_valid_stop_speed(&has_bits);
          _impl_.watch_vehicle_max_valid_stop_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double watch_vehicle_max_valid_stop_distance = 7 [default = 5];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_watch_vehicle_max_valid_stop_distance(&has_bits);
          _impl_.watch_vehicle_max_valid_stop_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double wait_timeout = 8 [default = 8];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_wait_timeout(&has_bits);
          _impl_.wait_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.CreepConfig creep = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_creep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StopSignConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.StopSignConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double stop_distance = 1 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_stop_distance(), target);
  }

  // optional double min_pass_s_distance = 2 [default = 1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_min_pass_s_distance(), target);
  }

  // optional double max_stop_speed = 3 [default = 0.3];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_max_stop_speed(), target);
  }

  // optional double max_valid_stop_distance = 4 [default = 3];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_max_valid_stop_distance(), target);
  }

  // optional double stop_duration = 5 [default = 1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_stop_duration(), target);
  }

  // optional double watch_vehicle_max_valid_stop_speed = 6 [default = 0.5];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_watch_vehicle_max_valid_stop_speed(), target);
  }

  // optional double watch_vehicle_max_valid_stop_distance = 7 [default = 5];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_watch_vehicle_max_valid_stop_distance(), target);
  }

  // optional double wait_timeout = 8 [default = 8];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_wait_timeout(), target);
  }

  // optional .apollo.planning.CreepConfig creep = 9;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::creep(this),
        _Internal::creep(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.StopSignConfig)
  return target;
}

size_t StopSignConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.StopSignConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .apollo.planning.CreepConfig creep = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.creep_);
    }

    // optional double stop_distance = 1 [default = 1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double min_pass_s_distance = 2 [default = 1];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double max_stop_speed = 3 [default = 0.3];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double max_valid_stop_distance = 4 [default = 3];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double stop_duration = 5 [default = 1];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double watch_vehicle_max_valid_stop_speed = 6 [default = 0.5];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double watch_vehicle_max_valid_stop_distance = 7 [default = 5];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  // optional double wait_timeout = 8 [default = 8];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StopSignConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StopSignConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StopSignConfig::GetClassData() const { return &_class_data_; }

void StopSignConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StopSignConfig *>(to)->MergeFrom(
      static_cast<const StopSignConfig &>(from));
}


void StopSignConfig::MergeFrom(const StopSignConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.StopSignConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_creep()->::apollo::planning::CreepConfig::MergeFrom(from._internal_creep());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.stop_distance_ = from._impl_.stop_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.min_pass_s_distance_ = from._impl_.min_pass_s_distance_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.max_stop_speed_ = from._impl_.max_stop_speed_;
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.max_valid_stop_distance_ = from._impl_.max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.stop_duration_ = from._impl_.stop_duration_;
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.watch_vehicle_max_valid_stop_speed_ = from._impl_.watch_vehicle_max_valid_stop_speed_;
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.watch_vehicle_max_valid_stop_distance_ = from._impl_.watch_vehicle_max_valid_stop_distance_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_wait_timeout(from._internal_wait_timeout());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StopSignConfig::CopyFrom(const StopSignConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.StopSignConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopSignConfig::IsInitialized() const {
  return true;
}

void StopSignConfig::InternalSwap(StopSignConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.creep_, other->_impl_.creep_);
  swap(_impl_.stop_distance_, other->_impl_.stop_distance_);
  swap(_impl_.min_pass_s_distance_, other->_impl_.min_pass_s_distance_);
  swap(_impl_.max_stop_speed_, other->_impl_.max_stop_speed_);
  swap(_impl_.max_valid_stop_distance_, other->_impl_.max_valid_stop_distance_);
  swap(_impl_.stop_duration_, other->_impl_.stop_duration_);
  swap(_impl_.watch_vehicle_max_valid_stop_speed_, other->_impl_.watch_vehicle_max_valid_stop_speed_);
  swap(_impl_.watch_vehicle_max_valid_stop_distance_, other->_impl_.watch_vehicle_max_valid_stop_distance_);
  swap(_impl_.wait_timeout_, other->_impl_.wait_timeout_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StopSignConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[11]);
}

// ===================================================================

class TrafficRuleConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<TrafficRuleConfig>()._impl_._has_bits_);
  static void set_has_rule_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::apollo::planning::BacksideVehicleConfig& backside_vehicle(const TrafficRuleConfig* msg);
  static const ::apollo::planning::ChangeLaneConfig& change_lane(const TrafficRuleConfig* msg);
  static const ::apollo::planning::CrosswalkConfig& crosswalk(const TrafficRuleConfig* msg);
  static const ::apollo::planning::DestinationConfig& destination(const TrafficRuleConfig* msg);
  static const ::apollo::planning::FrontVehicleConfig& front_vehicle(const TrafficRuleConfig* msg);
  static const ::apollo::planning::KeepClearConfig& keep_clear(const TrafficRuleConfig* msg);
  static const ::apollo::planning::PullOverConfig& pull_over(const TrafficRuleConfig* msg);
  static const ::apollo::planning::ReferenceLineEndConfig& reference_line_end(const TrafficRuleConfig* msg);
  static const ::apollo::planning::ReroutingConfig& rerouting(const TrafficRuleConfig* msg);
  static const ::apollo::planning::SignalLightConfig& signal_light(const TrafficRuleConfig* msg);
  static const ::apollo::planning::StopSignConfig& stop_sign(const TrafficRuleConfig* msg);
};

const ::apollo::planning::BacksideVehicleConfig&
TrafficRuleConfig::_Internal::backside_vehicle(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.backside_vehicle_;
}
const ::apollo::planning::ChangeLaneConfig&
TrafficRuleConfig::_Internal::change_lane(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.change_lane_;
}
const ::apollo::planning::CrosswalkConfig&
TrafficRuleConfig::_Internal::crosswalk(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.crosswalk_;
}
const ::apollo::planning::DestinationConfig&
TrafficRuleConfig::_Internal::destination(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.destination_;
}
const ::apollo::planning::FrontVehicleConfig&
TrafficRuleConfig::_Internal::front_vehicle(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.front_vehicle_;
}
const ::apollo::planning::KeepClearConfig&
TrafficRuleConfig::_Internal::keep_clear(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.keep_clear_;
}
const ::apollo::planning::PullOverConfig&
TrafficRuleConfig::_Internal::pull_over(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.pull_over_;
}
const ::apollo::planning::ReferenceLineEndConfig&
TrafficRuleConfig::_Internal::reference_line_end(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.reference_line_end_;
}
const ::apollo::planning::ReroutingConfig&
TrafficRuleConfig::_Internal::rerouting(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.rerouting_;
}
const ::apollo::planning::SignalLightConfig&
TrafficRuleConfig::_Internal::signal_light(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.signal_light_;
}
const ::apollo::planning::StopSignConfig&
TrafficRuleConfig::_Internal::stop_sign(const TrafficRuleConfig* msg) {
  return *msg->_impl_.config_.stop_sign_;
}
void TrafficRuleConfig::set_allocated_backside_vehicle(::apollo::planning::BacksideVehicleConfig* backside_vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (backside_vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(backside_vehicle);
    if (message_arena != submessage_arena) {
      backside_vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backside_vehicle, submessage_arena);
    }
    set_has_backside_vehicle();
    _impl_.config_.backside_vehicle_ = backside_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.backside_vehicle)
}
void TrafficRuleConfig::set_allocated_change_lane(::apollo::planning::ChangeLaneConfig* change_lane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (change_lane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(change_lane);
    if (message_arena != submessage_arena) {
      change_lane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_lane, submessage_arena);
    }
    set_has_change_lane();
    _impl_.config_.change_lane_ = change_lane;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.change_lane)
}
void TrafficRuleConfig::set_allocated_crosswalk(::apollo::planning::CrosswalkConfig* crosswalk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (crosswalk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(crosswalk);
    if (message_arena != submessage_arena) {
      crosswalk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crosswalk, submessage_arena);
    }
    set_has_crosswalk();
    _impl_.config_.crosswalk_ = crosswalk;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.crosswalk)
}
void TrafficRuleConfig::set_allocated_destination(::apollo::planning::DestinationConfig* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(destination);
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    set_has_destination();
    _impl_.config_.destination_ = destination;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.destination)
}
void TrafficRuleConfig::set_allocated_front_vehicle(::apollo::planning::FrontVehicleConfig* front_vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (front_vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(front_vehicle);
    if (message_arena != submessage_arena) {
      front_vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, front_vehicle, submessage_arena);
    }
    set_has_front_vehicle();
    _impl_.config_.front_vehicle_ = front_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.front_vehicle)
}
void TrafficRuleConfig::set_allocated_keep_clear(::apollo::planning::KeepClearConfig* keep_clear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (keep_clear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keep_clear);
    if (message_arena != submessage_arena) {
      keep_clear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keep_clear, submessage_arena);
    }
    set_has_keep_clear();
    _impl_.config_.keep_clear_ = keep_clear;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.keep_clear)
}
void TrafficRuleConfig::set_allocated_pull_over(::apollo::planning::PullOverConfig* pull_over) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (pull_over) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pull_over);
    if (message_arena != submessage_arena) {
      pull_over = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pull_over, submessage_arena);
    }
    set_has_pull_over();
    _impl_.config_.pull_over_ = pull_over;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.pull_over)
}
void TrafficRuleConfig::set_allocated_reference_line_end(::apollo::planning::ReferenceLineEndConfig* reference_line_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (reference_line_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference_line_end);
    if (message_arena != submessage_arena) {
      reference_line_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference_line_end, submessage_arena);
    }
    set_has_reference_line_end();
    _impl_.config_.reference_line_end_ = reference_line_end;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.reference_line_end)
}
void TrafficRuleConfig::set_allocated_rerouting(::apollo::planning::ReroutingConfig* rerouting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (rerouting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rerouting);
    if (message_arena != submessage_arena) {
      rerouting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rerouting, submessage_arena);
    }
    set_has_rerouting();
    _impl_.config_.rerouting_ = rerouting;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.rerouting)
}
void TrafficRuleConfig::set_allocated_signal_light(::apollo::planning::SignalLightConfig* signal_light) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (signal_light) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(signal_light);
    if (message_arena != submessage_arena) {
      signal_light = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_light, submessage_arena);
    }
    set_has_signal_light();
    _impl_.config_.signal_light_ = signal_light;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.signal_light)
}
void TrafficRuleConfig::set_allocated_stop_sign(::apollo::planning::StopSignConfig* stop_sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_config();
  if (stop_sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stop_sign);
    if (message_arena != submessage_arena) {
      stop_sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_sign, submessage_arena);
    }
    set_has_stop_sign();
    _impl_.config_.stop_sign_ = stop_sign;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.stop_sign)
}
TrafficRuleConfig::TrafficRuleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.TrafficRuleConfig)
}
TrafficRuleConfig::TrafficRuleConfig(const TrafficRuleConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.rule_id_){}
    , decltype(_impl_.config_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enabled_, &from._impl_.enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rule_id_) -
    reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.rule_id_));
  clear_has_config();
  switch (from.config_case()) {
    case kBacksideVehicle: {
      _internal_mutable_backside_vehicle()->::apollo::planning::BacksideVehicleConfig::MergeFrom(from._internal_backside_vehicle());
      break;
    }
    case kChangeLane: {
      _internal_mutable_change_lane()->::apollo::planning::ChangeLaneConfig::MergeFrom(from._internal_change_lane());
      break;
    }
    case kCrosswalk: {
      _internal_mutable_crosswalk()->::apollo::planning::CrosswalkConfig::MergeFrom(from._internal_crosswalk());
      break;
    }
    case kDestination: {
      _internal_mutable_destination()->::apollo::planning::DestinationConfig::MergeFrom(from._internal_destination());
      break;
    }
    case kFrontVehicle: {
      _internal_mutable_front_vehicle()->::apollo::planning::FrontVehicleConfig::MergeFrom(from._internal_front_vehicle());
      break;
    }
    case kKeepClear: {
      _internal_mutable_keep_clear()->::apollo::planning::KeepClearConfig::MergeFrom(from._internal_keep_clear());
      break;
    }
    case kPullOver: {
      _internal_mutable_pull_over()->::apollo::planning::PullOverConfig::MergeFrom(from._internal_pull_over());
      break;
    }
    case kReferenceLineEnd: {
      _internal_mutable_reference_line_end()->::apollo::planning::ReferenceLineEndConfig::MergeFrom(from._internal_reference_line_end());
      break;
    }
    case kRerouting: {
      _internal_mutable_rerouting()->::apollo::planning::ReroutingConfig::MergeFrom(from._internal_rerouting());
      break;
    }
    case kSignalLight: {
      _internal_mutable_signal_light()->::apollo::planning::SignalLightConfig::MergeFrom(from._internal_signal_light());
      break;
    }
    case kStopSign: {
      _internal_mutable_stop_sign()->::apollo::planning::StopSignConfig::MergeFrom(from._internal_stop_sign());
      break;
    }
    case CONFIG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:apollo.planning.TrafficRuleConfig)
}

inline void TrafficRuleConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.rule_id_){1}
    , decltype(_impl_.config_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_config();
}

TrafficRuleConfig::~TrafficRuleConfig() {
  // @@protoc_insertion_point(destructor:apollo.planning.TrafficRuleConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrafficRuleConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_config()) {
    clear_config();
  }
}

void TrafficRuleConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrafficRuleConfig::clear_config() {
// @@protoc_insertion_point(one_of_clear_start:apollo.planning.TrafficRuleConfig)
  switch (config_case()) {
    case kBacksideVehicle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.backside_vehicle_;
      }
      break;
    }
    case kChangeLane: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.change_lane_;
      }
      break;
    }
    case kCrosswalk: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.crosswalk_;
      }
      break;
    }
    case kDestination: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.destination_;
      }
      break;
    }
    case kFrontVehicle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.front_vehicle_;
      }
      break;
    }
    case kKeepClear: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.keep_clear_;
      }
      break;
    }
    case kPullOver: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.pull_over_;
      }
      break;
    }
    case kReferenceLineEnd: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.reference_line_end_;
      }
      break;
    }
    case kRerouting: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.rerouting_;
      }
      break;
    }
    case kSignalLight: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.signal_light_;
      }
      break;
    }
    case kStopSign: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.config_.stop_sign_;
      }
      break;
    }
    case CONFIG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = CONFIG_NOT_SET;
}


void TrafficRuleConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.TrafficRuleConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.enabled_ = false;
    _impl_.rule_id_ = 1;
  }
  clear_config();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrafficRuleConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::apollo::planning::TrafficRuleConfig_RuleId_IsValid(val))) {
            _internal_set_rule_id(static_cast<::apollo::planning::TrafficRuleConfig_RuleId>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.BacksideVehicleConfig backside_vehicle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_backside_vehicle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.ChangeLaneConfig change_lane = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_change_lane(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.CrosswalkConfig crosswalk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_crosswalk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.DestinationConfig destination = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_destination(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.FrontVehicleConfig front_vehicle = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_front_vehicle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.KeepClearConfig keep_clear = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_keep_clear(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.PullOverConfig pull_over = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_pull_over(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.ReferenceLineEndConfig reference_line_end = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference_line_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.ReroutingConfig rerouting = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_rerouting(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.SignalLightConfig signal_light = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_signal_light(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.planning.StopSignConfig stop_sign = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_sign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrafficRuleConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.TrafficRuleConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_rule_id(), target);
  }

  // optional bool enabled = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_enabled(), target);
  }

  switch (config_case()) {
    case kBacksideVehicle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::backside_vehicle(this),
          _Internal::backside_vehicle(this).GetCachedSize(), target, stream);
      break;
    }
    case kChangeLane: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::change_lane(this),
          _Internal::change_lane(this).GetCachedSize(), target, stream);
      break;
    }
    case kCrosswalk: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::crosswalk(this),
          _Internal::crosswalk(this).GetCachedSize(), target, stream);
      break;
    }
    case kDestination: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::destination(this),
          _Internal::destination(this).GetCachedSize(), target, stream);
      break;
    }
    case kFrontVehicle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::front_vehicle(this),
          _Internal::front_vehicle(this).GetCachedSize(), target, stream);
      break;
    }
    case kKeepClear: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::keep_clear(this),
          _Internal::keep_clear(this).GetCachedSize(), target, stream);
      break;
    }
    case kPullOver: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::pull_over(this),
          _Internal::pull_over(this).GetCachedSize(), target, stream);
      break;
    }
    case kReferenceLineEnd: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::reference_line_end(this),
          _Internal::reference_line_end(this).GetCachedSize(), target, stream);
      break;
    }
    case kRerouting: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::rerouting(this),
          _Internal::rerouting(this).GetCachedSize(), target, stream);
      break;
    }
    case kSignalLight: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::signal_light(this),
          _Internal::signal_light(this).GetCachedSize(), target, stream);
      break;
    }
    case kStopSign: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::stop_sign(this),
          _Internal::stop_sign(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.TrafficRuleConfig)
  return target;
}

size_t TrafficRuleConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.TrafficRuleConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool enabled = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_rule_id());
    }

  }
  switch (config_case()) {
    // .apollo.planning.BacksideVehicleConfig backside_vehicle = 3;
    case kBacksideVehicle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.backside_vehicle_);
      break;
    }
    // .apollo.planning.ChangeLaneConfig change_lane = 4;
    case kChangeLane: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.change_lane_);
      break;
    }
    // .apollo.planning.CrosswalkConfig crosswalk = 5;
    case kCrosswalk: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.crosswalk_);
      break;
    }
    // .apollo.planning.DestinationConfig destination = 6;
    case kDestination: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.destination_);
      break;
    }
    // .apollo.planning.FrontVehicleConfig front_vehicle = 7;
    case kFrontVehicle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.front_vehicle_);
      break;
    }
    // .apollo.planning.KeepClearConfig keep_clear = 8;
    case kKeepClear: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.keep_clear_);
      break;
    }
    // .apollo.planning.PullOverConfig pull_over = 9;
    case kPullOver: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.pull_over_);
      break;
    }
    // .apollo.planning.ReferenceLineEndConfig reference_line_end = 10;
    case kReferenceLineEnd: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.reference_line_end_);
      break;
    }
    // .apollo.planning.ReroutingConfig rerouting = 11;
    case kRerouting: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.rerouting_);
      break;
    }
    // .apollo.planning.SignalLightConfig signal_light = 12;
    case kSignalLight: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.signal_light_);
      break;
    }
    // .apollo.planning.StopSignConfig stop_sign = 13;
    case kStopSign: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_.stop_sign_);
      break;
    }
    case CONFIG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrafficRuleConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TrafficRuleConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrafficRuleConfig::GetClassData() const { return &_class_data_; }

void TrafficRuleConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TrafficRuleConfig *>(to)->MergeFrom(
      static_cast<const TrafficRuleConfig &>(from));
}


void TrafficRuleConfig::MergeFrom(const TrafficRuleConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.TrafficRuleConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.enabled_ = from._impl_.enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.rule_id_ = from._impl_.rule_id_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.config_case()) {
    case kBacksideVehicle: {
      _internal_mutable_backside_vehicle()->::apollo::planning::BacksideVehicleConfig::MergeFrom(from._internal_backside_vehicle());
      break;
    }
    case kChangeLane: {
      _internal_mutable_change_lane()->::apollo::planning::ChangeLaneConfig::MergeFrom(from._internal_change_lane());
      break;
    }
    case kCrosswalk: {
      _internal_mutable_crosswalk()->::apollo::planning::CrosswalkConfig::MergeFrom(from._internal_crosswalk());
      break;
    }
    case kDestination: {
      _internal_mutable_destination()->::apollo::planning::DestinationConfig::MergeFrom(from._internal_destination());
      break;
    }
    case kFrontVehicle: {
      _internal_mutable_front_vehicle()->::apollo::planning::FrontVehicleConfig::MergeFrom(from._internal_front_vehicle());
      break;
    }
    case kKeepClear: {
      _internal_mutable_keep_clear()->::apollo::planning::KeepClearConfig::MergeFrom(from._internal_keep_clear());
      break;
    }
    case kPullOver: {
      _internal_mutable_pull_over()->::apollo::planning::PullOverConfig::MergeFrom(from._internal_pull_over());
      break;
    }
    case kReferenceLineEnd: {
      _internal_mutable_reference_line_end()->::apollo::planning::ReferenceLineEndConfig::MergeFrom(from._internal_reference_line_end());
      break;
    }
    case kRerouting: {
      _internal_mutable_rerouting()->::apollo::planning::ReroutingConfig::MergeFrom(from._internal_rerouting());
      break;
    }
    case kSignalLight: {
      _internal_mutable_signal_light()->::apollo::planning::SignalLightConfig::MergeFrom(from._internal_signal_light());
      break;
    }
    case kStopSign: {
      _internal_mutable_stop_sign()->::apollo::planning::StopSignConfig::MergeFrom(from._internal_stop_sign());
      break;
    }
    case CONFIG_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrafficRuleConfig::CopyFrom(const TrafficRuleConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.TrafficRuleConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficRuleConfig::IsInitialized() const {
  return true;
}

void TrafficRuleConfig::InternalSwap(TrafficRuleConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
  swap(_impl_.rule_id_, other->_impl_.rule_id_);
  swap(_impl_.config_, other->_impl_.config_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TrafficRuleConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[12]);
}

// ===================================================================

class TrafficRuleConfigs::_Internal {
 public:
};

TrafficRuleConfigs::TrafficRuleConfigs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.TrafficRuleConfigs)
}
TrafficRuleConfigs::TrafficRuleConfigs(const TrafficRuleConfigs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_.config_){from._impl_.config_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.planning.TrafficRuleConfigs)
}

inline void TrafficRuleConfigs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.config_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrafficRuleConfigs::~TrafficRuleConfigs() {
  // @@protoc_insertion_point(destructor:apollo.planning.TrafficRuleConfigs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrafficRuleConfigs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.config_.~RepeatedPtrField();
}

void TrafficRuleConfigs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrafficRuleConfigs::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.TrafficRuleConfigs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.config_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrafficRuleConfigs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .apollo.planning.TrafficRuleConfig config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_config(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrafficRuleConfigs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.TrafficRuleConfigs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .apollo.planning.TrafficRuleConfig config = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_config_size()); i < n; i++) {
    const auto& repfield = this->_internal_config(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.TrafficRuleConfigs)
  return target;
}

size_t TrafficRuleConfigs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.TrafficRuleConfigs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .apollo.planning.TrafficRuleConfig config = 1;
  total_size += 1UL * this->_internal_config_size();
  for (const auto& msg : this->_impl_.config_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrafficRuleConfigs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TrafficRuleConfigs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrafficRuleConfigs::GetClassData() const { return &_class_data_; }

void TrafficRuleConfigs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TrafficRuleConfigs *>(to)->MergeFrom(
      static_cast<const TrafficRuleConfigs &>(from));
}


void TrafficRuleConfigs::MergeFrom(const TrafficRuleConfigs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.TrafficRuleConfigs)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.config_.MergeFrom(from._impl_.config_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrafficRuleConfigs::CopyFrom(const TrafficRuleConfigs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.TrafficRuleConfigs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficRuleConfigs::IsInitialized() const {
  return true;
}

void TrafficRuleConfigs::InternalSwap(TrafficRuleConfigs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.config_.InternalSwap(&other->_impl_.config_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TrafficRuleConfigs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace planning
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::apollo::planning::BacksideVehicleConfig*
Arena::CreateMaybeMessage< ::apollo::planning::BacksideVehicleConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::BacksideVehicleConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::ChangeLaneConfig*
Arena::CreateMaybeMessage< ::apollo::planning::ChangeLaneConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::ChangeLaneConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::CreepConfig*
Arena::CreateMaybeMessage< ::apollo::planning::CreepConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::CreepConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::CrosswalkConfig*
Arena::CreateMaybeMessage< ::apollo::planning::CrosswalkConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::CrosswalkConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::DestinationConfig*
Arena::CreateMaybeMessage< ::apollo::planning::DestinationConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::DestinationConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::FrontVehicleConfig*
Arena::CreateMaybeMessage< ::apollo::planning::FrontVehicleConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::FrontVehicleConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::KeepClearConfig*
Arena::CreateMaybeMessage< ::apollo::planning::KeepClearConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::KeepClearConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::PullOverConfig*
Arena::CreateMaybeMessage< ::apollo::planning::PullOverConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::PullOverConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::ReferenceLineEndConfig*
Arena::CreateMaybeMessage< ::apollo::planning::ReferenceLineEndConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::ReferenceLineEndConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::ReroutingConfig*
Arena::CreateMaybeMessage< ::apollo::planning::ReroutingConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::ReroutingConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::SignalLightConfig*
Arena::CreateMaybeMessage< ::apollo::planning::SignalLightConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::SignalLightConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::StopSignConfig*
Arena::CreateMaybeMessage< ::apollo::planning::StopSignConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::StopSignConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::TrafficRuleConfig*
Arena::CreateMaybeMessage< ::apollo::planning::TrafficRuleConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::TrafficRuleConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::TrafficRuleConfigs*
Arena::CreateMaybeMessage< ::apollo::planning::TrafficRuleConfigs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::TrafficRuleConfigs >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
