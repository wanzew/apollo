// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_status.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/planning/proto/decision.pb.h"
#include "modules/common/proto/drive_state.pb.h"
#include "modules/common/proto/geometry.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
namespace apollo {
namespace planning {
class ChangeLaneStatus;
struct ChangeLaneStatusDefaultTypeInternal;
extern ChangeLaneStatusDefaultTypeInternal _ChangeLaneStatus_default_instance_;
class CrosswalkStatus;
struct CrosswalkStatusDefaultTypeInternal;
extern CrosswalkStatusDefaultTypeInternal _CrosswalkStatus_default_instance_;
class PlanningState;
struct PlanningStateDefaultTypeInternal;
extern PlanningStateDefaultTypeInternal _PlanningState_default_instance_;
class PlanningStatus;
struct PlanningStatusDefaultTypeInternal;
extern PlanningStatusDefaultTypeInternal _PlanningStatus_default_instance_;
class PullOverStatus;
struct PullOverStatusDefaultTypeInternal;
extern PullOverStatusDefaultTypeInternal _PullOverStatus_default_instance_;
class ReroutingStatus;
struct ReroutingStatusDefaultTypeInternal;
extern ReroutingStatusDefaultTypeInternal _ReroutingStatus_default_instance_;
class RightOfWayStatus;
struct RightOfWayStatusDefaultTypeInternal;
extern RightOfWayStatusDefaultTypeInternal _RightOfWayStatus_default_instance_;
class RightOfWayStatus_JunctionEntry_DoNotUse;
struct RightOfWayStatus_JunctionEntry_DoNotUseDefaultTypeInternal;
extern RightOfWayStatus_JunctionEntry_DoNotUseDefaultTypeInternal _RightOfWayStatus_JunctionEntry_DoNotUse_default_instance_;
class SidePassStatus;
struct SidePassStatusDefaultTypeInternal;
extern SidePassStatusDefaultTypeInternal _SidePassStatus_default_instance_;
class StopSignStatus;
struct StopSignStatusDefaultTypeInternal;
extern StopSignStatusDefaultTypeInternal _StopSignStatus_default_instance_;
class StopSignStatus_LaneWatchVehicles;
struct StopSignStatus_LaneWatchVehiclesDefaultTypeInternal;
extern StopSignStatus_LaneWatchVehiclesDefaultTypeInternal _StopSignStatus_LaneWatchVehicles_default_instance_;
class StopTimer;
struct StopTimerDefaultTypeInternal;
extern StopTimerDefaultTypeInternal _StopTimer_default_instance_;
}  // namespace planning
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::planning::ChangeLaneStatus* Arena::CreateMaybeMessage<::apollo::planning::ChangeLaneStatus>(Arena*);
template<> ::apollo::planning::CrosswalkStatus* Arena::CreateMaybeMessage<::apollo::planning::CrosswalkStatus>(Arena*);
template<> ::apollo::planning::PlanningState* Arena::CreateMaybeMessage<::apollo::planning::PlanningState>(Arena*);
template<> ::apollo::planning::PlanningStatus* Arena::CreateMaybeMessage<::apollo::planning::PlanningStatus>(Arena*);
template<> ::apollo::planning::PullOverStatus* Arena::CreateMaybeMessage<::apollo::planning::PullOverStatus>(Arena*);
template<> ::apollo::planning::ReroutingStatus* Arena::CreateMaybeMessage<::apollo::planning::ReroutingStatus>(Arena*);
template<> ::apollo::planning::RightOfWayStatus* Arena::CreateMaybeMessage<::apollo::planning::RightOfWayStatus>(Arena*);
template<> ::apollo::planning::RightOfWayStatus_JunctionEntry_DoNotUse* Arena::CreateMaybeMessage<::apollo::planning::RightOfWayStatus_JunctionEntry_DoNotUse>(Arena*);
template<> ::apollo::planning::SidePassStatus* Arena::CreateMaybeMessage<::apollo::planning::SidePassStatus>(Arena*);
template<> ::apollo::planning::StopSignStatus* Arena::CreateMaybeMessage<::apollo::planning::StopSignStatus>(Arena*);
template<> ::apollo::planning::StopSignStatus_LaneWatchVehicles* Arena::CreateMaybeMessage<::apollo::planning::StopSignStatus_LaneWatchVehicles>(Arena*);
template<> ::apollo::planning::StopTimer* Arena::CreateMaybeMessage<::apollo::planning::StopTimer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace planning {

enum ChangeLaneStatus_Status : int {
  ChangeLaneStatus_Status_IN_CHANGE_LANE = 1,
  ChangeLaneStatus_Status_CHANGE_LANE_FAILED = 2,
  ChangeLaneStatus_Status_CHANGE_LANE_SUCCESS = 3
};
bool ChangeLaneStatus_Status_IsValid(int value);
constexpr ChangeLaneStatus_Status ChangeLaneStatus_Status_Status_MIN = ChangeLaneStatus_Status_IN_CHANGE_LANE;
constexpr ChangeLaneStatus_Status ChangeLaneStatus_Status_Status_MAX = ChangeLaneStatus_Status_CHANGE_LANE_SUCCESS;
constexpr int ChangeLaneStatus_Status_Status_ARRAYSIZE = ChangeLaneStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeLaneStatus_Status_descriptor();
template<typename T>
inline const std::string& ChangeLaneStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeLaneStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeLaneStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeLaneStatus_Status_descriptor(), enum_t_value);
}
inline bool ChangeLaneStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeLaneStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeLaneStatus_Status>(
    ChangeLaneStatus_Status_descriptor(), name, value);
}
enum PullOverStatus_Reason : int {
  PullOverStatus_Reason_DESTINATION = 1
};
bool PullOverStatus_Reason_IsValid(int value);
constexpr PullOverStatus_Reason PullOverStatus_Reason_Reason_MIN = PullOverStatus_Reason_DESTINATION;
constexpr PullOverStatus_Reason PullOverStatus_Reason_Reason_MAX = PullOverStatus_Reason_DESTINATION;
constexpr int PullOverStatus_Reason_Reason_ARRAYSIZE = PullOverStatus_Reason_Reason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PullOverStatus_Reason_descriptor();
template<typename T>
inline const std::string& PullOverStatus_Reason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PullOverStatus_Reason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PullOverStatus_Reason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PullOverStatus_Reason_descriptor(), enum_t_value);
}
inline bool PullOverStatus_Reason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PullOverStatus_Reason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PullOverStatus_Reason>(
    PullOverStatus_Reason_descriptor(), name, value);
}
enum PullOverStatus_Status : int {
  PullOverStatus_Status_UNKNOWN = 1,
  PullOverStatus_Status_IN_OPERATION = 2,
  PullOverStatus_Status_DONE = 3
};
bool PullOverStatus_Status_IsValid(int value);
constexpr PullOverStatus_Status PullOverStatus_Status_Status_MIN = PullOverStatus_Status_UNKNOWN;
constexpr PullOverStatus_Status PullOverStatus_Status_Status_MAX = PullOverStatus_Status_DONE;
constexpr int PullOverStatus_Status_Status_ARRAYSIZE = PullOverStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PullOverStatus_Status_descriptor();
template<typename T>
inline const std::string& PullOverStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PullOverStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PullOverStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PullOverStatus_Status_descriptor(), enum_t_value);
}
inline bool PullOverStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PullOverStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PullOverStatus_Status>(
    PullOverStatus_Status_descriptor(), name, value);
}
enum SidePassStatus_Status : int {
  SidePassStatus_Status_UNKNOWN = 0,
  SidePassStatus_Status_DRIVE = 1,
  SidePassStatus_Status_WAIT = 2,
  SidePassStatus_Status_SIDEPASS = 3
};
bool SidePassStatus_Status_IsValid(int value);
constexpr SidePassStatus_Status SidePassStatus_Status_Status_MIN = SidePassStatus_Status_UNKNOWN;
constexpr SidePassStatus_Status SidePassStatus_Status_Status_MAX = SidePassStatus_Status_SIDEPASS;
constexpr int SidePassStatus_Status_Status_ARRAYSIZE = SidePassStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SidePassStatus_Status_descriptor();
template<typename T>
inline const std::string& SidePassStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SidePassStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SidePassStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SidePassStatus_Status_descriptor(), enum_t_value);
}
inline bool SidePassStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SidePassStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SidePassStatus_Status>(
    SidePassStatus_Status_descriptor(), name, value);
}
enum StopSignStatus_Status : int {
  StopSignStatus_Status_UNKNOWN = 0,
  StopSignStatus_Status_DRIVE = 1,
  StopSignStatus_Status_STOP = 2,
  StopSignStatus_Status_WAIT = 3,
  StopSignStatus_Status_CREEP = 4,
  StopSignStatus_Status_STOP_DONE = 5
};
bool StopSignStatus_Status_IsValid(int value);
constexpr StopSignStatus_Status StopSignStatus_Status_Status_MIN = StopSignStatus_Status_UNKNOWN;
constexpr StopSignStatus_Status StopSignStatus_Status_Status_MAX = StopSignStatus_Status_STOP_DONE;
constexpr int StopSignStatus_Status_Status_ARRAYSIZE = StopSignStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StopSignStatus_Status_descriptor();
template<typename T>
inline const std::string& StopSignStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopSignStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopSignStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StopSignStatus_Status_descriptor(), enum_t_value);
}
inline bool StopSignStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StopSignStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StopSignStatus_Status>(
    StopSignStatus_Status_descriptor(), name, value);
}
// ===================================================================

class ChangeLaneStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ChangeLaneStatus) */ {
 public:
  inline ChangeLaneStatus() : ChangeLaneStatus(nullptr) {}
  ~ChangeLaneStatus() override;
  explicit PROTOBUF_CONSTEXPR ChangeLaneStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeLaneStatus(const ChangeLaneStatus& from);
  ChangeLaneStatus(ChangeLaneStatus&& from) noexcept
    : ChangeLaneStatus() {
    *this = ::std::move(from);
  }

  inline ChangeLaneStatus& operator=(const ChangeLaneStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeLaneStatus& operator=(ChangeLaneStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeLaneStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeLaneStatus* internal_default_instance() {
    return reinterpret_cast<const ChangeLaneStatus*>(
               &_ChangeLaneStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChangeLaneStatus& a, ChangeLaneStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeLaneStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeLaneStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeLaneStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeLaneStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeLaneStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeLaneStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeLaneStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ChangeLaneStatus";
  }
  protected:
  explicit ChangeLaneStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChangeLaneStatus_Status Status;
  static constexpr Status IN_CHANGE_LANE =
    ChangeLaneStatus_Status_IN_CHANGE_LANE;
  static constexpr Status CHANGE_LANE_FAILED =
    ChangeLaneStatus_Status_CHANGE_LANE_FAILED;
  static constexpr Status CHANGE_LANE_SUCCESS =
    ChangeLaneStatus_Status_CHANGE_LANE_SUCCESS;
  static inline bool Status_IsValid(int value) {
    return ChangeLaneStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ChangeLaneStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ChangeLaneStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ChangeLaneStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ChangeLaneStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ChangeLaneStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ChangeLaneStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathIdFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string path_id = 2;
  bool has_path_id() const;
  private:
  bool _internal_has_path_id() const;
  public:
  void clear_path_id();
  const std::string& path_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path_id();
  PROTOBUF_NODISCARD std::string* release_path_id();
  void set_allocated_path_id(std::string* path_id);
  private:
  const std::string& _internal_path_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path_id(const std::string& value);
  std::string* _internal_mutable_path_id();
  public:

  // optional double timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  double timestamp() const;
  void set_timestamp(double value);
  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);
  public:

  // optional .apollo.planning.ChangeLaneStatus.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::apollo::planning::ChangeLaneStatus_Status status() const;
  void set_status(::apollo::planning::ChangeLaneStatus_Status value);
  private:
  ::apollo::planning::ChangeLaneStatus_Status _internal_status() const;
  void _internal_set_status(::apollo::planning::ChangeLaneStatus_Status value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ChangeLaneStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_id_;
    double timestamp_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class StopTimer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopTimer) */ {
 public:
  inline StopTimer() : StopTimer(nullptr) {}
  ~StopTimer() override;
  explicit PROTOBUF_CONSTEXPR StopTimer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopTimer(const StopTimer& from);
  StopTimer(StopTimer&& from) noexcept
    : StopTimer() {
    *this = ::std::move(from);
  }

  inline StopTimer& operator=(const StopTimer& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopTimer& operator=(StopTimer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopTimer& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopTimer* internal_default_instance() {
    return reinterpret_cast<const StopTimer*>(
               &_StopTimer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StopTimer& a, StopTimer& b) {
    a.Swap(&b);
  }
  inline void Swap(StopTimer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopTimer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopTimer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopTimer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopTimer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopTimer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopTimer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StopTimer";
  }
  protected:
  explicit StopTimer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstacleIdFieldNumber = 1,
    kStopTimeFieldNumber = 2,
  };
  // optional string obstacle_id = 1;
  bool has_obstacle_id() const;
  private:
  bool _internal_has_obstacle_id() const;
  public:
  void clear_obstacle_id();
  const std::string& obstacle_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obstacle_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obstacle_id();
  PROTOBUF_NODISCARD std::string* release_obstacle_id();
  void set_allocated_obstacle_id(std::string* obstacle_id);
  private:
  const std::string& _internal_obstacle_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obstacle_id(const std::string& value);
  std::string* _internal_mutable_obstacle_id();
  public:

  // optional double stop_time = 2;
  bool has_stop_time() const;
  private:
  bool _internal_has_stop_time() const;
  public:
  void clear_stop_time();
  double stop_time() const;
  void set_stop_time(double value);
  private:
  double _internal_stop_time() const;
  void _internal_set_stop_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StopTimer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obstacle_id_;
    double stop_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class CrosswalkStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CrosswalkStatus) */ {
 public:
  inline CrosswalkStatus() : CrosswalkStatus(nullptr) {}
  ~CrosswalkStatus() override;
  explicit PROTOBUF_CONSTEXPR CrosswalkStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrosswalkStatus(const CrosswalkStatus& from);
  CrosswalkStatus(CrosswalkStatus&& from) noexcept
    : CrosswalkStatus() {
    *this = ::std::move(from);
  }

  inline CrosswalkStatus& operator=(const CrosswalkStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrosswalkStatus& operator=(CrosswalkStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CrosswalkStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrosswalkStatus* internal_default_instance() {
    return reinterpret_cast<const CrosswalkStatus*>(
               &_CrosswalkStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CrosswalkStatus& a, CrosswalkStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CrosswalkStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrosswalkStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrosswalkStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrosswalkStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CrosswalkStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CrosswalkStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CrosswalkStatus";
  }
  protected:
  explicit CrosswalkStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopTimersFieldNumber = 2,
    kCrosswalkIdFieldNumber = 1,
  };
  // repeated .apollo.planning.StopTimer stop_timers = 2;
  int stop_timers_size() const;
  private:
  int _internal_stop_timers_size() const;
  public:
  void clear_stop_timers();
  ::apollo::planning::StopTimer* mutable_stop_timers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTimer >*
      mutable_stop_timers();
  private:
  const ::apollo::planning::StopTimer& _internal_stop_timers(int index) const;
  ::apollo::planning::StopTimer* _internal_add_stop_timers();
  public:
  const ::apollo::planning::StopTimer& stop_timers(int index) const;
  ::apollo::planning::StopTimer* add_stop_timers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTimer >&
      stop_timers() const;

  // optional string crosswalk_id = 1;
  bool has_crosswalk_id() const;
  private:
  bool _internal_has_crosswalk_id() const;
  public:
  void clear_crosswalk_id();
  const std::string& crosswalk_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_crosswalk_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_crosswalk_id();
  PROTOBUF_NODISCARD std::string* release_crosswalk_id();
  void set_allocated_crosswalk_id(std::string* crosswalk_id);
  private:
  const std::string& _internal_crosswalk_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_crosswalk_id(const std::string& value);
  std::string* _internal_mutable_crosswalk_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CrosswalkStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTimer > stop_timers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crosswalk_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class PullOverStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PullOverStatus) */ {
 public:
  inline PullOverStatus() : PullOverStatus(nullptr) {}
  ~PullOverStatus() override;
  explicit PROTOBUF_CONSTEXPR PullOverStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullOverStatus(const PullOverStatus& from);
  PullOverStatus(PullOverStatus&& from) noexcept
    : PullOverStatus() {
    *this = ::std::move(from);
  }

  inline PullOverStatus& operator=(const PullOverStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullOverStatus& operator=(PullOverStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullOverStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullOverStatus* internal_default_instance() {
    return reinterpret_cast<const PullOverStatus*>(
               &_PullOverStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PullOverStatus& a, PullOverStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PullOverStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullOverStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullOverStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullOverStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PullOverStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PullOverStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullOverStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PullOverStatus";
  }
  protected:
  explicit PullOverStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PullOverStatus_Reason Reason;
  static constexpr Reason DESTINATION =
    PullOverStatus_Reason_DESTINATION;
  static inline bool Reason_IsValid(int value) {
    return PullOverStatus_Reason_IsValid(value);
  }
  static constexpr Reason Reason_MIN =
    PullOverStatus_Reason_Reason_MIN;
  static constexpr Reason Reason_MAX =
    PullOverStatus_Reason_Reason_MAX;
  static constexpr int Reason_ARRAYSIZE =
    PullOverStatus_Reason_Reason_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Reason_descriptor() {
    return PullOverStatus_Reason_descriptor();
  }
  template<typename T>
  static inline const std::string& Reason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Reason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Reason_Name.");
    return PullOverStatus_Reason_Name(enum_t_value);
  }
  static inline bool Reason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Reason* value) {
    return PullOverStatus_Reason_Parse(name, value);
  }

  typedef PullOverStatus_Status Status;
  static constexpr Status UNKNOWN =
    PullOverStatus_Status_UNKNOWN;
  static constexpr Status IN_OPERATION =
    PullOverStatus_Status_IN_OPERATION;
  static constexpr Status DONE =
    PullOverStatus_Status_DONE;
  static inline bool Status_IsValid(int value) {
    return PullOverStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    PullOverStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    PullOverStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    PullOverStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return PullOverStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return PullOverStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return PullOverStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInlaneDestPointFieldNumber = 3,
    kStartPointFieldNumber = 4,
    kStopPointFieldNumber = 5,
    kStopPointHeadingFieldNumber = 6,
    kStatusSetTimeFieldNumber = 8,
    kInPullOverFieldNumber = 1,
    kStatusFieldNumber = 2,
    kReasonFieldNumber = 7,
  };
  // optional .apollo.common.PointENU inlane_dest_point = 3;
  bool has_inlane_dest_point() const;
  private:
  bool _internal_has_inlane_dest_point() const;
  public:
  void clear_inlane_dest_point();
  const ::apollo::common::PointENU& inlane_dest_point() const;
  PROTOBUF_NODISCARD ::apollo::common::PointENU* release_inlane_dest_point();
  ::apollo::common::PointENU* mutable_inlane_dest_point();
  void set_allocated_inlane_dest_point(::apollo::common::PointENU* inlane_dest_point);
  private:
  const ::apollo::common::PointENU& _internal_inlane_dest_point() const;
  ::apollo::common::PointENU* _internal_mutable_inlane_dest_point();
  public:
  void unsafe_arena_set_allocated_inlane_dest_point(
      ::apollo::common::PointENU* inlane_dest_point);
  ::apollo::common::PointENU* unsafe_arena_release_inlane_dest_point();

  // optional .apollo.common.PointENU start_point = 4;
  bool has_start_point() const;
  private:
  bool _internal_has_start_point() const;
  public:
  void clear_start_point();
  const ::apollo::common::PointENU& start_point() const;
  PROTOBUF_NODISCARD ::apollo::common::PointENU* release_start_point();
  ::apollo::common::PointENU* mutable_start_point();
  void set_allocated_start_point(::apollo::common::PointENU* start_point);
  private:
  const ::apollo::common::PointENU& _internal_start_point() const;
  ::apollo::common::PointENU* _internal_mutable_start_point();
  public:
  void unsafe_arena_set_allocated_start_point(
      ::apollo::common::PointENU* start_point);
  ::apollo::common::PointENU* unsafe_arena_release_start_point();

  // optional .apollo.common.PointENU stop_point = 5;
  bool has_stop_point() const;
  private:
  bool _internal_has_stop_point() const;
  public:
  void clear_stop_point();
  const ::apollo::common::PointENU& stop_point() const;
  PROTOBUF_NODISCARD ::apollo::common::PointENU* release_stop_point();
  ::apollo::common::PointENU* mutable_stop_point();
  void set_allocated_stop_point(::apollo::common::PointENU* stop_point);
  private:
  const ::apollo::common::PointENU& _internal_stop_point() const;
  ::apollo::common::PointENU* _internal_mutable_stop_point();
  public:
  void unsafe_arena_set_allocated_stop_point(
      ::apollo::common::PointENU* stop_point);
  ::apollo::common::PointENU* unsafe_arena_release_stop_point();

  // optional double stop_point_heading = 6;
  bool has_stop_point_heading() const;
  private:
  bool _internal_has_stop_point_heading() const;
  public:
  void clear_stop_point_heading();
  double stop_point_heading() const;
  void set_stop_point_heading(double value);
  private:
  double _internal_stop_point_heading() const;
  void _internal_set_stop_point_heading(double value);
  public:

  // optional double status_set_time = 8;
  bool has_status_set_time() const;
  private:
  bool _internal_has_status_set_time() const;
  public:
  void clear_status_set_time();
  double status_set_time() const;
  void set_status_set_time(double value);
  private:
  double _internal_status_set_time() const;
  void _internal_set_status_set_time(double value);
  public:

  // optional bool in_pull_over = 1 [default = false];
  bool has_in_pull_over() const;
  private:
  bool _internal_has_in_pull_over() const;
  public:
  void clear_in_pull_over();
  bool in_pull_over() const;
  void set_in_pull_over(bool value);
  private:
  bool _internal_in_pull_over() const;
  void _internal_set_in_pull_over(bool value);
  public:

  // optional .apollo.planning.PullOverStatus.Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::apollo::planning::PullOverStatus_Status status() const;
  void set_status(::apollo::planning::PullOverStatus_Status value);
  private:
  ::apollo::planning::PullOverStatus_Status _internal_status() const;
  void _internal_set_status(::apollo::planning::PullOverStatus_Status value);
  public:

  // optional .apollo.planning.PullOverStatus.Reason reason = 7;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  ::apollo::planning::PullOverStatus_Reason reason() const;
  void set_reason(::apollo::planning::PullOverStatus_Reason value);
  private:
  ::apollo::planning::PullOverStatus_Reason _internal_reason() const;
  void _internal_set_reason(::apollo::planning::PullOverStatus_Reason value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PullOverStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::common::PointENU* inlane_dest_point_;
    ::apollo::common::PointENU* start_point_;
    ::apollo::common::PointENU* stop_point_;
    double stop_point_heading_;
    double status_set_time_;
    bool in_pull_over_;
    int status_;
    int reason_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class ReroutingStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReroutingStatus) */ {
 public:
  inline ReroutingStatus() : ReroutingStatus(nullptr) {}
  ~ReroutingStatus() override;
  explicit PROTOBUF_CONSTEXPR ReroutingStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReroutingStatus(const ReroutingStatus& from);
  ReroutingStatus(ReroutingStatus&& from) noexcept
    : ReroutingStatus() {
    *this = ::std::move(from);
  }

  inline ReroutingStatus& operator=(const ReroutingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReroutingStatus& operator=(ReroutingStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReroutingStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReroutingStatus* internal_default_instance() {
    return reinterpret_cast<const ReroutingStatus*>(
               &_ReroutingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReroutingStatus& a, ReroutingStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ReroutingStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReroutingStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReroutingStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReroutingStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReroutingStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReroutingStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReroutingStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ReroutingStatus";
  }
  protected:
  explicit ReroutingStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastReroutingTimeFieldNumber = 1,
  };
  // optional double last_rerouting_time = 1;
  bool has_last_rerouting_time() const;
  private:
  bool _internal_has_last_rerouting_time() const;
  public:
  void clear_last_rerouting_time();
  double last_rerouting_time() const;
  void set_last_rerouting_time(double value);
  private:
  double _internal_last_rerouting_time() const;
  void _internal_set_last_rerouting_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ReroutingStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double last_rerouting_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class RightOfWayStatus_JunctionEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RightOfWayStatus_JunctionEntry_DoNotUse, 
    std::string, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RightOfWayStatus_JunctionEntry_DoNotUse, 
    std::string, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> SuperType;
  RightOfWayStatus_JunctionEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RightOfWayStatus_JunctionEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RightOfWayStatus_JunctionEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RightOfWayStatus_JunctionEntry_DoNotUse& other);
  static const RightOfWayStatus_JunctionEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RightOfWayStatus_JunctionEntry_DoNotUse*>(&_RightOfWayStatus_JunctionEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apollo.planning.RightOfWayStatus.JunctionEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};

// -------------------------------------------------------------------

class RightOfWayStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.RightOfWayStatus) */ {
 public:
  inline RightOfWayStatus() : RightOfWayStatus(nullptr) {}
  ~RightOfWayStatus() override;
  explicit PROTOBUF_CONSTEXPR RightOfWayStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RightOfWayStatus(const RightOfWayStatus& from);
  RightOfWayStatus(RightOfWayStatus&& from) noexcept
    : RightOfWayStatus() {
    *this = ::std::move(from);
  }

  inline RightOfWayStatus& operator=(const RightOfWayStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightOfWayStatus& operator=(RightOfWayStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RightOfWayStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RightOfWayStatus* internal_default_instance() {
    return reinterpret_cast<const RightOfWayStatus*>(
               &_RightOfWayStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RightOfWayStatus& a, RightOfWayStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RightOfWayStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightOfWayStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RightOfWayStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RightOfWayStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RightOfWayStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RightOfWayStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightOfWayStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.RightOfWayStatus";
  }
  protected:
  explicit RightOfWayStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kJunctionFieldNumber = 1,
  };
  // map<string, bool> junction = 1;
  int junction_size() const;
  private:
  int _internal_junction_size() const;
  public:
  void clear_junction();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
      _internal_junction() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
      _internal_mutable_junction();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
      junction() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
      mutable_junction();

  // @@protoc_insertion_point(class_scope:apollo.planning.RightOfWayStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RightOfWayStatus_JunctionEntry_DoNotUse,
        std::string, bool,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> junction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class SidePassStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.SidePassStatus) */ {
 public:
  inline SidePassStatus() : SidePassStatus(nullptr) {}
  ~SidePassStatus() override;
  explicit PROTOBUF_CONSTEXPR SidePassStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SidePassStatus(const SidePassStatus& from);
  SidePassStatus(SidePassStatus&& from) noexcept
    : SidePassStatus() {
    *this = ::std::move(from);
  }

  inline SidePassStatus& operator=(const SidePassStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SidePassStatus& operator=(SidePassStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SidePassStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SidePassStatus* internal_default_instance() {
    return reinterpret_cast<const SidePassStatus*>(
               &_SidePassStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SidePassStatus& a, SidePassStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SidePassStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SidePassStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SidePassStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SidePassStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SidePassStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SidePassStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SidePassStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.SidePassStatus";
  }
  protected:
  explicit SidePassStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SidePassStatus_Status Status;
  static constexpr Status UNKNOWN =
    SidePassStatus_Status_UNKNOWN;
  static constexpr Status DRIVE =
    SidePassStatus_Status_DRIVE;
  static constexpr Status WAIT =
    SidePassStatus_Status_WAIT;
  static constexpr Status SIDEPASS =
    SidePassStatus_Status_SIDEPASS;
  static inline bool Status_IsValid(int value) {
    return SidePassStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SidePassStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SidePassStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SidePassStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SidePassStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SidePassStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SidePassStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPassObstacleIdFieldNumber = 3,
    kWaitStartTimeFieldNumber = 2,
    kStatusFieldNumber = 1,
    kPassSideFieldNumber = 4,
  };
  // optional string pass_obstacle_id = 3;
  bool has_pass_obstacle_id() const;
  private:
  bool _internal_has_pass_obstacle_id() const;
  public:
  void clear_pass_obstacle_id();
  const std::string& pass_obstacle_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pass_obstacle_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pass_obstacle_id();
  PROTOBUF_NODISCARD std::string* release_pass_obstacle_id();
  void set_allocated_pass_obstacle_id(std::string* pass_obstacle_id);
  private:
  const std::string& _internal_pass_obstacle_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pass_obstacle_id(const std::string& value);
  std::string* _internal_mutable_pass_obstacle_id();
  public:

  // optional double wait_start_time = 2;
  bool has_wait_start_time() const;
  private:
  bool _internal_has_wait_start_time() const;
  public:
  void clear_wait_start_time();
  double wait_start_time() const;
  void set_wait_start_time(double value);
  private:
  double _internal_wait_start_time() const;
  void _internal_set_wait_start_time(double value);
  public:

  // optional .apollo.planning.SidePassStatus.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::apollo::planning::SidePassStatus_Status status() const;
  void set_status(::apollo::planning::SidePassStatus_Status value);
  private:
  ::apollo::planning::SidePassStatus_Status _internal_status() const;
  void _internal_set_status(::apollo::planning::SidePassStatus_Status value);
  public:

  // optional .apollo.planning.ObjectSidePass.Type pass_side = 4;
  bool has_pass_side() const;
  private:
  bool _internal_has_pass_side() const;
  public:
  void clear_pass_side();
  ::apollo::planning::ObjectSidePass_Type pass_side() const;
  void set_pass_side(::apollo::planning::ObjectSidePass_Type value);
  private:
  ::apollo::planning::ObjectSidePass_Type _internal_pass_side() const;
  void _internal_set_pass_side(::apollo::planning::ObjectSidePass_Type value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.SidePassStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pass_obstacle_id_;
    double wait_start_time_;
    int status_;
    int pass_side_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class StopSignStatus_LaneWatchVehicles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopSignStatus.LaneWatchVehicles) */ {
 public:
  inline StopSignStatus_LaneWatchVehicles() : StopSignStatus_LaneWatchVehicles(nullptr) {}
  ~StopSignStatus_LaneWatchVehicles() override;
  explicit PROTOBUF_CONSTEXPR StopSignStatus_LaneWatchVehicles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopSignStatus_LaneWatchVehicles(const StopSignStatus_LaneWatchVehicles& from);
  StopSignStatus_LaneWatchVehicles(StopSignStatus_LaneWatchVehicles&& from) noexcept
    : StopSignStatus_LaneWatchVehicles() {
    *this = ::std::move(from);
  }

  inline StopSignStatus_LaneWatchVehicles& operator=(const StopSignStatus_LaneWatchVehicles& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSignStatus_LaneWatchVehicles& operator=(StopSignStatus_LaneWatchVehicles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopSignStatus_LaneWatchVehicles& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopSignStatus_LaneWatchVehicles* internal_default_instance() {
    return reinterpret_cast<const StopSignStatus_LaneWatchVehicles*>(
               &_StopSignStatus_LaneWatchVehicles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StopSignStatus_LaneWatchVehicles& a, StopSignStatus_LaneWatchVehicles& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSignStatus_LaneWatchVehicles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSignStatus_LaneWatchVehicles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopSignStatus_LaneWatchVehicles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopSignStatus_LaneWatchVehicles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopSignStatus_LaneWatchVehicles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopSignStatus_LaneWatchVehicles& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSignStatus_LaneWatchVehicles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StopSignStatus.LaneWatchVehicles";
  }
  protected:
  explicit StopSignStatus_LaneWatchVehicles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWatchVehiclesFieldNumber = 2,
    kLaneIdFieldNumber = 1,
  };
  // repeated string watch_vehicles = 2;
  int watch_vehicles_size() const;
  private:
  int _internal_watch_vehicles_size() const;
  public:
  void clear_watch_vehicles();
  const std::string& watch_vehicles(int index) const;
  std::string* mutable_watch_vehicles(int index);
  void set_watch_vehicles(int index, const std::string& value);
  void set_watch_vehicles(int index, std::string&& value);
  void set_watch_vehicles(int index, const char* value);
  void set_watch_vehicles(int index, const char* value, size_t size);
  std::string* add_watch_vehicles();
  void add_watch_vehicles(const std::string& value);
  void add_watch_vehicles(std::string&& value);
  void add_watch_vehicles(const char* value);
  void add_watch_vehicles(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& watch_vehicles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_watch_vehicles();
  private:
  const std::string& _internal_watch_vehicles(int index) const;
  std::string* _internal_add_watch_vehicles();
  public:

  // optional string lane_id = 1;
  bool has_lane_id() const;
  private:
  bool _internal_has_lane_id() const;
  public:
  void clear_lane_id();
  const std::string& lane_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lane_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lane_id();
  PROTOBUF_NODISCARD std::string* release_lane_id();
  void set_allocated_lane_id(std::string* lane_id);
  private:
  const std::string& _internal_lane_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lane_id(const std::string& value);
  std::string* _internal_mutable_lane_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StopSignStatus.LaneWatchVehicles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> watch_vehicles_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lane_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class StopSignStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopSignStatus) */ {
 public:
  inline StopSignStatus() : StopSignStatus(nullptr) {}
  ~StopSignStatus() override;
  explicit PROTOBUF_CONSTEXPR StopSignStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopSignStatus(const StopSignStatus& from);
  StopSignStatus(StopSignStatus&& from) noexcept
    : StopSignStatus() {
    *this = ::std::move(from);
  }

  inline StopSignStatus& operator=(const StopSignStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSignStatus& operator=(StopSignStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopSignStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopSignStatus* internal_default_instance() {
    return reinterpret_cast<const StopSignStatus*>(
               &_StopSignStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StopSignStatus& a, StopSignStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSignStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSignStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopSignStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopSignStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopSignStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopSignStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSignStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StopSignStatus";
  }
  protected:
  explicit StopSignStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StopSignStatus_LaneWatchVehicles LaneWatchVehicles;

  typedef StopSignStatus_Status Status;
  static constexpr Status UNKNOWN =
    StopSignStatus_Status_UNKNOWN;
  static constexpr Status DRIVE =
    StopSignStatus_Status_DRIVE;
  static constexpr Status STOP =
    StopSignStatus_Status_STOP;
  static constexpr Status WAIT =
    StopSignStatus_Status_WAIT;
  static constexpr Status CREEP =
    StopSignStatus_Status_CREEP;
  static constexpr Status STOP_DONE =
    StopSignStatus_Status_STOP_DONE;
  static inline bool Status_IsValid(int value) {
    return StopSignStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    StopSignStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    StopSignStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    StopSignStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return StopSignStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return StopSignStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return StopSignStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLaneWatchVehiclesFieldNumber = 4,
    kStopSignIdFieldNumber = 1,
    kStopStartTimeFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // repeated .apollo.planning.StopSignStatus.LaneWatchVehicles lane_watch_vehicles = 4;
  int lane_watch_vehicles_size() const;
  private:
  int _internal_lane_watch_vehicles_size() const;
  public:
  void clear_lane_watch_vehicles();
  ::apollo::planning::StopSignStatus_LaneWatchVehicles* mutable_lane_watch_vehicles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopSignStatus_LaneWatchVehicles >*
      mutable_lane_watch_vehicles();
  private:
  const ::apollo::planning::StopSignStatus_LaneWatchVehicles& _internal_lane_watch_vehicles(int index) const;
  ::apollo::planning::StopSignStatus_LaneWatchVehicles* _internal_add_lane_watch_vehicles();
  public:
  const ::apollo::planning::StopSignStatus_LaneWatchVehicles& lane_watch_vehicles(int index) const;
  ::apollo::planning::StopSignStatus_LaneWatchVehicles* add_lane_watch_vehicles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopSignStatus_LaneWatchVehicles >&
      lane_watch_vehicles() const;

  // optional string stop_sign_id = 1;
  bool has_stop_sign_id() const;
  private:
  bool _internal_has_stop_sign_id() const;
  public:
  void clear_stop_sign_id();
  const std::string& stop_sign_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_sign_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_sign_id();
  PROTOBUF_NODISCARD std::string* release_stop_sign_id();
  void set_allocated_stop_sign_id(std::string* stop_sign_id);
  private:
  const std::string& _internal_stop_sign_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_sign_id(const std::string& value);
  std::string* _internal_mutable_stop_sign_id();
  public:

  // optional double stop_start_time = 3;
  bool has_stop_start_time() const;
  private:
  bool _internal_has_stop_start_time() const;
  public:
  void clear_stop_start_time();
  double stop_start_time() const;
  void set_stop_start_time(double value);
  private:
  double _internal_stop_start_time() const;
  void _internal_set_stop_start_time(double value);
  public:

  // optional .apollo.planning.StopSignStatus.Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::apollo::planning::StopSignStatus_Status status() const;
  void set_status(::apollo::planning::StopSignStatus_Status value);
  private:
  ::apollo::planning::StopSignStatus_Status _internal_status() const;
  void _internal_set_status(::apollo::planning::StopSignStatus_Status value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StopSignStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopSignStatus_LaneWatchVehicles > lane_watch_vehicles_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_sign_id_;
    double stop_start_time_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class PlanningState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningState) */ {
 public:
  inline PlanningState() : PlanningState(nullptr) {}
  ~PlanningState() override;
  explicit PROTOBUF_CONSTEXPR PlanningState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanningState(const PlanningState& from);
  PlanningState(PlanningState&& from) noexcept
    : PlanningState() {
    *this = ::std::move(from);
  }

  inline PlanningState& operator=(const PlanningState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanningState& operator=(PlanningState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanningState& default_instance() {
    return *internal_default_instance();
  }
  enum ObjectTagCase {
    kPullOver = 1,
    OBJECT_TAG_NOT_SET = 0,
  };

  static inline const PlanningState* internal_default_instance() {
    return reinterpret_cast<const PlanningState*>(
               &_PlanningState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PlanningState& a, PlanningState& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanningState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanningState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanningState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanningState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanningState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlanningState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanningState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PlanningState";
  }
  protected:
  explicit PlanningState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPullOverFieldNumber = 1,
  };
  // .apollo.planning.PullOverStatus pull_over = 1;
  bool has_pull_over() const;
  private:
  bool _internal_has_pull_over() const;
  public:
  void clear_pull_over();
  const ::apollo::planning::PullOverStatus& pull_over() const;
  PROTOBUF_NODISCARD ::apollo::planning::PullOverStatus* release_pull_over();
  ::apollo::planning::PullOverStatus* mutable_pull_over();
  void set_allocated_pull_over(::apollo::planning::PullOverStatus* pull_over);
  private:
  const ::apollo::planning::PullOverStatus& _internal_pull_over() const;
  ::apollo::planning::PullOverStatus* _internal_mutable_pull_over();
  public:
  void unsafe_arena_set_allocated_pull_over(
      ::apollo::planning::PullOverStatus* pull_over);
  ::apollo::planning::PullOverStatus* unsafe_arena_release_pull_over();

  void clear_object_tag();
  ObjectTagCase object_tag_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningState)
 private:
  class _Internal;
  void set_has_pull_over();

  inline bool has_object_tag() const;
  inline void clear_has_object_tag();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ObjectTagUnion {
      constexpr ObjectTagUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::apollo::planning::PullOverStatus* pull_over_;
    } object_tag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class PlanningStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningStatus) */ {
 public:
  inline PlanningStatus() : PlanningStatus(nullptr) {}
  ~PlanningStatus() override;
  explicit PROTOBUF_CONSTEXPR PlanningStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanningStatus(const PlanningStatus& from);
  PlanningStatus(PlanningStatus&& from) noexcept
    : PlanningStatus() {
    *this = ::std::move(from);
  }

  inline PlanningStatus& operator=(const PlanningStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanningStatus& operator=(PlanningStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanningStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanningStatus* internal_default_instance() {
    return reinterpret_cast<const PlanningStatus*>(
               &_PlanningStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PlanningStatus& a, PlanningStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanningStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanningStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanningStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanningStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanningStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlanningStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanningStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PlanningStatus";
  }
  protected:
  explicit PlanningStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlanningStateFieldNumber = 1,
    kChangeLaneFieldNumber = 2,
    kCrosswalkFieldNumber = 3,
    kEngageAdviceFieldNumber = 4,
    kReroutingFieldNumber = 5,
    kRightOfWayFieldNumber = 6,
    kSidePassFieldNumber = 7,
    kStopSignFieldNumber = 8,
  };
  // optional .apollo.planning.PlanningState planning_state = 1;
  bool has_planning_state() const;
  private:
  bool _internal_has_planning_state() const;
  public:
  void clear_planning_state();
  const ::apollo::planning::PlanningState& planning_state() const;
  PROTOBUF_NODISCARD ::apollo::planning::PlanningState* release_planning_state();
  ::apollo::planning::PlanningState* mutable_planning_state();
  void set_allocated_planning_state(::apollo::planning::PlanningState* planning_state);
  private:
  const ::apollo::planning::PlanningState& _internal_planning_state() const;
  ::apollo::planning::PlanningState* _internal_mutable_planning_state();
  public:
  void unsafe_arena_set_allocated_planning_state(
      ::apollo::planning::PlanningState* planning_state);
  ::apollo::planning::PlanningState* unsafe_arena_release_planning_state();

  // optional .apollo.planning.ChangeLaneStatus change_lane = 2;
  bool has_change_lane() const;
  private:
  bool _internal_has_change_lane() const;
  public:
  void clear_change_lane();
  const ::apollo::planning::ChangeLaneStatus& change_lane() const;
  PROTOBUF_NODISCARD ::apollo::planning::ChangeLaneStatus* release_change_lane();
  ::apollo::planning::ChangeLaneStatus* mutable_change_lane();
  void set_allocated_change_lane(::apollo::planning::ChangeLaneStatus* change_lane);
  private:
  const ::apollo::planning::ChangeLaneStatus& _internal_change_lane() const;
  ::apollo::planning::ChangeLaneStatus* _internal_mutable_change_lane();
  public:
  void unsafe_arena_set_allocated_change_lane(
      ::apollo::planning::ChangeLaneStatus* change_lane);
  ::apollo::planning::ChangeLaneStatus* unsafe_arena_release_change_lane();

  // optional .apollo.planning.CrosswalkStatus crosswalk = 3;
  bool has_crosswalk() const;
  private:
  bool _internal_has_crosswalk() const;
  public:
  void clear_crosswalk();
  const ::apollo::planning::CrosswalkStatus& crosswalk() const;
  PROTOBUF_NODISCARD ::apollo::planning::CrosswalkStatus* release_crosswalk();
  ::apollo::planning::CrosswalkStatus* mutable_crosswalk();
  void set_allocated_crosswalk(::apollo::planning::CrosswalkStatus* crosswalk);
  private:
  const ::apollo::planning::CrosswalkStatus& _internal_crosswalk() const;
  ::apollo::planning::CrosswalkStatus* _internal_mutable_crosswalk();
  public:
  void unsafe_arena_set_allocated_crosswalk(
      ::apollo::planning::CrosswalkStatus* crosswalk);
  ::apollo::planning::CrosswalkStatus* unsafe_arena_release_crosswalk();

  // optional .apollo.common.EngageAdvice engage_advice = 4;
  bool has_engage_advice() const;
  private:
  bool _internal_has_engage_advice() const;
  public:
  void clear_engage_advice();
  const ::apollo::common::EngageAdvice& engage_advice() const;
  PROTOBUF_NODISCARD ::apollo::common::EngageAdvice* release_engage_advice();
  ::apollo::common::EngageAdvice* mutable_engage_advice();
  void set_allocated_engage_advice(::apollo::common::EngageAdvice* engage_advice);
  private:
  const ::apollo::common::EngageAdvice& _internal_engage_advice() const;
  ::apollo::common::EngageAdvice* _internal_mutable_engage_advice();
  public:
  void unsafe_arena_set_allocated_engage_advice(
      ::apollo::common::EngageAdvice* engage_advice);
  ::apollo::common::EngageAdvice* unsafe_arena_release_engage_advice();

  // optional .apollo.planning.ReroutingStatus rerouting = 5;
  bool has_rerouting() const;
  private:
  bool _internal_has_rerouting() const;
  public:
  void clear_rerouting();
  const ::apollo::planning::ReroutingStatus& rerouting() const;
  PROTOBUF_NODISCARD ::apollo::planning::ReroutingStatus* release_rerouting();
  ::apollo::planning::ReroutingStatus* mutable_rerouting();
  void set_allocated_rerouting(::apollo::planning::ReroutingStatus* rerouting);
  private:
  const ::apollo::planning::ReroutingStatus& _internal_rerouting() const;
  ::apollo::planning::ReroutingStatus* _internal_mutable_rerouting();
  public:
  void unsafe_arena_set_allocated_rerouting(
      ::apollo::planning::ReroutingStatus* rerouting);
  ::apollo::planning::ReroutingStatus* unsafe_arena_release_rerouting();

  // optional .apollo.planning.RightOfWayStatus right_of_way = 6;
  bool has_right_of_way() const;
  private:
  bool _internal_has_right_of_way() const;
  public:
  void clear_right_of_way();
  const ::apollo::planning::RightOfWayStatus& right_of_way() const;
  PROTOBUF_NODISCARD ::apollo::planning::RightOfWayStatus* release_right_of_way();
  ::apollo::planning::RightOfWayStatus* mutable_right_of_way();
  void set_allocated_right_of_way(::apollo::planning::RightOfWayStatus* right_of_way);
  private:
  const ::apollo::planning::RightOfWayStatus& _internal_right_of_way() const;
  ::apollo::planning::RightOfWayStatus* _internal_mutable_right_of_way();
  public:
  void unsafe_arena_set_allocated_right_of_way(
      ::apollo::planning::RightOfWayStatus* right_of_way);
  ::apollo::planning::RightOfWayStatus* unsafe_arena_release_right_of_way();

  // optional .apollo.planning.SidePassStatus side_pass = 7;
  bool has_side_pass() const;
  private:
  bool _internal_has_side_pass() const;
  public:
  void clear_side_pass();
  const ::apollo::planning::SidePassStatus& side_pass() const;
  PROTOBUF_NODISCARD ::apollo::planning::SidePassStatus* release_side_pass();
  ::apollo::planning::SidePassStatus* mutable_side_pass();
  void set_allocated_side_pass(::apollo::planning::SidePassStatus* side_pass);
  private:
  const ::apollo::planning::SidePassStatus& _internal_side_pass() const;
  ::apollo::planning::SidePassStatus* _internal_mutable_side_pass();
  public:
  void unsafe_arena_set_allocated_side_pass(
      ::apollo::planning::SidePassStatus* side_pass);
  ::apollo::planning::SidePassStatus* unsafe_arena_release_side_pass();

  // optional .apollo.planning.StopSignStatus stop_sign = 8;
  bool has_stop_sign() const;
  private:
  bool _internal_has_stop_sign() const;
  public:
  void clear_stop_sign();
  const ::apollo::planning::StopSignStatus& stop_sign() const;
  PROTOBUF_NODISCARD ::apollo::planning::StopSignStatus* release_stop_sign();
  ::apollo::planning::StopSignStatus* mutable_stop_sign();
  void set_allocated_stop_sign(::apollo::planning::StopSignStatus* stop_sign);
  private:
  const ::apollo::planning::StopSignStatus& _internal_stop_sign() const;
  ::apollo::planning::StopSignStatus* _internal_mutable_stop_sign();
  public:
  void unsafe_arena_set_allocated_stop_sign(
      ::apollo::planning::StopSignStatus* stop_sign);
  ::apollo::planning::StopSignStatus* unsafe_arena_release_stop_sign();

  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::planning::PlanningState* planning_state_;
    ::apollo::planning::ChangeLaneStatus* change_lane_;
    ::apollo::planning::CrosswalkStatus* crosswalk_;
    ::apollo::common::EngageAdvice* engage_advice_;
    ::apollo::planning::ReroutingStatus* rerouting_;
    ::apollo::planning::RightOfWayStatus* right_of_way_;
    ::apollo::planning::SidePassStatus* side_pass_;
    ::apollo::planning::StopSignStatus* stop_sign_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ChangeLaneStatus

// optional .apollo.planning.ChangeLaneStatus.Status status = 1;
inline bool ChangeLaneStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_status() const {
  return _internal_has_status();
}
inline void ChangeLaneStatus::clear_status() {
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::planning::ChangeLaneStatus_Status ChangeLaneStatus::_internal_status() const {
  return static_cast< ::apollo::planning::ChangeLaneStatus_Status >(_impl_.status_);
}
inline ::apollo::planning::ChangeLaneStatus_Status ChangeLaneStatus::status() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.status)
  return _internal_status();
}
inline void ChangeLaneStatus::_internal_set_status(::apollo::planning::ChangeLaneStatus_Status value) {
  assert(::apollo::planning::ChangeLaneStatus_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}
inline void ChangeLaneStatus::set_status(::apollo::planning::ChangeLaneStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.status)
}

// optional string path_id = 2;
inline bool ChangeLaneStatus::_internal_has_path_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_path_id() const {
  return _internal_has_path_id();
}
inline void ChangeLaneStatus::clear_path_id() {
  _impl_.path_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeLaneStatus::path_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.path_id)
  return _internal_path_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeLaneStatus::set_path_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.path_id)
}
inline std::string* ChangeLaneStatus::mutable_path_id() {
  std::string* _s = _internal_mutable_path_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ChangeLaneStatus.path_id)
  return _s;
}
inline const std::string& ChangeLaneStatus::_internal_path_id() const {
  return _impl_.path_id_.Get();
}
inline void ChangeLaneStatus::_internal_set_path_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeLaneStatus::_internal_mutable_path_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeLaneStatus::release_path_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.ChangeLaneStatus.path_id)
  if (!_internal_has_path_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_id_.IsDefault()) {
    _impl_.path_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChangeLaneStatus::set_allocated_path_id(std::string* path_id) {
  if (path_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_id_.SetAllocated(path_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_id_.IsDefault()) {
    _impl_.path_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ChangeLaneStatus.path_id)
}

// optional double timestamp = 3;
inline bool ChangeLaneStatus::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ChangeLaneStatus::clear_timestamp() {
  _impl_.timestamp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ChangeLaneStatus::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline double ChangeLaneStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.timestamp)
  return _internal_timestamp();
}
inline void ChangeLaneStatus::_internal_set_timestamp(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}
inline void ChangeLaneStatus::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.timestamp)
}

// -------------------------------------------------------------------

// StopTimer

// optional string obstacle_id = 1;
inline bool StopTimer::_internal_has_obstacle_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopTimer::has_obstacle_id() const {
  return _internal_has_obstacle_id();
}
inline void StopTimer::clear_obstacle_id() {
  _impl_.obstacle_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopTimer::obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopTimer.obstacle_id)
  return _internal_obstacle_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopTimer::set_obstacle_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.obstacle_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.StopTimer.obstacle_id)
}
inline std::string* StopTimer::mutable_obstacle_id() {
  std::string* _s = _internal_mutable_obstacle_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopTimer.obstacle_id)
  return _s;
}
inline const std::string& StopTimer::_internal_obstacle_id() const {
  return _impl_.obstacle_id_.Get();
}
inline void StopTimer::_internal_set_obstacle_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obstacle_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopTimer::_internal_mutable_obstacle_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.obstacle_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopTimer::release_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopTimer.obstacle_id)
  if (!_internal_has_obstacle_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.obstacle_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obstacle_id_.IsDefault()) {
    _impl_.obstacle_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StopTimer::set_allocated_obstacle_id(std::string* obstacle_id) {
  if (obstacle_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.obstacle_id_.SetAllocated(obstacle_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obstacle_id_.IsDefault()) {
    _impl_.obstacle_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopTimer.obstacle_id)
}

// optional double stop_time = 2;
inline bool StopTimer::_internal_has_stop_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopTimer::has_stop_time() const {
  return _internal_has_stop_time();
}
inline void StopTimer::clear_stop_time() {
  _impl_.stop_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double StopTimer::_internal_stop_time() const {
  return _impl_.stop_time_;
}
inline double StopTimer::stop_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopTimer.stop_time)
  return _internal_stop_time();
}
inline void StopTimer::_internal_set_stop_time(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stop_time_ = value;
}
inline void StopTimer::set_stop_time(double value) {
  _internal_set_stop_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopTimer.stop_time)
}

// -------------------------------------------------------------------

// CrosswalkStatus

// optional string crosswalk_id = 1;
inline bool CrosswalkStatus::_internal_has_crosswalk_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrosswalkStatus::has_crosswalk_id() const {
  return _internal_has_crosswalk_id();
}
inline void CrosswalkStatus::clear_crosswalk_id() {
  _impl_.crosswalk_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrosswalkStatus::crosswalk_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkStatus.crosswalk_id)
  return _internal_crosswalk_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrosswalkStatus::set_crosswalk_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.crosswalk_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkStatus.crosswalk_id)
}
inline std::string* CrosswalkStatus::mutable_crosswalk_id() {
  std::string* _s = _internal_mutable_crosswalk_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.CrosswalkStatus.crosswalk_id)
  return _s;
}
inline const std::string& CrosswalkStatus::_internal_crosswalk_id() const {
  return _impl_.crosswalk_id_.Get();
}
inline void CrosswalkStatus::_internal_set_crosswalk_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.crosswalk_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CrosswalkStatus::_internal_mutable_crosswalk_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.crosswalk_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CrosswalkStatus::release_crosswalk_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.CrosswalkStatus.crosswalk_id)
  if (!_internal_has_crosswalk_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.crosswalk_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.crosswalk_id_.IsDefault()) {
    _impl_.crosswalk_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CrosswalkStatus::set_allocated_crosswalk_id(std::string* crosswalk_id) {
  if (crosswalk_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.crosswalk_id_.SetAllocated(crosswalk_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.crosswalk_id_.IsDefault()) {
    _impl_.crosswalk_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.CrosswalkStatus.crosswalk_id)
}

// repeated .apollo.planning.StopTimer stop_timers = 2;
inline int CrosswalkStatus::_internal_stop_timers_size() const {
  return _impl_.stop_timers_.size();
}
inline int CrosswalkStatus::stop_timers_size() const {
  return _internal_stop_timers_size();
}
inline void CrosswalkStatus::clear_stop_timers() {
  _impl_.stop_timers_.Clear();
}
inline ::apollo::planning::StopTimer* CrosswalkStatus::mutable_stop_timers(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.CrosswalkStatus.stop_timers)
  return _impl_.stop_timers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTimer >*
CrosswalkStatus::mutable_stop_timers() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.CrosswalkStatus.stop_timers)
  return &_impl_.stop_timers_;
}
inline const ::apollo::planning::StopTimer& CrosswalkStatus::_internal_stop_timers(int index) const {
  return _impl_.stop_timers_.Get(index);
}
inline const ::apollo::planning::StopTimer& CrosswalkStatus::stop_timers(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkStatus.stop_timers)
  return _internal_stop_timers(index);
}
inline ::apollo::planning::StopTimer* CrosswalkStatus::_internal_add_stop_timers() {
  return _impl_.stop_timers_.Add();
}
inline ::apollo::planning::StopTimer* CrosswalkStatus::add_stop_timers() {
  ::apollo::planning::StopTimer* _add = _internal_add_stop_timers();
  // @@protoc_insertion_point(field_add:apollo.planning.CrosswalkStatus.stop_timers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTimer >&
CrosswalkStatus::stop_timers() const {
  // @@protoc_insertion_point(field_list:apollo.planning.CrosswalkStatus.stop_timers)
  return _impl_.stop_timers_;
}

// -------------------------------------------------------------------

// PullOverStatus

// optional bool in_pull_over = 1 [default = false];
inline bool PullOverStatus::_internal_has_in_pull_over() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PullOverStatus::has_in_pull_over() const {
  return _internal_has_in_pull_over();
}
inline void PullOverStatus::clear_in_pull_over() {
  _impl_.in_pull_over_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool PullOverStatus::_internal_in_pull_over() const {
  return _impl_.in_pull_over_;
}
inline bool PullOverStatus::in_pull_over() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.in_pull_over)
  return _internal_in_pull_over();
}
inline void PullOverStatus::_internal_set_in_pull_over(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.in_pull_over_ = value;
}
inline void PullOverStatus::set_in_pull_over(bool value) {
  _internal_set_in_pull_over(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.in_pull_over)
}

// optional .apollo.planning.PullOverStatus.Status status = 2;
inline bool PullOverStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PullOverStatus::has_status() const {
  return _internal_has_status();
}
inline void PullOverStatus::clear_status() {
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::apollo::planning::PullOverStatus_Status PullOverStatus::_internal_status() const {
  return static_cast< ::apollo::planning::PullOverStatus_Status >(_impl_.status_);
}
inline ::apollo::planning::PullOverStatus_Status PullOverStatus::status() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.status)
  return _internal_status();
}
inline void PullOverStatus::_internal_set_status(::apollo::planning::PullOverStatus_Status value) {
  assert(::apollo::planning::PullOverStatus_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.status_ = value;
}
inline void PullOverStatus::set_status(::apollo::planning::PullOverStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.status)
}

// optional .apollo.common.PointENU inlane_dest_point = 3;
inline bool PullOverStatus::_internal_has_inlane_dest_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inlane_dest_point_ != nullptr);
  return value;
}
inline bool PullOverStatus::has_inlane_dest_point() const {
  return _internal_has_inlane_dest_point();
}
inline const ::apollo::common::PointENU& PullOverStatus::_internal_inlane_dest_point() const {
  const ::apollo::common::PointENU* p = _impl_.inlane_dest_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::PointENU&>(
      ::apollo::common::_PointENU_default_instance_);
}
inline const ::apollo::common::PointENU& PullOverStatus::inlane_dest_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.inlane_dest_point)
  return _internal_inlane_dest_point();
}
inline void PullOverStatus::unsafe_arena_set_allocated_inlane_dest_point(
    ::apollo::common::PointENU* inlane_dest_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inlane_dest_point_);
  }
  _impl_.inlane_dest_point_ = inlane_dest_point;
  if (inlane_dest_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PullOverStatus.inlane_dest_point)
}
inline ::apollo::common::PointENU* PullOverStatus::release_inlane_dest_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = _impl_.inlane_dest_point_;
  _impl_.inlane_dest_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::PointENU* PullOverStatus::unsafe_arena_release_inlane_dest_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.PullOverStatus.inlane_dest_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = _impl_.inlane_dest_point_;
  _impl_.inlane_dest_point_ = nullptr;
  return temp;
}
inline ::apollo::common::PointENU* PullOverStatus::_internal_mutable_inlane_dest_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.inlane_dest_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::PointENU>(GetArenaForAllocation());
    _impl_.inlane_dest_point_ = p;
  }
  return _impl_.inlane_dest_point_;
}
inline ::apollo::common::PointENU* PullOverStatus::mutable_inlane_dest_point() {
  ::apollo::common::PointENU* _msg = _internal_mutable_inlane_dest_point();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PullOverStatus.inlane_dest_point)
  return _msg;
}
inline void PullOverStatus::set_allocated_inlane_dest_point(::apollo::common::PointENU* inlane_dest_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inlane_dest_point_);
  }
  if (inlane_dest_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inlane_dest_point));
    if (message_arena != submessage_arena) {
      inlane_dest_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inlane_dest_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.inlane_dest_point_ = inlane_dest_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PullOverStatus.inlane_dest_point)
}

// optional .apollo.common.PointENU start_point = 4;
inline bool PullOverStatus::_internal_has_start_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_point_ != nullptr);
  return value;
}
inline bool PullOverStatus::has_start_point() const {
  return _internal_has_start_point();
}
inline const ::apollo::common::PointENU& PullOverStatus::_internal_start_point() const {
  const ::apollo::common::PointENU* p = _impl_.start_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::PointENU&>(
      ::apollo::common::_PointENU_default_instance_);
}
inline const ::apollo::common::PointENU& PullOverStatus::start_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.start_point)
  return _internal_start_point();
}
inline void PullOverStatus::unsafe_arena_set_allocated_start_point(
    ::apollo::common::PointENU* start_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_point_);
  }
  _impl_.start_point_ = start_point;
  if (start_point) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PullOverStatus.start_point)
}
inline ::apollo::common::PointENU* PullOverStatus::release_start_point() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::PointENU* temp = _impl_.start_point_;
  _impl_.start_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::PointENU* PullOverStatus::unsafe_arena_release_start_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.PullOverStatus.start_point)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::PointENU* temp = _impl_.start_point_;
  _impl_.start_point_ = nullptr;
  return temp;
}
inline ::apollo::common::PointENU* PullOverStatus::_internal_mutable_start_point() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.start_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::PointENU>(GetArenaForAllocation());
    _impl_.start_point_ = p;
  }
  return _impl_.start_point_;
}
inline ::apollo::common::PointENU* PullOverStatus::mutable_start_point() {
  ::apollo::common::PointENU* _msg = _internal_mutable_start_point();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PullOverStatus.start_point)
  return _msg;
}
inline void PullOverStatus::set_allocated_start_point(::apollo::common::PointENU* start_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_point_);
  }
  if (start_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_point));
    if (message_arena != submessage_arena) {
      start_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.start_point_ = start_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PullOverStatus.start_point)
}

// optional .apollo.common.PointENU stop_point = 5;
inline bool PullOverStatus::_internal_has_stop_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_point_ != nullptr);
  return value;
}
inline bool PullOverStatus::has_stop_point() const {
  return _internal_has_stop_point();
}
inline const ::apollo::common::PointENU& PullOverStatus::_internal_stop_point() const {
  const ::apollo::common::PointENU* p = _impl_.stop_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::PointENU&>(
      ::apollo::common::_PointENU_default_instance_);
}
inline const ::apollo::common::PointENU& PullOverStatus::stop_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.stop_point)
  return _internal_stop_point();
}
inline void PullOverStatus::unsafe_arena_set_allocated_stop_point(
    ::apollo::common::PointENU* stop_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stop_point_);
  }
  _impl_.stop_point_ = stop_point;
  if (stop_point) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PullOverStatus.stop_point)
}
inline ::apollo::common::PointENU* PullOverStatus::release_stop_point() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::common::PointENU* temp = _impl_.stop_point_;
  _impl_.stop_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::PointENU* PullOverStatus::unsafe_arena_release_stop_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.PullOverStatus.stop_point)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::common::PointENU* temp = _impl_.stop_point_;
  _impl_.stop_point_ = nullptr;
  return temp;
}
inline ::apollo::common::PointENU* PullOverStatus::_internal_mutable_stop_point() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.stop_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::PointENU>(GetArenaForAllocation());
    _impl_.stop_point_ = p;
  }
  return _impl_.stop_point_;
}
inline ::apollo::common::PointENU* PullOverStatus::mutable_stop_point() {
  ::apollo::common::PointENU* _msg = _internal_mutable_stop_point();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PullOverStatus.stop_point)
  return _msg;
}
inline void PullOverStatus::set_allocated_stop_point(::apollo::common::PointENU* stop_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stop_point_);
  }
  if (stop_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point));
    if (message_arena != submessage_arena) {
      stop_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stop_point_ = stop_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PullOverStatus.stop_point)
}

// optional double stop_point_heading = 6;
inline bool PullOverStatus::_internal_has_stop_point_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PullOverStatus::has_stop_point_heading() const {
  return _internal_has_stop_point_heading();
}
inline void PullOverStatus::clear_stop_point_heading() {
  _impl_.stop_point_heading_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double PullOverStatus::_internal_stop_point_heading() const {
  return _impl_.stop_point_heading_;
}
inline double PullOverStatus::stop_point_heading() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.stop_point_heading)
  return _internal_stop_point_heading();
}
inline void PullOverStatus::_internal_set_stop_point_heading(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stop_point_heading_ = value;
}
inline void PullOverStatus::set_stop_point_heading(double value) {
  _internal_set_stop_point_heading(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.stop_point_heading)
}

// optional .apollo.planning.PullOverStatus.Reason reason = 7;
inline bool PullOverStatus::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PullOverStatus::has_reason() const {
  return _internal_has_reason();
}
inline void PullOverStatus::clear_reason() {
  _impl_.reason_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::apollo::planning::PullOverStatus_Reason PullOverStatus::_internal_reason() const {
  return static_cast< ::apollo::planning::PullOverStatus_Reason >(_impl_.reason_);
}
inline ::apollo::planning::PullOverStatus_Reason PullOverStatus::reason() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.reason)
  return _internal_reason();
}
inline void PullOverStatus::_internal_set_reason(::apollo::planning::PullOverStatus_Reason value) {
  assert(::apollo::planning::PullOverStatus_Reason_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.reason_ = value;
}
inline void PullOverStatus::set_reason(::apollo::planning::PullOverStatus_Reason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.reason)
}

// optional double status_set_time = 8;
inline bool PullOverStatus::_internal_has_status_set_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PullOverStatus::has_status_set_time() const {
  return _internal_has_status_set_time();
}
inline void PullOverStatus::clear_status_set_time() {
  _impl_.status_set_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double PullOverStatus::_internal_status_set_time() const {
  return _impl_.status_set_time_;
}
inline double PullOverStatus::status_set_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.status_set_time)
  return _internal_status_set_time();
}
inline void PullOverStatus::_internal_set_status_set_time(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.status_set_time_ = value;
}
inline void PullOverStatus::set_status_set_time(double value) {
  _internal_set_status_set_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.status_set_time)
}

// -------------------------------------------------------------------

// ReroutingStatus

// optional double last_rerouting_time = 1;
inline bool ReroutingStatus::_internal_has_last_rerouting_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReroutingStatus::has_last_rerouting_time() const {
  return _internal_has_last_rerouting_time();
}
inline void ReroutingStatus::clear_last_rerouting_time() {
  _impl_.last_rerouting_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ReroutingStatus::_internal_last_rerouting_time() const {
  return _impl_.last_rerouting_time_;
}
inline double ReroutingStatus::last_rerouting_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingStatus.last_rerouting_time)
  return _internal_last_rerouting_time();
}
inline void ReroutingStatus::_internal_set_last_rerouting_time(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.last_rerouting_time_ = value;
}
inline void ReroutingStatus::set_last_rerouting_time(double value) {
  _internal_set_last_rerouting_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingStatus.last_rerouting_time)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RightOfWayStatus

// map<string, bool> junction = 1;
inline int RightOfWayStatus::_internal_junction_size() const {
  return _impl_.junction_.size();
}
inline int RightOfWayStatus::junction_size() const {
  return _internal_junction_size();
}
inline void RightOfWayStatus::clear_junction() {
  _impl_.junction_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
RightOfWayStatus::_internal_junction() const {
  return _impl_.junction_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
RightOfWayStatus::junction() const {
  // @@protoc_insertion_point(field_map:apollo.planning.RightOfWayStatus.junction)
  return _internal_junction();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
RightOfWayStatus::_internal_mutable_junction() {
  return _impl_.junction_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
RightOfWayStatus::mutable_junction() {
  // @@protoc_insertion_point(field_mutable_map:apollo.planning.RightOfWayStatus.junction)
  return _internal_mutable_junction();
}

// -------------------------------------------------------------------

// SidePassStatus

// optional .apollo.planning.SidePassStatus.Status status = 1;
inline bool SidePassStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SidePassStatus::has_status() const {
  return _internal_has_status();
}
inline void SidePassStatus::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::planning::SidePassStatus_Status SidePassStatus::_internal_status() const {
  return static_cast< ::apollo::planning::SidePassStatus_Status >(_impl_.status_);
}
inline ::apollo::planning::SidePassStatus_Status SidePassStatus::status() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStatus.status)
  return _internal_status();
}
inline void SidePassStatus::_internal_set_status(::apollo::planning::SidePassStatus_Status value) {
  assert(::apollo::planning::SidePassStatus_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}
inline void SidePassStatus::set_status(::apollo::planning::SidePassStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:apollo.planning.SidePassStatus.status)
}

// optional double wait_start_time = 2;
inline bool SidePassStatus::_internal_has_wait_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SidePassStatus::has_wait_start_time() const {
  return _internal_has_wait_start_time();
}
inline void SidePassStatus::clear_wait_start_time() {
  _impl_.wait_start_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double SidePassStatus::_internal_wait_start_time() const {
  return _impl_.wait_start_time_;
}
inline double SidePassStatus::wait_start_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStatus.wait_start_time)
  return _internal_wait_start_time();
}
inline void SidePassStatus::_internal_set_wait_start_time(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wait_start_time_ = value;
}
inline void SidePassStatus::set_wait_start_time(double value) {
  _internal_set_wait_start_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.SidePassStatus.wait_start_time)
}

// optional string pass_obstacle_id = 3;
inline bool SidePassStatus::_internal_has_pass_obstacle_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SidePassStatus::has_pass_obstacle_id() const {
  return _internal_has_pass_obstacle_id();
}
inline void SidePassStatus::clear_pass_obstacle_id() {
  _impl_.pass_obstacle_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SidePassStatus::pass_obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStatus.pass_obstacle_id)
  return _internal_pass_obstacle_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SidePassStatus::set_pass_obstacle_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pass_obstacle_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.SidePassStatus.pass_obstacle_id)
}
inline std::string* SidePassStatus::mutable_pass_obstacle_id() {
  std::string* _s = _internal_mutable_pass_obstacle_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.SidePassStatus.pass_obstacle_id)
  return _s;
}
inline const std::string& SidePassStatus::_internal_pass_obstacle_id() const {
  return _impl_.pass_obstacle_id_.Get();
}
inline void SidePassStatus::_internal_set_pass_obstacle_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pass_obstacle_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SidePassStatus::_internal_mutable_pass_obstacle_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pass_obstacle_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SidePassStatus::release_pass_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.SidePassStatus.pass_obstacle_id)
  if (!_internal_has_pass_obstacle_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pass_obstacle_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pass_obstacle_id_.IsDefault()) {
    _impl_.pass_obstacle_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SidePassStatus::set_allocated_pass_obstacle_id(std::string* pass_obstacle_id) {
  if (pass_obstacle_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pass_obstacle_id_.SetAllocated(pass_obstacle_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pass_obstacle_id_.IsDefault()) {
    _impl_.pass_obstacle_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.SidePassStatus.pass_obstacle_id)
}

// optional .apollo.planning.ObjectSidePass.Type pass_side = 4;
inline bool SidePassStatus::_internal_has_pass_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SidePassStatus::has_pass_side() const {
  return _internal_has_pass_side();
}
inline void SidePassStatus::clear_pass_side() {
  _impl_.pass_side_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::apollo::planning::ObjectSidePass_Type SidePassStatus::_internal_pass_side() const {
  return static_cast< ::apollo::planning::ObjectSidePass_Type >(_impl_.pass_side_);
}
inline ::apollo::planning::ObjectSidePass_Type SidePassStatus::pass_side() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStatus.pass_side)
  return _internal_pass_side();
}
inline void SidePassStatus::_internal_set_pass_side(::apollo::planning::ObjectSidePass_Type value) {
  assert(::apollo::planning::ObjectSidePass_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pass_side_ = value;
}
inline void SidePassStatus::set_pass_side(::apollo::planning::ObjectSidePass_Type value) {
  _internal_set_pass_side(value);
  // @@protoc_insertion_point(field_set:apollo.planning.SidePassStatus.pass_side)
}

// -------------------------------------------------------------------

// StopSignStatus_LaneWatchVehicles

// optional string lane_id = 1;
inline bool StopSignStatus_LaneWatchVehicles::_internal_has_lane_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopSignStatus_LaneWatchVehicles::has_lane_id() const {
  return _internal_has_lane_id();
}
inline void StopSignStatus_LaneWatchVehicles::clear_lane_id() {
  _impl_.lane_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopSignStatus_LaneWatchVehicles::lane_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
  return _internal_lane_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopSignStatus_LaneWatchVehicles::set_lane_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.lane_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
}
inline std::string* StopSignStatus_LaneWatchVehicles::mutable_lane_id() {
  std::string* _s = _internal_mutable_lane_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
  return _s;
}
inline const std::string& StopSignStatus_LaneWatchVehicles::_internal_lane_id() const {
  return _impl_.lane_id_.Get();
}
inline void StopSignStatus_LaneWatchVehicles::_internal_set_lane_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lane_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopSignStatus_LaneWatchVehicles::_internal_mutable_lane_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.lane_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopSignStatus_LaneWatchVehicles::release_lane_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
  if (!_internal_has_lane_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.lane_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lane_id_.IsDefault()) {
    _impl_.lane_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StopSignStatus_LaneWatchVehicles::set_allocated_lane_id(std::string* lane_id) {
  if (lane_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lane_id_.SetAllocated(lane_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lane_id_.IsDefault()) {
    _impl_.lane_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
}

// repeated string watch_vehicles = 2;
inline int StopSignStatus_LaneWatchVehicles::_internal_watch_vehicles_size() const {
  return _impl_.watch_vehicles_.size();
}
inline int StopSignStatus_LaneWatchVehicles::watch_vehicles_size() const {
  return _internal_watch_vehicles_size();
}
inline void StopSignStatus_LaneWatchVehicles::clear_watch_vehicles() {
  _impl_.watch_vehicles_.Clear();
}
inline std::string* StopSignStatus_LaneWatchVehicles::add_watch_vehicles() {
  std::string* _s = _internal_add_watch_vehicles();
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  return _s;
}
inline const std::string& StopSignStatus_LaneWatchVehicles::_internal_watch_vehicles(int index) const {
  return _impl_.watch_vehicles_.Get(index);
}
inline const std::string& StopSignStatus_LaneWatchVehicles::watch_vehicles(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  return _internal_watch_vehicles(index);
}
inline std::string* StopSignStatus_LaneWatchVehicles::mutable_watch_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  return _impl_.watch_vehicles_.Mutable(index);
}
inline void StopSignStatus_LaneWatchVehicles::set_watch_vehicles(int index, const std::string& value) {
  _impl_.watch_vehicles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline void StopSignStatus_LaneWatchVehicles::set_watch_vehicles(int index, std::string&& value) {
  _impl_.watch_vehicles_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline void StopSignStatus_LaneWatchVehicles::set_watch_vehicles(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.watch_vehicles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline void StopSignStatus_LaneWatchVehicles::set_watch_vehicles(int index, const char* value, size_t size) {
  _impl_.watch_vehicles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline std::string* StopSignStatus_LaneWatchVehicles::_internal_add_watch_vehicles() {
  return _impl_.watch_vehicles_.Add();
}
inline void StopSignStatus_LaneWatchVehicles::add_watch_vehicles(const std::string& value) {
  _impl_.watch_vehicles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline void StopSignStatus_LaneWatchVehicles::add_watch_vehicles(std::string&& value) {
  _impl_.watch_vehicles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline void StopSignStatus_LaneWatchVehicles::add_watch_vehicles(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.watch_vehicles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline void StopSignStatus_LaneWatchVehicles::add_watch_vehicles(const char* value, size_t size) {
  _impl_.watch_vehicles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StopSignStatus_LaneWatchVehicles::watch_vehicles() const {
  // @@protoc_insertion_point(field_list:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  return _impl_.watch_vehicles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StopSignStatus_LaneWatchVehicles::mutable_watch_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  return &_impl_.watch_vehicles_;
}

// -------------------------------------------------------------------

// StopSignStatus

// optional string stop_sign_id = 1;
inline bool StopSignStatus::_internal_has_stop_sign_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopSignStatus::has_stop_sign_id() const {
  return _internal_has_stop_sign_id();
}
inline void StopSignStatus::clear_stop_sign_id() {
  _impl_.stop_sign_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopSignStatus::stop_sign_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.stop_sign_id)
  return _internal_stop_sign_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopSignStatus::set_stop_sign_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stop_sign_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.stop_sign_id)
}
inline std::string* StopSignStatus::mutable_stop_sign_id() {
  std::string* _s = _internal_mutable_stop_sign_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.stop_sign_id)
  return _s;
}
inline const std::string& StopSignStatus::_internal_stop_sign_id() const {
  return _impl_.stop_sign_id_.Get();
}
inline void StopSignStatus::_internal_set_stop_sign_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_sign_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopSignStatus::_internal_mutable_stop_sign_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stop_sign_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopSignStatus::release_stop_sign_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopSignStatus.stop_sign_id)
  if (!_internal_has_stop_sign_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stop_sign_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_sign_id_.IsDefault()) {
    _impl_.stop_sign_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StopSignStatus::set_allocated_stop_sign_id(std::string* stop_sign_id) {
  if (stop_sign_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_sign_id_.SetAllocated(stop_sign_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_sign_id_.IsDefault()) {
    _impl_.stop_sign_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopSignStatus.stop_sign_id)
}

// optional .apollo.planning.StopSignStatus.Status status = 2;
inline bool StopSignStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StopSignStatus::has_status() const {
  return _internal_has_status();
}
inline void StopSignStatus::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::apollo::planning::StopSignStatus_Status StopSignStatus::_internal_status() const {
  return static_cast< ::apollo::planning::StopSignStatus_Status >(_impl_.status_);
}
inline ::apollo::planning::StopSignStatus_Status StopSignStatus::status() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.status)
  return _internal_status();
}
inline void StopSignStatus::_internal_set_status(::apollo::planning::StopSignStatus_Status value) {
  assert(::apollo::planning::StopSignStatus_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}
inline void StopSignStatus::set_status(::apollo::planning::StopSignStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.status)
}

// optional double stop_start_time = 3;
inline bool StopSignStatus::_internal_has_stop_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopSignStatus::has_stop_start_time() const {
  return _internal_has_stop_start_time();
}
inline void StopSignStatus::clear_stop_start_time() {
  _impl_.stop_start_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double StopSignStatus::_internal_stop_start_time() const {
  return _impl_.stop_start_time_;
}
inline double StopSignStatus::stop_start_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.stop_start_time)
  return _internal_stop_start_time();
}
inline void StopSignStatus::_internal_set_stop_start_time(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stop_start_time_ = value;
}
inline void StopSignStatus::set_stop_start_time(double value) {
  _internal_set_stop_start_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.stop_start_time)
}

// repeated .apollo.planning.StopSignStatus.LaneWatchVehicles lane_watch_vehicles = 4;
inline int StopSignStatus::_internal_lane_watch_vehicles_size() const {
  return _impl_.lane_watch_vehicles_.size();
}
inline int StopSignStatus::lane_watch_vehicles_size() const {
  return _internal_lane_watch_vehicles_size();
}
inline void StopSignStatus::clear_lane_watch_vehicles() {
  _impl_.lane_watch_vehicles_.Clear();
}
inline ::apollo::planning::StopSignStatus_LaneWatchVehicles* StopSignStatus::mutable_lane_watch_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.lane_watch_vehicles)
  return _impl_.lane_watch_vehicles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopSignStatus_LaneWatchVehicles >*
StopSignStatus::mutable_lane_watch_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.StopSignStatus.lane_watch_vehicles)
  return &_impl_.lane_watch_vehicles_;
}
inline const ::apollo::planning::StopSignStatus_LaneWatchVehicles& StopSignStatus::_internal_lane_watch_vehicles(int index) const {
  return _impl_.lane_watch_vehicles_.Get(index);
}
inline const ::apollo::planning::StopSignStatus_LaneWatchVehicles& StopSignStatus::lane_watch_vehicles(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.lane_watch_vehicles)
  return _internal_lane_watch_vehicles(index);
}
inline ::apollo::planning::StopSignStatus_LaneWatchVehicles* StopSignStatus::_internal_add_lane_watch_vehicles() {
  return _impl_.lane_watch_vehicles_.Add();
}
inline ::apollo::planning::StopSignStatus_LaneWatchVehicles* StopSignStatus::add_lane_watch_vehicles() {
  ::apollo::planning::StopSignStatus_LaneWatchVehicles* _add = _internal_add_lane_watch_vehicles();
  // @@protoc_insertion_point(field_add:apollo.planning.StopSignStatus.lane_watch_vehicles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopSignStatus_LaneWatchVehicles >&
StopSignStatus::lane_watch_vehicles() const {
  // @@protoc_insertion_point(field_list:apollo.planning.StopSignStatus.lane_watch_vehicles)
  return _impl_.lane_watch_vehicles_;
}

// -------------------------------------------------------------------

// PlanningState

// .apollo.planning.PullOverStatus pull_over = 1;
inline bool PlanningState::_internal_has_pull_over() const {
  return object_tag_case() == kPullOver;
}
inline bool PlanningState::has_pull_over() const {
  return _internal_has_pull_over();
}
inline void PlanningState::set_has_pull_over() {
  _impl_._oneof_case_[0] = kPullOver;
}
inline void PlanningState::clear_pull_over() {
  if (_internal_has_pull_over()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.object_tag_.pull_over_;
    }
    clear_has_object_tag();
  }
}
inline ::apollo::planning::PullOverStatus* PlanningState::release_pull_over() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningState.pull_over)
  if (_internal_has_pull_over()) {
    clear_has_object_tag();
    ::apollo::planning::PullOverStatus* temp = _impl_.object_tag_.pull_over_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_tag_.pull_over_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::PullOverStatus& PlanningState::_internal_pull_over() const {
  return _internal_has_pull_over()
      ? *_impl_.object_tag_.pull_over_
      : reinterpret_cast< ::apollo::planning::PullOverStatus&>(::apollo::planning::_PullOverStatus_default_instance_);
}
inline const ::apollo::planning::PullOverStatus& PlanningState::pull_over() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningState.pull_over)
  return _internal_pull_over();
}
inline ::apollo::planning::PullOverStatus* PlanningState::unsafe_arena_release_pull_over() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.PlanningState.pull_over)
  if (_internal_has_pull_over()) {
    clear_has_object_tag();
    ::apollo::planning::PullOverStatus* temp = _impl_.object_tag_.pull_over_;
    _impl_.object_tag_.pull_over_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanningState::unsafe_arena_set_allocated_pull_over(::apollo::planning::PullOverStatus* pull_over) {
  clear_object_tag();
  if (pull_over) {
    set_has_pull_over();
    _impl_.object_tag_.pull_over_ = pull_over;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningState.pull_over)
}
inline ::apollo::planning::PullOverStatus* PlanningState::_internal_mutable_pull_over() {
  if (!_internal_has_pull_over()) {
    clear_object_tag();
    set_has_pull_over();
    _impl_.object_tag_.pull_over_ = CreateMaybeMessage< ::apollo::planning::PullOverStatus >(GetArenaForAllocation());
  }
  return _impl_.object_tag_.pull_over_;
}
inline ::apollo::planning::PullOverStatus* PlanningState::mutable_pull_over() {
  ::apollo::planning::PullOverStatus* _msg = _internal_mutable_pull_over();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningState.pull_over)
  return _msg;
}

inline bool PlanningState::has_object_tag() const {
  return object_tag_case() != OBJECT_TAG_NOT_SET;
}
inline void PlanningState::clear_has_object_tag() {
  _impl_._oneof_case_[0] = OBJECT_TAG_NOT_SET;
}
inline PlanningState::ObjectTagCase PlanningState::object_tag_case() const {
  return PlanningState::ObjectTagCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlanningStatus

// optional .apollo.planning.PlanningState planning_state = 1;
inline bool PlanningStatus::_internal_has_planning_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.planning_state_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_planning_state() const {
  return _internal_has_planning_state();
}
inline void PlanningStatus::clear_planning_state() {
  if (_impl_.planning_state_ != nullptr) _impl_.planning_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::PlanningState& PlanningStatus::_internal_planning_state() const {
  const ::apollo::planning::PlanningState* p = _impl_.planning_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::PlanningState&>(
      ::apollo::planning::_PlanningState_default_instance_);
}
inline const ::apollo::planning::PlanningState& PlanningStatus::planning_state() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.planning_state)
  return _internal_planning_state();
}
inline void PlanningStatus::unsafe_arena_set_allocated_planning_state(
    ::apollo::planning::PlanningState* planning_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.planning_state_);
  }
  _impl_.planning_state_ = planning_state;
  if (planning_state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.planning_state)
}
inline ::apollo::planning::PlanningState* PlanningStatus::release_planning_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::PlanningState* temp = _impl_.planning_state_;
  _impl_.planning_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::PlanningState* PlanningStatus::unsafe_arena_release_planning_state() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.planning_state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::PlanningState* temp = _impl_.planning_state_;
  _impl_.planning_state_ = nullptr;
  return temp;
}
inline ::apollo::planning::PlanningState* PlanningStatus::_internal_mutable_planning_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.planning_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::PlanningState>(GetArenaForAllocation());
    _impl_.planning_state_ = p;
  }
  return _impl_.planning_state_;
}
inline ::apollo::planning::PlanningState* PlanningStatus::mutable_planning_state() {
  ::apollo::planning::PlanningState* _msg = _internal_mutable_planning_state();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.planning_state)
  return _msg;
}
inline void PlanningStatus::set_allocated_planning_state(::apollo::planning::PlanningState* planning_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.planning_state_;
  }
  if (planning_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(planning_state);
    if (message_arena != submessage_arena) {
      planning_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planning_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.planning_state_ = planning_state;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.planning_state)
}

// optional .apollo.planning.ChangeLaneStatus change_lane = 2;
inline bool PlanningStatus::_internal_has_change_lane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.change_lane_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_change_lane() const {
  return _internal_has_change_lane();
}
inline void PlanningStatus::clear_change_lane() {
  if (_impl_.change_lane_ != nullptr) _impl_.change_lane_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::planning::ChangeLaneStatus& PlanningStatus::_internal_change_lane() const {
  const ::apollo::planning::ChangeLaneStatus* p = _impl_.change_lane_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::ChangeLaneStatus&>(
      ::apollo::planning::_ChangeLaneStatus_default_instance_);
}
inline const ::apollo::planning::ChangeLaneStatus& PlanningStatus::change_lane() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.change_lane)
  return _internal_change_lane();
}
inline void PlanningStatus::unsafe_arena_set_allocated_change_lane(
    ::apollo::planning::ChangeLaneStatus* change_lane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.change_lane_);
  }
  _impl_.change_lane_ = change_lane;
  if (change_lane) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.change_lane)
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::release_change_lane() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::ChangeLaneStatus* temp = _impl_.change_lane_;
  _impl_.change_lane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::unsafe_arena_release_change_lane() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.change_lane)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::ChangeLaneStatus* temp = _impl_.change_lane_;
  _impl_.change_lane_ = nullptr;
  return temp;
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::_internal_mutable_change_lane() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.change_lane_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ChangeLaneStatus>(GetArenaForAllocation());
    _impl_.change_lane_ = p;
  }
  return _impl_.change_lane_;
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::mutable_change_lane() {
  ::apollo::planning::ChangeLaneStatus* _msg = _internal_mutable_change_lane();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.change_lane)
  return _msg;
}
inline void PlanningStatus::set_allocated_change_lane(::apollo::planning::ChangeLaneStatus* change_lane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.change_lane_;
  }
  if (change_lane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(change_lane);
    if (message_arena != submessage_arena) {
      change_lane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_lane, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.change_lane_ = change_lane;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.change_lane)
}

// optional .apollo.planning.CrosswalkStatus crosswalk = 3;
inline bool PlanningStatus::_internal_has_crosswalk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.crosswalk_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_crosswalk() const {
  return _internal_has_crosswalk();
}
inline void PlanningStatus::clear_crosswalk() {
  if (_impl_.crosswalk_ != nullptr) _impl_.crosswalk_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::planning::CrosswalkStatus& PlanningStatus::_internal_crosswalk() const {
  const ::apollo::planning::CrosswalkStatus* p = _impl_.crosswalk_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::CrosswalkStatus&>(
      ::apollo::planning::_CrosswalkStatus_default_instance_);
}
inline const ::apollo::planning::CrosswalkStatus& PlanningStatus::crosswalk() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.crosswalk)
  return _internal_crosswalk();
}
inline void PlanningStatus::unsafe_arena_set_allocated_crosswalk(
    ::apollo::planning::CrosswalkStatus* crosswalk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.crosswalk_);
  }
  _impl_.crosswalk_ = crosswalk;
  if (crosswalk) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.crosswalk)
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::release_crosswalk() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::planning::CrosswalkStatus* temp = _impl_.crosswalk_;
  _impl_.crosswalk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::unsafe_arena_release_crosswalk() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.crosswalk)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::planning::CrosswalkStatus* temp = _impl_.crosswalk_;
  _impl_.crosswalk_ = nullptr;
  return temp;
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::_internal_mutable_crosswalk() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.crosswalk_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::CrosswalkStatus>(GetArenaForAllocation());
    _impl_.crosswalk_ = p;
  }
  return _impl_.crosswalk_;
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::mutable_crosswalk() {
  ::apollo::planning::CrosswalkStatus* _msg = _internal_mutable_crosswalk();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.crosswalk)
  return _msg;
}
inline void PlanningStatus::set_allocated_crosswalk(::apollo::planning::CrosswalkStatus* crosswalk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.crosswalk_;
  }
  if (crosswalk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(crosswalk);
    if (message_arena != submessage_arena) {
      crosswalk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crosswalk, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.crosswalk_ = crosswalk;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.crosswalk)
}

// optional .apollo.common.EngageAdvice engage_advice = 4;
inline bool PlanningStatus::_internal_has_engage_advice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.engage_advice_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_engage_advice() const {
  return _internal_has_engage_advice();
}
inline const ::apollo::common::EngageAdvice& PlanningStatus::_internal_engage_advice() const {
  const ::apollo::common::EngageAdvice* p = _impl_.engage_advice_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::EngageAdvice&>(
      ::apollo::common::_EngageAdvice_default_instance_);
}
inline const ::apollo::common::EngageAdvice& PlanningStatus::engage_advice() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.engage_advice)
  return _internal_engage_advice();
}
inline void PlanningStatus::unsafe_arena_set_allocated_engage_advice(
    ::apollo::common::EngageAdvice* engage_advice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.engage_advice_);
  }
  _impl_.engage_advice_ = engage_advice;
  if (engage_advice) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.engage_advice)
}
inline ::apollo::common::EngageAdvice* PlanningStatus::release_engage_advice() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::common::EngageAdvice* temp = _impl_.engage_advice_;
  _impl_.engage_advice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::EngageAdvice* PlanningStatus::unsafe_arena_release_engage_advice() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.engage_advice)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::common::EngageAdvice* temp = _impl_.engage_advice_;
  _impl_.engage_advice_ = nullptr;
  return temp;
}
inline ::apollo::common::EngageAdvice* PlanningStatus::_internal_mutable_engage_advice() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.engage_advice_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::EngageAdvice>(GetArenaForAllocation());
    _impl_.engage_advice_ = p;
  }
  return _impl_.engage_advice_;
}
inline ::apollo::common::EngageAdvice* PlanningStatus::mutable_engage_advice() {
  ::apollo::common::EngageAdvice* _msg = _internal_mutable_engage_advice();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.engage_advice)
  return _msg;
}
inline void PlanningStatus::set_allocated_engage_advice(::apollo::common::EngageAdvice* engage_advice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.engage_advice_);
  }
  if (engage_advice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(engage_advice));
    if (message_arena != submessage_arena) {
      engage_advice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, engage_advice, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.engage_advice_ = engage_advice;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.engage_advice)
}

// optional .apollo.planning.ReroutingStatus rerouting = 5;
inline bool PlanningStatus::_internal_has_rerouting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rerouting_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_rerouting() const {
  return _internal_has_rerouting();
}
inline void PlanningStatus::clear_rerouting() {
  if (_impl_.rerouting_ != nullptr) _impl_.rerouting_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::planning::ReroutingStatus& PlanningStatus::_internal_rerouting() const {
  const ::apollo::planning::ReroutingStatus* p = _impl_.rerouting_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::ReroutingStatus&>(
      ::apollo::planning::_ReroutingStatus_default_instance_);
}
inline const ::apollo::planning::ReroutingStatus& PlanningStatus::rerouting() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.rerouting)
  return _internal_rerouting();
}
inline void PlanningStatus::unsafe_arena_set_allocated_rerouting(
    ::apollo::planning::ReroutingStatus* rerouting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rerouting_);
  }
  _impl_.rerouting_ = rerouting;
  if (rerouting) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.rerouting)
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::release_rerouting() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::planning::ReroutingStatus* temp = _impl_.rerouting_;
  _impl_.rerouting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::unsafe_arena_release_rerouting() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.rerouting)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::planning::ReroutingStatus* temp = _impl_.rerouting_;
  _impl_.rerouting_ = nullptr;
  return temp;
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::_internal_mutable_rerouting() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.rerouting_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ReroutingStatus>(GetArenaForAllocation());
    _impl_.rerouting_ = p;
  }
  return _impl_.rerouting_;
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::mutable_rerouting() {
  ::apollo::planning::ReroutingStatus* _msg = _internal_mutable_rerouting();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.rerouting)
  return _msg;
}
inline void PlanningStatus::set_allocated_rerouting(::apollo::planning::ReroutingStatus* rerouting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rerouting_;
  }
  if (rerouting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rerouting);
    if (message_arena != submessage_arena) {
      rerouting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rerouting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.rerouting_ = rerouting;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.rerouting)
}

// optional .apollo.planning.RightOfWayStatus right_of_way = 6;
inline bool PlanningStatus::_internal_has_right_of_way() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_of_way_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_right_of_way() const {
  return _internal_has_right_of_way();
}
inline void PlanningStatus::clear_right_of_way() {
  if (_impl_.right_of_way_ != nullptr) _impl_.right_of_way_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::apollo::planning::RightOfWayStatus& PlanningStatus::_internal_right_of_way() const {
  const ::apollo::planning::RightOfWayStatus* p = _impl_.right_of_way_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::RightOfWayStatus&>(
      ::apollo::planning::_RightOfWayStatus_default_instance_);
}
inline const ::apollo::planning::RightOfWayStatus& PlanningStatus::right_of_way() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.right_of_way)
  return _internal_right_of_way();
}
inline void PlanningStatus::unsafe_arena_set_allocated_right_of_way(
    ::apollo::planning::RightOfWayStatus* right_of_way) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_of_way_);
  }
  _impl_.right_of_way_ = right_of_way;
  if (right_of_way) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.right_of_way)
}
inline ::apollo::planning::RightOfWayStatus* PlanningStatus::release_right_of_way() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::apollo::planning::RightOfWayStatus* temp = _impl_.right_of_way_;
  _impl_.right_of_way_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::RightOfWayStatus* PlanningStatus::unsafe_arena_release_right_of_way() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.right_of_way)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::apollo::planning::RightOfWayStatus* temp = _impl_.right_of_way_;
  _impl_.right_of_way_ = nullptr;
  return temp;
}
inline ::apollo::planning::RightOfWayStatus* PlanningStatus::_internal_mutable_right_of_way() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.right_of_way_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::RightOfWayStatus>(GetArenaForAllocation());
    _impl_.right_of_way_ = p;
  }
  return _impl_.right_of_way_;
}
inline ::apollo::planning::RightOfWayStatus* PlanningStatus::mutable_right_of_way() {
  ::apollo::planning::RightOfWayStatus* _msg = _internal_mutable_right_of_way();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.right_of_way)
  return _msg;
}
inline void PlanningStatus::set_allocated_right_of_way(::apollo::planning::RightOfWayStatus* right_of_way) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_of_way_;
  }
  if (right_of_way) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_of_way);
    if (message_arena != submessage_arena) {
      right_of_way = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_of_way, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.right_of_way_ = right_of_way;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.right_of_way)
}

// optional .apollo.planning.SidePassStatus side_pass = 7;
inline bool PlanningStatus::_internal_has_side_pass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.side_pass_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_side_pass() const {
  return _internal_has_side_pass();
}
inline void PlanningStatus::clear_side_pass() {
  if (_impl_.side_pass_ != nullptr) _impl_.side_pass_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::apollo::planning::SidePassStatus& PlanningStatus::_internal_side_pass() const {
  const ::apollo::planning::SidePassStatus* p = _impl_.side_pass_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::SidePassStatus&>(
      ::apollo::planning::_SidePassStatus_default_instance_);
}
inline const ::apollo::planning::SidePassStatus& PlanningStatus::side_pass() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.side_pass)
  return _internal_side_pass();
}
inline void PlanningStatus::unsafe_arena_set_allocated_side_pass(
    ::apollo::planning::SidePassStatus* side_pass) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.side_pass_);
  }
  _impl_.side_pass_ = side_pass;
  if (side_pass) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.side_pass)
}
inline ::apollo::planning::SidePassStatus* PlanningStatus::release_side_pass() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::apollo::planning::SidePassStatus* temp = _impl_.side_pass_;
  _impl_.side_pass_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::SidePassStatus* PlanningStatus::unsafe_arena_release_side_pass() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.side_pass)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::apollo::planning::SidePassStatus* temp = _impl_.side_pass_;
  _impl_.side_pass_ = nullptr;
  return temp;
}
inline ::apollo::planning::SidePassStatus* PlanningStatus::_internal_mutable_side_pass() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.side_pass_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::SidePassStatus>(GetArenaForAllocation());
    _impl_.side_pass_ = p;
  }
  return _impl_.side_pass_;
}
inline ::apollo::planning::SidePassStatus* PlanningStatus::mutable_side_pass() {
  ::apollo::planning::SidePassStatus* _msg = _internal_mutable_side_pass();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.side_pass)
  return _msg;
}
inline void PlanningStatus::set_allocated_side_pass(::apollo::planning::SidePassStatus* side_pass) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.side_pass_;
  }
  if (side_pass) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(side_pass);
    if (message_arena != submessage_arena) {
      side_pass = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, side_pass, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.side_pass_ = side_pass;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.side_pass)
}

// optional .apollo.planning.StopSignStatus stop_sign = 8;
inline bool PlanningStatus::_internal_has_stop_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_sign_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_stop_sign() const {
  return _internal_has_stop_sign();
}
inline void PlanningStatus::clear_stop_sign() {
  if (_impl_.stop_sign_ != nullptr) _impl_.stop_sign_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::apollo::planning::StopSignStatus& PlanningStatus::_internal_stop_sign() const {
  const ::apollo::planning::StopSignStatus* p = _impl_.stop_sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::StopSignStatus&>(
      ::apollo::planning::_StopSignStatus_default_instance_);
}
inline const ::apollo::planning::StopSignStatus& PlanningStatus::stop_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.stop_sign)
  return _internal_stop_sign();
}
inline void PlanningStatus::unsafe_arena_set_allocated_stop_sign(
    ::apollo::planning::StopSignStatus* stop_sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stop_sign_);
  }
  _impl_.stop_sign_ = stop_sign;
  if (stop_sign) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.stop_sign)
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::release_stop_sign() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::apollo::planning::StopSignStatus* temp = _impl_.stop_sign_;
  _impl_.stop_sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::unsafe_arena_release_stop_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.stop_sign)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::apollo::planning::StopSignStatus* temp = _impl_.stop_sign_;
  _impl_.stop_sign_ = nullptr;
  return temp;
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::_internal_mutable_stop_sign() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.stop_sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::StopSignStatus>(GetArenaForAllocation());
    _impl_.stop_sign_ = p;
  }
  return _impl_.stop_sign_;
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::mutable_stop_sign() {
  ::apollo::planning::StopSignStatus* _msg = _internal_mutable_stop_sign();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.stop_sign)
  return _msg;
}
inline void PlanningStatus::set_allocated_stop_sign(::apollo::planning::StopSignStatus* stop_sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stop_sign_;
  }
  if (stop_sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stop_sign);
    if (message_arena != submessage_arena) {
      stop_sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_sign, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.stop_sign_ = stop_sign;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.stop_sign)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::planning::ChangeLaneStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::ChangeLaneStatus_Status>() {
  return ::apollo::planning::ChangeLaneStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::PullOverStatus_Reason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::PullOverStatus_Reason>() {
  return ::apollo::planning::PullOverStatus_Reason_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::PullOverStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::PullOverStatus_Status>() {
  return ::apollo::planning::PullOverStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::SidePassStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::SidePassStatus_Status>() {
  return ::apollo::planning::SidePassStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::StopSignStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::StopSignStatus_Status>() {
  return ::apollo::planning::StopSignStatus_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto
