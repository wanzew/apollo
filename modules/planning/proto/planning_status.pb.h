// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_status.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/common/proto/geometry.pb.h"
#include "modules/planning/proto/planning_config.pb.h"
#include "modules/routing/proto/routing.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
namespace apollo {
namespace planning {
class BareIntersectionStatus;
struct BareIntersectionStatusDefaultTypeInternal;
extern BareIntersectionStatusDefaultTypeInternal _BareIntersectionStatus_default_instance_;
class ChangeLaneStatus;
struct ChangeLaneStatusDefaultTypeInternal;
extern ChangeLaneStatusDefaultTypeInternal _ChangeLaneStatus_default_instance_;
class CreepDeciderStatus;
struct CreepDeciderStatusDefaultTypeInternal;
extern CreepDeciderStatusDefaultTypeInternal _CreepDeciderStatus_default_instance_;
class CrosswalkStatus;
struct CrosswalkStatusDefaultTypeInternal;
extern CrosswalkStatusDefaultTypeInternal _CrosswalkStatus_default_instance_;
class DestinationStatus;
struct DestinationStatusDefaultTypeInternal;
extern DestinationStatusDefaultTypeInternal _DestinationStatus_default_instance_;
class EmergencyStopStatus;
struct EmergencyStopStatusDefaultTypeInternal;
extern EmergencyStopStatusDefaultTypeInternal _EmergencyStopStatus_default_instance_;
class OpenSpaceStatus;
struct OpenSpaceStatusDefaultTypeInternal;
extern OpenSpaceStatusDefaultTypeInternal _OpenSpaceStatus_default_instance_;
class ParkAndGoStatus;
struct ParkAndGoStatusDefaultTypeInternal;
extern ParkAndGoStatusDefaultTypeInternal _ParkAndGoStatus_default_instance_;
class PathDeciderStatus;
struct PathDeciderStatusDefaultTypeInternal;
extern PathDeciderStatusDefaultTypeInternal _PathDeciderStatus_default_instance_;
class PlanningStatus;
struct PlanningStatusDefaultTypeInternal;
extern PlanningStatusDefaultTypeInternal _PlanningStatus_default_instance_;
class PullOverStatus;
struct PullOverStatusDefaultTypeInternal;
extern PullOverStatusDefaultTypeInternal _PullOverStatus_default_instance_;
class ReroutingStatus;
struct ReroutingStatusDefaultTypeInternal;
extern ReroutingStatusDefaultTypeInternal _ReroutingStatus_default_instance_;
class ScenarioStatus;
struct ScenarioStatusDefaultTypeInternal;
extern ScenarioStatusDefaultTypeInternal _ScenarioStatus_default_instance_;
class SpeedDeciderStatus;
struct SpeedDeciderStatusDefaultTypeInternal;
extern SpeedDeciderStatusDefaultTypeInternal _SpeedDeciderStatus_default_instance_;
class StopSignStatus;
struct StopSignStatusDefaultTypeInternal;
extern StopSignStatusDefaultTypeInternal _StopSignStatus_default_instance_;
class StopTime;
struct StopTimeDefaultTypeInternal;
extern StopTimeDefaultTypeInternal _StopTime_default_instance_;
class TrafficLightStatus;
struct TrafficLightStatusDefaultTypeInternal;
extern TrafficLightStatusDefaultTypeInternal _TrafficLightStatus_default_instance_;
class YieldSignStatus;
struct YieldSignStatusDefaultTypeInternal;
extern YieldSignStatusDefaultTypeInternal _YieldSignStatus_default_instance_;
}  // namespace planning
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::planning::BareIntersectionStatus* Arena::CreateMaybeMessage<::apollo::planning::BareIntersectionStatus>(Arena*);
template<> ::apollo::planning::ChangeLaneStatus* Arena::CreateMaybeMessage<::apollo::planning::ChangeLaneStatus>(Arena*);
template<> ::apollo::planning::CreepDeciderStatus* Arena::CreateMaybeMessage<::apollo::planning::CreepDeciderStatus>(Arena*);
template<> ::apollo::planning::CrosswalkStatus* Arena::CreateMaybeMessage<::apollo::planning::CrosswalkStatus>(Arena*);
template<> ::apollo::planning::DestinationStatus* Arena::CreateMaybeMessage<::apollo::planning::DestinationStatus>(Arena*);
template<> ::apollo::planning::EmergencyStopStatus* Arena::CreateMaybeMessage<::apollo::planning::EmergencyStopStatus>(Arena*);
template<> ::apollo::planning::OpenSpaceStatus* Arena::CreateMaybeMessage<::apollo::planning::OpenSpaceStatus>(Arena*);
template<> ::apollo::planning::ParkAndGoStatus* Arena::CreateMaybeMessage<::apollo::planning::ParkAndGoStatus>(Arena*);
template<> ::apollo::planning::PathDeciderStatus* Arena::CreateMaybeMessage<::apollo::planning::PathDeciderStatus>(Arena*);
template<> ::apollo::planning::PlanningStatus* Arena::CreateMaybeMessage<::apollo::planning::PlanningStatus>(Arena*);
template<> ::apollo::planning::PullOverStatus* Arena::CreateMaybeMessage<::apollo::planning::PullOverStatus>(Arena*);
template<> ::apollo::planning::ReroutingStatus* Arena::CreateMaybeMessage<::apollo::planning::ReroutingStatus>(Arena*);
template<> ::apollo::planning::ScenarioStatus* Arena::CreateMaybeMessage<::apollo::planning::ScenarioStatus>(Arena*);
template<> ::apollo::planning::SpeedDeciderStatus* Arena::CreateMaybeMessage<::apollo::planning::SpeedDeciderStatus>(Arena*);
template<> ::apollo::planning::StopSignStatus* Arena::CreateMaybeMessage<::apollo::planning::StopSignStatus>(Arena*);
template<> ::apollo::planning::StopTime* Arena::CreateMaybeMessage<::apollo::planning::StopTime>(Arena*);
template<> ::apollo::planning::TrafficLightStatus* Arena::CreateMaybeMessage<::apollo::planning::TrafficLightStatus>(Arena*);
template<> ::apollo::planning::YieldSignStatus* Arena::CreateMaybeMessage<::apollo::planning::YieldSignStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace planning {

enum ChangeLaneStatus_Status : int {
  ChangeLaneStatus_Status_IN_CHANGE_LANE = 1,
  ChangeLaneStatus_Status_CHANGE_LANE_FAILED = 2,
  ChangeLaneStatus_Status_CHANGE_LANE_FINISHED = 3
};
bool ChangeLaneStatus_Status_IsValid(int value);
constexpr ChangeLaneStatus_Status ChangeLaneStatus_Status_Status_MIN = ChangeLaneStatus_Status_IN_CHANGE_LANE;
constexpr ChangeLaneStatus_Status ChangeLaneStatus_Status_Status_MAX = ChangeLaneStatus_Status_CHANGE_LANE_FINISHED;
constexpr int ChangeLaneStatus_Status_Status_ARRAYSIZE = ChangeLaneStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeLaneStatus_Status_descriptor();
template<typename T>
inline const std::string& ChangeLaneStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeLaneStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeLaneStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeLaneStatus_Status_descriptor(), enum_t_value);
}
inline bool ChangeLaneStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeLaneStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeLaneStatus_Status>(
    ChangeLaneStatus_Status_descriptor(), name, value);
}
enum PathDeciderStatus_LaneBorrowDirection : int {
  PathDeciderStatus_LaneBorrowDirection_LEFT_BORROW = 1,
  PathDeciderStatus_LaneBorrowDirection_RIGHT_BORROW = 2
};
bool PathDeciderStatus_LaneBorrowDirection_IsValid(int value);
constexpr PathDeciderStatus_LaneBorrowDirection PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_MIN = PathDeciderStatus_LaneBorrowDirection_LEFT_BORROW;
constexpr PathDeciderStatus_LaneBorrowDirection PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_MAX = PathDeciderStatus_LaneBorrowDirection_RIGHT_BORROW;
constexpr int PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_ARRAYSIZE = PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PathDeciderStatus_LaneBorrowDirection_descriptor();
template<typename T>
inline const std::string& PathDeciderStatus_LaneBorrowDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PathDeciderStatus_LaneBorrowDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PathDeciderStatus_LaneBorrowDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PathDeciderStatus_LaneBorrowDirection_descriptor(), enum_t_value);
}
inline bool PathDeciderStatus_LaneBorrowDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PathDeciderStatus_LaneBorrowDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PathDeciderStatus_LaneBorrowDirection>(
    PathDeciderStatus_LaneBorrowDirection_descriptor(), name, value);
}
enum PullOverStatus_PullOverType : int {
  PullOverStatus_PullOverType_PULL_OVER = 1,
  PullOverStatus_PullOverType_EMERGENCY_PULL_OVER = 2
};
bool PullOverStatus_PullOverType_IsValid(int value);
constexpr PullOverStatus_PullOverType PullOverStatus_PullOverType_PullOverType_MIN = PullOverStatus_PullOverType_PULL_OVER;
constexpr PullOverStatus_PullOverType PullOverStatus_PullOverType_PullOverType_MAX = PullOverStatus_PullOverType_EMERGENCY_PULL_OVER;
constexpr int PullOverStatus_PullOverType_PullOverType_ARRAYSIZE = PullOverStatus_PullOverType_PullOverType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PullOverStatus_PullOverType_descriptor();
template<typename T>
inline const std::string& PullOverStatus_PullOverType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PullOverStatus_PullOverType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PullOverStatus_PullOverType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PullOverStatus_PullOverType_descriptor(), enum_t_value);
}
inline bool PullOverStatus_PullOverType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PullOverStatus_PullOverType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PullOverStatus_PullOverType>(
    PullOverStatus_PullOverType_descriptor(), name, value);
}
// ===================================================================

class BareIntersectionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.BareIntersectionStatus) */ {
 public:
  inline BareIntersectionStatus() : BareIntersectionStatus(nullptr) {}
  ~BareIntersectionStatus() override;
  explicit PROTOBUF_CONSTEXPR BareIntersectionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BareIntersectionStatus(const BareIntersectionStatus& from);
  BareIntersectionStatus(BareIntersectionStatus&& from) noexcept
    : BareIntersectionStatus() {
    *this = ::std::move(from);
  }

  inline BareIntersectionStatus& operator=(const BareIntersectionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline BareIntersectionStatus& operator=(BareIntersectionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BareIntersectionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const BareIntersectionStatus* internal_default_instance() {
    return reinterpret_cast<const BareIntersectionStatus*>(
               &_BareIntersectionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BareIntersectionStatus& a, BareIntersectionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(BareIntersectionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BareIntersectionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BareIntersectionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BareIntersectionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BareIntersectionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BareIntersectionStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BareIntersectionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.BareIntersectionStatus";
  }
  protected:
  explicit BareIntersectionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentPncJunctionOverlapIdFieldNumber = 1,
    kDonePncJunctionOverlapIdFieldNumber = 2,
    kClearCounterFieldNumber = 3,
  };
  // optional string current_pnc_junction_overlap_id = 1;
  bool has_current_pnc_junction_overlap_id() const;
  private:
  bool _internal_has_current_pnc_junction_overlap_id() const;
  public:
  void clear_current_pnc_junction_overlap_id();
  const std::string& current_pnc_junction_overlap_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_pnc_junction_overlap_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_pnc_junction_overlap_id();
  PROTOBUF_NODISCARD std::string* release_current_pnc_junction_overlap_id();
  void set_allocated_current_pnc_junction_overlap_id(std::string* current_pnc_junction_overlap_id);
  private:
  const std::string& _internal_current_pnc_junction_overlap_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_pnc_junction_overlap_id(const std::string& value);
  std::string* _internal_mutable_current_pnc_junction_overlap_id();
  public:

  // optional string done_pnc_junction_overlap_id = 2;
  bool has_done_pnc_junction_overlap_id() const;
  private:
  bool _internal_has_done_pnc_junction_overlap_id() const;
  public:
  void clear_done_pnc_junction_overlap_id();
  const std::string& done_pnc_junction_overlap_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_done_pnc_junction_overlap_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_done_pnc_junction_overlap_id();
  PROTOBUF_NODISCARD std::string* release_done_pnc_junction_overlap_id();
  void set_allocated_done_pnc_junction_overlap_id(std::string* done_pnc_junction_overlap_id);
  private:
  const std::string& _internal_done_pnc_junction_overlap_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_done_pnc_junction_overlap_id(const std::string& value);
  std::string* _internal_mutable_done_pnc_junction_overlap_id();
  public:

  // optional uint32 clear_counter = 3;
  bool has_clear_counter() const;
  private:
  bool _internal_has_clear_counter() const;
  public:
  void clear_clear_counter();
  uint32_t clear_counter() const;
  void set_clear_counter(uint32_t value);
  private:
  uint32_t _internal_clear_counter() const;
  void _internal_set_clear_counter(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.BareIntersectionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_pnc_junction_overlap_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr done_pnc_junction_overlap_id_;
    uint32_t clear_counter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class ChangeLaneStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ChangeLaneStatus) */ {
 public:
  inline ChangeLaneStatus() : ChangeLaneStatus(nullptr) {}
  ~ChangeLaneStatus() override;
  explicit PROTOBUF_CONSTEXPR ChangeLaneStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeLaneStatus(const ChangeLaneStatus& from);
  ChangeLaneStatus(ChangeLaneStatus&& from) noexcept
    : ChangeLaneStatus() {
    *this = ::std::move(from);
  }

  inline ChangeLaneStatus& operator=(const ChangeLaneStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeLaneStatus& operator=(ChangeLaneStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeLaneStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeLaneStatus* internal_default_instance() {
    return reinterpret_cast<const ChangeLaneStatus*>(
               &_ChangeLaneStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChangeLaneStatus& a, ChangeLaneStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeLaneStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeLaneStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeLaneStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeLaneStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeLaneStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeLaneStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeLaneStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ChangeLaneStatus";
  }
  protected:
  explicit ChangeLaneStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChangeLaneStatus_Status Status;
  static constexpr Status IN_CHANGE_LANE =
    ChangeLaneStatus_Status_IN_CHANGE_LANE;
  static constexpr Status CHANGE_LANE_FAILED =
    ChangeLaneStatus_Status_CHANGE_LANE_FAILED;
  static constexpr Status CHANGE_LANE_FINISHED =
    ChangeLaneStatus_Status_CHANGE_LANE_FINISHED;
  static inline bool Status_IsValid(int value) {
    return ChangeLaneStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ChangeLaneStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ChangeLaneStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ChangeLaneStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ChangeLaneStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ChangeLaneStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ChangeLaneStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathIdFieldNumber = 2,
    kLaneChangeStartPositionFieldNumber = 5,
    kTimestampFieldNumber = 3,
    kLastSucceedTimestampFieldNumber = 6,
    kExistLaneChangeStartPositionFieldNumber = 4,
    kIsCurrentOptSucceedFieldNumber = 7,
    kIsClearToChangeLaneFieldNumber = 8,
    kStatusFieldNumber = 1,
  };
  // optional string path_id = 2;
  bool has_path_id() const;
  private:
  bool _internal_has_path_id() const;
  public:
  void clear_path_id();
  const std::string& path_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path_id();
  PROTOBUF_NODISCARD std::string* release_path_id();
  void set_allocated_path_id(std::string* path_id);
  private:
  const std::string& _internal_path_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path_id(const std::string& value);
  std::string* _internal_mutable_path_id();
  public:

  // optional .apollo.common.Point3D lane_change_start_position = 5;
  bool has_lane_change_start_position() const;
  private:
  bool _internal_has_lane_change_start_position() const;
  public:
  void clear_lane_change_start_position();
  const ::apollo::common::Point3D& lane_change_start_position() const;
  PROTOBUF_NODISCARD ::apollo::common::Point3D* release_lane_change_start_position();
  ::apollo::common::Point3D* mutable_lane_change_start_position();
  void set_allocated_lane_change_start_position(::apollo::common::Point3D* lane_change_start_position);
  private:
  const ::apollo::common::Point3D& _internal_lane_change_start_position() const;
  ::apollo::common::Point3D* _internal_mutable_lane_change_start_position();
  public:
  void unsafe_arena_set_allocated_lane_change_start_position(
      ::apollo::common::Point3D* lane_change_start_position);
  ::apollo::common::Point3D* unsafe_arena_release_lane_change_start_position();

  // optional double timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  double timestamp() const;
  void set_timestamp(double value);
  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);
  public:

  // optional double last_succeed_timestamp = 6;
  bool has_last_succeed_timestamp() const;
  private:
  bool _internal_has_last_succeed_timestamp() const;
  public:
  void clear_last_succeed_timestamp();
  double last_succeed_timestamp() const;
  void set_last_succeed_timestamp(double value);
  private:
  double _internal_last_succeed_timestamp() const;
  void _internal_set_last_succeed_timestamp(double value);
  public:

  // optional bool exist_lane_change_start_position = 4 [default = false];
  bool has_exist_lane_change_start_position() const;
  private:
  bool _internal_has_exist_lane_change_start_position() const;
  public:
  void clear_exist_lane_change_start_position();
  bool exist_lane_change_start_position() const;
  void set_exist_lane_change_start_position(bool value);
  private:
  bool _internal_exist_lane_change_start_position() const;
  void _internal_set_exist_lane_change_start_position(bool value);
  public:

  // optional bool is_current_opt_succeed = 7 [default = false];
  bool has_is_current_opt_succeed() const;
  private:
  bool _internal_has_is_current_opt_succeed() const;
  public:
  void clear_is_current_opt_succeed();
  bool is_current_opt_succeed() const;
  void set_is_current_opt_succeed(bool value);
  private:
  bool _internal_is_current_opt_succeed() const;
  void _internal_set_is_current_opt_succeed(bool value);
  public:

  // optional bool is_clear_to_change_lane = 8 [default = false];
  bool has_is_clear_to_change_lane() const;
  private:
  bool _internal_has_is_clear_to_change_lane() const;
  public:
  void clear_is_clear_to_change_lane();
  bool is_clear_to_change_lane() const;
  void set_is_clear_to_change_lane(bool value);
  private:
  bool _internal_is_clear_to_change_lane() const;
  void _internal_set_is_clear_to_change_lane(bool value);
  public:

  // optional .apollo.planning.ChangeLaneStatus.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::apollo::planning::ChangeLaneStatus_Status status() const;
  void set_status(::apollo::planning::ChangeLaneStatus_Status value);
  private:
  ::apollo::planning::ChangeLaneStatus_Status _internal_status() const;
  void _internal_set_status(::apollo::planning::ChangeLaneStatus_Status value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ChangeLaneStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_id_;
    ::apollo::common::Point3D* lane_change_start_position_;
    double timestamp_;
    double last_succeed_timestamp_;
    bool exist_lane_change_start_position_;
    bool is_current_opt_succeed_;
    bool is_clear_to_change_lane_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class CreepDeciderStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CreepDeciderStatus) */ {
 public:
  inline CreepDeciderStatus() : CreepDeciderStatus(nullptr) {}
  ~CreepDeciderStatus() override;
  explicit PROTOBUF_CONSTEXPR CreepDeciderStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreepDeciderStatus(const CreepDeciderStatus& from);
  CreepDeciderStatus(CreepDeciderStatus&& from) noexcept
    : CreepDeciderStatus() {
    *this = ::std::move(from);
  }

  inline CreepDeciderStatus& operator=(const CreepDeciderStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreepDeciderStatus& operator=(CreepDeciderStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreepDeciderStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreepDeciderStatus* internal_default_instance() {
    return reinterpret_cast<const CreepDeciderStatus*>(
               &_CreepDeciderStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreepDeciderStatus& a, CreepDeciderStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CreepDeciderStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreepDeciderStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreepDeciderStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreepDeciderStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreepDeciderStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreepDeciderStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreepDeciderStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CreepDeciderStatus";
  }
  protected:
  explicit CreepDeciderStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreepClearCounterFieldNumber = 1,
  };
  // optional uint32 creep_clear_counter = 1;
  bool has_creep_clear_counter() const;
  private:
  bool _internal_has_creep_clear_counter() const;
  public:
  void clear_creep_clear_counter();
  uint32_t creep_clear_counter() const;
  void set_creep_clear_counter(uint32_t value);
  private:
  uint32_t _internal_creep_clear_counter() const;
  void _internal_set_creep_clear_counter(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CreepDeciderStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t creep_clear_counter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class StopTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopTime) */ {
 public:
  inline StopTime() : StopTime(nullptr) {}
  ~StopTime() override;
  explicit PROTOBUF_CONSTEXPR StopTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopTime(const StopTime& from);
  StopTime(StopTime&& from) noexcept
    : StopTime() {
    *this = ::std::move(from);
  }

  inline StopTime& operator=(const StopTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopTime& operator=(StopTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopTime* internal_default_instance() {
    return reinterpret_cast<const StopTime*>(
               &_StopTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StopTime& a, StopTime& b) {
    a.Swap(&b);
  }
  inline void Swap(StopTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopTime& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StopTime";
  }
  protected:
  explicit StopTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstacleIdFieldNumber = 1,
    kStopTimestampSecFieldNumber = 2,
  };
  // optional string obstacle_id = 1;
  bool has_obstacle_id() const;
  private:
  bool _internal_has_obstacle_id() const;
  public:
  void clear_obstacle_id();
  const std::string& obstacle_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obstacle_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obstacle_id();
  PROTOBUF_NODISCARD std::string* release_obstacle_id();
  void set_allocated_obstacle_id(std::string* obstacle_id);
  private:
  const std::string& _internal_obstacle_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obstacle_id(const std::string& value);
  std::string* _internal_mutable_obstacle_id();
  public:

  // optional double stop_timestamp_sec = 2;
  bool has_stop_timestamp_sec() const;
  private:
  bool _internal_has_stop_timestamp_sec() const;
  public:
  void clear_stop_timestamp_sec();
  double stop_timestamp_sec() const;
  void set_stop_timestamp_sec(double value);
  private:
  double _internal_stop_timestamp_sec() const;
  void _internal_set_stop_timestamp_sec(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StopTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obstacle_id_;
    double stop_timestamp_sec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class CrosswalkStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CrosswalkStatus) */ {
 public:
  inline CrosswalkStatus() : CrosswalkStatus(nullptr) {}
  ~CrosswalkStatus() override;
  explicit PROTOBUF_CONSTEXPR CrosswalkStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrosswalkStatus(const CrosswalkStatus& from);
  CrosswalkStatus(CrosswalkStatus&& from) noexcept
    : CrosswalkStatus() {
    *this = ::std::move(from);
  }

  inline CrosswalkStatus& operator=(const CrosswalkStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrosswalkStatus& operator=(CrosswalkStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CrosswalkStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrosswalkStatus* internal_default_instance() {
    return reinterpret_cast<const CrosswalkStatus*>(
               &_CrosswalkStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CrosswalkStatus& a, CrosswalkStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CrosswalkStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrosswalkStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrosswalkStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrosswalkStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CrosswalkStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CrosswalkStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CrosswalkStatus";
  }
  protected:
  explicit CrosswalkStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopTimeFieldNumber = 2,
    kFinishedCrosswalkFieldNumber = 3,
    kCrosswalkIdFieldNumber = 1,
  };
  // repeated .apollo.planning.StopTime stop_time = 2;
  int stop_time_size() const;
  private:
  int _internal_stop_time_size() const;
  public:
  void clear_stop_time();
  ::apollo::planning::StopTime* mutable_stop_time(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >*
      mutable_stop_time();
  private:
  const ::apollo::planning::StopTime& _internal_stop_time(int index) const;
  ::apollo::planning::StopTime* _internal_add_stop_time();
  public:
  const ::apollo::planning::StopTime& stop_time(int index) const;
  ::apollo::planning::StopTime* add_stop_time();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >&
      stop_time() const;

  // repeated string finished_crosswalk = 3;
  int finished_crosswalk_size() const;
  private:
  int _internal_finished_crosswalk_size() const;
  public:
  void clear_finished_crosswalk();
  const std::string& finished_crosswalk(int index) const;
  std::string* mutable_finished_crosswalk(int index);
  void set_finished_crosswalk(int index, const std::string& value);
  void set_finished_crosswalk(int index, std::string&& value);
  void set_finished_crosswalk(int index, const char* value);
  void set_finished_crosswalk(int index, const char* value, size_t size);
  std::string* add_finished_crosswalk();
  void add_finished_crosswalk(const std::string& value);
  void add_finished_crosswalk(std::string&& value);
  void add_finished_crosswalk(const char* value);
  void add_finished_crosswalk(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& finished_crosswalk() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_finished_crosswalk();
  private:
  const std::string& _internal_finished_crosswalk(int index) const;
  std::string* _internal_add_finished_crosswalk();
  public:

  // optional string crosswalk_id = 1;
  bool has_crosswalk_id() const;
  private:
  bool _internal_has_crosswalk_id() const;
  public:
  void clear_crosswalk_id();
  const std::string& crosswalk_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_crosswalk_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_crosswalk_id();
  PROTOBUF_NODISCARD std::string* release_crosswalk_id();
  void set_allocated_crosswalk_id(std::string* crosswalk_id);
  private:
  const std::string& _internal_crosswalk_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_crosswalk_id(const std::string& value);
  std::string* _internal_mutable_crosswalk_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CrosswalkStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime > stop_time_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> finished_crosswalk_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crosswalk_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class DestinationStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.DestinationStatus) */ {
 public:
  inline DestinationStatus() : DestinationStatus(nullptr) {}
  ~DestinationStatus() override;
  explicit PROTOBUF_CONSTEXPR DestinationStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestinationStatus(const DestinationStatus& from);
  DestinationStatus(DestinationStatus&& from) noexcept
    : DestinationStatus() {
    *this = ::std::move(from);
  }

  inline DestinationStatus& operator=(const DestinationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestinationStatus& operator=(DestinationStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestinationStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestinationStatus* internal_default_instance() {
    return reinterpret_cast<const DestinationStatus*>(
               &_DestinationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DestinationStatus& a, DestinationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(DestinationStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestinationStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestinationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestinationStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DestinationStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DestinationStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestinationStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.DestinationStatus";
  }
  protected:
  explicit DestinationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHasPassedDestinationFieldNumber = 1,
  };
  // optional bool has_passed_destination = 1 [default = false];
  bool has_has_passed_destination() const;
  private:
  bool _internal_has_has_passed_destination() const;
  public:
  void clear_has_passed_destination();
  bool has_passed_destination() const;
  void set_has_passed_destination(bool value);
  private:
  bool _internal_has_passed_destination() const;
  void _internal_set_has_passed_destination(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.DestinationStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool has_passed_destination_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class EmergencyStopStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.EmergencyStopStatus) */ {
 public:
  inline EmergencyStopStatus() : EmergencyStopStatus(nullptr) {}
  ~EmergencyStopStatus() override;
  explicit PROTOBUF_CONSTEXPR EmergencyStopStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmergencyStopStatus(const EmergencyStopStatus& from);
  EmergencyStopStatus(EmergencyStopStatus&& from) noexcept
    : EmergencyStopStatus() {
    *this = ::std::move(from);
  }

  inline EmergencyStopStatus& operator=(const EmergencyStopStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmergencyStopStatus& operator=(EmergencyStopStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmergencyStopStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmergencyStopStatus* internal_default_instance() {
    return reinterpret_cast<const EmergencyStopStatus*>(
               &_EmergencyStopStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EmergencyStopStatus& a, EmergencyStopStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(EmergencyStopStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmergencyStopStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmergencyStopStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmergencyStopStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmergencyStopStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EmergencyStopStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmergencyStopStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.EmergencyStopStatus";
  }
  protected:
  explicit EmergencyStopStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopFencePointFieldNumber = 1,
  };
  // optional .apollo.common.PointENU stop_fence_point = 1;
  bool has_stop_fence_point() const;
  private:
  bool _internal_has_stop_fence_point() const;
  public:
  void clear_stop_fence_point();
  const ::apollo::common::PointENU& stop_fence_point() const;
  PROTOBUF_NODISCARD ::apollo::common::PointENU* release_stop_fence_point();
  ::apollo::common::PointENU* mutable_stop_fence_point();
  void set_allocated_stop_fence_point(::apollo::common::PointENU* stop_fence_point);
  private:
  const ::apollo::common::PointENU& _internal_stop_fence_point() const;
  ::apollo::common::PointENU* _internal_mutable_stop_fence_point();
  public:
  void unsafe_arena_set_allocated_stop_fence_point(
      ::apollo::common::PointENU* stop_fence_point);
  ::apollo::common::PointENU* unsafe_arena_release_stop_fence_point();

  // @@protoc_insertion_point(class_scope:apollo.planning.EmergencyStopStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::common::PointENU* stop_fence_point_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class OpenSpaceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.OpenSpaceStatus) */ {
 public:
  inline OpenSpaceStatus() : OpenSpaceStatus(nullptr) {}
  ~OpenSpaceStatus() override;
  explicit PROTOBUF_CONSTEXPR OpenSpaceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenSpaceStatus(const OpenSpaceStatus& from);
  OpenSpaceStatus(OpenSpaceStatus&& from) noexcept
    : OpenSpaceStatus() {
    *this = ::std::move(from);
  }

  inline OpenSpaceStatus& operator=(const OpenSpaceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenSpaceStatus& operator=(OpenSpaceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenSpaceStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenSpaceStatus* internal_default_instance() {
    return reinterpret_cast<const OpenSpaceStatus*>(
               &_OpenSpaceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OpenSpaceStatus& a, OpenSpaceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenSpaceStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenSpaceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenSpaceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenSpaceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenSpaceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OpenSpaceStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenSpaceStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.OpenSpaceStatus";
  }
  protected:
  explicit OpenSpaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionedTrajectoriesIndexHistoryFieldNumber = 1,
    kPositionInitFieldNumber = 2,
  };
  // repeated string partitioned_trajectories_index_history = 1;
  int partitioned_trajectories_index_history_size() const;
  private:
  int _internal_partitioned_trajectories_index_history_size() const;
  public:
  void clear_partitioned_trajectories_index_history();
  const std::string& partitioned_trajectories_index_history(int index) const;
  std::string* mutable_partitioned_trajectories_index_history(int index);
  void set_partitioned_trajectories_index_history(int index, const std::string& value);
  void set_partitioned_trajectories_index_history(int index, std::string&& value);
  void set_partitioned_trajectories_index_history(int index, const char* value);
  void set_partitioned_trajectories_index_history(int index, const char* value, size_t size);
  std::string* add_partitioned_trajectories_index_history();
  void add_partitioned_trajectories_index_history(const std::string& value);
  void add_partitioned_trajectories_index_history(std::string&& value);
  void add_partitioned_trajectories_index_history(const char* value);
  void add_partitioned_trajectories_index_history(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& partitioned_trajectories_index_history() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_partitioned_trajectories_index_history();
  private:
  const std::string& _internal_partitioned_trajectories_index_history(int index) const;
  std::string* _internal_add_partitioned_trajectories_index_history();
  public:

  // optional bool position_init = 2 [default = false];
  bool has_position_init() const;
  private:
  bool _internal_has_position_init() const;
  public:
  void clear_position_init();
  bool position_init() const;
  void set_position_init(bool value);
  private:
  bool _internal_position_init() const;
  void _internal_set_position_init(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.OpenSpaceStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> partitioned_trajectories_index_history_;
    bool position_init_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class ParkAndGoStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ParkAndGoStatus) */ {
 public:
  inline ParkAndGoStatus() : ParkAndGoStatus(nullptr) {}
  ~ParkAndGoStatus() override;
  explicit PROTOBUF_CONSTEXPR ParkAndGoStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParkAndGoStatus(const ParkAndGoStatus& from);
  ParkAndGoStatus(ParkAndGoStatus&& from) noexcept
    : ParkAndGoStatus() {
    *this = ::std::move(from);
  }

  inline ParkAndGoStatus& operator=(const ParkAndGoStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParkAndGoStatus& operator=(ParkAndGoStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParkAndGoStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParkAndGoStatus* internal_default_instance() {
    return reinterpret_cast<const ParkAndGoStatus*>(
               &_ParkAndGoStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ParkAndGoStatus& a, ParkAndGoStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ParkAndGoStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParkAndGoStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParkAndGoStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParkAndGoStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParkAndGoStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ParkAndGoStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkAndGoStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ParkAndGoStatus";
  }
  protected:
  explicit ParkAndGoStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdcInitPositionFieldNumber = 1,
    kAdcAdjustEndPoseFieldNumber = 4,
    kAdcInitHeadingFieldNumber = 2,
    kInCheckStageFieldNumber = 3,
  };
  // optional .apollo.common.PointENU adc_init_position = 1;
  bool has_adc_init_position() const;
  private:
  bool _internal_has_adc_init_position() const;
  public:
  void clear_adc_init_position();
  const ::apollo::common::PointENU& adc_init_position() const;
  PROTOBUF_NODISCARD ::apollo::common::PointENU* release_adc_init_position();
  ::apollo::common::PointENU* mutable_adc_init_position();
  void set_allocated_adc_init_position(::apollo::common::PointENU* adc_init_position);
  private:
  const ::apollo::common::PointENU& _internal_adc_init_position() const;
  ::apollo::common::PointENU* _internal_mutable_adc_init_position();
  public:
  void unsafe_arena_set_allocated_adc_init_position(
      ::apollo::common::PointENU* adc_init_position);
  ::apollo::common::PointENU* unsafe_arena_release_adc_init_position();

  // optional .apollo.common.PointENU adc_adjust_end_pose = 4;
  bool has_adc_adjust_end_pose() const;
  private:
  bool _internal_has_adc_adjust_end_pose() const;
  public:
  void clear_adc_adjust_end_pose();
  const ::apollo::common::PointENU& adc_adjust_end_pose() const;
  PROTOBUF_NODISCARD ::apollo::common::PointENU* release_adc_adjust_end_pose();
  ::apollo::common::PointENU* mutable_adc_adjust_end_pose();
  void set_allocated_adc_adjust_end_pose(::apollo::common::PointENU* adc_adjust_end_pose);
  private:
  const ::apollo::common::PointENU& _internal_adc_adjust_end_pose() const;
  ::apollo::common::PointENU* _internal_mutable_adc_adjust_end_pose();
  public:
  void unsafe_arena_set_allocated_adc_adjust_end_pose(
      ::apollo::common::PointENU* adc_adjust_end_pose);
  ::apollo::common::PointENU* unsafe_arena_release_adc_adjust_end_pose();

  // optional double adc_init_heading = 2;
  bool has_adc_init_heading() const;
  private:
  bool _internal_has_adc_init_heading() const;
  public:
  void clear_adc_init_heading();
  double adc_init_heading() const;
  void set_adc_init_heading(double value);
  private:
  double _internal_adc_init_heading() const;
  void _internal_set_adc_init_heading(double value);
  public:

  // optional bool in_check_stage = 3;
  bool has_in_check_stage() const;
  private:
  bool _internal_has_in_check_stage() const;
  public:
  void clear_in_check_stage();
  bool in_check_stage() const;
  void set_in_check_stage(bool value);
  private:
  bool _internal_in_check_stage() const;
  void _internal_set_in_check_stage(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ParkAndGoStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::common::PointENU* adc_init_position_;
    ::apollo::common::PointENU* adc_adjust_end_pose_;
    double adc_init_heading_;
    bool in_check_stage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class PathDeciderStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PathDeciderStatus) */ {
 public:
  inline PathDeciderStatus() : PathDeciderStatus(nullptr) {}
  ~PathDeciderStatus() override;
  explicit PROTOBUF_CONSTEXPR PathDeciderStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathDeciderStatus(const PathDeciderStatus& from);
  PathDeciderStatus(PathDeciderStatus&& from) noexcept
    : PathDeciderStatus() {
    *this = ::std::move(from);
  }

  inline PathDeciderStatus& operator=(const PathDeciderStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathDeciderStatus& operator=(PathDeciderStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathDeciderStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathDeciderStatus* internal_default_instance() {
    return reinterpret_cast<const PathDeciderStatus*>(
               &_PathDeciderStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PathDeciderStatus& a, PathDeciderStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PathDeciderStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathDeciderStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathDeciderStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathDeciderStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathDeciderStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PathDeciderStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathDeciderStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PathDeciderStatus";
  }
  protected:
  explicit PathDeciderStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PathDeciderStatus_LaneBorrowDirection LaneBorrowDirection;
  static constexpr LaneBorrowDirection LEFT_BORROW =
    PathDeciderStatus_LaneBorrowDirection_LEFT_BORROW;
  static constexpr LaneBorrowDirection RIGHT_BORROW =
    PathDeciderStatus_LaneBorrowDirection_RIGHT_BORROW;
  static inline bool LaneBorrowDirection_IsValid(int value) {
    return PathDeciderStatus_LaneBorrowDirection_IsValid(value);
  }
  static constexpr LaneBorrowDirection LaneBorrowDirection_MIN =
    PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_MIN;
  static constexpr LaneBorrowDirection LaneBorrowDirection_MAX =
    PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_MAX;
  static constexpr int LaneBorrowDirection_ARRAYSIZE =
    PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LaneBorrowDirection_descriptor() {
    return PathDeciderStatus_LaneBorrowDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& LaneBorrowDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LaneBorrowDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LaneBorrowDirection_Name.");
    return PathDeciderStatus_LaneBorrowDirection_Name(enum_t_value);
  }
  static inline bool LaneBorrowDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LaneBorrowDirection* value) {
    return PathDeciderStatus_LaneBorrowDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDecidedSidePassDirectionFieldNumber = 5,
    kFrontStaticObstacleIdFieldNumber = 4,
    kFrontStaticObstacleCycleCounterFieldNumber = 1,
    kAbleToUseSelfLaneCounterFieldNumber = 2,
    kIsInPathLaneBorrowScenarioFieldNumber = 3,
  };
  // repeated .apollo.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
  int decided_side_pass_direction_size() const;
  private:
  int _internal_decided_side_pass_direction_size() const;
  public:
  void clear_decided_side_pass_direction();
  private:
  ::apollo::planning::PathDeciderStatus_LaneBorrowDirection _internal_decided_side_pass_direction(int index) const;
  void _internal_add_decided_side_pass_direction(::apollo::planning::PathDeciderStatus_LaneBorrowDirection value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_decided_side_pass_direction();
  public:
  ::apollo::planning::PathDeciderStatus_LaneBorrowDirection decided_side_pass_direction(int index) const;
  void set_decided_side_pass_direction(int index, ::apollo::planning::PathDeciderStatus_LaneBorrowDirection value);
  void add_decided_side_pass_direction(::apollo::planning::PathDeciderStatus_LaneBorrowDirection value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& decided_side_pass_direction() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_decided_side_pass_direction();

  // optional string front_static_obstacle_id = 4 [default = ""];
  bool has_front_static_obstacle_id() const;
  private:
  bool _internal_has_front_static_obstacle_id() const;
  public:
  void clear_front_static_obstacle_id();
  const std::string& front_static_obstacle_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_front_static_obstacle_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_front_static_obstacle_id();
  PROTOBUF_NODISCARD std::string* release_front_static_obstacle_id();
  void set_allocated_front_static_obstacle_id(std::string* front_static_obstacle_id);
  private:
  const std::string& _internal_front_static_obstacle_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_front_static_obstacle_id(const std::string& value);
  std::string* _internal_mutable_front_static_obstacle_id();
  public:

  // optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
  bool has_front_static_obstacle_cycle_counter() const;
  private:
  bool _internal_has_front_static_obstacle_cycle_counter() const;
  public:
  void clear_front_static_obstacle_cycle_counter();
  int32_t front_static_obstacle_cycle_counter() const;
  void set_front_static_obstacle_cycle_counter(int32_t value);
  private:
  int32_t _internal_front_static_obstacle_cycle_counter() const;
  void _internal_set_front_static_obstacle_cycle_counter(int32_t value);
  public:

  // optional int32 able_to_use_self_lane_counter = 2 [default = 0];
  bool has_able_to_use_self_lane_counter() const;
  private:
  bool _internal_has_able_to_use_self_lane_counter() const;
  public:
  void clear_able_to_use_self_lane_counter();
  int32_t able_to_use_self_lane_counter() const;
  void set_able_to_use_self_lane_counter(int32_t value);
  private:
  int32_t _internal_able_to_use_self_lane_counter() const;
  void _internal_set_able_to_use_self_lane_counter(int32_t value);
  public:

  // optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
  bool has_is_in_path_lane_borrow_scenario() const;
  private:
  bool _internal_has_is_in_path_lane_borrow_scenario() const;
  public:
  void clear_is_in_path_lane_borrow_scenario();
  bool is_in_path_lane_borrow_scenario() const;
  void set_is_in_path_lane_borrow_scenario(bool value);
  private:
  bool _internal_is_in_path_lane_borrow_scenario() const;
  void _internal_set_is_in_path_lane_borrow_scenario(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PathDeciderStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> decided_side_pass_direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr front_static_obstacle_id_;
    int32_t front_static_obstacle_cycle_counter_;
    int32_t able_to_use_self_lane_counter_;
    bool is_in_path_lane_borrow_scenario_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class PullOverStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PullOverStatus) */ {
 public:
  inline PullOverStatus() : PullOverStatus(nullptr) {}
  ~PullOverStatus() override;
  explicit PROTOBUF_CONSTEXPR PullOverStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullOverStatus(const PullOverStatus& from);
  PullOverStatus(PullOverStatus&& from) noexcept
    : PullOverStatus() {
    *this = ::std::move(from);
  }

  inline PullOverStatus& operator=(const PullOverStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullOverStatus& operator=(PullOverStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullOverStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullOverStatus* internal_default_instance() {
    return reinterpret_cast<const PullOverStatus*>(
               &_PullOverStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PullOverStatus& a, PullOverStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PullOverStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullOverStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullOverStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullOverStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PullOverStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PullOverStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullOverStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PullOverStatus";
  }
  protected:
  explicit PullOverStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PullOverStatus_PullOverType PullOverType;
  static constexpr PullOverType PULL_OVER =
    PullOverStatus_PullOverType_PULL_OVER;
  static constexpr PullOverType EMERGENCY_PULL_OVER =
    PullOverStatus_PullOverType_EMERGENCY_PULL_OVER;
  static inline bool PullOverType_IsValid(int value) {
    return PullOverStatus_PullOverType_IsValid(value);
  }
  static constexpr PullOverType PullOverType_MIN =
    PullOverStatus_PullOverType_PullOverType_MIN;
  static constexpr PullOverType PullOverType_MAX =
    PullOverStatus_PullOverType_PullOverType_MAX;
  static constexpr int PullOverType_ARRAYSIZE =
    PullOverStatus_PullOverType_PullOverType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PullOverType_descriptor() {
    return PullOverStatus_PullOverType_descriptor();
  }
  template<typename T>
  static inline const std::string& PullOverType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PullOverType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PullOverType_Name.");
    return PullOverStatus_PullOverType_Name(enum_t_value);
  }
  static inline bool PullOverType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PullOverType* value) {
    return PullOverStatus_PullOverType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 3,
    kThetaFieldNumber = 4,
    kLengthFrontFieldNumber = 5,
    kLengthBackFieldNumber = 6,
    kWidthLeftFieldNumber = 7,
    kWidthRightFieldNumber = 8,
    kPlanPullOverPathFieldNumber = 2,
    kPullOverTypeFieldNumber = 1,
  };
  // optional .apollo.common.PointENU position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::apollo::common::PointENU& position() const;
  PROTOBUF_NODISCARD ::apollo::common::PointENU* release_position();
  ::apollo::common::PointENU* mutable_position();
  void set_allocated_position(::apollo::common::PointENU* position);
  private:
  const ::apollo::common::PointENU& _internal_position() const;
  ::apollo::common::PointENU* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::apollo::common::PointENU* position);
  ::apollo::common::PointENU* unsafe_arena_release_position();

  // optional double theta = 4;
  bool has_theta() const;
  private:
  bool _internal_has_theta() const;
  public:
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // optional double length_front = 5;
  bool has_length_front() const;
  private:
  bool _internal_has_length_front() const;
  public:
  void clear_length_front();
  double length_front() const;
  void set_length_front(double value);
  private:
  double _internal_length_front() const;
  void _internal_set_length_front(double value);
  public:

  // optional double length_back = 6;
  bool has_length_back() const;
  private:
  bool _internal_has_length_back() const;
  public:
  void clear_length_back();
  double length_back() const;
  void set_length_back(double value);
  private:
  double _internal_length_back() const;
  void _internal_set_length_back(double value);
  public:

  // optional double width_left = 7;
  bool has_width_left() const;
  private:
  bool _internal_has_width_left() const;
  public:
  void clear_width_left();
  double width_left() const;
  void set_width_left(double value);
  private:
  double _internal_width_left() const;
  void _internal_set_width_left(double value);
  public:

  // optional double width_right = 8;
  bool has_width_right() const;
  private:
  bool _internal_has_width_right() const;
  public:
  void clear_width_right();
  double width_right() const;
  void set_width_right(double value);
  private:
  double _internal_width_right() const;
  void _internal_set_width_right(double value);
  public:

  // optional bool plan_pull_over_path = 2 [default = false];
  bool has_plan_pull_over_path() const;
  private:
  bool _internal_has_plan_pull_over_path() const;
  public:
  void clear_plan_pull_over_path();
  bool plan_pull_over_path() const;
  void set_plan_pull_over_path(bool value);
  private:
  bool _internal_plan_pull_over_path() const;
  void _internal_set_plan_pull_over_path(bool value);
  public:

  // optional .apollo.planning.PullOverStatus.PullOverType pull_over_type = 1;
  bool has_pull_over_type() const;
  private:
  bool _internal_has_pull_over_type() const;
  public:
  void clear_pull_over_type();
  ::apollo::planning::PullOverStatus_PullOverType pull_over_type() const;
  void set_pull_over_type(::apollo::planning::PullOverStatus_PullOverType value);
  private:
  ::apollo::planning::PullOverStatus_PullOverType _internal_pull_over_type() const;
  void _internal_set_pull_over_type(::apollo::planning::PullOverStatus_PullOverType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PullOverStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::common::PointENU* position_;
    double theta_;
    double length_front_;
    double length_back_;
    double width_left_;
    double width_right_;
    bool plan_pull_over_path_;
    int pull_over_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class ReroutingStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReroutingStatus) */ {
 public:
  inline ReroutingStatus() : ReroutingStatus(nullptr) {}
  ~ReroutingStatus() override;
  explicit PROTOBUF_CONSTEXPR ReroutingStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReroutingStatus(const ReroutingStatus& from);
  ReroutingStatus(ReroutingStatus&& from) noexcept
    : ReroutingStatus() {
    *this = ::std::move(from);
  }

  inline ReroutingStatus& operator=(const ReroutingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReroutingStatus& operator=(ReroutingStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReroutingStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReroutingStatus* internal_default_instance() {
    return reinterpret_cast<const ReroutingStatus*>(
               &_ReroutingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ReroutingStatus& a, ReroutingStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ReroutingStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReroutingStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReroutingStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReroutingStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReroutingStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReroutingStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReroutingStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ReroutingStatus";
  }
  protected:
  explicit ReroutingStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutingRequestFieldNumber = 3,
    kLastReroutingTimeFieldNumber = 1,
    kNeedReroutingFieldNumber = 2,
  };
  // optional .apollo.routing.RoutingRequest routing_request = 3;
  bool has_routing_request() const;
  private:
  bool _internal_has_routing_request() const;
  public:
  void clear_routing_request();
  const ::apollo::routing::RoutingRequest& routing_request() const;
  PROTOBUF_NODISCARD ::apollo::routing::RoutingRequest* release_routing_request();
  ::apollo::routing::RoutingRequest* mutable_routing_request();
  void set_allocated_routing_request(::apollo::routing::RoutingRequest* routing_request);
  private:
  const ::apollo::routing::RoutingRequest& _internal_routing_request() const;
  ::apollo::routing::RoutingRequest* _internal_mutable_routing_request();
  public:
  void unsafe_arena_set_allocated_routing_request(
      ::apollo::routing::RoutingRequest* routing_request);
  ::apollo::routing::RoutingRequest* unsafe_arena_release_routing_request();

  // optional double last_rerouting_time = 1;
  bool has_last_rerouting_time() const;
  private:
  bool _internal_has_last_rerouting_time() const;
  public:
  void clear_last_rerouting_time();
  double last_rerouting_time() const;
  void set_last_rerouting_time(double value);
  private:
  double _internal_last_rerouting_time() const;
  void _internal_set_last_rerouting_time(double value);
  public:

  // optional bool need_rerouting = 2 [default = false];
  bool has_need_rerouting() const;
  private:
  bool _internal_has_need_rerouting() const;
  public:
  void clear_need_rerouting();
  bool need_rerouting() const;
  void set_need_rerouting(bool value);
  private:
  bool _internal_need_rerouting() const;
  void _internal_set_need_rerouting(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ReroutingStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::routing::RoutingRequest* routing_request_;
    double last_rerouting_time_;
    bool need_rerouting_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class SpeedDeciderStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.SpeedDeciderStatus) */ {
 public:
  inline SpeedDeciderStatus() : SpeedDeciderStatus(nullptr) {}
  ~SpeedDeciderStatus() override;
  explicit PROTOBUF_CONSTEXPR SpeedDeciderStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeedDeciderStatus(const SpeedDeciderStatus& from);
  SpeedDeciderStatus(SpeedDeciderStatus&& from) noexcept
    : SpeedDeciderStatus() {
    *this = ::std::move(from);
  }

  inline SpeedDeciderStatus& operator=(const SpeedDeciderStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedDeciderStatus& operator=(SpeedDeciderStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeedDeciderStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeedDeciderStatus* internal_default_instance() {
    return reinterpret_cast<const SpeedDeciderStatus*>(
               &_SpeedDeciderStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SpeedDeciderStatus& a, SpeedDeciderStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedDeciderStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedDeciderStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeedDeciderStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeedDeciderStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeedDeciderStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpeedDeciderStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedDeciderStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.SpeedDeciderStatus";
  }
  protected:
  explicit SpeedDeciderStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPedestrianStopTimeFieldNumber = 1,
  };
  // repeated .apollo.planning.StopTime pedestrian_stop_time = 1;
  int pedestrian_stop_time_size() const;
  private:
  int _internal_pedestrian_stop_time_size() const;
  public:
  void clear_pedestrian_stop_time();
  ::apollo::planning::StopTime* mutable_pedestrian_stop_time(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >*
      mutable_pedestrian_stop_time();
  private:
  const ::apollo::planning::StopTime& _internal_pedestrian_stop_time(int index) const;
  ::apollo::planning::StopTime* _internal_add_pedestrian_stop_time();
  public:
  const ::apollo::planning::StopTime& pedestrian_stop_time(int index) const;
  ::apollo::planning::StopTime* add_pedestrian_stop_time();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >&
      pedestrian_stop_time() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.SpeedDeciderStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime > pedestrian_stop_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class ScenarioStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioStatus) */ {
 public:
  inline ScenarioStatus() : ScenarioStatus(nullptr) {}
  ~ScenarioStatus() override;
  explicit PROTOBUF_CONSTEXPR ScenarioStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScenarioStatus(const ScenarioStatus& from);
  ScenarioStatus(ScenarioStatus&& from) noexcept
    : ScenarioStatus() {
    *this = ::std::move(from);
  }

  inline ScenarioStatus& operator=(const ScenarioStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioStatus& operator=(ScenarioStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScenarioStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScenarioStatus* internal_default_instance() {
    return reinterpret_cast<const ScenarioStatus*>(
               &_ScenarioStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ScenarioStatus& a, ScenarioStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScenarioStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScenarioStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScenarioStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScenarioStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ScenarioStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ScenarioStatus";
  }
  protected:
  explicit ScenarioStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScenarioTypeFieldNumber = 1,
    kStageTypeFieldNumber = 2,
  };
  // optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  bool has_scenario_type() const;
  private:
  bool _internal_has_scenario_type() const;
  public:
  void clear_scenario_type();
  ::apollo::planning::ScenarioConfig_ScenarioType scenario_type() const;
  void set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value);
  private:
  ::apollo::planning::ScenarioConfig_ScenarioType _internal_scenario_type() const;
  void _internal_set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value);
  public:

  // optional .apollo.planning.ScenarioConfig.StageType stage_type = 2;
  bool has_stage_type() const;
  private:
  bool _internal_has_stage_type() const;
  public:
  void clear_stage_type();
  ::apollo::planning::ScenarioConfig_StageType stage_type() const;
  void set_stage_type(::apollo::planning::ScenarioConfig_StageType value);
  private:
  ::apollo::planning::ScenarioConfig_StageType _internal_stage_type() const;
  void _internal_set_stage_type(::apollo::planning::ScenarioConfig_StageType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int scenario_type_;
    int stage_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class StopSignStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopSignStatus) */ {
 public:
  inline StopSignStatus() : StopSignStatus(nullptr) {}
  ~StopSignStatus() override;
  explicit PROTOBUF_CONSTEXPR StopSignStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopSignStatus(const StopSignStatus& from);
  StopSignStatus(StopSignStatus&& from) noexcept
    : StopSignStatus() {
    *this = ::std::move(from);
  }

  inline StopSignStatus& operator=(const StopSignStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSignStatus& operator=(StopSignStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopSignStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopSignStatus* internal_default_instance() {
    return reinterpret_cast<const StopSignStatus*>(
               &_StopSignStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StopSignStatus& a, StopSignStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSignStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSignStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopSignStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopSignStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopSignStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopSignStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSignStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StopSignStatus";
  }
  protected:
  explicit StopSignStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaitForObstacleIdFieldNumber = 3,
    kCurrentStopSignOverlapIdFieldNumber = 1,
    kDoneStopSignOverlapIdFieldNumber = 2,
  };
  // repeated string wait_for_obstacle_id = 3;
  int wait_for_obstacle_id_size() const;
  private:
  int _internal_wait_for_obstacle_id_size() const;
  public:
  void clear_wait_for_obstacle_id();
  const std::string& wait_for_obstacle_id(int index) const;
  std::string* mutable_wait_for_obstacle_id(int index);
  void set_wait_for_obstacle_id(int index, const std::string& value);
  void set_wait_for_obstacle_id(int index, std::string&& value);
  void set_wait_for_obstacle_id(int index, const char* value);
  void set_wait_for_obstacle_id(int index, const char* value, size_t size);
  std::string* add_wait_for_obstacle_id();
  void add_wait_for_obstacle_id(const std::string& value);
  void add_wait_for_obstacle_id(std::string&& value);
  void add_wait_for_obstacle_id(const char* value);
  void add_wait_for_obstacle_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wait_for_obstacle_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wait_for_obstacle_id();
  private:
  const std::string& _internal_wait_for_obstacle_id(int index) const;
  std::string* _internal_add_wait_for_obstacle_id();
  public:

  // optional string current_stop_sign_overlap_id = 1;
  bool has_current_stop_sign_overlap_id() const;
  private:
  bool _internal_has_current_stop_sign_overlap_id() const;
  public:
  void clear_current_stop_sign_overlap_id();
  const std::string& current_stop_sign_overlap_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_stop_sign_overlap_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_stop_sign_overlap_id();
  PROTOBUF_NODISCARD std::string* release_current_stop_sign_overlap_id();
  void set_allocated_current_stop_sign_overlap_id(std::string* current_stop_sign_overlap_id);
  private:
  const std::string& _internal_current_stop_sign_overlap_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_stop_sign_overlap_id(const std::string& value);
  std::string* _internal_mutable_current_stop_sign_overlap_id();
  public:

  // optional string done_stop_sign_overlap_id = 2;
  bool has_done_stop_sign_overlap_id() const;
  private:
  bool _internal_has_done_stop_sign_overlap_id() const;
  public:
  void clear_done_stop_sign_overlap_id();
  const std::string& done_stop_sign_overlap_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_done_stop_sign_overlap_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_done_stop_sign_overlap_id();
  PROTOBUF_NODISCARD std::string* release_done_stop_sign_overlap_id();
  void set_allocated_done_stop_sign_overlap_id(std::string* done_stop_sign_overlap_id);
  private:
  const std::string& _internal_done_stop_sign_overlap_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_done_stop_sign_overlap_id(const std::string& value);
  std::string* _internal_mutable_done_stop_sign_overlap_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StopSignStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wait_for_obstacle_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_stop_sign_overlap_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr done_stop_sign_overlap_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class TrafficLightStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficLightStatus) */ {
 public:
  inline TrafficLightStatus() : TrafficLightStatus(nullptr) {}
  ~TrafficLightStatus() override;
  explicit PROTOBUF_CONSTEXPR TrafficLightStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficLightStatus(const TrafficLightStatus& from);
  TrafficLightStatus(TrafficLightStatus&& from) noexcept
    : TrafficLightStatus() {
    *this = ::std::move(from);
  }

  inline TrafficLightStatus& operator=(const TrafficLightStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficLightStatus& operator=(TrafficLightStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficLightStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficLightStatus* internal_default_instance() {
    return reinterpret_cast<const TrafficLightStatus*>(
               &_TrafficLightStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TrafficLightStatus& a, TrafficLightStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficLightStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficLightStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficLightStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficLightStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficLightStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrafficLightStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLightStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficLightStatus";
  }
  protected:
  explicit TrafficLightStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentTrafficLightOverlapIdFieldNumber = 1,
    kDoneTrafficLightOverlapIdFieldNumber = 2,
  };
  // repeated string current_traffic_light_overlap_id = 1;
  int current_traffic_light_overlap_id_size() const;
  private:
  int _internal_current_traffic_light_overlap_id_size() const;
  public:
  void clear_current_traffic_light_overlap_id();
  const std::string& current_traffic_light_overlap_id(int index) const;
  std::string* mutable_current_traffic_light_overlap_id(int index);
  void set_current_traffic_light_overlap_id(int index, const std::string& value);
  void set_current_traffic_light_overlap_id(int index, std::string&& value);
  void set_current_traffic_light_overlap_id(int index, const char* value);
  void set_current_traffic_light_overlap_id(int index, const char* value, size_t size);
  std::string* add_current_traffic_light_overlap_id();
  void add_current_traffic_light_overlap_id(const std::string& value);
  void add_current_traffic_light_overlap_id(std::string&& value);
  void add_current_traffic_light_overlap_id(const char* value);
  void add_current_traffic_light_overlap_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& current_traffic_light_overlap_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_current_traffic_light_overlap_id();
  private:
  const std::string& _internal_current_traffic_light_overlap_id(int index) const;
  std::string* _internal_add_current_traffic_light_overlap_id();
  public:

  // repeated string done_traffic_light_overlap_id = 2;
  int done_traffic_light_overlap_id_size() const;
  private:
  int _internal_done_traffic_light_overlap_id_size() const;
  public:
  void clear_done_traffic_light_overlap_id();
  const std::string& done_traffic_light_overlap_id(int index) const;
  std::string* mutable_done_traffic_light_overlap_id(int index);
  void set_done_traffic_light_overlap_id(int index, const std::string& value);
  void set_done_traffic_light_overlap_id(int index, std::string&& value);
  void set_done_traffic_light_overlap_id(int index, const char* value);
  void set_done_traffic_light_overlap_id(int index, const char* value, size_t size);
  std::string* add_done_traffic_light_overlap_id();
  void add_done_traffic_light_overlap_id(const std::string& value);
  void add_done_traffic_light_overlap_id(std::string&& value);
  void add_done_traffic_light_overlap_id(const char* value);
  void add_done_traffic_light_overlap_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& done_traffic_light_overlap_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_done_traffic_light_overlap_id();
  private:
  const std::string& _internal_done_traffic_light_overlap_id(int index) const;
  std::string* _internal_add_done_traffic_light_overlap_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficLightStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> current_traffic_light_overlap_id_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> done_traffic_light_overlap_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class YieldSignStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.YieldSignStatus) */ {
 public:
  inline YieldSignStatus() : YieldSignStatus(nullptr) {}
  ~YieldSignStatus() override;
  explicit PROTOBUF_CONSTEXPR YieldSignStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  YieldSignStatus(const YieldSignStatus& from);
  YieldSignStatus(YieldSignStatus&& from) noexcept
    : YieldSignStatus() {
    *this = ::std::move(from);
  }

  inline YieldSignStatus& operator=(const YieldSignStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline YieldSignStatus& operator=(YieldSignStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const YieldSignStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const YieldSignStatus* internal_default_instance() {
    return reinterpret_cast<const YieldSignStatus*>(
               &_YieldSignStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(YieldSignStatus& a, YieldSignStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(YieldSignStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(YieldSignStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  YieldSignStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<YieldSignStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const YieldSignStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const YieldSignStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YieldSignStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.YieldSignStatus";
  }
  protected:
  explicit YieldSignStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentYieldSignOverlapIdFieldNumber = 1,
    kDoneYieldSignOverlapIdFieldNumber = 2,
    kWaitForObstacleIdFieldNumber = 3,
  };
  // repeated string current_yield_sign_overlap_id = 1;
  int current_yield_sign_overlap_id_size() const;
  private:
  int _internal_current_yield_sign_overlap_id_size() const;
  public:
  void clear_current_yield_sign_overlap_id();
  const std::string& current_yield_sign_overlap_id(int index) const;
  std::string* mutable_current_yield_sign_overlap_id(int index);
  void set_current_yield_sign_overlap_id(int index, const std::string& value);
  void set_current_yield_sign_overlap_id(int index, std::string&& value);
  void set_current_yield_sign_overlap_id(int index, const char* value);
  void set_current_yield_sign_overlap_id(int index, const char* value, size_t size);
  std::string* add_current_yield_sign_overlap_id();
  void add_current_yield_sign_overlap_id(const std::string& value);
  void add_current_yield_sign_overlap_id(std::string&& value);
  void add_current_yield_sign_overlap_id(const char* value);
  void add_current_yield_sign_overlap_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& current_yield_sign_overlap_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_current_yield_sign_overlap_id();
  private:
  const std::string& _internal_current_yield_sign_overlap_id(int index) const;
  std::string* _internal_add_current_yield_sign_overlap_id();
  public:

  // repeated string done_yield_sign_overlap_id = 2;
  int done_yield_sign_overlap_id_size() const;
  private:
  int _internal_done_yield_sign_overlap_id_size() const;
  public:
  void clear_done_yield_sign_overlap_id();
  const std::string& done_yield_sign_overlap_id(int index) const;
  std::string* mutable_done_yield_sign_overlap_id(int index);
  void set_done_yield_sign_overlap_id(int index, const std::string& value);
  void set_done_yield_sign_overlap_id(int index, std::string&& value);
  void set_done_yield_sign_overlap_id(int index, const char* value);
  void set_done_yield_sign_overlap_id(int index, const char* value, size_t size);
  std::string* add_done_yield_sign_overlap_id();
  void add_done_yield_sign_overlap_id(const std::string& value);
  void add_done_yield_sign_overlap_id(std::string&& value);
  void add_done_yield_sign_overlap_id(const char* value);
  void add_done_yield_sign_overlap_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& done_yield_sign_overlap_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_done_yield_sign_overlap_id();
  private:
  const std::string& _internal_done_yield_sign_overlap_id(int index) const;
  std::string* _internal_add_done_yield_sign_overlap_id();
  public:

  // repeated string wait_for_obstacle_id = 3;
  int wait_for_obstacle_id_size() const;
  private:
  int _internal_wait_for_obstacle_id_size() const;
  public:
  void clear_wait_for_obstacle_id();
  const std::string& wait_for_obstacle_id(int index) const;
  std::string* mutable_wait_for_obstacle_id(int index);
  void set_wait_for_obstacle_id(int index, const std::string& value);
  void set_wait_for_obstacle_id(int index, std::string&& value);
  void set_wait_for_obstacle_id(int index, const char* value);
  void set_wait_for_obstacle_id(int index, const char* value, size_t size);
  std::string* add_wait_for_obstacle_id();
  void add_wait_for_obstacle_id(const std::string& value);
  void add_wait_for_obstacle_id(std::string&& value);
  void add_wait_for_obstacle_id(const char* value);
  void add_wait_for_obstacle_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wait_for_obstacle_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wait_for_obstacle_id();
  private:
  const std::string& _internal_wait_for_obstacle_id(int index) const;
  std::string* _internal_add_wait_for_obstacle_id();
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.YieldSignStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> current_yield_sign_overlap_id_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> done_yield_sign_overlap_id_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wait_for_obstacle_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class PlanningStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningStatus) */ {
 public:
  inline PlanningStatus() : PlanningStatus(nullptr) {}
  ~PlanningStatus() override;
  explicit PROTOBUF_CONSTEXPR PlanningStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanningStatus(const PlanningStatus& from);
  PlanningStatus(PlanningStatus&& from) noexcept
    : PlanningStatus() {
    *this = ::std::move(from);
  }

  inline PlanningStatus& operator=(const PlanningStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanningStatus& operator=(PlanningStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanningStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanningStatus* internal_default_instance() {
    return reinterpret_cast<const PlanningStatus*>(
               &_PlanningStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PlanningStatus& a, PlanningStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanningStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanningStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanningStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanningStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanningStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlanningStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanningStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PlanningStatus";
  }
  protected:
  explicit PlanningStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBareIntersectionFieldNumber = 1,
    kChangeLaneFieldNumber = 2,
    kCreepDeciderFieldNumber = 3,
    kCrosswalkFieldNumber = 4,
    kDestinationFieldNumber = 5,
    kEmergencyStopFieldNumber = 6,
    kOpenSpaceFieldNumber = 7,
    kParkAndGoFieldNumber = 8,
    kPathDeciderFieldNumber = 9,
    kPullOverFieldNumber = 10,
    kReroutingFieldNumber = 11,
    kScenarioFieldNumber = 12,
    kSpeedDeciderFieldNumber = 13,
    kStopSignFieldNumber = 14,
    kTrafficLightFieldNumber = 15,
    kYieldSignFieldNumber = 16,
  };
  // optional .apollo.planning.BareIntersectionStatus bare_intersection = 1;
  bool has_bare_intersection() const;
  private:
  bool _internal_has_bare_intersection() const;
  public:
  void clear_bare_intersection();
  const ::apollo::planning::BareIntersectionStatus& bare_intersection() const;
  PROTOBUF_NODISCARD ::apollo::planning::BareIntersectionStatus* release_bare_intersection();
  ::apollo::planning::BareIntersectionStatus* mutable_bare_intersection();
  void set_allocated_bare_intersection(::apollo::planning::BareIntersectionStatus* bare_intersection);
  private:
  const ::apollo::planning::BareIntersectionStatus& _internal_bare_intersection() const;
  ::apollo::planning::BareIntersectionStatus* _internal_mutable_bare_intersection();
  public:
  void unsafe_arena_set_allocated_bare_intersection(
      ::apollo::planning::BareIntersectionStatus* bare_intersection);
  ::apollo::planning::BareIntersectionStatus* unsafe_arena_release_bare_intersection();

  // optional .apollo.planning.ChangeLaneStatus change_lane = 2;
  bool has_change_lane() const;
  private:
  bool _internal_has_change_lane() const;
  public:
  void clear_change_lane();
  const ::apollo::planning::ChangeLaneStatus& change_lane() const;
  PROTOBUF_NODISCARD ::apollo::planning::ChangeLaneStatus* release_change_lane();
  ::apollo::planning::ChangeLaneStatus* mutable_change_lane();
  void set_allocated_change_lane(::apollo::planning::ChangeLaneStatus* change_lane);
  private:
  const ::apollo::planning::ChangeLaneStatus& _internal_change_lane() const;
  ::apollo::planning::ChangeLaneStatus* _internal_mutable_change_lane();
  public:
  void unsafe_arena_set_allocated_change_lane(
      ::apollo::planning::ChangeLaneStatus* change_lane);
  ::apollo::planning::ChangeLaneStatus* unsafe_arena_release_change_lane();

  // optional .apollo.planning.CreepDeciderStatus creep_decider = 3;
  bool has_creep_decider() const;
  private:
  bool _internal_has_creep_decider() const;
  public:
  void clear_creep_decider();
  const ::apollo::planning::CreepDeciderStatus& creep_decider() const;
  PROTOBUF_NODISCARD ::apollo::planning::CreepDeciderStatus* release_creep_decider();
  ::apollo::planning::CreepDeciderStatus* mutable_creep_decider();
  void set_allocated_creep_decider(::apollo::planning::CreepDeciderStatus* creep_decider);
  private:
  const ::apollo::planning::CreepDeciderStatus& _internal_creep_decider() const;
  ::apollo::planning::CreepDeciderStatus* _internal_mutable_creep_decider();
  public:
  void unsafe_arena_set_allocated_creep_decider(
      ::apollo::planning::CreepDeciderStatus* creep_decider);
  ::apollo::planning::CreepDeciderStatus* unsafe_arena_release_creep_decider();

  // optional .apollo.planning.CrosswalkStatus crosswalk = 4;
  bool has_crosswalk() const;
  private:
  bool _internal_has_crosswalk() const;
  public:
  void clear_crosswalk();
  const ::apollo::planning::CrosswalkStatus& crosswalk() const;
  PROTOBUF_NODISCARD ::apollo::planning::CrosswalkStatus* release_crosswalk();
  ::apollo::planning::CrosswalkStatus* mutable_crosswalk();
  void set_allocated_crosswalk(::apollo::planning::CrosswalkStatus* crosswalk);
  private:
  const ::apollo::planning::CrosswalkStatus& _internal_crosswalk() const;
  ::apollo::planning::CrosswalkStatus* _internal_mutable_crosswalk();
  public:
  void unsafe_arena_set_allocated_crosswalk(
      ::apollo::planning::CrosswalkStatus* crosswalk);
  ::apollo::planning::CrosswalkStatus* unsafe_arena_release_crosswalk();

  // optional .apollo.planning.DestinationStatus destination = 5;
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::apollo::planning::DestinationStatus& destination() const;
  PROTOBUF_NODISCARD ::apollo::planning::DestinationStatus* release_destination();
  ::apollo::planning::DestinationStatus* mutable_destination();
  void set_allocated_destination(::apollo::planning::DestinationStatus* destination);
  private:
  const ::apollo::planning::DestinationStatus& _internal_destination() const;
  ::apollo::planning::DestinationStatus* _internal_mutable_destination();
  public:
  void unsafe_arena_set_allocated_destination(
      ::apollo::planning::DestinationStatus* destination);
  ::apollo::planning::DestinationStatus* unsafe_arena_release_destination();

  // optional .apollo.planning.EmergencyStopStatus emergency_stop = 6;
  bool has_emergency_stop() const;
  private:
  bool _internal_has_emergency_stop() const;
  public:
  void clear_emergency_stop();
  const ::apollo::planning::EmergencyStopStatus& emergency_stop() const;
  PROTOBUF_NODISCARD ::apollo::planning::EmergencyStopStatus* release_emergency_stop();
  ::apollo::planning::EmergencyStopStatus* mutable_emergency_stop();
  void set_allocated_emergency_stop(::apollo::planning::EmergencyStopStatus* emergency_stop);
  private:
  const ::apollo::planning::EmergencyStopStatus& _internal_emergency_stop() const;
  ::apollo::planning::EmergencyStopStatus* _internal_mutable_emergency_stop();
  public:
  void unsafe_arena_set_allocated_emergency_stop(
      ::apollo::planning::EmergencyStopStatus* emergency_stop);
  ::apollo::planning::EmergencyStopStatus* unsafe_arena_release_emergency_stop();

  // optional .apollo.planning.OpenSpaceStatus open_space = 7;
  bool has_open_space() const;
  private:
  bool _internal_has_open_space() const;
  public:
  void clear_open_space();
  const ::apollo::planning::OpenSpaceStatus& open_space() const;
  PROTOBUF_NODISCARD ::apollo::planning::OpenSpaceStatus* release_open_space();
  ::apollo::planning::OpenSpaceStatus* mutable_open_space();
  void set_allocated_open_space(::apollo::planning::OpenSpaceStatus* open_space);
  private:
  const ::apollo::planning::OpenSpaceStatus& _internal_open_space() const;
  ::apollo::planning::OpenSpaceStatus* _internal_mutable_open_space();
  public:
  void unsafe_arena_set_allocated_open_space(
      ::apollo::planning::OpenSpaceStatus* open_space);
  ::apollo::planning::OpenSpaceStatus* unsafe_arena_release_open_space();

  // optional .apollo.planning.ParkAndGoStatus park_and_go = 8;
  bool has_park_and_go() const;
  private:
  bool _internal_has_park_and_go() const;
  public:
  void clear_park_and_go();
  const ::apollo::planning::ParkAndGoStatus& park_and_go() const;
  PROTOBUF_NODISCARD ::apollo::planning::ParkAndGoStatus* release_park_and_go();
  ::apollo::planning::ParkAndGoStatus* mutable_park_and_go();
  void set_allocated_park_and_go(::apollo::planning::ParkAndGoStatus* park_and_go);
  private:
  const ::apollo::planning::ParkAndGoStatus& _internal_park_and_go() const;
  ::apollo::planning::ParkAndGoStatus* _internal_mutable_park_and_go();
  public:
  void unsafe_arena_set_allocated_park_and_go(
      ::apollo::planning::ParkAndGoStatus* park_and_go);
  ::apollo::planning::ParkAndGoStatus* unsafe_arena_release_park_and_go();

  // optional .apollo.planning.PathDeciderStatus path_decider = 9;
  bool has_path_decider() const;
  private:
  bool _internal_has_path_decider() const;
  public:
  void clear_path_decider();
  const ::apollo::planning::PathDeciderStatus& path_decider() const;
  PROTOBUF_NODISCARD ::apollo::planning::PathDeciderStatus* release_path_decider();
  ::apollo::planning::PathDeciderStatus* mutable_path_decider();
  void set_allocated_path_decider(::apollo::planning::PathDeciderStatus* path_decider);
  private:
  const ::apollo::planning::PathDeciderStatus& _internal_path_decider() const;
  ::apollo::planning::PathDeciderStatus* _internal_mutable_path_decider();
  public:
  void unsafe_arena_set_allocated_path_decider(
      ::apollo::planning::PathDeciderStatus* path_decider);
  ::apollo::planning::PathDeciderStatus* unsafe_arena_release_path_decider();

  // optional .apollo.planning.PullOverStatus pull_over = 10;
  bool has_pull_over() const;
  private:
  bool _internal_has_pull_over() const;
  public:
  void clear_pull_over();
  const ::apollo::planning::PullOverStatus& pull_over() const;
  PROTOBUF_NODISCARD ::apollo::planning::PullOverStatus* release_pull_over();
  ::apollo::planning::PullOverStatus* mutable_pull_over();
  void set_allocated_pull_over(::apollo::planning::PullOverStatus* pull_over);
  private:
  const ::apollo::planning::PullOverStatus& _internal_pull_over() const;
  ::apollo::planning::PullOverStatus* _internal_mutable_pull_over();
  public:
  void unsafe_arena_set_allocated_pull_over(
      ::apollo::planning::PullOverStatus* pull_over);
  ::apollo::planning::PullOverStatus* unsafe_arena_release_pull_over();

  // optional .apollo.planning.ReroutingStatus rerouting = 11;
  bool has_rerouting() const;
  private:
  bool _internal_has_rerouting() const;
  public:
  void clear_rerouting();
  const ::apollo::planning::ReroutingStatus& rerouting() const;
  PROTOBUF_NODISCARD ::apollo::planning::ReroutingStatus* release_rerouting();
  ::apollo::planning::ReroutingStatus* mutable_rerouting();
  void set_allocated_rerouting(::apollo::planning::ReroutingStatus* rerouting);
  private:
  const ::apollo::planning::ReroutingStatus& _internal_rerouting() const;
  ::apollo::planning::ReroutingStatus* _internal_mutable_rerouting();
  public:
  void unsafe_arena_set_allocated_rerouting(
      ::apollo::planning::ReroutingStatus* rerouting);
  ::apollo::planning::ReroutingStatus* unsafe_arena_release_rerouting();

  // optional .apollo.planning.ScenarioStatus scenario = 12;
  bool has_scenario() const;
  private:
  bool _internal_has_scenario() const;
  public:
  void clear_scenario();
  const ::apollo::planning::ScenarioStatus& scenario() const;
  PROTOBUF_NODISCARD ::apollo::planning::ScenarioStatus* release_scenario();
  ::apollo::planning::ScenarioStatus* mutable_scenario();
  void set_allocated_scenario(::apollo::planning::ScenarioStatus* scenario);
  private:
  const ::apollo::planning::ScenarioStatus& _internal_scenario() const;
  ::apollo::planning::ScenarioStatus* _internal_mutable_scenario();
  public:
  void unsafe_arena_set_allocated_scenario(
      ::apollo::planning::ScenarioStatus* scenario);
  ::apollo::planning::ScenarioStatus* unsafe_arena_release_scenario();

  // optional .apollo.planning.SpeedDeciderStatus speed_decider = 13;
  bool has_speed_decider() const;
  private:
  bool _internal_has_speed_decider() const;
  public:
  void clear_speed_decider();
  const ::apollo::planning::SpeedDeciderStatus& speed_decider() const;
  PROTOBUF_NODISCARD ::apollo::planning::SpeedDeciderStatus* release_speed_decider();
  ::apollo::planning::SpeedDeciderStatus* mutable_speed_decider();
  void set_allocated_speed_decider(::apollo::planning::SpeedDeciderStatus* speed_decider);
  private:
  const ::apollo::planning::SpeedDeciderStatus& _internal_speed_decider() const;
  ::apollo::planning::SpeedDeciderStatus* _internal_mutable_speed_decider();
  public:
  void unsafe_arena_set_allocated_speed_decider(
      ::apollo::planning::SpeedDeciderStatus* speed_decider);
  ::apollo::planning::SpeedDeciderStatus* unsafe_arena_release_speed_decider();

  // optional .apollo.planning.StopSignStatus stop_sign = 14;
  bool has_stop_sign() const;
  private:
  bool _internal_has_stop_sign() const;
  public:
  void clear_stop_sign();
  const ::apollo::planning::StopSignStatus& stop_sign() const;
  PROTOBUF_NODISCARD ::apollo::planning::StopSignStatus* release_stop_sign();
  ::apollo::planning::StopSignStatus* mutable_stop_sign();
  void set_allocated_stop_sign(::apollo::planning::StopSignStatus* stop_sign);
  private:
  const ::apollo::planning::StopSignStatus& _internal_stop_sign() const;
  ::apollo::planning::StopSignStatus* _internal_mutable_stop_sign();
  public:
  void unsafe_arena_set_allocated_stop_sign(
      ::apollo::planning::StopSignStatus* stop_sign);
  ::apollo::planning::StopSignStatus* unsafe_arena_release_stop_sign();

  // optional .apollo.planning.TrafficLightStatus traffic_light = 15;
  bool has_traffic_light() const;
  private:
  bool _internal_has_traffic_light() const;
  public:
  void clear_traffic_light();
  const ::apollo::planning::TrafficLightStatus& traffic_light() const;
  PROTOBUF_NODISCARD ::apollo::planning::TrafficLightStatus* release_traffic_light();
  ::apollo::planning::TrafficLightStatus* mutable_traffic_light();
  void set_allocated_traffic_light(::apollo::planning::TrafficLightStatus* traffic_light);
  private:
  const ::apollo::planning::TrafficLightStatus& _internal_traffic_light() const;
  ::apollo::planning::TrafficLightStatus* _internal_mutable_traffic_light();
  public:
  void unsafe_arena_set_allocated_traffic_light(
      ::apollo::planning::TrafficLightStatus* traffic_light);
  ::apollo::planning::TrafficLightStatus* unsafe_arena_release_traffic_light();

  // optional .apollo.planning.YieldSignStatus yield_sign = 16;
  bool has_yield_sign() const;
  private:
  bool _internal_has_yield_sign() const;
  public:
  void clear_yield_sign();
  const ::apollo::planning::YieldSignStatus& yield_sign() const;
  PROTOBUF_NODISCARD ::apollo::planning::YieldSignStatus* release_yield_sign();
  ::apollo::planning::YieldSignStatus* mutable_yield_sign();
  void set_allocated_yield_sign(::apollo::planning::YieldSignStatus* yield_sign);
  private:
  const ::apollo::planning::YieldSignStatus& _internal_yield_sign() const;
  ::apollo::planning::YieldSignStatus* _internal_mutable_yield_sign();
  public:
  void unsafe_arena_set_allocated_yield_sign(
      ::apollo::planning::YieldSignStatus* yield_sign);
  ::apollo::planning::YieldSignStatus* unsafe_arena_release_yield_sign();

  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::planning::BareIntersectionStatus* bare_intersection_;
    ::apollo::planning::ChangeLaneStatus* change_lane_;
    ::apollo::planning::CreepDeciderStatus* creep_decider_;
    ::apollo::planning::CrosswalkStatus* crosswalk_;
    ::apollo::planning::DestinationStatus* destination_;
    ::apollo::planning::EmergencyStopStatus* emergency_stop_;
    ::apollo::planning::OpenSpaceStatus* open_space_;
    ::apollo::planning::ParkAndGoStatus* park_and_go_;
    ::apollo::planning::PathDeciderStatus* path_decider_;
    ::apollo::planning::PullOverStatus* pull_over_;
    ::apollo::planning::ReroutingStatus* rerouting_;
    ::apollo::planning::ScenarioStatus* scenario_;
    ::apollo::planning::SpeedDeciderStatus* speed_decider_;
    ::apollo::planning::StopSignStatus* stop_sign_;
    ::apollo::planning::TrafficLightStatus* traffic_light_;
    ::apollo::planning::YieldSignStatus* yield_sign_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BareIntersectionStatus

// optional string current_pnc_junction_overlap_id = 1;
inline bool BareIntersectionStatus::_internal_has_current_pnc_junction_overlap_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BareIntersectionStatus::has_current_pnc_junction_overlap_id() const {
  return _internal_has_current_pnc_junction_overlap_id();
}
inline void BareIntersectionStatus::clear_current_pnc_junction_overlap_id() {
  _impl_.current_pnc_junction_overlap_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BareIntersectionStatus::current_pnc_junction_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  return _internal_current_pnc_junction_overlap_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BareIntersectionStatus::set_current_pnc_junction_overlap_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.current_pnc_junction_overlap_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
inline std::string* BareIntersectionStatus::mutable_current_pnc_junction_overlap_id() {
  std::string* _s = _internal_mutable_current_pnc_junction_overlap_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  return _s;
}
inline const std::string& BareIntersectionStatus::_internal_current_pnc_junction_overlap_id() const {
  return _impl_.current_pnc_junction_overlap_id_.Get();
}
inline void BareIntersectionStatus::_internal_set_current_pnc_junction_overlap_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.current_pnc_junction_overlap_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BareIntersectionStatus::_internal_mutable_current_pnc_junction_overlap_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.current_pnc_junction_overlap_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BareIntersectionStatus::release_current_pnc_junction_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  if (!_internal_has_current_pnc_junction_overlap_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.current_pnc_junction_overlap_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_pnc_junction_overlap_id_.IsDefault()) {
    _impl_.current_pnc_junction_overlap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BareIntersectionStatus::set_allocated_current_pnc_junction_overlap_id(std::string* current_pnc_junction_overlap_id) {
  if (current_pnc_junction_overlap_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.current_pnc_junction_overlap_id_.SetAllocated(current_pnc_junction_overlap_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_pnc_junction_overlap_id_.IsDefault()) {
    _impl_.current_pnc_junction_overlap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}

// optional string done_pnc_junction_overlap_id = 2;
inline bool BareIntersectionStatus::_internal_has_done_pnc_junction_overlap_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BareIntersectionStatus::has_done_pnc_junction_overlap_id() const {
  return _internal_has_done_pnc_junction_overlap_id();
}
inline void BareIntersectionStatus::clear_done_pnc_junction_overlap_id() {
  _impl_.done_pnc_junction_overlap_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BareIntersectionStatus::done_pnc_junction_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  return _internal_done_pnc_junction_overlap_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BareIntersectionStatus::set_done_pnc_junction_overlap_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.done_pnc_junction_overlap_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
inline std::string* BareIntersectionStatus::mutable_done_pnc_junction_overlap_id() {
  std::string* _s = _internal_mutable_done_pnc_junction_overlap_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  return _s;
}
inline const std::string& BareIntersectionStatus::_internal_done_pnc_junction_overlap_id() const {
  return _impl_.done_pnc_junction_overlap_id_.Get();
}
inline void BareIntersectionStatus::_internal_set_done_pnc_junction_overlap_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.done_pnc_junction_overlap_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BareIntersectionStatus::_internal_mutable_done_pnc_junction_overlap_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.done_pnc_junction_overlap_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BareIntersectionStatus::release_done_pnc_junction_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  if (!_internal_has_done_pnc_junction_overlap_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.done_pnc_junction_overlap_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.done_pnc_junction_overlap_id_.IsDefault()) {
    _impl_.done_pnc_junction_overlap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BareIntersectionStatus::set_allocated_done_pnc_junction_overlap_id(std::string* done_pnc_junction_overlap_id) {
  if (done_pnc_junction_overlap_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.done_pnc_junction_overlap_id_.SetAllocated(done_pnc_junction_overlap_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.done_pnc_junction_overlap_id_.IsDefault()) {
    _impl_.done_pnc_junction_overlap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}

// optional uint32 clear_counter = 3;
inline bool BareIntersectionStatus::_internal_has_clear_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BareIntersectionStatus::has_clear_counter() const {
  return _internal_has_clear_counter();
}
inline void BareIntersectionStatus::clear_clear_counter() {
  _impl_.clear_counter_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t BareIntersectionStatus::_internal_clear_counter() const {
  return _impl_.clear_counter_;
}
inline uint32_t BareIntersectionStatus::clear_counter() const {
  // @@protoc_insertion_point(field_get:apollo.planning.BareIntersectionStatus.clear_counter)
  return _internal_clear_counter();
}
inline void BareIntersectionStatus::_internal_set_clear_counter(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.clear_counter_ = value;
}
inline void BareIntersectionStatus::set_clear_counter(uint32_t value) {
  _internal_set_clear_counter(value);
  // @@protoc_insertion_point(field_set:apollo.planning.BareIntersectionStatus.clear_counter)
}

// -------------------------------------------------------------------

// ChangeLaneStatus

// optional .apollo.planning.ChangeLaneStatus.Status status = 1;
inline bool ChangeLaneStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_status() const {
  return _internal_has_status();
}
inline void ChangeLaneStatus::clear_status() {
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::apollo::planning::ChangeLaneStatus_Status ChangeLaneStatus::_internal_status() const {
  return static_cast< ::apollo::planning::ChangeLaneStatus_Status >(_impl_.status_);
}
inline ::apollo::planning::ChangeLaneStatus_Status ChangeLaneStatus::status() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.status)
  return _internal_status();
}
inline void ChangeLaneStatus::_internal_set_status(::apollo::planning::ChangeLaneStatus_Status value) {
  assert(::apollo::planning::ChangeLaneStatus_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.status_ = value;
}
inline void ChangeLaneStatus::set_status(::apollo::planning::ChangeLaneStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.status)
}

// optional string path_id = 2;
inline bool ChangeLaneStatus::_internal_has_path_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_path_id() const {
  return _internal_has_path_id();
}
inline void ChangeLaneStatus::clear_path_id() {
  _impl_.path_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeLaneStatus::path_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.path_id)
  return _internal_path_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeLaneStatus::set_path_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.path_id)
}
inline std::string* ChangeLaneStatus::mutable_path_id() {
  std::string* _s = _internal_mutable_path_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ChangeLaneStatus.path_id)
  return _s;
}
inline const std::string& ChangeLaneStatus::_internal_path_id() const {
  return _impl_.path_id_.Get();
}
inline void ChangeLaneStatus::_internal_set_path_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeLaneStatus::_internal_mutable_path_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeLaneStatus::release_path_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.ChangeLaneStatus.path_id)
  if (!_internal_has_path_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_id_.IsDefault()) {
    _impl_.path_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChangeLaneStatus::set_allocated_path_id(std::string* path_id) {
  if (path_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_id_.SetAllocated(path_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_id_.IsDefault()) {
    _impl_.path_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ChangeLaneStatus.path_id)
}

// optional double timestamp = 3;
inline bool ChangeLaneStatus::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ChangeLaneStatus::clear_timestamp() {
  _impl_.timestamp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ChangeLaneStatus::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline double ChangeLaneStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.timestamp)
  return _internal_timestamp();
}
inline void ChangeLaneStatus::_internal_set_timestamp(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_ = value;
}
inline void ChangeLaneStatus::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.timestamp)
}

// optional bool exist_lane_change_start_position = 4 [default = false];
inline bool ChangeLaneStatus::_internal_has_exist_lane_change_start_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_exist_lane_change_start_position() const {
  return _internal_has_exist_lane_change_start_position();
}
inline void ChangeLaneStatus::clear_exist_lane_change_start_position() {
  _impl_.exist_lane_change_start_position_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ChangeLaneStatus::_internal_exist_lane_change_start_position() const {
  return _impl_.exist_lane_change_start_position_;
}
inline bool ChangeLaneStatus::exist_lane_change_start_position() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.exist_lane_change_start_position)
  return _internal_exist_lane_change_start_position();
}
inline void ChangeLaneStatus::_internal_set_exist_lane_change_start_position(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.exist_lane_change_start_position_ = value;
}
inline void ChangeLaneStatus::set_exist_lane_change_start_position(bool value) {
  _internal_set_exist_lane_change_start_position(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.exist_lane_change_start_position)
}

// optional .apollo.common.Point3D lane_change_start_position = 5;
inline bool ChangeLaneStatus::_internal_has_lane_change_start_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lane_change_start_position_ != nullptr);
  return value;
}
inline bool ChangeLaneStatus::has_lane_change_start_position() const {
  return _internal_has_lane_change_start_position();
}
inline const ::apollo::common::Point3D& ChangeLaneStatus::_internal_lane_change_start_position() const {
  const ::apollo::common::Point3D* p = _impl_.lane_change_start_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::Point3D&>(
      ::apollo::common::_Point3D_default_instance_);
}
inline const ::apollo::common::Point3D& ChangeLaneStatus::lane_change_start_position() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.lane_change_start_position)
  return _internal_lane_change_start_position();
}
inline void ChangeLaneStatus::unsafe_arena_set_allocated_lane_change_start_position(
    ::apollo::common::Point3D* lane_change_start_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lane_change_start_position_);
  }
  _impl_.lane_change_start_position_ = lane_change_start_position;
  if (lane_change_start_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.ChangeLaneStatus.lane_change_start_position)
}
inline ::apollo::common::Point3D* ChangeLaneStatus::release_lane_change_start_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::Point3D* temp = _impl_.lane_change_start_position_;
  _impl_.lane_change_start_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::Point3D* ChangeLaneStatus::unsafe_arena_release_lane_change_start_position() {
  // @@protoc_insertion_point(field_release:apollo.planning.ChangeLaneStatus.lane_change_start_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::Point3D* temp = _impl_.lane_change_start_position_;
  _impl_.lane_change_start_position_ = nullptr;
  return temp;
}
inline ::apollo::common::Point3D* ChangeLaneStatus::_internal_mutable_lane_change_start_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lane_change_start_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaForAllocation());
    _impl_.lane_change_start_position_ = p;
  }
  return _impl_.lane_change_start_position_;
}
inline ::apollo::common::Point3D* ChangeLaneStatus::mutable_lane_change_start_position() {
  ::apollo::common::Point3D* _msg = _internal_mutable_lane_change_start_position();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ChangeLaneStatus.lane_change_start_position)
  return _msg;
}
inline void ChangeLaneStatus::set_allocated_lane_change_start_position(::apollo::common::Point3D* lane_change_start_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lane_change_start_position_);
  }
  if (lane_change_start_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lane_change_start_position));
    if (message_arena != submessage_arena) {
      lane_change_start_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lane_change_start_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.lane_change_start_position_ = lane_change_start_position;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ChangeLaneStatus.lane_change_start_position)
}

// optional double last_succeed_timestamp = 6;
inline bool ChangeLaneStatus::_internal_has_last_succeed_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_last_succeed_timestamp() const {
  return _internal_has_last_succeed_timestamp();
}
inline void ChangeLaneStatus::clear_last_succeed_timestamp() {
  _impl_.last_succeed_timestamp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ChangeLaneStatus::_internal_last_succeed_timestamp() const {
  return _impl_.last_succeed_timestamp_;
}
inline double ChangeLaneStatus::last_succeed_timestamp() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.last_succeed_timestamp)
  return _internal_last_succeed_timestamp();
}
inline void ChangeLaneStatus::_internal_set_last_succeed_timestamp(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.last_succeed_timestamp_ = value;
}
inline void ChangeLaneStatus::set_last_succeed_timestamp(double value) {
  _internal_set_last_succeed_timestamp(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.last_succeed_timestamp)
}

// optional bool is_current_opt_succeed = 7 [default = false];
inline bool ChangeLaneStatus::_internal_has_is_current_opt_succeed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_is_current_opt_succeed() const {
  return _internal_has_is_current_opt_succeed();
}
inline void ChangeLaneStatus::clear_is_current_opt_succeed() {
  _impl_.is_current_opt_succeed_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ChangeLaneStatus::_internal_is_current_opt_succeed() const {
  return _impl_.is_current_opt_succeed_;
}
inline bool ChangeLaneStatus::is_current_opt_succeed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.is_current_opt_succeed)
  return _internal_is_current_opt_succeed();
}
inline void ChangeLaneStatus::_internal_set_is_current_opt_succeed(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.is_current_opt_succeed_ = value;
}
inline void ChangeLaneStatus::set_is_current_opt_succeed(bool value) {
  _internal_set_is_current_opt_succeed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.is_current_opt_succeed)
}

// optional bool is_clear_to_change_lane = 8 [default = false];
inline bool ChangeLaneStatus::_internal_has_is_clear_to_change_lane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ChangeLaneStatus::has_is_clear_to_change_lane() const {
  return _internal_has_is_clear_to_change_lane();
}
inline void ChangeLaneStatus::clear_is_clear_to_change_lane() {
  _impl_.is_clear_to_change_lane_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool ChangeLaneStatus::_internal_is_clear_to_change_lane() const {
  return _impl_.is_clear_to_change_lane_;
}
inline bool ChangeLaneStatus::is_clear_to_change_lane() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.is_clear_to_change_lane)
  return _internal_is_clear_to_change_lane();
}
inline void ChangeLaneStatus::_internal_set_is_clear_to_change_lane(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.is_clear_to_change_lane_ = value;
}
inline void ChangeLaneStatus::set_is_clear_to_change_lane(bool value) {
  _internal_set_is_clear_to_change_lane(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.is_clear_to_change_lane)
}

// -------------------------------------------------------------------

// CreepDeciderStatus

// optional uint32 creep_clear_counter = 1;
inline bool CreepDeciderStatus::_internal_has_creep_clear_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreepDeciderStatus::has_creep_clear_counter() const {
  return _internal_has_creep_clear_counter();
}
inline void CreepDeciderStatus::clear_creep_clear_counter() {
  _impl_.creep_clear_counter_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CreepDeciderStatus::_internal_creep_clear_counter() const {
  return _impl_.creep_clear_counter_;
}
inline uint32_t CreepDeciderStatus::creep_clear_counter() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepDeciderStatus.creep_clear_counter)
  return _internal_creep_clear_counter();
}
inline void CreepDeciderStatus::_internal_set_creep_clear_counter(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.creep_clear_counter_ = value;
}
inline void CreepDeciderStatus::set_creep_clear_counter(uint32_t value) {
  _internal_set_creep_clear_counter(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepDeciderStatus.creep_clear_counter)
}

// -------------------------------------------------------------------

// StopTime

// optional string obstacle_id = 1;
inline bool StopTime::_internal_has_obstacle_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopTime::has_obstacle_id() const {
  return _internal_has_obstacle_id();
}
inline void StopTime::clear_obstacle_id() {
  _impl_.obstacle_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopTime::obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopTime.obstacle_id)
  return _internal_obstacle_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopTime::set_obstacle_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.obstacle_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.StopTime.obstacle_id)
}
inline std::string* StopTime::mutable_obstacle_id() {
  std::string* _s = _internal_mutable_obstacle_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopTime.obstacle_id)
  return _s;
}
inline const std::string& StopTime::_internal_obstacle_id() const {
  return _impl_.obstacle_id_.Get();
}
inline void StopTime::_internal_set_obstacle_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.obstacle_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopTime::_internal_mutable_obstacle_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.obstacle_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopTime::release_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopTime.obstacle_id)
  if (!_internal_has_obstacle_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.obstacle_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obstacle_id_.IsDefault()) {
    _impl_.obstacle_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StopTime::set_allocated_obstacle_id(std::string* obstacle_id) {
  if (obstacle_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.obstacle_id_.SetAllocated(obstacle_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obstacle_id_.IsDefault()) {
    _impl_.obstacle_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopTime.obstacle_id)
}

// optional double stop_timestamp_sec = 2;
inline bool StopTime::_internal_has_stop_timestamp_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopTime::has_stop_timestamp_sec() const {
  return _internal_has_stop_timestamp_sec();
}
inline void StopTime::clear_stop_timestamp_sec() {
  _impl_.stop_timestamp_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double StopTime::_internal_stop_timestamp_sec() const {
  return _impl_.stop_timestamp_sec_;
}
inline double StopTime::stop_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopTime.stop_timestamp_sec)
  return _internal_stop_timestamp_sec();
}
inline void StopTime::_internal_set_stop_timestamp_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stop_timestamp_sec_ = value;
}
inline void StopTime::set_stop_timestamp_sec(double value) {
  _internal_set_stop_timestamp_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopTime.stop_timestamp_sec)
}

// -------------------------------------------------------------------

// CrosswalkStatus

// optional string crosswalk_id = 1;
inline bool CrosswalkStatus::_internal_has_crosswalk_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrosswalkStatus::has_crosswalk_id() const {
  return _internal_has_crosswalk_id();
}
inline void CrosswalkStatus::clear_crosswalk_id() {
  _impl_.crosswalk_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrosswalkStatus::crosswalk_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkStatus.crosswalk_id)
  return _internal_crosswalk_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrosswalkStatus::set_crosswalk_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.crosswalk_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkStatus.crosswalk_id)
}
inline std::string* CrosswalkStatus::mutable_crosswalk_id() {
  std::string* _s = _internal_mutable_crosswalk_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.CrosswalkStatus.crosswalk_id)
  return _s;
}
inline const std::string& CrosswalkStatus::_internal_crosswalk_id() const {
  return _impl_.crosswalk_id_.Get();
}
inline void CrosswalkStatus::_internal_set_crosswalk_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.crosswalk_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CrosswalkStatus::_internal_mutable_crosswalk_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.crosswalk_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CrosswalkStatus::release_crosswalk_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.CrosswalkStatus.crosswalk_id)
  if (!_internal_has_crosswalk_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.crosswalk_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.crosswalk_id_.IsDefault()) {
    _impl_.crosswalk_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CrosswalkStatus::set_allocated_crosswalk_id(std::string* crosswalk_id) {
  if (crosswalk_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.crosswalk_id_.SetAllocated(crosswalk_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.crosswalk_id_.IsDefault()) {
    _impl_.crosswalk_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.CrosswalkStatus.crosswalk_id)
}

// repeated .apollo.planning.StopTime stop_time = 2;
inline int CrosswalkStatus::_internal_stop_time_size() const {
  return _impl_.stop_time_.size();
}
inline int CrosswalkStatus::stop_time_size() const {
  return _internal_stop_time_size();
}
inline void CrosswalkStatus::clear_stop_time() {
  _impl_.stop_time_.Clear();
}
inline ::apollo::planning::StopTime* CrosswalkStatus::mutable_stop_time(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.CrosswalkStatus.stop_time)
  return _impl_.stop_time_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >*
CrosswalkStatus::mutable_stop_time() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.CrosswalkStatus.stop_time)
  return &_impl_.stop_time_;
}
inline const ::apollo::planning::StopTime& CrosswalkStatus::_internal_stop_time(int index) const {
  return _impl_.stop_time_.Get(index);
}
inline const ::apollo::planning::StopTime& CrosswalkStatus::stop_time(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkStatus.stop_time)
  return _internal_stop_time(index);
}
inline ::apollo::planning::StopTime* CrosswalkStatus::_internal_add_stop_time() {
  return _impl_.stop_time_.Add();
}
inline ::apollo::planning::StopTime* CrosswalkStatus::add_stop_time() {
  ::apollo::planning::StopTime* _add = _internal_add_stop_time();
  // @@protoc_insertion_point(field_add:apollo.planning.CrosswalkStatus.stop_time)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >&
CrosswalkStatus::stop_time() const {
  // @@protoc_insertion_point(field_list:apollo.planning.CrosswalkStatus.stop_time)
  return _impl_.stop_time_;
}

// repeated string finished_crosswalk = 3;
inline int CrosswalkStatus::_internal_finished_crosswalk_size() const {
  return _impl_.finished_crosswalk_.size();
}
inline int CrosswalkStatus::finished_crosswalk_size() const {
  return _internal_finished_crosswalk_size();
}
inline void CrosswalkStatus::clear_finished_crosswalk() {
  _impl_.finished_crosswalk_.Clear();
}
inline std::string* CrosswalkStatus::add_finished_crosswalk() {
  std::string* _s = _internal_add_finished_crosswalk();
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.CrosswalkStatus.finished_crosswalk)
  return _s;
}
inline const std::string& CrosswalkStatus::_internal_finished_crosswalk(int index) const {
  return _impl_.finished_crosswalk_.Get(index);
}
inline const std::string& CrosswalkStatus::finished_crosswalk(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkStatus.finished_crosswalk)
  return _internal_finished_crosswalk(index);
}
inline std::string* CrosswalkStatus::mutable_finished_crosswalk(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.CrosswalkStatus.finished_crosswalk)
  return _impl_.finished_crosswalk_.Mutable(index);
}
inline void CrosswalkStatus::set_finished_crosswalk(int index, const std::string& value) {
  _impl_.finished_crosswalk_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::set_finished_crosswalk(int index, std::string&& value) {
  _impl_.finished_crosswalk_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::set_finished_crosswalk(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.finished_crosswalk_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::set_finished_crosswalk(int index, const char* value, size_t size) {
  _impl_.finished_crosswalk_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline std::string* CrosswalkStatus::_internal_add_finished_crosswalk() {
  return _impl_.finished_crosswalk_.Add();
}
inline void CrosswalkStatus::add_finished_crosswalk(const std::string& value) {
  _impl_.finished_crosswalk_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::add_finished_crosswalk(std::string&& value) {
  _impl_.finished_crosswalk_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::add_finished_crosswalk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.finished_crosswalk_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::add_finished_crosswalk(const char* value, size_t size) {
  _impl_.finished_crosswalk_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.CrosswalkStatus.finished_crosswalk)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrosswalkStatus::finished_crosswalk() const {
  // @@protoc_insertion_point(field_list:apollo.planning.CrosswalkStatus.finished_crosswalk)
  return _impl_.finished_crosswalk_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrosswalkStatus::mutable_finished_crosswalk() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.CrosswalkStatus.finished_crosswalk)
  return &_impl_.finished_crosswalk_;
}

// -------------------------------------------------------------------

// DestinationStatus

// optional bool has_passed_destination = 1 [default = false];
inline bool DestinationStatus::_internal_has_has_passed_destination() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DestinationStatus::has_has_passed_destination() const {
  return _internal_has_has_passed_destination();
}
inline void DestinationStatus::clear_has_passed_destination() {
  _impl_.has_passed_destination_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DestinationStatus::_internal_has_passed_destination() const {
  return _impl_.has_passed_destination_;
}
inline bool DestinationStatus::has_passed_destination() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationStatus.has_passed_destination)
  return _internal_has_passed_destination();
}
inline void DestinationStatus::_internal_set_has_passed_destination(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.has_passed_destination_ = value;
}
inline void DestinationStatus::set_has_passed_destination(bool value) {
  _internal_set_has_passed_destination(value);
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationStatus.has_passed_destination)
}

// -------------------------------------------------------------------

// EmergencyStopStatus

// optional .apollo.common.PointENU stop_fence_point = 1;
inline bool EmergencyStopStatus::_internal_has_stop_fence_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_fence_point_ != nullptr);
  return value;
}
inline bool EmergencyStopStatus::has_stop_fence_point() const {
  return _internal_has_stop_fence_point();
}
inline const ::apollo::common::PointENU& EmergencyStopStatus::_internal_stop_fence_point() const {
  const ::apollo::common::PointENU* p = _impl_.stop_fence_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::PointENU&>(
      ::apollo::common::_PointENU_default_instance_);
}
inline const ::apollo::common::PointENU& EmergencyStopStatus::stop_fence_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.EmergencyStopStatus.stop_fence_point)
  return _internal_stop_fence_point();
}
inline void EmergencyStopStatus::unsafe_arena_set_allocated_stop_fence_point(
    ::apollo::common::PointENU* stop_fence_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stop_fence_point_);
  }
  _impl_.stop_fence_point_ = stop_fence_point;
  if (stop_fence_point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.EmergencyStopStatus.stop_fence_point)
}
inline ::apollo::common::PointENU* EmergencyStopStatus::release_stop_fence_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = _impl_.stop_fence_point_;
  _impl_.stop_fence_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::PointENU* EmergencyStopStatus::unsafe_arena_release_stop_fence_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.EmergencyStopStatus.stop_fence_point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = _impl_.stop_fence_point_;
  _impl_.stop_fence_point_ = nullptr;
  return temp;
}
inline ::apollo::common::PointENU* EmergencyStopStatus::_internal_mutable_stop_fence_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stop_fence_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::PointENU>(GetArenaForAllocation());
    _impl_.stop_fence_point_ = p;
  }
  return _impl_.stop_fence_point_;
}
inline ::apollo::common::PointENU* EmergencyStopStatus::mutable_stop_fence_point() {
  ::apollo::common::PointENU* _msg = _internal_mutable_stop_fence_point();
  // @@protoc_insertion_point(field_mutable:apollo.planning.EmergencyStopStatus.stop_fence_point)
  return _msg;
}
inline void EmergencyStopStatus::set_allocated_stop_fence_point(::apollo::common::PointENU* stop_fence_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stop_fence_point_);
  }
  if (stop_fence_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_fence_point));
    if (message_arena != submessage_arena) {
      stop_fence_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_fence_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_fence_point_ = stop_fence_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.EmergencyStopStatus.stop_fence_point)
}

// -------------------------------------------------------------------

// OpenSpaceStatus

// repeated string partitioned_trajectories_index_history = 1;
inline int OpenSpaceStatus::_internal_partitioned_trajectories_index_history_size() const {
  return _impl_.partitioned_trajectories_index_history_.size();
}
inline int OpenSpaceStatus::partitioned_trajectories_index_history_size() const {
  return _internal_partitioned_trajectories_index_history_size();
}
inline void OpenSpaceStatus::clear_partitioned_trajectories_index_history() {
  _impl_.partitioned_trajectories_index_history_.Clear();
}
inline std::string* OpenSpaceStatus::add_partitioned_trajectories_index_history() {
  std::string* _s = _internal_add_partitioned_trajectories_index_history();
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return _s;
}
inline const std::string& OpenSpaceStatus::_internal_partitioned_trajectories_index_history(int index) const {
  return _impl_.partitioned_trajectories_index_history_.Get(index);
}
inline const std::string& OpenSpaceStatus::partitioned_trajectories_index_history(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return _internal_partitioned_trajectories_index_history(index);
}
inline std::string* OpenSpaceStatus::mutable_partitioned_trajectories_index_history(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return _impl_.partitioned_trajectories_index_history_.Mutable(index);
}
inline void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, const std::string& value) {
  _impl_.partitioned_trajectories_index_history_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, std::string&& value) {
  _impl_.partitioned_trajectories_index_history_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.partitioned_trajectories_index_history_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, const char* value, size_t size) {
  _impl_.partitioned_trajectories_index_history_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline std::string* OpenSpaceStatus::_internal_add_partitioned_trajectories_index_history() {
  return _impl_.partitioned_trajectories_index_history_.Add();
}
inline void OpenSpaceStatus::add_partitioned_trajectories_index_history(const std::string& value) {
  _impl_.partitioned_trajectories_index_history_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline void OpenSpaceStatus::add_partitioned_trajectories_index_history(std::string&& value) {
  _impl_.partitioned_trajectories_index_history_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline void OpenSpaceStatus::add_partitioned_trajectories_index_history(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.partitioned_trajectories_index_history_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline void OpenSpaceStatus::add_partitioned_trajectories_index_history(const char* value, size_t size) {
  _impl_.partitioned_trajectories_index_history_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OpenSpaceStatus::partitioned_trajectories_index_history() const {
  // @@protoc_insertion_point(field_list:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return _impl_.partitioned_trajectories_index_history_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OpenSpaceStatus::mutable_partitioned_trajectories_index_history() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return &_impl_.partitioned_trajectories_index_history_;
}

// optional bool position_init = 2 [default = false];
inline bool OpenSpaceStatus::_internal_has_position_init() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpenSpaceStatus::has_position_init() const {
  return _internal_has_position_init();
}
inline void OpenSpaceStatus::clear_position_init() {
  _impl_.position_init_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool OpenSpaceStatus::_internal_position_init() const {
  return _impl_.position_init_;
}
inline bool OpenSpaceStatus::position_init() const {
  // @@protoc_insertion_point(field_get:apollo.planning.OpenSpaceStatus.position_init)
  return _internal_position_init();
}
inline void OpenSpaceStatus::_internal_set_position_init(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.position_init_ = value;
}
inline void OpenSpaceStatus::set_position_init(bool value) {
  _internal_set_position_init(value);
  // @@protoc_insertion_point(field_set:apollo.planning.OpenSpaceStatus.position_init)
}

// -------------------------------------------------------------------

// ParkAndGoStatus

// optional .apollo.common.PointENU adc_init_position = 1;
inline bool ParkAndGoStatus::_internal_has_adc_init_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.adc_init_position_ != nullptr);
  return value;
}
inline bool ParkAndGoStatus::has_adc_init_position() const {
  return _internal_has_adc_init_position();
}
inline const ::apollo::common::PointENU& ParkAndGoStatus::_internal_adc_init_position() const {
  const ::apollo::common::PointENU* p = _impl_.adc_init_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::PointENU&>(
      ::apollo::common::_PointENU_default_instance_);
}
inline const ::apollo::common::PointENU& ParkAndGoStatus::adc_init_position() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ParkAndGoStatus.adc_init_position)
  return _internal_adc_init_position();
}
inline void ParkAndGoStatus::unsafe_arena_set_allocated_adc_init_position(
    ::apollo::common::PointENU* adc_init_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adc_init_position_);
  }
  _impl_.adc_init_position_ = adc_init_position;
  if (adc_init_position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.ParkAndGoStatus.adc_init_position)
}
inline ::apollo::common::PointENU* ParkAndGoStatus::release_adc_init_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = _impl_.adc_init_position_;
  _impl_.adc_init_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::PointENU* ParkAndGoStatus::unsafe_arena_release_adc_init_position() {
  // @@protoc_insertion_point(field_release:apollo.planning.ParkAndGoStatus.adc_init_position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = _impl_.adc_init_position_;
  _impl_.adc_init_position_ = nullptr;
  return temp;
}
inline ::apollo::common::PointENU* ParkAndGoStatus::_internal_mutable_adc_init_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.adc_init_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::PointENU>(GetArenaForAllocation());
    _impl_.adc_init_position_ = p;
  }
  return _impl_.adc_init_position_;
}
inline ::apollo::common::PointENU* ParkAndGoStatus::mutable_adc_init_position() {
  ::apollo::common::PointENU* _msg = _internal_mutable_adc_init_position();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ParkAndGoStatus.adc_init_position)
  return _msg;
}
inline void ParkAndGoStatus::set_allocated_adc_init_position(::apollo::common::PointENU* adc_init_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adc_init_position_);
  }
  if (adc_init_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adc_init_position));
    if (message_arena != submessage_arena) {
      adc_init_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adc_init_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.adc_init_position_ = adc_init_position;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ParkAndGoStatus.adc_init_position)
}

// optional double adc_init_heading = 2;
inline bool ParkAndGoStatus::_internal_has_adc_init_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ParkAndGoStatus::has_adc_init_heading() const {
  return _internal_has_adc_init_heading();
}
inline void ParkAndGoStatus::clear_adc_init_heading() {
  _impl_.adc_init_heading_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ParkAndGoStatus::_internal_adc_init_heading() const {
  return _impl_.adc_init_heading_;
}
inline double ParkAndGoStatus::adc_init_heading() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ParkAndGoStatus.adc_init_heading)
  return _internal_adc_init_heading();
}
inline void ParkAndGoStatus::_internal_set_adc_init_heading(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.adc_init_heading_ = value;
}
inline void ParkAndGoStatus::set_adc_init_heading(double value) {
  _internal_set_adc_init_heading(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ParkAndGoStatus.adc_init_heading)
}

// optional bool in_check_stage = 3;
inline bool ParkAndGoStatus::_internal_has_in_check_stage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ParkAndGoStatus::has_in_check_stage() const {
  return _internal_has_in_check_stage();
}
inline void ParkAndGoStatus::clear_in_check_stage() {
  _impl_.in_check_stage_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ParkAndGoStatus::_internal_in_check_stage() const {
  return _impl_.in_check_stage_;
}
inline bool ParkAndGoStatus::in_check_stage() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ParkAndGoStatus.in_check_stage)
  return _internal_in_check_stage();
}
inline void ParkAndGoStatus::_internal_set_in_check_stage(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.in_check_stage_ = value;
}
inline void ParkAndGoStatus::set_in_check_stage(bool value) {
  _internal_set_in_check_stage(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ParkAndGoStatus.in_check_stage)
}

// optional .apollo.common.PointENU adc_adjust_end_pose = 4;
inline bool ParkAndGoStatus::_internal_has_adc_adjust_end_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.adc_adjust_end_pose_ != nullptr);
  return value;
}
inline bool ParkAndGoStatus::has_adc_adjust_end_pose() const {
  return _internal_has_adc_adjust_end_pose();
}
inline const ::apollo::common::PointENU& ParkAndGoStatus::_internal_adc_adjust_end_pose() const {
  const ::apollo::common::PointENU* p = _impl_.adc_adjust_end_pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::PointENU&>(
      ::apollo::common::_PointENU_default_instance_);
}
inline const ::apollo::common::PointENU& ParkAndGoStatus::adc_adjust_end_pose() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ParkAndGoStatus.adc_adjust_end_pose)
  return _internal_adc_adjust_end_pose();
}
inline void ParkAndGoStatus::unsafe_arena_set_allocated_adc_adjust_end_pose(
    ::apollo::common::PointENU* adc_adjust_end_pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adc_adjust_end_pose_);
  }
  _impl_.adc_adjust_end_pose_ = adc_adjust_end_pose;
  if (adc_adjust_end_pose) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.ParkAndGoStatus.adc_adjust_end_pose)
}
inline ::apollo::common::PointENU* ParkAndGoStatus::release_adc_adjust_end_pose() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::PointENU* temp = _impl_.adc_adjust_end_pose_;
  _impl_.adc_adjust_end_pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::PointENU* ParkAndGoStatus::unsafe_arena_release_adc_adjust_end_pose() {
  // @@protoc_insertion_point(field_release:apollo.planning.ParkAndGoStatus.adc_adjust_end_pose)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::common::PointENU* temp = _impl_.adc_adjust_end_pose_;
  _impl_.adc_adjust_end_pose_ = nullptr;
  return temp;
}
inline ::apollo::common::PointENU* ParkAndGoStatus::_internal_mutable_adc_adjust_end_pose() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.adc_adjust_end_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::PointENU>(GetArenaForAllocation());
    _impl_.adc_adjust_end_pose_ = p;
  }
  return _impl_.adc_adjust_end_pose_;
}
inline ::apollo::common::PointENU* ParkAndGoStatus::mutable_adc_adjust_end_pose() {
  ::apollo::common::PointENU* _msg = _internal_mutable_adc_adjust_end_pose();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ParkAndGoStatus.adc_adjust_end_pose)
  return _msg;
}
inline void ParkAndGoStatus::set_allocated_adc_adjust_end_pose(::apollo::common::PointENU* adc_adjust_end_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adc_adjust_end_pose_);
  }
  if (adc_adjust_end_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adc_adjust_end_pose));
    if (message_arena != submessage_arena) {
      adc_adjust_end_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adc_adjust_end_pose, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.adc_adjust_end_pose_ = adc_adjust_end_pose;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ParkAndGoStatus.adc_adjust_end_pose)
}

// -------------------------------------------------------------------

// PathDeciderStatus

// optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
inline bool PathDeciderStatus::_internal_has_front_static_obstacle_cycle_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PathDeciderStatus::has_front_static_obstacle_cycle_counter() const {
  return _internal_has_front_static_obstacle_cycle_counter();
}
inline void PathDeciderStatus::clear_front_static_obstacle_cycle_counter() {
  _impl_.front_static_obstacle_cycle_counter_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t PathDeciderStatus::_internal_front_static_obstacle_cycle_counter() const {
  return _impl_.front_static_obstacle_cycle_counter_;
}
inline int32_t PathDeciderStatus::front_static_obstacle_cycle_counter() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PathDeciderStatus.front_static_obstacle_cycle_counter)
  return _internal_front_static_obstacle_cycle_counter();
}
inline void PathDeciderStatus::_internal_set_front_static_obstacle_cycle_counter(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.front_static_obstacle_cycle_counter_ = value;
}
inline void PathDeciderStatus::set_front_static_obstacle_cycle_counter(int32_t value) {
  _internal_set_front_static_obstacle_cycle_counter(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PathDeciderStatus.front_static_obstacle_cycle_counter)
}

// optional int32 able_to_use_self_lane_counter = 2 [default = 0];
inline bool PathDeciderStatus::_internal_has_able_to_use_self_lane_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PathDeciderStatus::has_able_to_use_self_lane_counter() const {
  return _internal_has_able_to_use_self_lane_counter();
}
inline void PathDeciderStatus::clear_able_to_use_self_lane_counter() {
  _impl_.able_to_use_self_lane_counter_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t PathDeciderStatus::_internal_able_to_use_self_lane_counter() const {
  return _impl_.able_to_use_self_lane_counter_;
}
inline int32_t PathDeciderStatus::able_to_use_self_lane_counter() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PathDeciderStatus.able_to_use_self_lane_counter)
  return _internal_able_to_use_self_lane_counter();
}
inline void PathDeciderStatus::_internal_set_able_to_use_self_lane_counter(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.able_to_use_self_lane_counter_ = value;
}
inline void PathDeciderStatus::set_able_to_use_self_lane_counter(int32_t value) {
  _internal_set_able_to_use_self_lane_counter(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PathDeciderStatus.able_to_use_self_lane_counter)
}

// optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
inline bool PathDeciderStatus::_internal_has_is_in_path_lane_borrow_scenario() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PathDeciderStatus::has_is_in_path_lane_borrow_scenario() const {
  return _internal_has_is_in_path_lane_borrow_scenario();
}
inline void PathDeciderStatus::clear_is_in_path_lane_borrow_scenario() {
  _impl_.is_in_path_lane_borrow_scenario_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool PathDeciderStatus::_internal_is_in_path_lane_borrow_scenario() const {
  return _impl_.is_in_path_lane_borrow_scenario_;
}
inline bool PathDeciderStatus::is_in_path_lane_borrow_scenario() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PathDeciderStatus.is_in_path_lane_borrow_scenario)
  return _internal_is_in_path_lane_borrow_scenario();
}
inline void PathDeciderStatus::_internal_set_is_in_path_lane_borrow_scenario(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_in_path_lane_borrow_scenario_ = value;
}
inline void PathDeciderStatus::set_is_in_path_lane_borrow_scenario(bool value) {
  _internal_set_is_in_path_lane_borrow_scenario(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PathDeciderStatus.is_in_path_lane_borrow_scenario)
}

// optional string front_static_obstacle_id = 4 [default = ""];
inline bool PathDeciderStatus::_internal_has_front_static_obstacle_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PathDeciderStatus::has_front_static_obstacle_id() const {
  return _internal_has_front_static_obstacle_id();
}
inline void PathDeciderStatus::clear_front_static_obstacle_id() {
  _impl_.front_static_obstacle_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PathDeciderStatus::front_static_obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PathDeciderStatus.front_static_obstacle_id)
  return _internal_front_static_obstacle_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathDeciderStatus::set_front_static_obstacle_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.front_static_obstacle_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.PathDeciderStatus.front_static_obstacle_id)
}
inline std::string* PathDeciderStatus::mutable_front_static_obstacle_id() {
  std::string* _s = _internal_mutable_front_static_obstacle_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PathDeciderStatus.front_static_obstacle_id)
  return _s;
}
inline const std::string& PathDeciderStatus::_internal_front_static_obstacle_id() const {
  return _impl_.front_static_obstacle_id_.Get();
}
inline void PathDeciderStatus::_internal_set_front_static_obstacle_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.front_static_obstacle_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PathDeciderStatus::_internal_mutable_front_static_obstacle_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.front_static_obstacle_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PathDeciderStatus::release_front_static_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.PathDeciderStatus.front_static_obstacle_id)
  if (!_internal_has_front_static_obstacle_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.front_static_obstacle_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.front_static_obstacle_id_.IsDefault()) {
    _impl_.front_static_obstacle_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PathDeciderStatus::set_allocated_front_static_obstacle_id(std::string* front_static_obstacle_id) {
  if (front_static_obstacle_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.front_static_obstacle_id_.SetAllocated(front_static_obstacle_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.front_static_obstacle_id_.IsDefault()) {
    _impl_.front_static_obstacle_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PathDeciderStatus.front_static_obstacle_id)
}

// repeated .apollo.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
inline int PathDeciderStatus::_internal_decided_side_pass_direction_size() const {
  return _impl_.decided_side_pass_direction_.size();
}
inline int PathDeciderStatus::decided_side_pass_direction_size() const {
  return _internal_decided_side_pass_direction_size();
}
inline void PathDeciderStatus::clear_decided_side_pass_direction() {
  _impl_.decided_side_pass_direction_.Clear();
}
inline ::apollo::planning::PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::_internal_decided_side_pass_direction(int index) const {
  return static_cast< ::apollo::planning::PathDeciderStatus_LaneBorrowDirection >(_impl_.decided_side_pass_direction_.Get(index));
}
inline ::apollo::planning::PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::decided_side_pass_direction(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PathDeciderStatus.decided_side_pass_direction)
  return _internal_decided_side_pass_direction(index);
}
inline void PathDeciderStatus::set_decided_side_pass_direction(int index, ::apollo::planning::PathDeciderStatus_LaneBorrowDirection value) {
  assert(::apollo::planning::PathDeciderStatus_LaneBorrowDirection_IsValid(value));
  _impl_.decided_side_pass_direction_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.PathDeciderStatus.decided_side_pass_direction)
}
inline void PathDeciderStatus::_internal_add_decided_side_pass_direction(::apollo::planning::PathDeciderStatus_LaneBorrowDirection value) {
  assert(::apollo::planning::PathDeciderStatus_LaneBorrowDirection_IsValid(value));
  _impl_.decided_side_pass_direction_.Add(value);
}
inline void PathDeciderStatus::add_decided_side_pass_direction(::apollo::planning::PathDeciderStatus_LaneBorrowDirection value) {
  _internal_add_decided_side_pass_direction(value);
  // @@protoc_insertion_point(field_add:apollo.planning.PathDeciderStatus.decided_side_pass_direction)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
PathDeciderStatus::decided_side_pass_direction() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PathDeciderStatus.decided_side_pass_direction)
  return _impl_.decided_side_pass_direction_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PathDeciderStatus::_internal_mutable_decided_side_pass_direction() {
  return &_impl_.decided_side_pass_direction_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PathDeciderStatus::mutable_decided_side_pass_direction() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PathDeciderStatus.decided_side_pass_direction)
  return _internal_mutable_decided_side_pass_direction();
}

// -------------------------------------------------------------------

// PullOverStatus

// optional .apollo.planning.PullOverStatus.PullOverType pull_over_type = 1;
inline bool PullOverStatus::_internal_has_pull_over_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PullOverStatus::has_pull_over_type() const {
  return _internal_has_pull_over_type();
}
inline void PullOverStatus::clear_pull_over_type() {
  _impl_.pull_over_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::apollo::planning::PullOverStatus_PullOverType PullOverStatus::_internal_pull_over_type() const {
  return static_cast< ::apollo::planning::PullOverStatus_PullOverType >(_impl_.pull_over_type_);
}
inline ::apollo::planning::PullOverStatus_PullOverType PullOverStatus::pull_over_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.pull_over_type)
  return _internal_pull_over_type();
}
inline void PullOverStatus::_internal_set_pull_over_type(::apollo::planning::PullOverStatus_PullOverType value) {
  assert(::apollo::planning::PullOverStatus_PullOverType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.pull_over_type_ = value;
}
inline void PullOverStatus::set_pull_over_type(::apollo::planning::PullOverStatus_PullOverType value) {
  _internal_set_pull_over_type(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.pull_over_type)
}

// optional bool plan_pull_over_path = 2 [default = false];
inline bool PullOverStatus::_internal_has_plan_pull_over_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PullOverStatus::has_plan_pull_over_path() const {
  return _internal_has_plan_pull_over_path();
}
inline void PullOverStatus::clear_plan_pull_over_path() {
  _impl_.plan_pull_over_path_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool PullOverStatus::_internal_plan_pull_over_path() const {
  return _impl_.plan_pull_over_path_;
}
inline bool PullOverStatus::plan_pull_over_path() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.plan_pull_over_path)
  return _internal_plan_pull_over_path();
}
inline void PullOverStatus::_internal_set_plan_pull_over_path(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.plan_pull_over_path_ = value;
}
inline void PullOverStatus::set_plan_pull_over_path(bool value) {
  _internal_set_plan_pull_over_path(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.plan_pull_over_path)
}

// optional .apollo.common.PointENU position = 3;
inline bool PullOverStatus::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool PullOverStatus::has_position() const {
  return _internal_has_position();
}
inline const ::apollo::common::PointENU& PullOverStatus::_internal_position() const {
  const ::apollo::common::PointENU* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::PointENU&>(
      ::apollo::common::_PointENU_default_instance_);
}
inline const ::apollo::common::PointENU& PullOverStatus::position() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.position)
  return _internal_position();
}
inline void PullOverStatus::unsafe_arena_set_allocated_position(
    ::apollo::common::PointENU* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PullOverStatus.position)
}
inline ::apollo::common::PointENU* PullOverStatus::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::PointENU* PullOverStatus::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:apollo.planning.PullOverStatus.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::common::PointENU* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::apollo::common::PointENU* PullOverStatus::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::PointENU>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::apollo::common::PointENU* PullOverStatus::mutable_position() {
  ::apollo::common::PointENU* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PullOverStatus.position)
  return _msg;
}
inline void PullOverStatus::set_allocated_position(::apollo::common::PointENU* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PullOverStatus.position)
}

// optional double theta = 4;
inline bool PullOverStatus::_internal_has_theta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PullOverStatus::has_theta() const {
  return _internal_has_theta();
}
inline void PullOverStatus::clear_theta() {
  _impl_.theta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PullOverStatus::_internal_theta() const {
  return _impl_.theta_;
}
inline double PullOverStatus::theta() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.theta)
  return _internal_theta();
}
inline void PullOverStatus::_internal_set_theta(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.theta_ = value;
}
inline void PullOverStatus::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.theta)
}

// optional double length_front = 5;
inline bool PullOverStatus::_internal_has_length_front() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PullOverStatus::has_length_front() const {
  return _internal_has_length_front();
}
inline void PullOverStatus::clear_length_front() {
  _impl_.length_front_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double PullOverStatus::_internal_length_front() const {
  return _impl_.length_front_;
}
inline double PullOverStatus::length_front() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.length_front)
  return _internal_length_front();
}
inline void PullOverStatus::_internal_set_length_front(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.length_front_ = value;
}
inline void PullOverStatus::set_length_front(double value) {
  _internal_set_length_front(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.length_front)
}

// optional double length_back = 6;
inline bool PullOverStatus::_internal_has_length_back() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PullOverStatus::has_length_back() const {
  return _internal_has_length_back();
}
inline void PullOverStatus::clear_length_back() {
  _impl_.length_back_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double PullOverStatus::_internal_length_back() const {
  return _impl_.length_back_;
}
inline double PullOverStatus::length_back() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.length_back)
  return _internal_length_back();
}
inline void PullOverStatus::_internal_set_length_back(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.length_back_ = value;
}
inline void PullOverStatus::set_length_back(double value) {
  _internal_set_length_back(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.length_back)
}

// optional double width_left = 7;
inline bool PullOverStatus::_internal_has_width_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PullOverStatus::has_width_left() const {
  return _internal_has_width_left();
}
inline void PullOverStatus::clear_width_left() {
  _impl_.width_left_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double PullOverStatus::_internal_width_left() const {
  return _impl_.width_left_;
}
inline double PullOverStatus::width_left() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.width_left)
  return _internal_width_left();
}
inline void PullOverStatus::_internal_set_width_left(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.width_left_ = value;
}
inline void PullOverStatus::set_width_left(double value) {
  _internal_set_width_left(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.width_left)
}

// optional double width_right = 8;
inline bool PullOverStatus::_internal_has_width_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PullOverStatus::has_width_right() const {
  return _internal_has_width_right();
}
inline void PullOverStatus::clear_width_right() {
  _impl_.width_right_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double PullOverStatus::_internal_width_right() const {
  return _impl_.width_right_;
}
inline double PullOverStatus::width_right() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.width_right)
  return _internal_width_right();
}
inline void PullOverStatus::_internal_set_width_right(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.width_right_ = value;
}
inline void PullOverStatus::set_width_right(double value) {
  _internal_set_width_right(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.width_right)
}

// -------------------------------------------------------------------

// ReroutingStatus

// optional double last_rerouting_time = 1;
inline bool ReroutingStatus::_internal_has_last_rerouting_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReroutingStatus::has_last_rerouting_time() const {
  return _internal_has_last_rerouting_time();
}
inline void ReroutingStatus::clear_last_rerouting_time() {
  _impl_.last_rerouting_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ReroutingStatus::_internal_last_rerouting_time() const {
  return _impl_.last_rerouting_time_;
}
inline double ReroutingStatus::last_rerouting_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingStatus.last_rerouting_time)
  return _internal_last_rerouting_time();
}
inline void ReroutingStatus::_internal_set_last_rerouting_time(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.last_rerouting_time_ = value;
}
inline void ReroutingStatus::set_last_rerouting_time(double value) {
  _internal_set_last_rerouting_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingStatus.last_rerouting_time)
}

// optional bool need_rerouting = 2 [default = false];
inline bool ReroutingStatus::_internal_has_need_rerouting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReroutingStatus::has_need_rerouting() const {
  return _internal_has_need_rerouting();
}
inline void ReroutingStatus::clear_need_rerouting() {
  _impl_.need_rerouting_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ReroutingStatus::_internal_need_rerouting() const {
  return _impl_.need_rerouting_;
}
inline bool ReroutingStatus::need_rerouting() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingStatus.need_rerouting)
  return _internal_need_rerouting();
}
inline void ReroutingStatus::_internal_set_need_rerouting(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.need_rerouting_ = value;
}
inline void ReroutingStatus::set_need_rerouting(bool value) {
  _internal_set_need_rerouting(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingStatus.need_rerouting)
}

// optional .apollo.routing.RoutingRequest routing_request = 3;
inline bool ReroutingStatus::_internal_has_routing_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.routing_request_ != nullptr);
  return value;
}
inline bool ReroutingStatus::has_routing_request() const {
  return _internal_has_routing_request();
}
inline const ::apollo::routing::RoutingRequest& ReroutingStatus::_internal_routing_request() const {
  const ::apollo::routing::RoutingRequest* p = _impl_.routing_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::routing::RoutingRequest&>(
      ::apollo::routing::_RoutingRequest_default_instance_);
}
inline const ::apollo::routing::RoutingRequest& ReroutingStatus::routing_request() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingStatus.routing_request)
  return _internal_routing_request();
}
inline void ReroutingStatus::unsafe_arena_set_allocated_routing_request(
    ::apollo::routing::RoutingRequest* routing_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.routing_request_);
  }
  _impl_.routing_request_ = routing_request;
  if (routing_request) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.ReroutingStatus.routing_request)
}
inline ::apollo::routing::RoutingRequest* ReroutingStatus::release_routing_request() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::routing::RoutingRequest* temp = _impl_.routing_request_;
  _impl_.routing_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::routing::RoutingRequest* ReroutingStatus::unsafe_arena_release_routing_request() {
  // @@protoc_insertion_point(field_release:apollo.planning.ReroutingStatus.routing_request)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::routing::RoutingRequest* temp = _impl_.routing_request_;
  _impl_.routing_request_ = nullptr;
  return temp;
}
inline ::apollo::routing::RoutingRequest* ReroutingStatus::_internal_mutable_routing_request() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.routing_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::routing::RoutingRequest>(GetArenaForAllocation());
    _impl_.routing_request_ = p;
  }
  return _impl_.routing_request_;
}
inline ::apollo::routing::RoutingRequest* ReroutingStatus::mutable_routing_request() {
  ::apollo::routing::RoutingRequest* _msg = _internal_mutable_routing_request();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ReroutingStatus.routing_request)
  return _msg;
}
inline void ReroutingStatus::set_allocated_routing_request(::apollo::routing::RoutingRequest* routing_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.routing_request_);
  }
  if (routing_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing_request));
    if (message_arena != submessage_arena) {
      routing_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.routing_request_ = routing_request;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ReroutingStatus.routing_request)
}

// -------------------------------------------------------------------

// SpeedDeciderStatus

// repeated .apollo.planning.StopTime pedestrian_stop_time = 1;
inline int SpeedDeciderStatus::_internal_pedestrian_stop_time_size() const {
  return _impl_.pedestrian_stop_time_.size();
}
inline int SpeedDeciderStatus::pedestrian_stop_time_size() const {
  return _internal_pedestrian_stop_time_size();
}
inline void SpeedDeciderStatus::clear_pedestrian_stop_time() {
  _impl_.pedestrian_stop_time_.Clear();
}
inline ::apollo::planning::StopTime* SpeedDeciderStatus::mutable_pedestrian_stop_time(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.SpeedDeciderStatus.pedestrian_stop_time)
  return _impl_.pedestrian_stop_time_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >*
SpeedDeciderStatus::mutable_pedestrian_stop_time() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.SpeedDeciderStatus.pedestrian_stop_time)
  return &_impl_.pedestrian_stop_time_;
}
inline const ::apollo::planning::StopTime& SpeedDeciderStatus::_internal_pedestrian_stop_time(int index) const {
  return _impl_.pedestrian_stop_time_.Get(index);
}
inline const ::apollo::planning::StopTime& SpeedDeciderStatus::pedestrian_stop_time(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.SpeedDeciderStatus.pedestrian_stop_time)
  return _internal_pedestrian_stop_time(index);
}
inline ::apollo::planning::StopTime* SpeedDeciderStatus::_internal_add_pedestrian_stop_time() {
  return _impl_.pedestrian_stop_time_.Add();
}
inline ::apollo::planning::StopTime* SpeedDeciderStatus::add_pedestrian_stop_time() {
  ::apollo::planning::StopTime* _add = _internal_add_pedestrian_stop_time();
  // @@protoc_insertion_point(field_add:apollo.planning.SpeedDeciderStatus.pedestrian_stop_time)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::StopTime >&
SpeedDeciderStatus::pedestrian_stop_time() const {
  // @@protoc_insertion_point(field_list:apollo.planning.SpeedDeciderStatus.pedestrian_stop_time)
  return _impl_.pedestrian_stop_time_;
}

// -------------------------------------------------------------------

// ScenarioStatus

// optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
inline bool ScenarioStatus::_internal_has_scenario_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioStatus::has_scenario_type() const {
  return _internal_has_scenario_type();
}
inline void ScenarioStatus::clear_scenario_type() {
  _impl_.scenario_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::planning::ScenarioConfig_ScenarioType ScenarioStatus::_internal_scenario_type() const {
  return static_cast< ::apollo::planning::ScenarioConfig_ScenarioType >(_impl_.scenario_type_);
}
inline ::apollo::planning::ScenarioConfig_ScenarioType ScenarioStatus::scenario_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStatus.scenario_type)
  return _internal_scenario_type();
}
inline void ScenarioStatus::_internal_set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value) {
  assert(::apollo::planning::ScenarioConfig_ScenarioType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.scenario_type_ = value;
}
inline void ScenarioStatus::set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value) {
  _internal_set_scenario_type(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStatus.scenario_type)
}

// optional .apollo.planning.ScenarioConfig.StageType stage_type = 2;
inline bool ScenarioStatus::_internal_has_stage_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScenarioStatus::has_stage_type() const {
  return _internal_has_stage_type();
}
inline void ScenarioStatus::clear_stage_type() {
  _impl_.stage_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::planning::ScenarioConfig_StageType ScenarioStatus::_internal_stage_type() const {
  return static_cast< ::apollo::planning::ScenarioConfig_StageType >(_impl_.stage_type_);
}
inline ::apollo::planning::ScenarioConfig_StageType ScenarioStatus::stage_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStatus.stage_type)
  return _internal_stage_type();
}
inline void ScenarioStatus::_internal_set_stage_type(::apollo::planning::ScenarioConfig_StageType value) {
  assert(::apollo::planning::ScenarioConfig_StageType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stage_type_ = value;
}
inline void ScenarioStatus::set_stage_type(::apollo::planning::ScenarioConfig_StageType value) {
  _internal_set_stage_type(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStatus.stage_type)
}

// -------------------------------------------------------------------

// StopSignStatus

// optional string current_stop_sign_overlap_id = 1;
inline bool StopSignStatus::_internal_has_current_stop_sign_overlap_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopSignStatus::has_current_stop_sign_overlap_id() const {
  return _internal_has_current_stop_sign_overlap_id();
}
inline void StopSignStatus::clear_current_stop_sign_overlap_id() {
  _impl_.current_stop_sign_overlap_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopSignStatus::current_stop_sign_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
  return _internal_current_stop_sign_overlap_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopSignStatus::set_current_stop_sign_overlap_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.current_stop_sign_overlap_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
}
inline std::string* StopSignStatus::mutable_current_stop_sign_overlap_id() {
  std::string* _s = _internal_mutable_current_stop_sign_overlap_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
  return _s;
}
inline const std::string& StopSignStatus::_internal_current_stop_sign_overlap_id() const {
  return _impl_.current_stop_sign_overlap_id_.Get();
}
inline void StopSignStatus::_internal_set_current_stop_sign_overlap_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.current_stop_sign_overlap_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopSignStatus::_internal_mutable_current_stop_sign_overlap_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.current_stop_sign_overlap_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopSignStatus::release_current_stop_sign_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
  if (!_internal_has_current_stop_sign_overlap_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.current_stop_sign_overlap_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_stop_sign_overlap_id_.IsDefault()) {
    _impl_.current_stop_sign_overlap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StopSignStatus::set_allocated_current_stop_sign_overlap_id(std::string* current_stop_sign_overlap_id) {
  if (current_stop_sign_overlap_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.current_stop_sign_overlap_id_.SetAllocated(current_stop_sign_overlap_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_stop_sign_overlap_id_.IsDefault()) {
    _impl_.current_stop_sign_overlap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopSignStatus.current_stop_sign_overlap_id)
}

// optional string done_stop_sign_overlap_id = 2;
inline bool StopSignStatus::_internal_has_done_stop_sign_overlap_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopSignStatus::has_done_stop_sign_overlap_id() const {
  return _internal_has_done_stop_sign_overlap_id();
}
inline void StopSignStatus::clear_done_stop_sign_overlap_id() {
  _impl_.done_stop_sign_overlap_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StopSignStatus::done_stop_sign_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
  return _internal_done_stop_sign_overlap_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopSignStatus::set_done_stop_sign_overlap_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.done_stop_sign_overlap_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
}
inline std::string* StopSignStatus::mutable_done_stop_sign_overlap_id() {
  std::string* _s = _internal_mutable_done_stop_sign_overlap_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
  return _s;
}
inline const std::string& StopSignStatus::_internal_done_stop_sign_overlap_id() const {
  return _impl_.done_stop_sign_overlap_id_.Get();
}
inline void StopSignStatus::_internal_set_done_stop_sign_overlap_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.done_stop_sign_overlap_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopSignStatus::_internal_mutable_done_stop_sign_overlap_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.done_stop_sign_overlap_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopSignStatus::release_done_stop_sign_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
  if (!_internal_has_done_stop_sign_overlap_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.done_stop_sign_overlap_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.done_stop_sign_overlap_id_.IsDefault()) {
    _impl_.done_stop_sign_overlap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StopSignStatus::set_allocated_done_stop_sign_overlap_id(std::string* done_stop_sign_overlap_id) {
  if (done_stop_sign_overlap_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.done_stop_sign_overlap_id_.SetAllocated(done_stop_sign_overlap_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.done_stop_sign_overlap_id_.IsDefault()) {
    _impl_.done_stop_sign_overlap_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopSignStatus.done_stop_sign_overlap_id)
}

// repeated string wait_for_obstacle_id = 3;
inline int StopSignStatus::_internal_wait_for_obstacle_id_size() const {
  return _impl_.wait_for_obstacle_id_.size();
}
inline int StopSignStatus::wait_for_obstacle_id_size() const {
  return _internal_wait_for_obstacle_id_size();
}
inline void StopSignStatus::clear_wait_for_obstacle_id() {
  _impl_.wait_for_obstacle_id_.Clear();
}
inline std::string* StopSignStatus::add_wait_for_obstacle_id() {
  std::string* _s = _internal_add_wait_for_obstacle_id();
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  return _s;
}
inline const std::string& StopSignStatus::_internal_wait_for_obstacle_id(int index) const {
  return _impl_.wait_for_obstacle_id_.Get(index);
}
inline const std::string& StopSignStatus::wait_for_obstacle_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  return _internal_wait_for_obstacle_id(index);
}
inline std::string* StopSignStatus::mutable_wait_for_obstacle_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  return _impl_.wait_for_obstacle_id_.Mutable(index);
}
inline void StopSignStatus::set_wait_for_obstacle_id(int index, const std::string& value) {
  _impl_.wait_for_obstacle_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::set_wait_for_obstacle_id(int index, std::string&& value) {
  _impl_.wait_for_obstacle_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::set_wait_for_obstacle_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wait_for_obstacle_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::set_wait_for_obstacle_id(int index, const char* value, size_t size) {
  _impl_.wait_for_obstacle_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline std::string* StopSignStatus::_internal_add_wait_for_obstacle_id() {
  return _impl_.wait_for_obstacle_id_.Add();
}
inline void StopSignStatus::add_wait_for_obstacle_id(const std::string& value) {
  _impl_.wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::add_wait_for_obstacle_id(std::string&& value) {
  _impl_.wait_for_obstacle_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::add_wait_for_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::add_wait_for_obstacle_id(const char* value, size_t size) {
  _impl_.wait_for_obstacle_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.StopSignStatus.wait_for_obstacle_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StopSignStatus::wait_for_obstacle_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  return _impl_.wait_for_obstacle_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StopSignStatus::mutable_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.StopSignStatus.wait_for_obstacle_id)
  return &_impl_.wait_for_obstacle_id_;
}

// -------------------------------------------------------------------

// TrafficLightStatus

// repeated string current_traffic_light_overlap_id = 1;
inline int TrafficLightStatus::_internal_current_traffic_light_overlap_id_size() const {
  return _impl_.current_traffic_light_overlap_id_.size();
}
inline int TrafficLightStatus::current_traffic_light_overlap_id_size() const {
  return _internal_current_traffic_light_overlap_id_size();
}
inline void TrafficLightStatus::clear_current_traffic_light_overlap_id() {
  _impl_.current_traffic_light_overlap_id_.Clear();
}
inline std::string* TrafficLightStatus::add_current_traffic_light_overlap_id() {
  std::string* _s = _internal_add_current_traffic_light_overlap_id();
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return _s;
}
inline const std::string& TrafficLightStatus::_internal_current_traffic_light_overlap_id(int index) const {
  return _impl_.current_traffic_light_overlap_id_.Get(index);
}
inline const std::string& TrafficLightStatus::current_traffic_light_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return _internal_current_traffic_light_overlap_id(index);
}
inline std::string* TrafficLightStatus::mutable_current_traffic_light_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return _impl_.current_traffic_light_overlap_id_.Mutable(index);
}
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const std::string& value) {
  _impl_.current_traffic_light_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, std::string&& value) {
  _impl_.current_traffic_light_overlap_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.current_traffic_light_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const char* value, size_t size) {
  _impl_.current_traffic_light_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline std::string* TrafficLightStatus::_internal_add_current_traffic_light_overlap_id() {
  return _impl_.current_traffic_light_overlap_id_.Add();
}
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(const std::string& value) {
  _impl_.current_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(std::string&& value) {
  _impl_.current_traffic_light_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.current_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(const char* value, size_t size) {
  _impl_.current_traffic_light_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TrafficLightStatus::current_traffic_light_overlap_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return _impl_.current_traffic_light_overlap_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TrafficLightStatus::mutable_current_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return &_impl_.current_traffic_light_overlap_id_;
}

// repeated string done_traffic_light_overlap_id = 2;
inline int TrafficLightStatus::_internal_done_traffic_light_overlap_id_size() const {
  return _impl_.done_traffic_light_overlap_id_.size();
}
inline int TrafficLightStatus::done_traffic_light_overlap_id_size() const {
  return _internal_done_traffic_light_overlap_id_size();
}
inline void TrafficLightStatus::clear_done_traffic_light_overlap_id() {
  _impl_.done_traffic_light_overlap_id_.Clear();
}
inline std::string* TrafficLightStatus::add_done_traffic_light_overlap_id() {
  std::string* _s = _internal_add_done_traffic_light_overlap_id();
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return _s;
}
inline const std::string& TrafficLightStatus::_internal_done_traffic_light_overlap_id(int index) const {
  return _impl_.done_traffic_light_overlap_id_.Get(index);
}
inline const std::string& TrafficLightStatus::done_traffic_light_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return _internal_done_traffic_light_overlap_id(index);
}
inline std::string* TrafficLightStatus::mutable_done_traffic_light_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return _impl_.done_traffic_light_overlap_id_.Mutable(index);
}
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const std::string& value) {
  _impl_.done_traffic_light_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, std::string&& value) {
  _impl_.done_traffic_light_overlap_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.done_traffic_light_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const char* value, size_t size) {
  _impl_.done_traffic_light_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline std::string* TrafficLightStatus::_internal_add_done_traffic_light_overlap_id() {
  return _impl_.done_traffic_light_overlap_id_.Add();
}
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(const std::string& value) {
  _impl_.done_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(std::string&& value) {
  _impl_.done_traffic_light_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.done_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(const char* value, size_t size) {
  _impl_.done_traffic_light_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TrafficLightStatus::done_traffic_light_overlap_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return _impl_.done_traffic_light_overlap_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TrafficLightStatus::mutable_done_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return &_impl_.done_traffic_light_overlap_id_;
}

// -------------------------------------------------------------------

// YieldSignStatus

// repeated string current_yield_sign_overlap_id = 1;
inline int YieldSignStatus::_internal_current_yield_sign_overlap_id_size() const {
  return _impl_.current_yield_sign_overlap_id_.size();
}
inline int YieldSignStatus::current_yield_sign_overlap_id_size() const {
  return _internal_current_yield_sign_overlap_id_size();
}
inline void YieldSignStatus::clear_current_yield_sign_overlap_id() {
  _impl_.current_yield_sign_overlap_id_.Clear();
}
inline std::string* YieldSignStatus::add_current_yield_sign_overlap_id() {
  std::string* _s = _internal_add_current_yield_sign_overlap_id();
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return _s;
}
inline const std::string& YieldSignStatus::_internal_current_yield_sign_overlap_id(int index) const {
  return _impl_.current_yield_sign_overlap_id_.Get(index);
}
inline const std::string& YieldSignStatus::current_yield_sign_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return _internal_current_yield_sign_overlap_id(index);
}
inline std::string* YieldSignStatus::mutable_current_yield_sign_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return _impl_.current_yield_sign_overlap_id_.Mutable(index);
}
inline void YieldSignStatus::set_current_yield_sign_overlap_id(int index, const std::string& value) {
  _impl_.current_yield_sign_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline void YieldSignStatus::set_current_yield_sign_overlap_id(int index, std::string&& value) {
  _impl_.current_yield_sign_overlap_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline void YieldSignStatus::set_current_yield_sign_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.current_yield_sign_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline void YieldSignStatus::set_current_yield_sign_overlap_id(int index, const char* value, size_t size) {
  _impl_.current_yield_sign_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline std::string* YieldSignStatus::_internal_add_current_yield_sign_overlap_id() {
  return _impl_.current_yield_sign_overlap_id_.Add();
}
inline void YieldSignStatus::add_current_yield_sign_overlap_id(const std::string& value) {
  _impl_.current_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline void YieldSignStatus::add_current_yield_sign_overlap_id(std::string&& value) {
  _impl_.current_yield_sign_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline void YieldSignStatus::add_current_yield_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.current_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline void YieldSignStatus::add_current_yield_sign_overlap_id(const char* value, size_t size) {
  _impl_.current_yield_sign_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
YieldSignStatus::current_yield_sign_overlap_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return _impl_.current_yield_sign_overlap_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
YieldSignStatus::mutable_current_yield_sign_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return &_impl_.current_yield_sign_overlap_id_;
}

// repeated string done_yield_sign_overlap_id = 2;
inline int YieldSignStatus::_internal_done_yield_sign_overlap_id_size() const {
  return _impl_.done_yield_sign_overlap_id_.size();
}
inline int YieldSignStatus::done_yield_sign_overlap_id_size() const {
  return _internal_done_yield_sign_overlap_id_size();
}
inline void YieldSignStatus::clear_done_yield_sign_overlap_id() {
  _impl_.done_yield_sign_overlap_id_.Clear();
}
inline std::string* YieldSignStatus::add_done_yield_sign_overlap_id() {
  std::string* _s = _internal_add_done_yield_sign_overlap_id();
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return _s;
}
inline const std::string& YieldSignStatus::_internal_done_yield_sign_overlap_id(int index) const {
  return _impl_.done_yield_sign_overlap_id_.Get(index);
}
inline const std::string& YieldSignStatus::done_yield_sign_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return _internal_done_yield_sign_overlap_id(index);
}
inline std::string* YieldSignStatus::mutable_done_yield_sign_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return _impl_.done_yield_sign_overlap_id_.Mutable(index);
}
inline void YieldSignStatus::set_done_yield_sign_overlap_id(int index, const std::string& value) {
  _impl_.done_yield_sign_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline void YieldSignStatus::set_done_yield_sign_overlap_id(int index, std::string&& value) {
  _impl_.done_yield_sign_overlap_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline void YieldSignStatus::set_done_yield_sign_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.done_yield_sign_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline void YieldSignStatus::set_done_yield_sign_overlap_id(int index, const char* value, size_t size) {
  _impl_.done_yield_sign_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline std::string* YieldSignStatus::_internal_add_done_yield_sign_overlap_id() {
  return _impl_.done_yield_sign_overlap_id_.Add();
}
inline void YieldSignStatus::add_done_yield_sign_overlap_id(const std::string& value) {
  _impl_.done_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline void YieldSignStatus::add_done_yield_sign_overlap_id(std::string&& value) {
  _impl_.done_yield_sign_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline void YieldSignStatus::add_done_yield_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.done_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline void YieldSignStatus::add_done_yield_sign_overlap_id(const char* value, size_t size) {
  _impl_.done_yield_sign_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
YieldSignStatus::done_yield_sign_overlap_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return _impl_.done_yield_sign_overlap_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
YieldSignStatus::mutable_done_yield_sign_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return &_impl_.done_yield_sign_overlap_id_;
}

// repeated string wait_for_obstacle_id = 3;
inline int YieldSignStatus::_internal_wait_for_obstacle_id_size() const {
  return _impl_.wait_for_obstacle_id_.size();
}
inline int YieldSignStatus::wait_for_obstacle_id_size() const {
  return _internal_wait_for_obstacle_id_size();
}
inline void YieldSignStatus::clear_wait_for_obstacle_id() {
  _impl_.wait_for_obstacle_id_.Clear();
}
inline std::string* YieldSignStatus::add_wait_for_obstacle_id() {
  std::string* _s = _internal_add_wait_for_obstacle_id();
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
  return _s;
}
inline const std::string& YieldSignStatus::_internal_wait_for_obstacle_id(int index) const {
  return _impl_.wait_for_obstacle_id_.Get(index);
}
inline const std::string& YieldSignStatus::wait_for_obstacle_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
  return _internal_wait_for_obstacle_id(index);
}
inline std::string* YieldSignStatus::mutable_wait_for_obstacle_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
  return _impl_.wait_for_obstacle_id_.Mutable(index);
}
inline void YieldSignStatus::set_wait_for_obstacle_id(int index, const std::string& value) {
  _impl_.wait_for_obstacle_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline void YieldSignStatus::set_wait_for_obstacle_id(int index, std::string&& value) {
  _impl_.wait_for_obstacle_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline void YieldSignStatus::set_wait_for_obstacle_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wait_for_obstacle_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline void YieldSignStatus::set_wait_for_obstacle_id(int index, const char* value, size_t size) {
  _impl_.wait_for_obstacle_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline std::string* YieldSignStatus::_internal_add_wait_for_obstacle_id() {
  return _impl_.wait_for_obstacle_id_.Add();
}
inline void YieldSignStatus::add_wait_for_obstacle_id(const std::string& value) {
  _impl_.wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline void YieldSignStatus::add_wait_for_obstacle_id(std::string&& value) {
  _impl_.wait_for_obstacle_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline void YieldSignStatus::add_wait_for_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline void YieldSignStatus::add_wait_for_obstacle_id(const char* value, size_t size) {
  _impl_.wait_for_obstacle_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
YieldSignStatus::wait_for_obstacle_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
  return _impl_.wait_for_obstacle_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
YieldSignStatus::mutable_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.YieldSignStatus.wait_for_obstacle_id)
  return &_impl_.wait_for_obstacle_id_;
}

// -------------------------------------------------------------------

// PlanningStatus

// optional .apollo.planning.BareIntersectionStatus bare_intersection = 1;
inline bool PlanningStatus::_internal_has_bare_intersection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bare_intersection_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_bare_intersection() const {
  return _internal_has_bare_intersection();
}
inline void PlanningStatus::clear_bare_intersection() {
  if (_impl_.bare_intersection_ != nullptr) _impl_.bare_intersection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::BareIntersectionStatus& PlanningStatus::_internal_bare_intersection() const {
  const ::apollo::planning::BareIntersectionStatus* p = _impl_.bare_intersection_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::BareIntersectionStatus&>(
      ::apollo::planning::_BareIntersectionStatus_default_instance_);
}
inline const ::apollo::planning::BareIntersectionStatus& PlanningStatus::bare_intersection() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.bare_intersection)
  return _internal_bare_intersection();
}
inline void PlanningStatus::unsafe_arena_set_allocated_bare_intersection(
    ::apollo::planning::BareIntersectionStatus* bare_intersection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bare_intersection_);
  }
  _impl_.bare_intersection_ = bare_intersection;
  if (bare_intersection) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.bare_intersection)
}
inline ::apollo::planning::BareIntersectionStatus* PlanningStatus::release_bare_intersection() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::BareIntersectionStatus* temp = _impl_.bare_intersection_;
  _impl_.bare_intersection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::BareIntersectionStatus* PlanningStatus::unsafe_arena_release_bare_intersection() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.bare_intersection)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::BareIntersectionStatus* temp = _impl_.bare_intersection_;
  _impl_.bare_intersection_ = nullptr;
  return temp;
}
inline ::apollo::planning::BareIntersectionStatus* PlanningStatus::_internal_mutable_bare_intersection() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.bare_intersection_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::BareIntersectionStatus>(GetArenaForAllocation());
    _impl_.bare_intersection_ = p;
  }
  return _impl_.bare_intersection_;
}
inline ::apollo::planning::BareIntersectionStatus* PlanningStatus::mutable_bare_intersection() {
  ::apollo::planning::BareIntersectionStatus* _msg = _internal_mutable_bare_intersection();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.bare_intersection)
  return _msg;
}
inline void PlanningStatus::set_allocated_bare_intersection(::apollo::planning::BareIntersectionStatus* bare_intersection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bare_intersection_;
  }
  if (bare_intersection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bare_intersection);
    if (message_arena != submessage_arena) {
      bare_intersection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bare_intersection, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.bare_intersection_ = bare_intersection;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.bare_intersection)
}

// optional .apollo.planning.ChangeLaneStatus change_lane = 2;
inline bool PlanningStatus::_internal_has_change_lane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.change_lane_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_change_lane() const {
  return _internal_has_change_lane();
}
inline void PlanningStatus::clear_change_lane() {
  if (_impl_.change_lane_ != nullptr) _impl_.change_lane_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::planning::ChangeLaneStatus& PlanningStatus::_internal_change_lane() const {
  const ::apollo::planning::ChangeLaneStatus* p = _impl_.change_lane_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::ChangeLaneStatus&>(
      ::apollo::planning::_ChangeLaneStatus_default_instance_);
}
inline const ::apollo::planning::ChangeLaneStatus& PlanningStatus::change_lane() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.change_lane)
  return _internal_change_lane();
}
inline void PlanningStatus::unsafe_arena_set_allocated_change_lane(
    ::apollo::planning::ChangeLaneStatus* change_lane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.change_lane_);
  }
  _impl_.change_lane_ = change_lane;
  if (change_lane) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.change_lane)
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::release_change_lane() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::ChangeLaneStatus* temp = _impl_.change_lane_;
  _impl_.change_lane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::unsafe_arena_release_change_lane() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.change_lane)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::planning::ChangeLaneStatus* temp = _impl_.change_lane_;
  _impl_.change_lane_ = nullptr;
  return temp;
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::_internal_mutable_change_lane() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.change_lane_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ChangeLaneStatus>(GetArenaForAllocation());
    _impl_.change_lane_ = p;
  }
  return _impl_.change_lane_;
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::mutable_change_lane() {
  ::apollo::planning::ChangeLaneStatus* _msg = _internal_mutable_change_lane();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.change_lane)
  return _msg;
}
inline void PlanningStatus::set_allocated_change_lane(::apollo::planning::ChangeLaneStatus* change_lane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.change_lane_;
  }
  if (change_lane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(change_lane);
    if (message_arena != submessage_arena) {
      change_lane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_lane, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.change_lane_ = change_lane;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.change_lane)
}

// optional .apollo.planning.CreepDeciderStatus creep_decider = 3;
inline bool PlanningStatus::_internal_has_creep_decider() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creep_decider_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_creep_decider() const {
  return _internal_has_creep_decider();
}
inline void PlanningStatus::clear_creep_decider() {
  if (_impl_.creep_decider_ != nullptr) _impl_.creep_decider_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::planning::CreepDeciderStatus& PlanningStatus::_internal_creep_decider() const {
  const ::apollo::planning::CreepDeciderStatus* p = _impl_.creep_decider_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::CreepDeciderStatus&>(
      ::apollo::planning::_CreepDeciderStatus_default_instance_);
}
inline const ::apollo::planning::CreepDeciderStatus& PlanningStatus::creep_decider() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.creep_decider)
  return _internal_creep_decider();
}
inline void PlanningStatus::unsafe_arena_set_allocated_creep_decider(
    ::apollo::planning::CreepDeciderStatus* creep_decider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creep_decider_);
  }
  _impl_.creep_decider_ = creep_decider;
  if (creep_decider) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.creep_decider)
}
inline ::apollo::planning::CreepDeciderStatus* PlanningStatus::release_creep_decider() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::planning::CreepDeciderStatus* temp = _impl_.creep_decider_;
  _impl_.creep_decider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::CreepDeciderStatus* PlanningStatus::unsafe_arena_release_creep_decider() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.creep_decider)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::planning::CreepDeciderStatus* temp = _impl_.creep_decider_;
  _impl_.creep_decider_ = nullptr;
  return temp;
}
inline ::apollo::planning::CreepDeciderStatus* PlanningStatus::_internal_mutable_creep_decider() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.creep_decider_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::CreepDeciderStatus>(GetArenaForAllocation());
    _impl_.creep_decider_ = p;
  }
  return _impl_.creep_decider_;
}
inline ::apollo::planning::CreepDeciderStatus* PlanningStatus::mutable_creep_decider() {
  ::apollo::planning::CreepDeciderStatus* _msg = _internal_mutable_creep_decider();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.creep_decider)
  return _msg;
}
inline void PlanningStatus::set_allocated_creep_decider(::apollo::planning::CreepDeciderStatus* creep_decider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.creep_decider_;
  }
  if (creep_decider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(creep_decider);
    if (message_arena != submessage_arena) {
      creep_decider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creep_decider, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.creep_decider_ = creep_decider;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.creep_decider)
}

// optional .apollo.planning.CrosswalkStatus crosswalk = 4;
inline bool PlanningStatus::_internal_has_crosswalk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.crosswalk_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_crosswalk() const {
  return _internal_has_crosswalk();
}
inline void PlanningStatus::clear_crosswalk() {
  if (_impl_.crosswalk_ != nullptr) _impl_.crosswalk_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::planning::CrosswalkStatus& PlanningStatus::_internal_crosswalk() const {
  const ::apollo::planning::CrosswalkStatus* p = _impl_.crosswalk_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::CrosswalkStatus&>(
      ::apollo::planning::_CrosswalkStatus_default_instance_);
}
inline const ::apollo::planning::CrosswalkStatus& PlanningStatus::crosswalk() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.crosswalk)
  return _internal_crosswalk();
}
inline void PlanningStatus::unsafe_arena_set_allocated_crosswalk(
    ::apollo::planning::CrosswalkStatus* crosswalk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.crosswalk_);
  }
  _impl_.crosswalk_ = crosswalk;
  if (crosswalk) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.crosswalk)
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::release_crosswalk() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::planning::CrosswalkStatus* temp = _impl_.crosswalk_;
  _impl_.crosswalk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::unsafe_arena_release_crosswalk() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.crosswalk)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::planning::CrosswalkStatus* temp = _impl_.crosswalk_;
  _impl_.crosswalk_ = nullptr;
  return temp;
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::_internal_mutable_crosswalk() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.crosswalk_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::CrosswalkStatus>(GetArenaForAllocation());
    _impl_.crosswalk_ = p;
  }
  return _impl_.crosswalk_;
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::mutable_crosswalk() {
  ::apollo::planning::CrosswalkStatus* _msg = _internal_mutable_crosswalk();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.crosswalk)
  return _msg;
}
inline void PlanningStatus::set_allocated_crosswalk(::apollo::planning::CrosswalkStatus* crosswalk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.crosswalk_;
  }
  if (crosswalk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(crosswalk);
    if (message_arena != submessage_arena) {
      crosswalk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crosswalk, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.crosswalk_ = crosswalk;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.crosswalk)
}

// optional .apollo.planning.DestinationStatus destination = 5;
inline bool PlanningStatus::_internal_has_destination() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.destination_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_destination() const {
  return _internal_has_destination();
}
inline void PlanningStatus::clear_destination() {
  if (_impl_.destination_ != nullptr) _impl_.destination_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::planning::DestinationStatus& PlanningStatus::_internal_destination() const {
  const ::apollo::planning::DestinationStatus* p = _impl_.destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::DestinationStatus&>(
      ::apollo::planning::_DestinationStatus_default_instance_);
}
inline const ::apollo::planning::DestinationStatus& PlanningStatus::destination() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.destination)
  return _internal_destination();
}
inline void PlanningStatus::unsafe_arena_set_allocated_destination(
    ::apollo::planning::DestinationStatus* destination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destination_);
  }
  _impl_.destination_ = destination;
  if (destination) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.destination)
}
inline ::apollo::planning::DestinationStatus* PlanningStatus::release_destination() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::planning::DestinationStatus* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::DestinationStatus* PlanningStatus::unsafe_arena_release_destination() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.destination)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::planning::DestinationStatus* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
  return temp;
}
inline ::apollo::planning::DestinationStatus* PlanningStatus::_internal_mutable_destination() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::DestinationStatus>(GetArenaForAllocation());
    _impl_.destination_ = p;
  }
  return _impl_.destination_;
}
inline ::apollo::planning::DestinationStatus* PlanningStatus::mutable_destination() {
  ::apollo::planning::DestinationStatus* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.destination)
  return _msg;
}
inline void PlanningStatus::set_allocated_destination(::apollo::planning::DestinationStatus* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.destination_;
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(destination);
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.destination)
}

// optional .apollo.planning.EmergencyStopStatus emergency_stop = 6;
inline bool PlanningStatus::_internal_has_emergency_stop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.emergency_stop_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_emergency_stop() const {
  return _internal_has_emergency_stop();
}
inline void PlanningStatus::clear_emergency_stop() {
  if (_impl_.emergency_stop_ != nullptr) _impl_.emergency_stop_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::apollo::planning::EmergencyStopStatus& PlanningStatus::_internal_emergency_stop() const {
  const ::apollo::planning::EmergencyStopStatus* p = _impl_.emergency_stop_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::EmergencyStopStatus&>(
      ::apollo::planning::_EmergencyStopStatus_default_instance_);
}
inline const ::apollo::planning::EmergencyStopStatus& PlanningStatus::emergency_stop() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.emergency_stop)
  return _internal_emergency_stop();
}
inline void PlanningStatus::unsafe_arena_set_allocated_emergency_stop(
    ::apollo::planning::EmergencyStopStatus* emergency_stop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.emergency_stop_);
  }
  _impl_.emergency_stop_ = emergency_stop;
  if (emergency_stop) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.emergency_stop)
}
inline ::apollo::planning::EmergencyStopStatus* PlanningStatus::release_emergency_stop() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::apollo::planning::EmergencyStopStatus* temp = _impl_.emergency_stop_;
  _impl_.emergency_stop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::EmergencyStopStatus* PlanningStatus::unsafe_arena_release_emergency_stop() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.emergency_stop)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::apollo::planning::EmergencyStopStatus* temp = _impl_.emergency_stop_;
  _impl_.emergency_stop_ = nullptr;
  return temp;
}
inline ::apollo::planning::EmergencyStopStatus* PlanningStatus::_internal_mutable_emergency_stop() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.emergency_stop_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::EmergencyStopStatus>(GetArenaForAllocation());
    _impl_.emergency_stop_ = p;
  }
  return _impl_.emergency_stop_;
}
inline ::apollo::planning::EmergencyStopStatus* PlanningStatus::mutable_emergency_stop() {
  ::apollo::planning::EmergencyStopStatus* _msg = _internal_mutable_emergency_stop();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.emergency_stop)
  return _msg;
}
inline void PlanningStatus::set_allocated_emergency_stop(::apollo::planning::EmergencyStopStatus* emergency_stop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.emergency_stop_;
  }
  if (emergency_stop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(emergency_stop);
    if (message_arena != submessage_arena) {
      emergency_stop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, emergency_stop, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.emergency_stop_ = emergency_stop;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.emergency_stop)
}

// optional .apollo.planning.OpenSpaceStatus open_space = 7;
inline bool PlanningStatus::_internal_has_open_space() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.open_space_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_open_space() const {
  return _internal_has_open_space();
}
inline void PlanningStatus::clear_open_space() {
  if (_impl_.open_space_ != nullptr) _impl_.open_space_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::apollo::planning::OpenSpaceStatus& PlanningStatus::_internal_open_space() const {
  const ::apollo::planning::OpenSpaceStatus* p = _impl_.open_space_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::OpenSpaceStatus&>(
      ::apollo::planning::_OpenSpaceStatus_default_instance_);
}
inline const ::apollo::planning::OpenSpaceStatus& PlanningStatus::open_space() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.open_space)
  return _internal_open_space();
}
inline void PlanningStatus::unsafe_arena_set_allocated_open_space(
    ::apollo::planning::OpenSpaceStatus* open_space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.open_space_);
  }
  _impl_.open_space_ = open_space;
  if (open_space) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.open_space)
}
inline ::apollo::planning::OpenSpaceStatus* PlanningStatus::release_open_space() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::apollo::planning::OpenSpaceStatus* temp = _impl_.open_space_;
  _impl_.open_space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::OpenSpaceStatus* PlanningStatus::unsafe_arena_release_open_space() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.open_space)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::apollo::planning::OpenSpaceStatus* temp = _impl_.open_space_;
  _impl_.open_space_ = nullptr;
  return temp;
}
inline ::apollo::planning::OpenSpaceStatus* PlanningStatus::_internal_mutable_open_space() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.open_space_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::OpenSpaceStatus>(GetArenaForAllocation());
    _impl_.open_space_ = p;
  }
  return _impl_.open_space_;
}
inline ::apollo::planning::OpenSpaceStatus* PlanningStatus::mutable_open_space() {
  ::apollo::planning::OpenSpaceStatus* _msg = _internal_mutable_open_space();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.open_space)
  return _msg;
}
inline void PlanningStatus::set_allocated_open_space(::apollo::planning::OpenSpaceStatus* open_space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.open_space_;
  }
  if (open_space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(open_space);
    if (message_arena != submessage_arena) {
      open_space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, open_space, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.open_space_ = open_space;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.open_space)
}

// optional .apollo.planning.ParkAndGoStatus park_and_go = 8;
inline bool PlanningStatus::_internal_has_park_and_go() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.park_and_go_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_park_and_go() const {
  return _internal_has_park_and_go();
}
inline void PlanningStatus::clear_park_and_go() {
  if (_impl_.park_and_go_ != nullptr) _impl_.park_and_go_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::apollo::planning::ParkAndGoStatus& PlanningStatus::_internal_park_and_go() const {
  const ::apollo::planning::ParkAndGoStatus* p = _impl_.park_and_go_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::ParkAndGoStatus&>(
      ::apollo::planning::_ParkAndGoStatus_default_instance_);
}
inline const ::apollo::planning::ParkAndGoStatus& PlanningStatus::park_and_go() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.park_and_go)
  return _internal_park_and_go();
}
inline void PlanningStatus::unsafe_arena_set_allocated_park_and_go(
    ::apollo::planning::ParkAndGoStatus* park_and_go) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.park_and_go_);
  }
  _impl_.park_and_go_ = park_and_go;
  if (park_and_go) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.park_and_go)
}
inline ::apollo::planning::ParkAndGoStatus* PlanningStatus::release_park_and_go() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::apollo::planning::ParkAndGoStatus* temp = _impl_.park_and_go_;
  _impl_.park_and_go_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::ParkAndGoStatus* PlanningStatus::unsafe_arena_release_park_and_go() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.park_and_go)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::apollo::planning::ParkAndGoStatus* temp = _impl_.park_and_go_;
  _impl_.park_and_go_ = nullptr;
  return temp;
}
inline ::apollo::planning::ParkAndGoStatus* PlanningStatus::_internal_mutable_park_and_go() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.park_and_go_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ParkAndGoStatus>(GetArenaForAllocation());
    _impl_.park_and_go_ = p;
  }
  return _impl_.park_and_go_;
}
inline ::apollo::planning::ParkAndGoStatus* PlanningStatus::mutable_park_and_go() {
  ::apollo::planning::ParkAndGoStatus* _msg = _internal_mutable_park_and_go();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.park_and_go)
  return _msg;
}
inline void PlanningStatus::set_allocated_park_and_go(::apollo::planning::ParkAndGoStatus* park_and_go) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.park_and_go_;
  }
  if (park_and_go) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(park_and_go);
    if (message_arena != submessage_arena) {
      park_and_go = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, park_and_go, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.park_and_go_ = park_and_go;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.park_and_go)
}

// optional .apollo.planning.PathDeciderStatus path_decider = 9;
inline bool PlanningStatus::_internal_has_path_decider() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.path_decider_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_path_decider() const {
  return _internal_has_path_decider();
}
inline void PlanningStatus::clear_path_decider() {
  if (_impl_.path_decider_ != nullptr) _impl_.path_decider_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::apollo::planning::PathDeciderStatus& PlanningStatus::_internal_path_decider() const {
  const ::apollo::planning::PathDeciderStatus* p = _impl_.path_decider_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::PathDeciderStatus&>(
      ::apollo::planning::_PathDeciderStatus_default_instance_);
}
inline const ::apollo::planning::PathDeciderStatus& PlanningStatus::path_decider() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.path_decider)
  return _internal_path_decider();
}
inline void PlanningStatus::unsafe_arena_set_allocated_path_decider(
    ::apollo::planning::PathDeciderStatus* path_decider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_decider_);
  }
  _impl_.path_decider_ = path_decider;
  if (path_decider) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.path_decider)
}
inline ::apollo::planning::PathDeciderStatus* PlanningStatus::release_path_decider() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::apollo::planning::PathDeciderStatus* temp = _impl_.path_decider_;
  _impl_.path_decider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::PathDeciderStatus* PlanningStatus::unsafe_arena_release_path_decider() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.path_decider)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::apollo::planning::PathDeciderStatus* temp = _impl_.path_decider_;
  _impl_.path_decider_ = nullptr;
  return temp;
}
inline ::apollo::planning::PathDeciderStatus* PlanningStatus::_internal_mutable_path_decider() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.path_decider_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::PathDeciderStatus>(GetArenaForAllocation());
    _impl_.path_decider_ = p;
  }
  return _impl_.path_decider_;
}
inline ::apollo::planning::PathDeciderStatus* PlanningStatus::mutable_path_decider() {
  ::apollo::planning::PathDeciderStatus* _msg = _internal_mutable_path_decider();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.path_decider)
  return _msg;
}
inline void PlanningStatus::set_allocated_path_decider(::apollo::planning::PathDeciderStatus* path_decider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.path_decider_;
  }
  if (path_decider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(path_decider);
    if (message_arena != submessage_arena) {
      path_decider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path_decider, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.path_decider_ = path_decider;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.path_decider)
}

// optional .apollo.planning.PullOverStatus pull_over = 10;
inline bool PlanningStatus::_internal_has_pull_over() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pull_over_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_pull_over() const {
  return _internal_has_pull_over();
}
inline void PlanningStatus::clear_pull_over() {
  if (_impl_.pull_over_ != nullptr) _impl_.pull_over_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::apollo::planning::PullOverStatus& PlanningStatus::_internal_pull_over() const {
  const ::apollo::planning::PullOverStatus* p = _impl_.pull_over_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::PullOverStatus&>(
      ::apollo::planning::_PullOverStatus_default_instance_);
}
inline const ::apollo::planning::PullOverStatus& PlanningStatus::pull_over() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.pull_over)
  return _internal_pull_over();
}
inline void PlanningStatus::unsafe_arena_set_allocated_pull_over(
    ::apollo::planning::PullOverStatus* pull_over) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pull_over_);
  }
  _impl_.pull_over_ = pull_over;
  if (pull_over) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.pull_over)
}
inline ::apollo::planning::PullOverStatus* PlanningStatus::release_pull_over() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::apollo::planning::PullOverStatus* temp = _impl_.pull_over_;
  _impl_.pull_over_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::PullOverStatus* PlanningStatus::unsafe_arena_release_pull_over() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.pull_over)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::apollo::planning::PullOverStatus* temp = _impl_.pull_over_;
  _impl_.pull_over_ = nullptr;
  return temp;
}
inline ::apollo::planning::PullOverStatus* PlanningStatus::_internal_mutable_pull_over() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.pull_over_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::PullOverStatus>(GetArenaForAllocation());
    _impl_.pull_over_ = p;
  }
  return _impl_.pull_over_;
}
inline ::apollo::planning::PullOverStatus* PlanningStatus::mutable_pull_over() {
  ::apollo::planning::PullOverStatus* _msg = _internal_mutable_pull_over();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.pull_over)
  return _msg;
}
inline void PlanningStatus::set_allocated_pull_over(::apollo::planning::PullOverStatus* pull_over) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pull_over_;
  }
  if (pull_over) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pull_over);
    if (message_arena != submessage_arena) {
      pull_over = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pull_over, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.pull_over_ = pull_over;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.pull_over)
}

// optional .apollo.planning.ReroutingStatus rerouting = 11;
inline bool PlanningStatus::_internal_has_rerouting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rerouting_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_rerouting() const {
  return _internal_has_rerouting();
}
inline void PlanningStatus::clear_rerouting() {
  if (_impl_.rerouting_ != nullptr) _impl_.rerouting_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::apollo::planning::ReroutingStatus& PlanningStatus::_internal_rerouting() const {
  const ::apollo::planning::ReroutingStatus* p = _impl_.rerouting_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::ReroutingStatus&>(
      ::apollo::planning::_ReroutingStatus_default_instance_);
}
inline const ::apollo::planning::ReroutingStatus& PlanningStatus::rerouting() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.rerouting)
  return _internal_rerouting();
}
inline void PlanningStatus::unsafe_arena_set_allocated_rerouting(
    ::apollo::planning::ReroutingStatus* rerouting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rerouting_);
  }
  _impl_.rerouting_ = rerouting;
  if (rerouting) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.rerouting)
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::release_rerouting() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::apollo::planning::ReroutingStatus* temp = _impl_.rerouting_;
  _impl_.rerouting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::unsafe_arena_release_rerouting() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.rerouting)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::apollo::planning::ReroutingStatus* temp = _impl_.rerouting_;
  _impl_.rerouting_ = nullptr;
  return temp;
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::_internal_mutable_rerouting() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.rerouting_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ReroutingStatus>(GetArenaForAllocation());
    _impl_.rerouting_ = p;
  }
  return _impl_.rerouting_;
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::mutable_rerouting() {
  ::apollo::planning::ReroutingStatus* _msg = _internal_mutable_rerouting();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.rerouting)
  return _msg;
}
inline void PlanningStatus::set_allocated_rerouting(::apollo::planning::ReroutingStatus* rerouting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rerouting_;
  }
  if (rerouting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rerouting);
    if (message_arena != submessage_arena) {
      rerouting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rerouting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.rerouting_ = rerouting;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.rerouting)
}

// optional .apollo.planning.ScenarioStatus scenario = 12;
inline bool PlanningStatus::_internal_has_scenario() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scenario_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_scenario() const {
  return _internal_has_scenario();
}
inline void PlanningStatus::clear_scenario() {
  if (_impl_.scenario_ != nullptr) _impl_.scenario_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::apollo::planning::ScenarioStatus& PlanningStatus::_internal_scenario() const {
  const ::apollo::planning::ScenarioStatus* p = _impl_.scenario_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::ScenarioStatus&>(
      ::apollo::planning::_ScenarioStatus_default_instance_);
}
inline const ::apollo::planning::ScenarioStatus& PlanningStatus::scenario() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.scenario)
  return _internal_scenario();
}
inline void PlanningStatus::unsafe_arena_set_allocated_scenario(
    ::apollo::planning::ScenarioStatus* scenario) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scenario_);
  }
  _impl_.scenario_ = scenario;
  if (scenario) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.scenario)
}
inline ::apollo::planning::ScenarioStatus* PlanningStatus::release_scenario() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::apollo::planning::ScenarioStatus* temp = _impl_.scenario_;
  _impl_.scenario_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::ScenarioStatus* PlanningStatus::unsafe_arena_release_scenario() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.scenario)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::apollo::planning::ScenarioStatus* temp = _impl_.scenario_;
  _impl_.scenario_ = nullptr;
  return temp;
}
inline ::apollo::planning::ScenarioStatus* PlanningStatus::_internal_mutable_scenario() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.scenario_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::ScenarioStatus>(GetArenaForAllocation());
    _impl_.scenario_ = p;
  }
  return _impl_.scenario_;
}
inline ::apollo::planning::ScenarioStatus* PlanningStatus::mutable_scenario() {
  ::apollo::planning::ScenarioStatus* _msg = _internal_mutable_scenario();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.scenario)
  return _msg;
}
inline void PlanningStatus::set_allocated_scenario(::apollo::planning::ScenarioStatus* scenario) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scenario_;
  }
  if (scenario) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scenario);
    if (message_arena != submessage_arena) {
      scenario = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scenario, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.scenario_ = scenario;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.scenario)
}

// optional .apollo.planning.SpeedDeciderStatus speed_decider = 13;
inline bool PlanningStatus::_internal_has_speed_decider() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_decider_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_speed_decider() const {
  return _internal_has_speed_decider();
}
inline void PlanningStatus::clear_speed_decider() {
  if (_impl_.speed_decider_ != nullptr) _impl_.speed_decider_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::apollo::planning::SpeedDeciderStatus& PlanningStatus::_internal_speed_decider() const {
  const ::apollo::planning::SpeedDeciderStatus* p = _impl_.speed_decider_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::SpeedDeciderStatus&>(
      ::apollo::planning::_SpeedDeciderStatus_default_instance_);
}
inline const ::apollo::planning::SpeedDeciderStatus& PlanningStatus::speed_decider() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.speed_decider)
  return _internal_speed_decider();
}
inline void PlanningStatus::unsafe_arena_set_allocated_speed_decider(
    ::apollo::planning::SpeedDeciderStatus* speed_decider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.speed_decider_);
  }
  _impl_.speed_decider_ = speed_decider;
  if (speed_decider) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.speed_decider)
}
inline ::apollo::planning::SpeedDeciderStatus* PlanningStatus::release_speed_decider() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::apollo::planning::SpeedDeciderStatus* temp = _impl_.speed_decider_;
  _impl_.speed_decider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::SpeedDeciderStatus* PlanningStatus::unsafe_arena_release_speed_decider() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.speed_decider)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::apollo::planning::SpeedDeciderStatus* temp = _impl_.speed_decider_;
  _impl_.speed_decider_ = nullptr;
  return temp;
}
inline ::apollo::planning::SpeedDeciderStatus* PlanningStatus::_internal_mutable_speed_decider() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.speed_decider_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::SpeedDeciderStatus>(GetArenaForAllocation());
    _impl_.speed_decider_ = p;
  }
  return _impl_.speed_decider_;
}
inline ::apollo::planning::SpeedDeciderStatus* PlanningStatus::mutable_speed_decider() {
  ::apollo::planning::SpeedDeciderStatus* _msg = _internal_mutable_speed_decider();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.speed_decider)
  return _msg;
}
inline void PlanningStatus::set_allocated_speed_decider(::apollo::planning::SpeedDeciderStatus* speed_decider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.speed_decider_;
  }
  if (speed_decider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(speed_decider);
    if (message_arena != submessage_arena) {
      speed_decider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed_decider, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.speed_decider_ = speed_decider;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.speed_decider)
}

// optional .apollo.planning.StopSignStatus stop_sign = 14;
inline bool PlanningStatus::_internal_has_stop_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_sign_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_stop_sign() const {
  return _internal_has_stop_sign();
}
inline void PlanningStatus::clear_stop_sign() {
  if (_impl_.stop_sign_ != nullptr) _impl_.stop_sign_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::apollo::planning::StopSignStatus& PlanningStatus::_internal_stop_sign() const {
  const ::apollo::planning::StopSignStatus* p = _impl_.stop_sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::StopSignStatus&>(
      ::apollo::planning::_StopSignStatus_default_instance_);
}
inline const ::apollo::planning::StopSignStatus& PlanningStatus::stop_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.stop_sign)
  return _internal_stop_sign();
}
inline void PlanningStatus::unsafe_arena_set_allocated_stop_sign(
    ::apollo::planning::StopSignStatus* stop_sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stop_sign_);
  }
  _impl_.stop_sign_ = stop_sign;
  if (stop_sign) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.stop_sign)
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::release_stop_sign() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::apollo::planning::StopSignStatus* temp = _impl_.stop_sign_;
  _impl_.stop_sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::unsafe_arena_release_stop_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.stop_sign)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::apollo::planning::StopSignStatus* temp = _impl_.stop_sign_;
  _impl_.stop_sign_ = nullptr;
  return temp;
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::_internal_mutable_stop_sign() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.stop_sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::StopSignStatus>(GetArenaForAllocation());
    _impl_.stop_sign_ = p;
  }
  return _impl_.stop_sign_;
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::mutable_stop_sign() {
  ::apollo::planning::StopSignStatus* _msg = _internal_mutable_stop_sign();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.stop_sign)
  return _msg;
}
inline void PlanningStatus::set_allocated_stop_sign(::apollo::planning::StopSignStatus* stop_sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stop_sign_;
  }
  if (stop_sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stop_sign);
    if (message_arena != submessage_arena) {
      stop_sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_sign, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.stop_sign_ = stop_sign;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.stop_sign)
}

// optional .apollo.planning.TrafficLightStatus traffic_light = 15;
inline bool PlanningStatus::_internal_has_traffic_light() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.traffic_light_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_traffic_light() const {
  return _internal_has_traffic_light();
}
inline void PlanningStatus::clear_traffic_light() {
  if (_impl_.traffic_light_ != nullptr) _impl_.traffic_light_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::apollo::planning::TrafficLightStatus& PlanningStatus::_internal_traffic_light() const {
  const ::apollo::planning::TrafficLightStatus* p = _impl_.traffic_light_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::TrafficLightStatus&>(
      ::apollo::planning::_TrafficLightStatus_default_instance_);
}
inline const ::apollo::planning::TrafficLightStatus& PlanningStatus::traffic_light() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.traffic_light)
  return _internal_traffic_light();
}
inline void PlanningStatus::unsafe_arena_set_allocated_traffic_light(
    ::apollo::planning::TrafficLightStatus* traffic_light) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.traffic_light_);
  }
  _impl_.traffic_light_ = traffic_light;
  if (traffic_light) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.traffic_light)
}
inline ::apollo::planning::TrafficLightStatus* PlanningStatus::release_traffic_light() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::apollo::planning::TrafficLightStatus* temp = _impl_.traffic_light_;
  _impl_.traffic_light_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::TrafficLightStatus* PlanningStatus::unsafe_arena_release_traffic_light() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.traffic_light)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::apollo::planning::TrafficLightStatus* temp = _impl_.traffic_light_;
  _impl_.traffic_light_ = nullptr;
  return temp;
}
inline ::apollo::planning::TrafficLightStatus* PlanningStatus::_internal_mutable_traffic_light() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.traffic_light_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::TrafficLightStatus>(GetArenaForAllocation());
    _impl_.traffic_light_ = p;
  }
  return _impl_.traffic_light_;
}
inline ::apollo::planning::TrafficLightStatus* PlanningStatus::mutable_traffic_light() {
  ::apollo::planning::TrafficLightStatus* _msg = _internal_mutable_traffic_light();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.traffic_light)
  return _msg;
}
inline void PlanningStatus::set_allocated_traffic_light(::apollo::planning::TrafficLightStatus* traffic_light) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.traffic_light_;
  }
  if (traffic_light) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(traffic_light);
    if (message_arena != submessage_arena) {
      traffic_light = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traffic_light, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.traffic_light_ = traffic_light;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.traffic_light)
}

// optional .apollo.planning.YieldSignStatus yield_sign = 16;
inline bool PlanningStatus::_internal_has_yield_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.yield_sign_ != nullptr);
  return value;
}
inline bool PlanningStatus::has_yield_sign() const {
  return _internal_has_yield_sign();
}
inline void PlanningStatus::clear_yield_sign() {
  if (_impl_.yield_sign_ != nullptr) _impl_.yield_sign_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::apollo::planning::YieldSignStatus& PlanningStatus::_internal_yield_sign() const {
  const ::apollo::planning::YieldSignStatus* p = _impl_.yield_sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::YieldSignStatus&>(
      ::apollo::planning::_YieldSignStatus_default_instance_);
}
inline const ::apollo::planning::YieldSignStatus& PlanningStatus::yield_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.yield_sign)
  return _internal_yield_sign();
}
inline void PlanningStatus::unsafe_arena_set_allocated_yield_sign(
    ::apollo::planning::YieldSignStatus* yield_sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.yield_sign_);
  }
  _impl_.yield_sign_ = yield_sign;
  if (yield_sign) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.PlanningStatus.yield_sign)
}
inline ::apollo::planning::YieldSignStatus* PlanningStatus::release_yield_sign() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::apollo::planning::YieldSignStatus* temp = _impl_.yield_sign_;
  _impl_.yield_sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::YieldSignStatus* PlanningStatus::unsafe_arena_release_yield_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.yield_sign)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::apollo::planning::YieldSignStatus* temp = _impl_.yield_sign_;
  _impl_.yield_sign_ = nullptr;
  return temp;
}
inline ::apollo::planning::YieldSignStatus* PlanningStatus::_internal_mutable_yield_sign() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.yield_sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::YieldSignStatus>(GetArenaForAllocation());
    _impl_.yield_sign_ = p;
  }
  return _impl_.yield_sign_;
}
inline ::apollo::planning::YieldSignStatus* PlanningStatus::mutable_yield_sign() {
  ::apollo::planning::YieldSignStatus* _msg = _internal_mutable_yield_sign();
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.yield_sign)
  return _msg;
}
inline void PlanningStatus::set_allocated_yield_sign(::apollo::planning::YieldSignStatus* yield_sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.yield_sign_;
  }
  if (yield_sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(yield_sign);
    if (message_arena != submessage_arena) {
      yield_sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yield_sign, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.yield_sign_ = yield_sign;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.yield_sign)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::planning::ChangeLaneStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::ChangeLaneStatus_Status>() {
  return ::apollo::planning::ChangeLaneStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::PathDeciderStatus_LaneBorrowDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::PathDeciderStatus_LaneBorrowDirection>() {
  return ::apollo::planning::PathDeciderStatus_LaneBorrowDirection_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::PullOverStatus_PullOverType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::PullOverStatus_PullOverType>() {
  return ::apollo::planning::PullOverStatus_PullOverType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto
