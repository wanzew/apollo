// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/traffic_rule_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
namespace apollo {
namespace planning {
class BacksideVehicleConfig;
struct BacksideVehicleConfigDefaultTypeInternal;
extern BacksideVehicleConfigDefaultTypeInternal _BacksideVehicleConfig_default_instance_;
class ChangeLaneConfig;
struct ChangeLaneConfigDefaultTypeInternal;
extern ChangeLaneConfigDefaultTypeInternal _ChangeLaneConfig_default_instance_;
class CreepConfig;
struct CreepConfigDefaultTypeInternal;
extern CreepConfigDefaultTypeInternal _CreepConfig_default_instance_;
class CrosswalkConfig;
struct CrosswalkConfigDefaultTypeInternal;
extern CrosswalkConfigDefaultTypeInternal _CrosswalkConfig_default_instance_;
class DestinationConfig;
struct DestinationConfigDefaultTypeInternal;
extern DestinationConfigDefaultTypeInternal _DestinationConfig_default_instance_;
class FrontVehicleConfig;
struct FrontVehicleConfigDefaultTypeInternal;
extern FrontVehicleConfigDefaultTypeInternal _FrontVehicleConfig_default_instance_;
class KeepClearConfig;
struct KeepClearConfigDefaultTypeInternal;
extern KeepClearConfigDefaultTypeInternal _KeepClearConfig_default_instance_;
class PullOverConfig;
struct PullOverConfigDefaultTypeInternal;
extern PullOverConfigDefaultTypeInternal _PullOverConfig_default_instance_;
class ReferenceLineEndConfig;
struct ReferenceLineEndConfigDefaultTypeInternal;
extern ReferenceLineEndConfigDefaultTypeInternal _ReferenceLineEndConfig_default_instance_;
class ReroutingConfig;
struct ReroutingConfigDefaultTypeInternal;
extern ReroutingConfigDefaultTypeInternal _ReroutingConfig_default_instance_;
class SignalLightConfig;
struct SignalLightConfigDefaultTypeInternal;
extern SignalLightConfigDefaultTypeInternal _SignalLightConfig_default_instance_;
class StopSignConfig;
struct StopSignConfigDefaultTypeInternal;
extern StopSignConfigDefaultTypeInternal _StopSignConfig_default_instance_;
class TrafficRuleConfig;
struct TrafficRuleConfigDefaultTypeInternal;
extern TrafficRuleConfigDefaultTypeInternal _TrafficRuleConfig_default_instance_;
class TrafficRuleConfigs;
struct TrafficRuleConfigsDefaultTypeInternal;
extern TrafficRuleConfigsDefaultTypeInternal _TrafficRuleConfigs_default_instance_;
}  // namespace planning
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::planning::BacksideVehicleConfig* Arena::CreateMaybeMessage<::apollo::planning::BacksideVehicleConfig>(Arena*);
template<> ::apollo::planning::ChangeLaneConfig* Arena::CreateMaybeMessage<::apollo::planning::ChangeLaneConfig>(Arena*);
template<> ::apollo::planning::CreepConfig* Arena::CreateMaybeMessage<::apollo::planning::CreepConfig>(Arena*);
template<> ::apollo::planning::CrosswalkConfig* Arena::CreateMaybeMessage<::apollo::planning::CrosswalkConfig>(Arena*);
template<> ::apollo::planning::DestinationConfig* Arena::CreateMaybeMessage<::apollo::planning::DestinationConfig>(Arena*);
template<> ::apollo::planning::FrontVehicleConfig* Arena::CreateMaybeMessage<::apollo::planning::FrontVehicleConfig>(Arena*);
template<> ::apollo::planning::KeepClearConfig* Arena::CreateMaybeMessage<::apollo::planning::KeepClearConfig>(Arena*);
template<> ::apollo::planning::PullOverConfig* Arena::CreateMaybeMessage<::apollo::planning::PullOverConfig>(Arena*);
template<> ::apollo::planning::ReferenceLineEndConfig* Arena::CreateMaybeMessage<::apollo::planning::ReferenceLineEndConfig>(Arena*);
template<> ::apollo::planning::ReroutingConfig* Arena::CreateMaybeMessage<::apollo::planning::ReroutingConfig>(Arena*);
template<> ::apollo::planning::SignalLightConfig* Arena::CreateMaybeMessage<::apollo::planning::SignalLightConfig>(Arena*);
template<> ::apollo::planning::StopSignConfig* Arena::CreateMaybeMessage<::apollo::planning::StopSignConfig>(Arena*);
template<> ::apollo::planning::TrafficRuleConfig* Arena::CreateMaybeMessage<::apollo::planning::TrafficRuleConfig>(Arena*);
template<> ::apollo::planning::TrafficRuleConfigs* Arena::CreateMaybeMessage<::apollo::planning::TrafficRuleConfigs>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace planning {

enum TrafficRuleConfig_RuleId : int {
  TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE = 1,
  TrafficRuleConfig_RuleId_CHANGE_LANE = 2,
  TrafficRuleConfig_RuleId_CROSSWALK = 3,
  TrafficRuleConfig_RuleId_DESTINATION = 4,
  TrafficRuleConfig_RuleId_FRONT_VEHICLE = 5,
  TrafficRuleConfig_RuleId_KEEP_CLEAR = 6,
  TrafficRuleConfig_RuleId_PULL_OVER = 7,
  TrafficRuleConfig_RuleId_REFERENCE_LINE_END = 8,
  TrafficRuleConfig_RuleId_REROUTING = 9,
  TrafficRuleConfig_RuleId_SIGNAL_LIGHT = 10,
  TrafficRuleConfig_RuleId_STOP_SIGN = 11
};
bool TrafficRuleConfig_RuleId_IsValid(int value);
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig_RuleId_RuleId_MIN = TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig_RuleId_RuleId_MAX = TrafficRuleConfig_RuleId_STOP_SIGN;
constexpr int TrafficRuleConfig_RuleId_RuleId_ARRAYSIZE = TrafficRuleConfig_RuleId_RuleId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficRuleConfig_RuleId_descriptor();
template<typename T>
inline const std::string& TrafficRuleConfig_RuleId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficRuleConfig_RuleId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficRuleConfig_RuleId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficRuleConfig_RuleId_descriptor(), enum_t_value);
}
inline bool TrafficRuleConfig_RuleId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrafficRuleConfig_RuleId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficRuleConfig_RuleId>(
    TrafficRuleConfig_RuleId_descriptor(), name, value);
}
// ===================================================================

class BacksideVehicleConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.BacksideVehicleConfig) */ {
 public:
  inline BacksideVehicleConfig() : BacksideVehicleConfig(nullptr) {}
  ~BacksideVehicleConfig() override;
  explicit PROTOBUF_CONSTEXPR BacksideVehicleConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BacksideVehicleConfig(const BacksideVehicleConfig& from);
  BacksideVehicleConfig(BacksideVehicleConfig&& from) noexcept
    : BacksideVehicleConfig() {
    *this = ::std::move(from);
  }

  inline BacksideVehicleConfig& operator=(const BacksideVehicleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BacksideVehicleConfig& operator=(BacksideVehicleConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BacksideVehicleConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const BacksideVehicleConfig* internal_default_instance() {
    return reinterpret_cast<const BacksideVehicleConfig*>(
               &_BacksideVehicleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BacksideVehicleConfig& a, BacksideVehicleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BacksideVehicleConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BacksideVehicleConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BacksideVehicleConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BacksideVehicleConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BacksideVehicleConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BacksideVehicleConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BacksideVehicleConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.BacksideVehicleConfig";
  }
  protected:
  explicit BacksideVehicleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBacksideLaneWidthFieldNumber = 1,
  };
  // optional double backside_lane_width = 1 [default = 4];
  bool has_backside_lane_width() const;
  private:
  bool _internal_has_backside_lane_width() const;
  public:
  void clear_backside_lane_width();
  double backside_lane_width() const;
  void set_backside_lane_width(double value);
  private:
  double _internal_backside_lane_width() const;
  void _internal_set_backside_lane_width(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.BacksideVehicleConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double backside_lane_width_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ChangeLaneConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ChangeLaneConfig) */ {
 public:
  inline ChangeLaneConfig() : ChangeLaneConfig(nullptr) {}
  ~ChangeLaneConfig() override;
  explicit PROTOBUF_CONSTEXPR ChangeLaneConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeLaneConfig(const ChangeLaneConfig& from);
  ChangeLaneConfig(ChangeLaneConfig&& from) noexcept
    : ChangeLaneConfig() {
    *this = ::std::move(from);
  }

  inline ChangeLaneConfig& operator=(const ChangeLaneConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeLaneConfig& operator=(ChangeLaneConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeLaneConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeLaneConfig* internal_default_instance() {
    return reinterpret_cast<const ChangeLaneConfig*>(
               &_ChangeLaneConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChangeLaneConfig& a, ChangeLaneConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeLaneConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeLaneConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeLaneConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeLaneConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeLaneConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeLaneConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeLaneConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ChangeLaneConfig";
  }
  protected:
  explicit ChangeLaneConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableGuardObstacleFieldNumber = 3,
    kMinOvertakeDistanceFieldNumber = 1,
    kMinOvertakeTimeFieldNumber = 2,
    kGuardDistanceFieldNumber = 4,
    kMinGuardSpeedFieldNumber = 5,
  };
  // optional bool enable_guard_obstacle = 3 [default = false];
  bool has_enable_guard_obstacle() const;
  private:
  bool _internal_has_enable_guard_obstacle() const;
  public:
  void clear_enable_guard_obstacle();
  bool enable_guard_obstacle() const;
  void set_enable_guard_obstacle(bool value);
  private:
  bool _internal_enable_guard_obstacle() const;
  void _internal_set_enable_guard_obstacle(bool value);
  public:

  // optional double min_overtake_distance = 1 [default = 10];
  bool has_min_overtake_distance() const;
  private:
  bool _internal_has_min_overtake_distance() const;
  public:
  void clear_min_overtake_distance();
  double min_overtake_distance() const;
  void set_min_overtake_distance(double value);
  private:
  double _internal_min_overtake_distance() const;
  void _internal_set_min_overtake_distance(double value);
  public:

  // optional double min_overtake_time = 2 [default = 2];
  bool has_min_overtake_time() const;
  private:
  bool _internal_has_min_overtake_time() const;
  public:
  void clear_min_overtake_time();
  double min_overtake_time() const;
  void set_min_overtake_time(double value);
  private:
  double _internal_min_overtake_time() const;
  void _internal_set_min_overtake_time(double value);
  public:

  // optional double guard_distance = 4 [default = 100];
  bool has_guard_distance() const;
  private:
  bool _internal_has_guard_distance() const;
  public:
  void clear_guard_distance();
  double guard_distance() const;
  void set_guard_distance(double value);
  private:
  double _internal_guard_distance() const;
  void _internal_set_guard_distance(double value);
  public:

  // optional double min_guard_speed = 5 [default = 1];
  bool has_min_guard_speed() const;
  private:
  bool _internal_has_min_guard_speed() const;
  public:
  void clear_min_guard_speed();
  double min_guard_speed() const;
  void set_min_guard_speed(double value);
  private:
  double _internal_min_guard_speed() const;
  void _internal_set_min_guard_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ChangeLaneConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enable_guard_obstacle_;
    double min_overtake_distance_;
    double min_overtake_time_;
    double guard_distance_;
    double min_guard_speed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CreepConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CreepConfig) */ {
 public:
  inline CreepConfig() : CreepConfig(nullptr) {}
  ~CreepConfig() override;
  explicit PROTOBUF_CONSTEXPR CreepConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreepConfig(const CreepConfig& from);
  CreepConfig(CreepConfig&& from) noexcept
    : CreepConfig() {
    *this = ::std::move(from);
  }

  inline CreepConfig& operator=(const CreepConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreepConfig& operator=(CreepConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreepConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreepConfig* internal_default_instance() {
    return reinterpret_cast<const CreepConfig*>(
               &_CreepConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreepConfig& a, CreepConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CreepConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreepConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreepConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreepConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreepConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreepConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreepConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CreepConfig";
  }
  protected:
  explicit CreepConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kCreepDistanceToStopLineFieldNumber = 2,
    kStopDistanceFieldNumber = 3,
    kSpeedLimitFieldNumber = 4,
    kMaxValidStopDistanceFieldNumber = 5,
    kMinBoundaryTFieldNumber = 6,
    kMinBoundarySFieldNumber = 7,
  };
  // optional bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional double creep_distance_to_stop_line = 2 [default = 1];
  bool has_creep_distance_to_stop_line() const;
  private:
  bool _internal_has_creep_distance_to_stop_line() const;
  public:
  void clear_creep_distance_to_stop_line();
  double creep_distance_to_stop_line() const;
  void set_creep_distance_to_stop_line(double value);
  private:
  double _internal_creep_distance_to_stop_line() const;
  void _internal_set_creep_distance_to_stop_line(double value);
  public:

  // optional double stop_distance = 3 [default = 0.5];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double speed_limit = 4 [default = 1];
  bool has_speed_limit() const;
  private:
  bool _internal_has_speed_limit() const;
  public:
  void clear_speed_limit();
  double speed_limit() const;
  void set_speed_limit(double value);
  private:
  double _internal_speed_limit() const;
  void _internal_set_speed_limit(double value);
  public:

  // optional double max_valid_stop_distance = 5 [default = 0.3];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double min_boundary_t = 6 [default = 6];
  bool has_min_boundary_t() const;
  private:
  bool _internal_has_min_boundary_t() const;
  public:
  void clear_min_boundary_t();
  double min_boundary_t() const;
  void set_min_boundary_t(double value);
  private:
  double _internal_min_boundary_t() const;
  void _internal_set_min_boundary_t(double value);
  public:

  // optional double min_boundary_s = 7 [default = 3];
  bool has_min_boundary_s() const;
  private:
  bool _internal_has_min_boundary_s() const;
  public:
  void clear_min_boundary_s();
  double min_boundary_s() const;
  void set_min_boundary_s(double value);
  private:
  double _internal_min_boundary_s() const;
  void _internal_set_min_boundary_s(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CreepConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
    double creep_distance_to_stop_line_;
    double stop_distance_;
    double speed_limit_;
    double max_valid_stop_distance_;
    double min_boundary_t_;
    double min_boundary_s_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CrosswalkConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CrosswalkConfig) */ {
 public:
  inline CrosswalkConfig() : CrosswalkConfig(nullptr) {}
  ~CrosswalkConfig() override;
  explicit PROTOBUF_CONSTEXPR CrosswalkConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrosswalkConfig(const CrosswalkConfig& from);
  CrosswalkConfig(CrosswalkConfig&& from) noexcept
    : CrosswalkConfig() {
    *this = ::std::move(from);
  }

  inline CrosswalkConfig& operator=(const CrosswalkConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrosswalkConfig& operator=(CrosswalkConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CrosswalkConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrosswalkConfig* internal_default_instance() {
    return reinterpret_cast<const CrosswalkConfig*>(
               &_CrosswalkConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CrosswalkConfig& a, CrosswalkConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CrosswalkConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrosswalkConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrosswalkConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrosswalkConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CrosswalkConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CrosswalkConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CrosswalkConfig";
  }
  protected:
  explicit CrosswalkConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopDistanceFieldNumber = 1,
    kMaxStopDecelerationFieldNumber = 2,
    kMinPassSDistanceFieldNumber = 3,
    kMaxStopSpeedFieldNumber = 4,
    kMaxValidStopDistanceFieldNumber = 5,
    kExpandSDistanceFieldNumber = 6,
    kStopStrickLDistanceFieldNumber = 7,
    kStopLooseLDistanceFieldNumber = 8,
    kStopTimeoutFieldNumber = 9,
  };
  // optional double stop_distance = 1 [default = 1];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double max_stop_deceleration = 2 [default = 6];
  bool has_max_stop_deceleration() const;
  private:
  bool _internal_has_max_stop_deceleration() const;
  public:
  void clear_max_stop_deceleration();
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);
  private:
  double _internal_max_stop_deceleration() const;
  void _internal_set_max_stop_deceleration(double value);
  public:

  // optional double min_pass_s_distance = 3 [default = 1];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // optional double max_stop_speed = 4 [default = 0.3];
  bool has_max_stop_speed() const;
  private:
  bool _internal_has_max_stop_speed() const;
  public:
  void clear_max_stop_speed();
  double max_stop_speed() const;
  void set_max_stop_speed(double value);
  private:
  double _internal_max_stop_speed() const;
  void _internal_set_max_stop_speed(double value);
  public:

  // optional double max_valid_stop_distance = 5 [default = 3];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double expand_s_distance = 6 [default = 2];
  bool has_expand_s_distance() const;
  private:
  bool _internal_has_expand_s_distance() const;
  public:
  void clear_expand_s_distance();
  double expand_s_distance() const;
  void set_expand_s_distance(double value);
  private:
  double _internal_expand_s_distance() const;
  void _internal_set_expand_s_distance(double value);
  public:

  // optional double stop_strick_l_distance = 7 [default = 4];
  bool has_stop_strick_l_distance() const;
  private:
  bool _internal_has_stop_strick_l_distance() const;
  public:
  void clear_stop_strick_l_distance();
  double stop_strick_l_distance() const;
  void set_stop_strick_l_distance(double value);
  private:
  double _internal_stop_strick_l_distance() const;
  void _internal_set_stop_strick_l_distance(double value);
  public:

  // optional double stop_loose_l_distance = 8 [default = 5];
  bool has_stop_loose_l_distance() const;
  private:
  bool _internal_has_stop_loose_l_distance() const;
  public:
  void clear_stop_loose_l_distance();
  double stop_loose_l_distance() const;
  void set_stop_loose_l_distance(double value);
  private:
  double _internal_stop_loose_l_distance() const;
  void _internal_set_stop_loose_l_distance(double value);
  public:

  // optional double stop_timeout = 9 [default = 10];
  bool has_stop_timeout() const;
  private:
  bool _internal_has_stop_timeout() const;
  public:
  void clear_stop_timeout();
  double stop_timeout() const;
  void set_stop_timeout(double value);
  private:
  double _internal_stop_timeout() const;
  void _internal_set_stop_timeout(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CrosswalkConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double stop_distance_;
    double max_stop_deceleration_;
    double min_pass_s_distance_;
    double max_stop_speed_;
    double max_valid_stop_distance_;
    double expand_s_distance_;
    double stop_strick_l_distance_;
    double stop_loose_l_distance_;
    double stop_timeout_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class DestinationConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.DestinationConfig) */ {
 public:
  inline DestinationConfig() : DestinationConfig(nullptr) {}
  ~DestinationConfig() override;
  explicit PROTOBUF_CONSTEXPR DestinationConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestinationConfig(const DestinationConfig& from);
  DestinationConfig(DestinationConfig&& from) noexcept
    : DestinationConfig() {
    *this = ::std::move(from);
  }

  inline DestinationConfig& operator=(const DestinationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestinationConfig& operator=(DestinationConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestinationConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestinationConfig* internal_default_instance() {
    return reinterpret_cast<const DestinationConfig*>(
               &_DestinationConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DestinationConfig& a, DestinationConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DestinationConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestinationConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestinationConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestinationConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DestinationConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DestinationConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestinationConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.DestinationConfig";
  }
  protected:
  explicit DestinationConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnablePullOverFieldNumber = 1,
    kStopDistanceFieldNumber = 2,
    kPullOverPlanDistanceFieldNumber = 3,
  };
  // optional bool enable_pull_over = 1 [default = false];
  bool has_enable_pull_over() const;
  private:
  bool _internal_has_enable_pull_over() const;
  public:
  void clear_enable_pull_over();
  bool enable_pull_over() const;
  void set_enable_pull_over(bool value);
  private:
  bool _internal_enable_pull_over() const;
  void _internal_set_enable_pull_over(bool value);
  public:

  // optional double stop_distance = 2 [default = 0.5];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double pull_over_plan_distance = 3 [default = 35];
  bool has_pull_over_plan_distance() const;
  private:
  bool _internal_has_pull_over_plan_distance() const;
  public:
  void clear_pull_over_plan_distance();
  double pull_over_plan_distance() const;
  void set_pull_over_plan_distance(double value);
  private:
  double _internal_pull_over_plan_distance() const;
  void _internal_set_pull_over_plan_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.DestinationConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enable_pull_over_;
    double stop_distance_;
    double pull_over_plan_distance_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class FrontVehicleConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.FrontVehicleConfig) */ {
 public:
  inline FrontVehicleConfig() : FrontVehicleConfig(nullptr) {}
  ~FrontVehicleConfig() override;
  explicit PROTOBUF_CONSTEXPR FrontVehicleConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrontVehicleConfig(const FrontVehicleConfig& from);
  FrontVehicleConfig(FrontVehicleConfig&& from) noexcept
    : FrontVehicleConfig() {
    *this = ::std::move(from);
  }

  inline FrontVehicleConfig& operator=(const FrontVehicleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrontVehicleConfig& operator=(FrontVehicleConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrontVehicleConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrontVehicleConfig* internal_default_instance() {
    return reinterpret_cast<const FrontVehicleConfig*>(
               &_FrontVehicleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FrontVehicleConfig& a, FrontVehicleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(FrontVehicleConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrontVehicleConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrontVehicleConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrontVehicleConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrontVehicleConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FrontVehicleConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrontVehicleConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.FrontVehicleConfig";
  }
  protected:
  explicit FrontVehicleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableSidePassFieldNumber = 1,
    kSidePassSThresholdFieldNumber = 2,
    kSidePassLThresholdFieldNumber = 3,
    kSidePassWaitTimeFieldNumber = 4,
    kNudgeLBufferFieldNumber = 5,
  };
  // optional bool enable_side_pass = 1 [default = true];
  bool has_enable_side_pass() const;
  private:
  bool _internal_has_enable_side_pass() const;
  public:
  void clear_enable_side_pass();
  bool enable_side_pass() const;
  void set_enable_side_pass(bool value);
  private:
  bool _internal_enable_side_pass() const;
  void _internal_set_enable_side_pass(bool value);
  public:

  // optional double side_pass_s_threshold = 2 [default = 15];
  bool has_side_pass_s_threshold() const;
  private:
  bool _internal_has_side_pass_s_threshold() const;
  public:
  void clear_side_pass_s_threshold();
  double side_pass_s_threshold() const;
  void set_side_pass_s_threshold(double value);
  private:
  double _internal_side_pass_s_threshold() const;
  void _internal_set_side_pass_s_threshold(double value);
  public:

  // optional double side_pass_l_threshold = 3 [default = 1];
  bool has_side_pass_l_threshold() const;
  private:
  bool _internal_has_side_pass_l_threshold() const;
  public:
  void clear_side_pass_l_threshold();
  double side_pass_l_threshold() const;
  void set_side_pass_l_threshold(double value);
  private:
  double _internal_side_pass_l_threshold() const;
  void _internal_set_side_pass_l_threshold(double value);
  public:

  // optional double side_pass_wait_time = 4 [default = 30];
  bool has_side_pass_wait_time() const;
  private:
  bool _internal_has_side_pass_wait_time() const;
  public:
  void clear_side_pass_wait_time();
  double side_pass_wait_time() const;
  void set_side_pass_wait_time(double value);
  private:
  double _internal_side_pass_wait_time() const;
  void _internal_set_side_pass_wait_time(double value);
  public:

  // optional double nudge_l_buffer = 5 [default = 0.5];
  bool has_nudge_l_buffer() const;
  private:
  bool _internal_has_nudge_l_buffer() const;
  public:
  void clear_nudge_l_buffer();
  double nudge_l_buffer() const;
  void set_nudge_l_buffer(double value);
  private:
  double _internal_nudge_l_buffer() const;
  void _internal_set_nudge_l_buffer(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.FrontVehicleConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enable_side_pass_;
    double side_pass_s_threshold_;
    double side_pass_l_threshold_;
    double side_pass_wait_time_;
    double nudge_l_buffer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class KeepClearConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.KeepClearConfig) */ {
 public:
  inline KeepClearConfig() : KeepClearConfig(nullptr) {}
  ~KeepClearConfig() override;
  explicit PROTOBUF_CONSTEXPR KeepClearConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeepClearConfig(const KeepClearConfig& from);
  KeepClearConfig(KeepClearConfig&& from) noexcept
    : KeepClearConfig() {
    *this = ::std::move(from);
  }

  inline KeepClearConfig& operator=(const KeepClearConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepClearConfig& operator=(KeepClearConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeepClearConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeepClearConfig* internal_default_instance() {
    return reinterpret_cast<const KeepClearConfig*>(
               &_KeepClearConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(KeepClearConfig& a, KeepClearConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(KeepClearConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeepClearConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeepClearConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeepClearConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeepClearConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeepClearConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeepClearConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.KeepClearConfig";
  }
  protected:
  explicit KeepClearConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableKeepClearZoneFieldNumber = 1,
    kEnableJunctionFieldNumber = 2,
    kMinPassSDistanceFieldNumber = 3,
  };
  // optional bool enable_keep_clear_zone = 1 [default = true];
  bool has_enable_keep_clear_zone() const;
  private:
  bool _internal_has_enable_keep_clear_zone() const;
  public:
  void clear_enable_keep_clear_zone();
  bool enable_keep_clear_zone() const;
  void set_enable_keep_clear_zone(bool value);
  private:
  bool _internal_enable_keep_clear_zone() const;
  void _internal_set_enable_keep_clear_zone(bool value);
  public:

  // optional bool enable_junction = 2 [default = true];
  bool has_enable_junction() const;
  private:
  bool _internal_has_enable_junction() const;
  public:
  void clear_enable_junction();
  bool enable_junction() const;
  void set_enable_junction(bool value);
  private:
  bool _internal_enable_junction() const;
  void _internal_set_enable_junction(bool value);
  public:

  // optional double min_pass_s_distance = 3 [default = 2];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.KeepClearConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enable_keep_clear_zone_;
    bool enable_junction_;
    double min_pass_s_distance_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class PullOverConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PullOverConfig) */ {
 public:
  inline PullOverConfig() : PullOverConfig(nullptr) {}
  ~PullOverConfig() override;
  explicit PROTOBUF_CONSTEXPR PullOverConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullOverConfig(const PullOverConfig& from);
  PullOverConfig(PullOverConfig&& from) noexcept
    : PullOverConfig() {
    *this = ::std::move(from);
  }

  inline PullOverConfig& operator=(const PullOverConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullOverConfig& operator=(PullOverConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullOverConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullOverConfig* internal_default_instance() {
    return reinterpret_cast<const PullOverConfig*>(
               &_PullOverConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PullOverConfig& a, PullOverConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PullOverConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullOverConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullOverConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullOverConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PullOverConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PullOverConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullOverConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.PullOverConfig";
  }
  protected:
  explicit PullOverConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxFailureCountFieldNumber = 8,
    kStopDistanceFieldNumber = 1,
    kMaxStopSpeedFieldNumber = 2,
    kMaxValidStopDistanceFieldNumber = 3,
    kBufferToBoundaryFieldNumber = 4,
    kPlanDistanceFieldNumber = 5,
    kOperationLengthFieldNumber = 6,
    kMaxCheckDistanceFieldNumber = 7,
  };
  // optional uint32 max_failure_count = 8 [default = 10];
  bool has_max_failure_count() const;
  private:
  bool _internal_has_max_failure_count() const;
  public:
  void clear_max_failure_count();
  uint32_t max_failure_count() const;
  void set_max_failure_count(uint32_t value);
  private:
  uint32_t _internal_max_failure_count() const;
  void _internal_set_max_failure_count(uint32_t value);
  public:

  // optional double stop_distance = 1 [default = 0.5];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double max_stop_speed = 2 [default = 0.3];
  bool has_max_stop_speed() const;
  private:
  bool _internal_has_max_stop_speed() const;
  public:
  void clear_max_stop_speed();
  double max_stop_speed() const;
  void set_max_stop_speed(double value);
  private:
  double _internal_max_stop_speed() const;
  void _internal_set_max_stop_speed(double value);
  public:

  // optional double max_valid_stop_distance = 3 [default = 3];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double buffer_to_boundary = 4 [default = 0.5];
  bool has_buffer_to_boundary() const;
  private:
  bool _internal_has_buffer_to_boundary() const;
  public:
  void clear_buffer_to_boundary();
  double buffer_to_boundary() const;
  void set_buffer_to_boundary(double value);
  private:
  double _internal_buffer_to_boundary() const;
  void _internal_set_buffer_to_boundary(double value);
  public:

  // optional double plan_distance = 5 [default = 35];
  bool has_plan_distance() const;
  private:
  bool _internal_has_plan_distance() const;
  public:
  void clear_plan_distance();
  double plan_distance() const;
  void set_plan_distance(double value);
  private:
  double _internal_plan_distance() const;
  void _internal_set_plan_distance(double value);
  public:

  // optional double operation_length = 6 [default = 30];
  bool has_operation_length() const;
  private:
  bool _internal_has_operation_length() const;
  public:
  void clear_operation_length();
  double operation_length() const;
  void set_operation_length(double value);
  private:
  double _internal_operation_length() const;
  void _internal_set_operation_length(double value);
  public:

  // optional double max_check_distance = 7 [default = 60];
  bool has_max_check_distance() const;
  private:
  bool _internal_has_max_check_distance() const;
  public:
  void clear_max_check_distance();
  double max_check_distance() const;
  void set_max_check_distance(double value);
  private:
  double _internal_max_check_distance() const;
  void _internal_set_max_check_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.PullOverConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t max_failure_count_;
    double stop_distance_;
    double max_stop_speed_;
    double max_valid_stop_distance_;
    double buffer_to_boundary_;
    double plan_distance_;
    double operation_length_;
    double max_check_distance_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ReferenceLineEndConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReferenceLineEndConfig) */ {
 public:
  inline ReferenceLineEndConfig() : ReferenceLineEndConfig(nullptr) {}
  ~ReferenceLineEndConfig() override;
  explicit PROTOBUF_CONSTEXPR ReferenceLineEndConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceLineEndConfig(const ReferenceLineEndConfig& from);
  ReferenceLineEndConfig(ReferenceLineEndConfig&& from) noexcept
    : ReferenceLineEndConfig() {
    *this = ::std::move(from);
  }

  inline ReferenceLineEndConfig& operator=(const ReferenceLineEndConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceLineEndConfig& operator=(ReferenceLineEndConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceLineEndConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceLineEndConfig* internal_default_instance() {
    return reinterpret_cast<const ReferenceLineEndConfig*>(
               &_ReferenceLineEndConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReferenceLineEndConfig& a, ReferenceLineEndConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceLineEndConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceLineEndConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReferenceLineEndConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReferenceLineEndConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReferenceLineEndConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReferenceLineEndConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceLineEndConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ReferenceLineEndConfig";
  }
  protected:
  explicit ReferenceLineEndConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopDistanceFieldNumber = 1,
    kMinReferenceLineRemainLengthFieldNumber = 2,
  };
  // optional double stop_distance = 1 [default = 0.5];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double min_reference_line_remain_length = 2 [default = 50];
  bool has_min_reference_line_remain_length() const;
  private:
  bool _internal_has_min_reference_line_remain_length() const;
  public:
  void clear_min_reference_line_remain_length();
  double min_reference_line_remain_length() const;
  void set_min_reference_line_remain_length(double value);
  private:
  double _internal_min_reference_line_remain_length() const;
  void _internal_set_min_reference_line_remain_length(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ReferenceLineEndConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double stop_distance_;
    double min_reference_line_remain_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ReroutingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReroutingConfig) */ {
 public:
  inline ReroutingConfig() : ReroutingConfig(nullptr) {}
  ~ReroutingConfig() override;
  explicit PROTOBUF_CONSTEXPR ReroutingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReroutingConfig(const ReroutingConfig& from);
  ReroutingConfig(ReroutingConfig&& from) noexcept
    : ReroutingConfig() {
    *this = ::std::move(from);
  }

  inline ReroutingConfig& operator=(const ReroutingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReroutingConfig& operator=(ReroutingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReroutingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReroutingConfig* internal_default_instance() {
    return reinterpret_cast<const ReroutingConfig*>(
               &_ReroutingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReroutingConfig& a, ReroutingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ReroutingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReroutingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReroutingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReroutingConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReroutingConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReroutingConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReroutingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ReroutingConfig";
  }
  protected:
  explicit ReroutingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCooldownTimeFieldNumber = 1,
    kPrepareReroutingTimeFieldNumber = 2,
  };
  // optional double cooldown_time = 1 [default = 3];
  bool has_cooldown_time() const;
  private:
  bool _internal_has_cooldown_time() const;
  public:
  void clear_cooldown_time();
  double cooldown_time() const;
  void set_cooldown_time(double value);
  private:
  double _internal_cooldown_time() const;
  void _internal_set_cooldown_time(double value);
  public:

  // optional double prepare_rerouting_time = 2 [default = 2];
  bool has_prepare_rerouting_time() const;
  private:
  bool _internal_has_prepare_rerouting_time() const;
  public:
  void clear_prepare_rerouting_time();
  double prepare_rerouting_time() const;
  void set_prepare_rerouting_time(double value);
  private:
  double _internal_prepare_rerouting_time() const;
  void _internal_set_prepare_rerouting_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ReroutingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double cooldown_time_;
    double prepare_rerouting_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class SignalLightConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.SignalLightConfig) */ {
 public:
  inline SignalLightConfig() : SignalLightConfig(nullptr) {}
  ~SignalLightConfig() override;
  explicit PROTOBUF_CONSTEXPR SignalLightConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalLightConfig(const SignalLightConfig& from);
  SignalLightConfig(SignalLightConfig&& from) noexcept
    : SignalLightConfig() {
    *this = ::std::move(from);
  }

  inline SignalLightConfig& operator=(const SignalLightConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalLightConfig& operator=(SignalLightConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalLightConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalLightConfig* internal_default_instance() {
    return reinterpret_cast<const SignalLightConfig*>(
               &_SignalLightConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SignalLightConfig& a, SignalLightConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalLightConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalLightConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalLightConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalLightConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalLightConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignalLightConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalLightConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.SignalLightConfig";
  }
  protected:
  explicit SignalLightConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRighTurnCreepFieldNumber = 6,
    kStopDistanceFieldNumber = 1,
    kMaxStopDecelerationFieldNumber = 2,
    kMinPassSDistanceFieldNumber = 3,
    kMaxStopDeaccelerationYellowLightFieldNumber = 4,
    kSignalExpireTimeSecFieldNumber = 5,
  };
  // optional .apollo.planning.CreepConfig righ_turn_creep = 6;
  bool has_righ_turn_creep() const;
  private:
  bool _internal_has_righ_turn_creep() const;
  public:
  void clear_righ_turn_creep();
  const ::apollo::planning::CreepConfig& righ_turn_creep() const;
  PROTOBUF_NODISCARD ::apollo::planning::CreepConfig* release_righ_turn_creep();
  ::apollo::planning::CreepConfig* mutable_righ_turn_creep();
  void set_allocated_righ_turn_creep(::apollo::planning::CreepConfig* righ_turn_creep);
  private:
  const ::apollo::planning::CreepConfig& _internal_righ_turn_creep() const;
  ::apollo::planning::CreepConfig* _internal_mutable_righ_turn_creep();
  public:
  void unsafe_arena_set_allocated_righ_turn_creep(
      ::apollo::planning::CreepConfig* righ_turn_creep);
  ::apollo::planning::CreepConfig* unsafe_arena_release_righ_turn_creep();

  // optional double stop_distance = 1 [default = 1];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double max_stop_deceleration = 2 [default = 6];
  bool has_max_stop_deceleration() const;
  private:
  bool _internal_has_max_stop_deceleration() const;
  public:
  void clear_max_stop_deceleration();
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);
  private:
  double _internal_max_stop_deceleration() const;
  void _internal_set_max_stop_deceleration(double value);
  public:

  // optional double min_pass_s_distance = 3 [default = 4];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // optional double max_stop_deacceleration_yellow_light = 4 [default = 3];
  bool has_max_stop_deacceleration_yellow_light() const;
  private:
  bool _internal_has_max_stop_deacceleration_yellow_light() const;
  public:
  void clear_max_stop_deacceleration_yellow_light();
  double max_stop_deacceleration_yellow_light() const;
  void set_max_stop_deacceleration_yellow_light(double value);
  private:
  double _internal_max_stop_deacceleration_yellow_light() const;
  void _internal_set_max_stop_deacceleration_yellow_light(double value);
  public:

  // optional double signal_expire_time_sec = 5 [default = 5];
  bool has_signal_expire_time_sec() const;
  private:
  bool _internal_has_signal_expire_time_sec() const;
  public:
  void clear_signal_expire_time_sec();
  double signal_expire_time_sec() const;
  void set_signal_expire_time_sec(double value);
  private:
  double _internal_signal_expire_time_sec() const;
  void _internal_set_signal_expire_time_sec(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.SignalLightConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::planning::CreepConfig* righ_turn_creep_;
    double stop_distance_;
    double max_stop_deceleration_;
    double min_pass_s_distance_;
    double max_stop_deacceleration_yellow_light_;
    double signal_expire_time_sec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class StopSignConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopSignConfig) */ {
 public:
  inline StopSignConfig() : StopSignConfig(nullptr) {}
  ~StopSignConfig() override;
  explicit PROTOBUF_CONSTEXPR StopSignConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopSignConfig(const StopSignConfig& from);
  StopSignConfig(StopSignConfig&& from) noexcept
    : StopSignConfig() {
    *this = ::std::move(from);
  }

  inline StopSignConfig& operator=(const StopSignConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSignConfig& operator=(StopSignConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopSignConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopSignConfig* internal_default_instance() {
    return reinterpret_cast<const StopSignConfig*>(
               &_StopSignConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StopSignConfig& a, StopSignConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSignConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSignConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopSignConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopSignConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopSignConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopSignConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSignConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StopSignConfig";
  }
  protected:
  explicit StopSignConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreepFieldNumber = 9,
    kStopDistanceFieldNumber = 1,
    kMinPassSDistanceFieldNumber = 2,
    kMaxStopSpeedFieldNumber = 3,
    kMaxValidStopDistanceFieldNumber = 4,
    kStopDurationFieldNumber = 5,
    kWatchVehicleMaxValidStopSpeedFieldNumber = 6,
    kWatchVehicleMaxValidStopDistanceFieldNumber = 7,
    kWaitTimeoutFieldNumber = 8,
  };
  // optional .apollo.planning.CreepConfig creep = 9;
  bool has_creep() const;
  private:
  bool _internal_has_creep() const;
  public:
  void clear_creep();
  const ::apollo::planning::CreepConfig& creep() const;
  PROTOBUF_NODISCARD ::apollo::planning::CreepConfig* release_creep();
  ::apollo::planning::CreepConfig* mutable_creep();
  void set_allocated_creep(::apollo::planning::CreepConfig* creep);
  private:
  const ::apollo::planning::CreepConfig& _internal_creep() const;
  ::apollo::planning::CreepConfig* _internal_mutable_creep();
  public:
  void unsafe_arena_set_allocated_creep(
      ::apollo::planning::CreepConfig* creep);
  ::apollo::planning::CreepConfig* unsafe_arena_release_creep();

  // optional double stop_distance = 1 [default = 1];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double min_pass_s_distance = 2 [default = 1];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // optional double max_stop_speed = 3 [default = 0.3];
  bool has_max_stop_speed() const;
  private:
  bool _internal_has_max_stop_speed() const;
  public:
  void clear_max_stop_speed();
  double max_stop_speed() const;
  void set_max_stop_speed(double value);
  private:
  double _internal_max_stop_speed() const;
  void _internal_set_max_stop_speed(double value);
  public:

  // optional double max_valid_stop_distance = 4 [default = 3];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double stop_duration = 5 [default = 1];
  bool has_stop_duration() const;
  private:
  bool _internal_has_stop_duration() const;
  public:
  void clear_stop_duration();
  double stop_duration() const;
  void set_stop_duration(double value);
  private:
  double _internal_stop_duration() const;
  void _internal_set_stop_duration(double value);
  public:

  // optional double watch_vehicle_max_valid_stop_speed = 6 [default = 0.5];
  bool has_watch_vehicle_max_valid_stop_speed() const;
  private:
  bool _internal_has_watch_vehicle_max_valid_stop_speed() const;
  public:
  void clear_watch_vehicle_max_valid_stop_speed();
  double watch_vehicle_max_valid_stop_speed() const;
  void set_watch_vehicle_max_valid_stop_speed(double value);
  private:
  double _internal_watch_vehicle_max_valid_stop_speed() const;
  void _internal_set_watch_vehicle_max_valid_stop_speed(double value);
  public:

  // optional double watch_vehicle_max_valid_stop_distance = 7 [default = 5];
  bool has_watch_vehicle_max_valid_stop_distance() const;
  private:
  bool _internal_has_watch_vehicle_max_valid_stop_distance() const;
  public:
  void clear_watch_vehicle_max_valid_stop_distance();
  double watch_vehicle_max_valid_stop_distance() const;
  void set_watch_vehicle_max_valid_stop_distance(double value);
  private:
  double _internal_watch_vehicle_max_valid_stop_distance() const;
  void _internal_set_watch_vehicle_max_valid_stop_distance(double value);
  public:

  // optional double wait_timeout = 8 [default = 8];
  bool has_wait_timeout() const;
  private:
  bool _internal_has_wait_timeout() const;
  public:
  void clear_wait_timeout();
  double wait_timeout() const;
  void set_wait_timeout(double value);
  private:
  double _internal_wait_timeout() const;
  void _internal_set_wait_timeout(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StopSignConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::planning::CreepConfig* creep_;
    double stop_distance_;
    double min_pass_s_distance_;
    double max_stop_speed_;
    double max_valid_stop_distance_;
    double stop_duration_;
    double watch_vehicle_max_valid_stop_speed_;
    double watch_vehicle_max_valid_stop_distance_;
    double wait_timeout_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TrafficRuleConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficRuleConfig) */ {
 public:
  inline TrafficRuleConfig() : TrafficRuleConfig(nullptr) {}
  ~TrafficRuleConfig() override;
  explicit PROTOBUF_CONSTEXPR TrafficRuleConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficRuleConfig(const TrafficRuleConfig& from);
  TrafficRuleConfig(TrafficRuleConfig&& from) noexcept
    : TrafficRuleConfig() {
    *this = ::std::move(from);
  }

  inline TrafficRuleConfig& operator=(const TrafficRuleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficRuleConfig& operator=(TrafficRuleConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficRuleConfig& default_instance() {
    return *internal_default_instance();
  }
  enum ConfigCase {
    kBacksideVehicle = 3,
    kChangeLane = 4,
    kCrosswalk = 5,
    kDestination = 6,
    kFrontVehicle = 7,
    kKeepClear = 8,
    kPullOver = 9,
    kReferenceLineEnd = 10,
    kRerouting = 11,
    kSignalLight = 12,
    kStopSign = 13,
    CONFIG_NOT_SET = 0,
  };

  static inline const TrafficRuleConfig* internal_default_instance() {
    return reinterpret_cast<const TrafficRuleConfig*>(
               &_TrafficRuleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TrafficRuleConfig& a, TrafficRuleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficRuleConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficRuleConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficRuleConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficRuleConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficRuleConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrafficRuleConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficRuleConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficRuleConfig";
  }
  protected:
  explicit TrafficRuleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficRuleConfig_RuleId RuleId;
  static constexpr RuleId BACKSIDE_VEHICLE =
    TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE;
  static constexpr RuleId CHANGE_LANE =
    TrafficRuleConfig_RuleId_CHANGE_LANE;
  static constexpr RuleId CROSSWALK =
    TrafficRuleConfig_RuleId_CROSSWALK;
  static constexpr RuleId DESTINATION =
    TrafficRuleConfig_RuleId_DESTINATION;
  static constexpr RuleId FRONT_VEHICLE =
    TrafficRuleConfig_RuleId_FRONT_VEHICLE;
  static constexpr RuleId KEEP_CLEAR =
    TrafficRuleConfig_RuleId_KEEP_CLEAR;
  static constexpr RuleId PULL_OVER =
    TrafficRuleConfig_RuleId_PULL_OVER;
  static constexpr RuleId REFERENCE_LINE_END =
    TrafficRuleConfig_RuleId_REFERENCE_LINE_END;
  static constexpr RuleId REROUTING =
    TrafficRuleConfig_RuleId_REROUTING;
  static constexpr RuleId SIGNAL_LIGHT =
    TrafficRuleConfig_RuleId_SIGNAL_LIGHT;
  static constexpr RuleId STOP_SIGN =
    TrafficRuleConfig_RuleId_STOP_SIGN;
  static inline bool RuleId_IsValid(int value) {
    return TrafficRuleConfig_RuleId_IsValid(value);
  }
  static constexpr RuleId RuleId_MIN =
    TrafficRuleConfig_RuleId_RuleId_MIN;
  static constexpr RuleId RuleId_MAX =
    TrafficRuleConfig_RuleId_RuleId_MAX;
  static constexpr int RuleId_ARRAYSIZE =
    TrafficRuleConfig_RuleId_RuleId_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RuleId_descriptor() {
    return TrafficRuleConfig_RuleId_descriptor();
  }
  template<typename T>
  static inline const std::string& RuleId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RuleId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RuleId_Name.");
    return TrafficRuleConfig_RuleId_Name(enum_t_value);
  }
  static inline bool RuleId_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RuleId* value) {
    return TrafficRuleConfig_RuleId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 2,
    kRuleIdFieldNumber = 1,
    kBacksideVehicleFieldNumber = 3,
    kChangeLaneFieldNumber = 4,
    kCrosswalkFieldNumber = 5,
    kDestinationFieldNumber = 6,
    kFrontVehicleFieldNumber = 7,
    kKeepClearFieldNumber = 8,
    kPullOverFieldNumber = 9,
    kReferenceLineEndFieldNumber = 10,
    kReroutingFieldNumber = 11,
    kSignalLightFieldNumber = 12,
    kStopSignFieldNumber = 13,
  };
  // optional bool enabled = 2;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
  bool has_rule_id() const;
  private:
  bool _internal_has_rule_id() const;
  public:
  void clear_rule_id();
  ::apollo::planning::TrafficRuleConfig_RuleId rule_id() const;
  void set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value);
  private:
  ::apollo::planning::TrafficRuleConfig_RuleId _internal_rule_id() const;
  void _internal_set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value);
  public:

  // .apollo.planning.BacksideVehicleConfig backside_vehicle = 3;
  bool has_backside_vehicle() const;
  private:
  bool _internal_has_backside_vehicle() const;
  public:
  void clear_backside_vehicle();
  const ::apollo::planning::BacksideVehicleConfig& backside_vehicle() const;
  PROTOBUF_NODISCARD ::apollo::planning::BacksideVehicleConfig* release_backside_vehicle();
  ::apollo::planning::BacksideVehicleConfig* mutable_backside_vehicle();
  void set_allocated_backside_vehicle(::apollo::planning::BacksideVehicleConfig* backside_vehicle);
  private:
  const ::apollo::planning::BacksideVehicleConfig& _internal_backside_vehicle() const;
  ::apollo::planning::BacksideVehicleConfig* _internal_mutable_backside_vehicle();
  public:
  void unsafe_arena_set_allocated_backside_vehicle(
      ::apollo::planning::BacksideVehicleConfig* backside_vehicle);
  ::apollo::planning::BacksideVehicleConfig* unsafe_arena_release_backside_vehicle();

  // .apollo.planning.ChangeLaneConfig change_lane = 4;
  bool has_change_lane() const;
  private:
  bool _internal_has_change_lane() const;
  public:
  void clear_change_lane();
  const ::apollo::planning::ChangeLaneConfig& change_lane() const;
  PROTOBUF_NODISCARD ::apollo::planning::ChangeLaneConfig* release_change_lane();
  ::apollo::planning::ChangeLaneConfig* mutable_change_lane();
  void set_allocated_change_lane(::apollo::planning::ChangeLaneConfig* change_lane);
  private:
  const ::apollo::planning::ChangeLaneConfig& _internal_change_lane() const;
  ::apollo::planning::ChangeLaneConfig* _internal_mutable_change_lane();
  public:
  void unsafe_arena_set_allocated_change_lane(
      ::apollo::planning::ChangeLaneConfig* change_lane);
  ::apollo::planning::ChangeLaneConfig* unsafe_arena_release_change_lane();

  // .apollo.planning.CrosswalkConfig crosswalk = 5;
  bool has_crosswalk() const;
  private:
  bool _internal_has_crosswalk() const;
  public:
  void clear_crosswalk();
  const ::apollo::planning::CrosswalkConfig& crosswalk() const;
  PROTOBUF_NODISCARD ::apollo::planning::CrosswalkConfig* release_crosswalk();
  ::apollo::planning::CrosswalkConfig* mutable_crosswalk();
  void set_allocated_crosswalk(::apollo::planning::CrosswalkConfig* crosswalk);
  private:
  const ::apollo::planning::CrosswalkConfig& _internal_crosswalk() const;
  ::apollo::planning::CrosswalkConfig* _internal_mutable_crosswalk();
  public:
  void unsafe_arena_set_allocated_crosswalk(
      ::apollo::planning::CrosswalkConfig* crosswalk);
  ::apollo::planning::CrosswalkConfig* unsafe_arena_release_crosswalk();

  // .apollo.planning.DestinationConfig destination = 6;
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::apollo::planning::DestinationConfig& destination() const;
  PROTOBUF_NODISCARD ::apollo::planning::DestinationConfig* release_destination();
  ::apollo::planning::DestinationConfig* mutable_destination();
  void set_allocated_destination(::apollo::planning::DestinationConfig* destination);
  private:
  const ::apollo::planning::DestinationConfig& _internal_destination() const;
  ::apollo::planning::DestinationConfig* _internal_mutable_destination();
  public:
  void unsafe_arena_set_allocated_destination(
      ::apollo::planning::DestinationConfig* destination);
  ::apollo::planning::DestinationConfig* unsafe_arena_release_destination();

  // .apollo.planning.FrontVehicleConfig front_vehicle = 7;
  bool has_front_vehicle() const;
  private:
  bool _internal_has_front_vehicle() const;
  public:
  void clear_front_vehicle();
  const ::apollo::planning::FrontVehicleConfig& front_vehicle() const;
  PROTOBUF_NODISCARD ::apollo::planning::FrontVehicleConfig* release_front_vehicle();
  ::apollo::planning::FrontVehicleConfig* mutable_front_vehicle();
  void set_allocated_front_vehicle(::apollo::planning::FrontVehicleConfig* front_vehicle);
  private:
  const ::apollo::planning::FrontVehicleConfig& _internal_front_vehicle() const;
  ::apollo::planning::FrontVehicleConfig* _internal_mutable_front_vehicle();
  public:
  void unsafe_arena_set_allocated_front_vehicle(
      ::apollo::planning::FrontVehicleConfig* front_vehicle);
  ::apollo::planning::FrontVehicleConfig* unsafe_arena_release_front_vehicle();

  // .apollo.planning.KeepClearConfig keep_clear = 8;
  bool has_keep_clear() const;
  private:
  bool _internal_has_keep_clear() const;
  public:
  void clear_keep_clear();
  const ::apollo::planning::KeepClearConfig& keep_clear() const;
  PROTOBUF_NODISCARD ::apollo::planning::KeepClearConfig* release_keep_clear();
  ::apollo::planning::KeepClearConfig* mutable_keep_clear();
  void set_allocated_keep_clear(::apollo::planning::KeepClearConfig* keep_clear);
  private:
  const ::apollo::planning::KeepClearConfig& _internal_keep_clear() const;
  ::apollo::planning::KeepClearConfig* _internal_mutable_keep_clear();
  public:
  void unsafe_arena_set_allocated_keep_clear(
      ::apollo::planning::KeepClearConfig* keep_clear);
  ::apollo::planning::KeepClearConfig* unsafe_arena_release_keep_clear();

  // .apollo.planning.PullOverConfig pull_over = 9;
  bool has_pull_over() const;
  private:
  bool _internal_has_pull_over() const;
  public:
  void clear_pull_over();
  const ::apollo::planning::PullOverConfig& pull_over() const;
  PROTOBUF_NODISCARD ::apollo::planning::PullOverConfig* release_pull_over();
  ::apollo::planning::PullOverConfig* mutable_pull_over();
  void set_allocated_pull_over(::apollo::planning::PullOverConfig* pull_over);
  private:
  const ::apollo::planning::PullOverConfig& _internal_pull_over() const;
  ::apollo::planning::PullOverConfig* _internal_mutable_pull_over();
  public:
  void unsafe_arena_set_allocated_pull_over(
      ::apollo::planning::PullOverConfig* pull_over);
  ::apollo::planning::PullOverConfig* unsafe_arena_release_pull_over();

  // .apollo.planning.ReferenceLineEndConfig reference_line_end = 10;
  bool has_reference_line_end() const;
  private:
  bool _internal_has_reference_line_end() const;
  public:
  void clear_reference_line_end();
  const ::apollo::planning::ReferenceLineEndConfig& reference_line_end() const;
  PROTOBUF_NODISCARD ::apollo::planning::ReferenceLineEndConfig* release_reference_line_end();
  ::apollo::planning::ReferenceLineEndConfig* mutable_reference_line_end();
  void set_allocated_reference_line_end(::apollo::planning::ReferenceLineEndConfig* reference_line_end);
  private:
  const ::apollo::planning::ReferenceLineEndConfig& _internal_reference_line_end() const;
  ::apollo::planning::ReferenceLineEndConfig* _internal_mutable_reference_line_end();
  public:
  void unsafe_arena_set_allocated_reference_line_end(
      ::apollo::planning::ReferenceLineEndConfig* reference_line_end);
  ::apollo::planning::ReferenceLineEndConfig* unsafe_arena_release_reference_line_end();

  // .apollo.planning.ReroutingConfig rerouting = 11;
  bool has_rerouting() const;
  private:
  bool _internal_has_rerouting() const;
  public:
  void clear_rerouting();
  const ::apollo::planning::ReroutingConfig& rerouting() const;
  PROTOBUF_NODISCARD ::apollo::planning::ReroutingConfig* release_rerouting();
  ::apollo::planning::ReroutingConfig* mutable_rerouting();
  void set_allocated_rerouting(::apollo::planning::ReroutingConfig* rerouting);
  private:
  const ::apollo::planning::ReroutingConfig& _internal_rerouting() const;
  ::apollo::planning::ReroutingConfig* _internal_mutable_rerouting();
  public:
  void unsafe_arena_set_allocated_rerouting(
      ::apollo::planning::ReroutingConfig* rerouting);
  ::apollo::planning::ReroutingConfig* unsafe_arena_release_rerouting();

  // .apollo.planning.SignalLightConfig signal_light = 12;
  bool has_signal_light() const;
  private:
  bool _internal_has_signal_light() const;
  public:
  void clear_signal_light();
  const ::apollo::planning::SignalLightConfig& signal_light() const;
  PROTOBUF_NODISCARD ::apollo::planning::SignalLightConfig* release_signal_light();
  ::apollo::planning::SignalLightConfig* mutable_signal_light();
  void set_allocated_signal_light(::apollo::planning::SignalLightConfig* signal_light);
  private:
  const ::apollo::planning::SignalLightConfig& _internal_signal_light() const;
  ::apollo::planning::SignalLightConfig* _internal_mutable_signal_light();
  public:
  void unsafe_arena_set_allocated_signal_light(
      ::apollo::planning::SignalLightConfig* signal_light);
  ::apollo::planning::SignalLightConfig* unsafe_arena_release_signal_light();

  // .apollo.planning.StopSignConfig stop_sign = 13;
  bool has_stop_sign() const;
  private:
  bool _internal_has_stop_sign() const;
  public:
  void clear_stop_sign();
  const ::apollo::planning::StopSignConfig& stop_sign() const;
  PROTOBUF_NODISCARD ::apollo::planning::StopSignConfig* release_stop_sign();
  ::apollo::planning::StopSignConfig* mutable_stop_sign();
  void set_allocated_stop_sign(::apollo::planning::StopSignConfig* stop_sign);
  private:
  const ::apollo::planning::StopSignConfig& _internal_stop_sign() const;
  ::apollo::planning::StopSignConfig* _internal_mutable_stop_sign();
  public:
  void unsafe_arena_set_allocated_stop_sign(
      ::apollo::planning::StopSignConfig* stop_sign);
  ::apollo::planning::StopSignConfig* unsafe_arena_release_stop_sign();

  void clear_config();
  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficRuleConfig)
 private:
  class _Internal;
  void set_has_backside_vehicle();
  void set_has_change_lane();
  void set_has_crosswalk();
  void set_has_destination();
  void set_has_front_vehicle();
  void set_has_keep_clear();
  void set_has_pull_over();
  void set_has_reference_line_end();
  void set_has_rerouting();
  void set_has_signal_light();
  void set_has_stop_sign();

  inline bool has_config() const;
  inline void clear_has_config();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
    int rule_id_;
    union ConfigUnion {
      constexpr ConfigUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::apollo::planning::BacksideVehicleConfig* backside_vehicle_;
      ::apollo::planning::ChangeLaneConfig* change_lane_;
      ::apollo::planning::CrosswalkConfig* crosswalk_;
      ::apollo::planning::DestinationConfig* destination_;
      ::apollo::planning::FrontVehicleConfig* front_vehicle_;
      ::apollo::planning::KeepClearConfig* keep_clear_;
      ::apollo::planning::PullOverConfig* pull_over_;
      ::apollo::planning::ReferenceLineEndConfig* reference_line_end_;
      ::apollo::planning::ReroutingConfig* rerouting_;
      ::apollo::planning::SignalLightConfig* signal_light_;
      ::apollo::planning::StopSignConfig* stop_sign_;
    } config_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TrafficRuleConfigs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficRuleConfigs) */ {
 public:
  inline TrafficRuleConfigs() : TrafficRuleConfigs(nullptr) {}
  ~TrafficRuleConfigs() override;
  explicit PROTOBUF_CONSTEXPR TrafficRuleConfigs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficRuleConfigs(const TrafficRuleConfigs& from);
  TrafficRuleConfigs(TrafficRuleConfigs&& from) noexcept
    : TrafficRuleConfigs() {
    *this = ::std::move(from);
  }

  inline TrafficRuleConfigs& operator=(const TrafficRuleConfigs& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficRuleConfigs& operator=(TrafficRuleConfigs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficRuleConfigs& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficRuleConfigs* internal_default_instance() {
    return reinterpret_cast<const TrafficRuleConfigs*>(
               &_TrafficRuleConfigs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TrafficRuleConfigs& a, TrafficRuleConfigs& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficRuleConfigs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficRuleConfigs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficRuleConfigs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficRuleConfigs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficRuleConfigs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrafficRuleConfigs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficRuleConfigs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficRuleConfigs";
  }
  protected:
  explicit TrafficRuleConfigs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // repeated .apollo.planning.TrafficRuleConfig config = 1;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  ::apollo::planning::TrafficRuleConfig* mutable_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >*
      mutable_config();
  private:
  const ::apollo::planning::TrafficRuleConfig& _internal_config(int index) const;
  ::apollo::planning::TrafficRuleConfig* _internal_add_config();
  public:
  const ::apollo::planning::TrafficRuleConfig& config(int index) const;
  ::apollo::planning::TrafficRuleConfig* add_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >&
      config() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficRuleConfigs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig > config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BacksideVehicleConfig

// optional double backside_lane_width = 1 [default = 4];
inline bool BacksideVehicleConfig::_internal_has_backside_lane_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BacksideVehicleConfig::has_backside_lane_width() const {
  return _internal_has_backside_lane_width();
}
inline void BacksideVehicleConfig::clear_backside_lane_width() {
  _impl_.backside_lane_width_ = 4;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double BacksideVehicleConfig::_internal_backside_lane_width() const {
  return _impl_.backside_lane_width_;
}
inline double BacksideVehicleConfig::backside_lane_width() const {
  // @@protoc_insertion_point(field_get:apollo.planning.BacksideVehicleConfig.backside_lane_width)
  return _internal_backside_lane_width();
}
inline void BacksideVehicleConfig::_internal_set_backside_lane_width(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.backside_lane_width_ = value;
}
inline void BacksideVehicleConfig::set_backside_lane_width(double value) {
  _internal_set_backside_lane_width(value);
  // @@protoc_insertion_point(field_set:apollo.planning.BacksideVehicleConfig.backside_lane_width)
}

// -------------------------------------------------------------------

// ChangeLaneConfig

// optional double min_overtake_distance = 1 [default = 10];
inline bool ChangeLaneConfig::_internal_has_min_overtake_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeLaneConfig::has_min_overtake_distance() const {
  return _internal_has_min_overtake_distance();
}
inline void ChangeLaneConfig::clear_min_overtake_distance() {
  _impl_.min_overtake_distance_ = 10;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ChangeLaneConfig::_internal_min_overtake_distance() const {
  return _impl_.min_overtake_distance_;
}
inline double ChangeLaneConfig::min_overtake_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.min_overtake_distance)
  return _internal_min_overtake_distance();
}
inline void ChangeLaneConfig::_internal_set_min_overtake_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.min_overtake_distance_ = value;
}
inline void ChangeLaneConfig::set_min_overtake_distance(double value) {
  _internal_set_min_overtake_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.min_overtake_distance)
}

// optional double min_overtake_time = 2 [default = 2];
inline bool ChangeLaneConfig::_internal_has_min_overtake_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeLaneConfig::has_min_overtake_time() const {
  return _internal_has_min_overtake_time();
}
inline void ChangeLaneConfig::clear_min_overtake_time() {
  _impl_.min_overtake_time_ = 2;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ChangeLaneConfig::_internal_min_overtake_time() const {
  return _impl_.min_overtake_time_;
}
inline double ChangeLaneConfig::min_overtake_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.min_overtake_time)
  return _internal_min_overtake_time();
}
inline void ChangeLaneConfig::_internal_set_min_overtake_time(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.min_overtake_time_ = value;
}
inline void ChangeLaneConfig::set_min_overtake_time(double value) {
  _internal_set_min_overtake_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.min_overtake_time)
}

// optional bool enable_guard_obstacle = 3 [default = false];
inline bool ChangeLaneConfig::_internal_has_enable_guard_obstacle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeLaneConfig::has_enable_guard_obstacle() const {
  return _internal_has_enable_guard_obstacle();
}
inline void ChangeLaneConfig::clear_enable_guard_obstacle() {
  _impl_.enable_guard_obstacle_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ChangeLaneConfig::_internal_enable_guard_obstacle() const {
  return _impl_.enable_guard_obstacle_;
}
inline bool ChangeLaneConfig::enable_guard_obstacle() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.enable_guard_obstacle)
  return _internal_enable_guard_obstacle();
}
inline void ChangeLaneConfig::_internal_set_enable_guard_obstacle(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enable_guard_obstacle_ = value;
}
inline void ChangeLaneConfig::set_enable_guard_obstacle(bool value) {
  _internal_set_enable_guard_obstacle(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.enable_guard_obstacle)
}

// optional double guard_distance = 4 [default = 100];
inline bool ChangeLaneConfig::_internal_has_guard_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChangeLaneConfig::has_guard_distance() const {
  return _internal_has_guard_distance();
}
inline void ChangeLaneConfig::clear_guard_distance() {
  _impl_.guard_distance_ = 100;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ChangeLaneConfig::_internal_guard_distance() const {
  return _impl_.guard_distance_;
}
inline double ChangeLaneConfig::guard_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.guard_distance)
  return _internal_guard_distance();
}
inline void ChangeLaneConfig::_internal_set_guard_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.guard_distance_ = value;
}
inline void ChangeLaneConfig::set_guard_distance(double value) {
  _internal_set_guard_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.guard_distance)
}

// optional double min_guard_speed = 5 [default = 1];
inline bool ChangeLaneConfig::_internal_has_min_guard_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChangeLaneConfig::has_min_guard_speed() const {
  return _internal_has_min_guard_speed();
}
inline void ChangeLaneConfig::clear_min_guard_speed() {
  _impl_.min_guard_speed_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double ChangeLaneConfig::_internal_min_guard_speed() const {
  return _impl_.min_guard_speed_;
}
inline double ChangeLaneConfig::min_guard_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.min_guard_speed)
  return _internal_min_guard_speed();
}
inline void ChangeLaneConfig::_internal_set_min_guard_speed(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.min_guard_speed_ = value;
}
inline void ChangeLaneConfig::set_min_guard_speed(double value) {
  _internal_set_min_guard_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.min_guard_speed)
}

// -------------------------------------------------------------------

// CreepConfig

// optional bool enabled = 1;
inline bool CreepConfig::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreepConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void CreepConfig::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool CreepConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool CreepConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.enabled)
  return _internal_enabled();
}
inline void CreepConfig::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void CreepConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.enabled)
}

// optional double creep_distance_to_stop_line = 2 [default = 1];
inline bool CreepConfig::_internal_has_creep_distance_to_stop_line() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreepConfig::has_creep_distance_to_stop_line() const {
  return _internal_has_creep_distance_to_stop_line();
}
inline void CreepConfig::clear_creep_distance_to_stop_line() {
  _impl_.creep_distance_to_stop_line_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double CreepConfig::_internal_creep_distance_to_stop_line() const {
  return _impl_.creep_distance_to_stop_line_;
}
inline double CreepConfig::creep_distance_to_stop_line() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.creep_distance_to_stop_line)
  return _internal_creep_distance_to_stop_line();
}
inline void CreepConfig::_internal_set_creep_distance_to_stop_line(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.creep_distance_to_stop_line_ = value;
}
inline void CreepConfig::set_creep_distance_to_stop_line(double value) {
  _internal_set_creep_distance_to_stop_line(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.creep_distance_to_stop_line)
}

// optional double stop_distance = 3 [default = 0.5];
inline bool CreepConfig::_internal_has_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CreepConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void CreepConfig::clear_stop_distance() {
  _impl_.stop_distance_ = 0.5;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double CreepConfig::_internal_stop_distance() const {
  return _impl_.stop_distance_;
}
inline double CreepConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.stop_distance)
  return _internal_stop_distance();
}
inline void CreepConfig::_internal_set_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stop_distance_ = value;
}
inline void CreepConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.stop_distance)
}

// optional double speed_limit = 4 [default = 1];
inline bool CreepConfig::_internal_has_speed_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CreepConfig::has_speed_limit() const {
  return _internal_has_speed_limit();
}
inline void CreepConfig::clear_speed_limit() {
  _impl_.speed_limit_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double CreepConfig::_internal_speed_limit() const {
  return _impl_.speed_limit_;
}
inline double CreepConfig::speed_limit() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.speed_limit)
  return _internal_speed_limit();
}
inline void CreepConfig::_internal_set_speed_limit(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.speed_limit_ = value;
}
inline void CreepConfig::set_speed_limit(double value) {
  _internal_set_speed_limit(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.speed_limit)
}

// optional double max_valid_stop_distance = 5 [default = 0.3];
inline bool CreepConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CreepConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void CreepConfig::clear_max_valid_stop_distance() {
  _impl_.max_valid_stop_distance_ = 0.3;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double CreepConfig::_internal_max_valid_stop_distance() const {
  return _impl_.max_valid_stop_distance_;
}
inline double CreepConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void CreepConfig::_internal_set_max_valid_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.max_valid_stop_distance_ = value;
}
inline void CreepConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.max_valid_stop_distance)
}

// optional double min_boundary_t = 6 [default = 6];
inline bool CreepConfig::_internal_has_min_boundary_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CreepConfig::has_min_boundary_t() const {
  return _internal_has_min_boundary_t();
}
inline void CreepConfig::clear_min_boundary_t() {
  _impl_.min_boundary_t_ = 6;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double CreepConfig::_internal_min_boundary_t() const {
  return _impl_.min_boundary_t_;
}
inline double CreepConfig::min_boundary_t() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.min_boundary_t)
  return _internal_min_boundary_t();
}
inline void CreepConfig::_internal_set_min_boundary_t(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.min_boundary_t_ = value;
}
inline void CreepConfig::set_min_boundary_t(double value) {
  _internal_set_min_boundary_t(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.min_boundary_t)
}

// optional double min_boundary_s = 7 [default = 3];
inline bool CreepConfig::_internal_has_min_boundary_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CreepConfig::has_min_boundary_s() const {
  return _internal_has_min_boundary_s();
}
inline void CreepConfig::clear_min_boundary_s() {
  _impl_.min_boundary_s_ = 3;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double CreepConfig::_internal_min_boundary_s() const {
  return _impl_.min_boundary_s_;
}
inline double CreepConfig::min_boundary_s() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.min_boundary_s)
  return _internal_min_boundary_s();
}
inline void CreepConfig::_internal_set_min_boundary_s(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.min_boundary_s_ = value;
}
inline void CreepConfig::set_min_boundary_s(double value) {
  _internal_set_min_boundary_s(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.min_boundary_s)
}

// -------------------------------------------------------------------

// CrosswalkConfig

// optional double stop_distance = 1 [default = 1];
inline bool CrosswalkConfig::_internal_has_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void CrosswalkConfig::clear_stop_distance() {
  _impl_.stop_distance_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double CrosswalkConfig::_internal_stop_distance() const {
  return _impl_.stop_distance_;
}
inline double CrosswalkConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_distance)
  return _internal_stop_distance();
}
inline void CrosswalkConfig::_internal_set_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_distance_ = value;
}
inline void CrosswalkConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_distance)
}

// optional double max_stop_deceleration = 2 [default = 6];
inline bool CrosswalkConfig::_internal_has_max_stop_deceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_max_stop_deceleration() const {
  return _internal_has_max_stop_deceleration();
}
inline void CrosswalkConfig::clear_max_stop_deceleration() {
  _impl_.max_stop_deceleration_ = 6;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double CrosswalkConfig::_internal_max_stop_deceleration() const {
  return _impl_.max_stop_deceleration_;
}
inline double CrosswalkConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_stop_deceleration)
  return _internal_max_stop_deceleration();
}
inline void CrosswalkConfig::_internal_set_max_stop_deceleration(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_stop_deceleration_ = value;
}
inline void CrosswalkConfig::set_max_stop_deceleration(double value) {
  _internal_set_max_stop_deceleration(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_stop_deceleration)
}

// optional double min_pass_s_distance = 3 [default = 1];
inline bool CrosswalkConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void CrosswalkConfig::clear_min_pass_s_distance() {
  _impl_.min_pass_s_distance_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double CrosswalkConfig::_internal_min_pass_s_distance() const {
  return _impl_.min_pass_s_distance_;
}
inline double CrosswalkConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void CrosswalkConfig::_internal_set_min_pass_s_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.min_pass_s_distance_ = value;
}
inline void CrosswalkConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.min_pass_s_distance)
}

// optional double max_stop_speed = 4 [default = 0.3];
inline bool CrosswalkConfig::_internal_has_max_stop_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_max_stop_speed() const {
  return _internal_has_max_stop_speed();
}
inline void CrosswalkConfig::clear_max_stop_speed() {
  _impl_.max_stop_speed_ = 0.3;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double CrosswalkConfig::_internal_max_stop_speed() const {
  return _impl_.max_stop_speed_;
}
inline double CrosswalkConfig::max_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_stop_speed)
  return _internal_max_stop_speed();
}
inline void CrosswalkConfig::_internal_set_max_stop_speed(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.max_stop_speed_ = value;
}
inline void CrosswalkConfig::set_max_stop_speed(double value) {
  _internal_set_max_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_stop_speed)
}

// optional double max_valid_stop_distance = 5 [default = 3];
inline bool CrosswalkConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void CrosswalkConfig::clear_max_valid_stop_distance() {
  _impl_.max_valid_stop_distance_ = 3;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double CrosswalkConfig::_internal_max_valid_stop_distance() const {
  return _impl_.max_valid_stop_distance_;
}
inline double CrosswalkConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void CrosswalkConfig::_internal_set_max_valid_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.max_valid_stop_distance_ = value;
}
inline void CrosswalkConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_valid_stop_distance)
}

// optional double expand_s_distance = 6 [default = 2];
inline bool CrosswalkConfig::_internal_has_expand_s_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_expand_s_distance() const {
  return _internal_has_expand_s_distance();
}
inline void CrosswalkConfig::clear_expand_s_distance() {
  _impl_.expand_s_distance_ = 2;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double CrosswalkConfig::_internal_expand_s_distance() const {
  return _impl_.expand_s_distance_;
}
inline double CrosswalkConfig::expand_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.expand_s_distance)
  return _internal_expand_s_distance();
}
inline void CrosswalkConfig::_internal_set_expand_s_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.expand_s_distance_ = value;
}
inline void CrosswalkConfig::set_expand_s_distance(double value) {
  _internal_set_expand_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.expand_s_distance)
}

// optional double stop_strick_l_distance = 7 [default = 4];
inline bool CrosswalkConfig::_internal_has_stop_strick_l_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_strick_l_distance() const {
  return _internal_has_stop_strick_l_distance();
}
inline void CrosswalkConfig::clear_stop_strick_l_distance() {
  _impl_.stop_strick_l_distance_ = 4;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double CrosswalkConfig::_internal_stop_strick_l_distance() const {
  return _impl_.stop_strick_l_distance_;
}
inline double CrosswalkConfig::stop_strick_l_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_strick_l_distance)
  return _internal_stop_strick_l_distance();
}
inline void CrosswalkConfig::_internal_set_stop_strick_l_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.stop_strick_l_distance_ = value;
}
inline void CrosswalkConfig::set_stop_strick_l_distance(double value) {
  _internal_set_stop_strick_l_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_strick_l_distance)
}

// optional double stop_loose_l_distance = 8 [default = 5];
inline bool CrosswalkConfig::_internal_has_stop_loose_l_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_loose_l_distance() const {
  return _internal_has_stop_loose_l_distance();
}
inline void CrosswalkConfig::clear_stop_loose_l_distance() {
  _impl_.stop_loose_l_distance_ = 5;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double CrosswalkConfig::_internal_stop_loose_l_distance() const {
  return _impl_.stop_loose_l_distance_;
}
inline double CrosswalkConfig::stop_loose_l_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_loose_l_distance)
  return _internal_stop_loose_l_distance();
}
inline void CrosswalkConfig::_internal_set_stop_loose_l_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.stop_loose_l_distance_ = value;
}
inline void CrosswalkConfig::set_stop_loose_l_distance(double value) {
  _internal_set_stop_loose_l_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_loose_l_distance)
}

// optional double stop_timeout = 9 [default = 10];
inline bool CrosswalkConfig::_internal_has_stop_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_timeout() const {
  return _internal_has_stop_timeout();
}
inline void CrosswalkConfig::clear_stop_timeout() {
  _impl_.stop_timeout_ = 10;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double CrosswalkConfig::_internal_stop_timeout() const {
  return _impl_.stop_timeout_;
}
inline double CrosswalkConfig::stop_timeout() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_timeout)
  return _internal_stop_timeout();
}
inline void CrosswalkConfig::_internal_set_stop_timeout(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.stop_timeout_ = value;
}
inline void CrosswalkConfig::set_stop_timeout(double value) {
  _internal_set_stop_timeout(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_timeout)
}

// -------------------------------------------------------------------

// DestinationConfig

// optional bool enable_pull_over = 1 [default = false];
inline bool DestinationConfig::_internal_has_enable_pull_over() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DestinationConfig::has_enable_pull_over() const {
  return _internal_has_enable_pull_over();
}
inline void DestinationConfig::clear_enable_pull_over() {
  _impl_.enable_pull_over_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DestinationConfig::_internal_enable_pull_over() const {
  return _impl_.enable_pull_over_;
}
inline bool DestinationConfig::enable_pull_over() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationConfig.enable_pull_over)
  return _internal_enable_pull_over();
}
inline void DestinationConfig::_internal_set_enable_pull_over(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enable_pull_over_ = value;
}
inline void DestinationConfig::set_enable_pull_over(bool value) {
  _internal_set_enable_pull_over(value);
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationConfig.enable_pull_over)
}

// optional double stop_distance = 2 [default = 0.5];
inline bool DestinationConfig::_internal_has_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DestinationConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void DestinationConfig::clear_stop_distance() {
  _impl_.stop_distance_ = 0.5;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double DestinationConfig::_internal_stop_distance() const {
  return _impl_.stop_distance_;
}
inline double DestinationConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationConfig.stop_distance)
  return _internal_stop_distance();
}
inline void DestinationConfig::_internal_set_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stop_distance_ = value;
}
inline void DestinationConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationConfig.stop_distance)
}

// optional double pull_over_plan_distance = 3 [default = 35];
inline bool DestinationConfig::_internal_has_pull_over_plan_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DestinationConfig::has_pull_over_plan_distance() const {
  return _internal_has_pull_over_plan_distance();
}
inline void DestinationConfig::clear_pull_over_plan_distance() {
  _impl_.pull_over_plan_distance_ = 35;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double DestinationConfig::_internal_pull_over_plan_distance() const {
  return _impl_.pull_over_plan_distance_;
}
inline double DestinationConfig::pull_over_plan_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationConfig.pull_over_plan_distance)
  return _internal_pull_over_plan_distance();
}
inline void DestinationConfig::_internal_set_pull_over_plan_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pull_over_plan_distance_ = value;
}
inline void DestinationConfig::set_pull_over_plan_distance(double value) {
  _internal_set_pull_over_plan_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationConfig.pull_over_plan_distance)
}

// -------------------------------------------------------------------

// FrontVehicleConfig

// optional bool enable_side_pass = 1 [default = true];
inline bool FrontVehicleConfig::_internal_has_enable_side_pass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FrontVehicleConfig::has_enable_side_pass() const {
  return _internal_has_enable_side_pass();
}
inline void FrontVehicleConfig::clear_enable_side_pass() {
  _impl_.enable_side_pass_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool FrontVehicleConfig::_internal_enable_side_pass() const {
  return _impl_.enable_side_pass_;
}
inline bool FrontVehicleConfig::enable_side_pass() const {
  // @@protoc_insertion_point(field_get:apollo.planning.FrontVehicleConfig.enable_side_pass)
  return _internal_enable_side_pass();
}
inline void FrontVehicleConfig::_internal_set_enable_side_pass(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enable_side_pass_ = value;
}
inline void FrontVehicleConfig::set_enable_side_pass(bool value) {
  _internal_set_enable_side_pass(value);
  // @@protoc_insertion_point(field_set:apollo.planning.FrontVehicleConfig.enable_side_pass)
}

// optional double side_pass_s_threshold = 2 [default = 15];
inline bool FrontVehicleConfig::_internal_has_side_pass_s_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FrontVehicleConfig::has_side_pass_s_threshold() const {
  return _internal_has_side_pass_s_threshold();
}
inline void FrontVehicleConfig::clear_side_pass_s_threshold() {
  _impl_.side_pass_s_threshold_ = 15;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double FrontVehicleConfig::_internal_side_pass_s_threshold() const {
  return _impl_.side_pass_s_threshold_;
}
inline double FrontVehicleConfig::side_pass_s_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.planning.FrontVehicleConfig.side_pass_s_threshold)
  return _internal_side_pass_s_threshold();
}
inline void FrontVehicleConfig::_internal_set_side_pass_s_threshold(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.side_pass_s_threshold_ = value;
}
inline void FrontVehicleConfig::set_side_pass_s_threshold(double value) {
  _internal_set_side_pass_s_threshold(value);
  // @@protoc_insertion_point(field_set:apollo.planning.FrontVehicleConfig.side_pass_s_threshold)
}

// optional double side_pass_l_threshold = 3 [default = 1];
inline bool FrontVehicleConfig::_internal_has_side_pass_l_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FrontVehicleConfig::has_side_pass_l_threshold() const {
  return _internal_has_side_pass_l_threshold();
}
inline void FrontVehicleConfig::clear_side_pass_l_threshold() {
  _impl_.side_pass_l_threshold_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double FrontVehicleConfig::_internal_side_pass_l_threshold() const {
  return _impl_.side_pass_l_threshold_;
}
inline double FrontVehicleConfig::side_pass_l_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.planning.FrontVehicleConfig.side_pass_l_threshold)
  return _internal_side_pass_l_threshold();
}
inline void FrontVehicleConfig::_internal_set_side_pass_l_threshold(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.side_pass_l_threshold_ = value;
}
inline void FrontVehicleConfig::set_side_pass_l_threshold(double value) {
  _internal_set_side_pass_l_threshold(value);
  // @@protoc_insertion_point(field_set:apollo.planning.FrontVehicleConfig.side_pass_l_threshold)
}

// optional double side_pass_wait_time = 4 [default = 30];
inline bool FrontVehicleConfig::_internal_has_side_pass_wait_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FrontVehicleConfig::has_side_pass_wait_time() const {
  return _internal_has_side_pass_wait_time();
}
inline void FrontVehicleConfig::clear_side_pass_wait_time() {
  _impl_.side_pass_wait_time_ = 30;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double FrontVehicleConfig::_internal_side_pass_wait_time() const {
  return _impl_.side_pass_wait_time_;
}
inline double FrontVehicleConfig::side_pass_wait_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.FrontVehicleConfig.side_pass_wait_time)
  return _internal_side_pass_wait_time();
}
inline void FrontVehicleConfig::_internal_set_side_pass_wait_time(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.side_pass_wait_time_ = value;
}
inline void FrontVehicleConfig::set_side_pass_wait_time(double value) {
  _internal_set_side_pass_wait_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.FrontVehicleConfig.side_pass_wait_time)
}

// optional double nudge_l_buffer = 5 [default = 0.5];
inline bool FrontVehicleConfig::_internal_has_nudge_l_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FrontVehicleConfig::has_nudge_l_buffer() const {
  return _internal_has_nudge_l_buffer();
}
inline void FrontVehicleConfig::clear_nudge_l_buffer() {
  _impl_.nudge_l_buffer_ = 0.5;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double FrontVehicleConfig::_internal_nudge_l_buffer() const {
  return _impl_.nudge_l_buffer_;
}
inline double FrontVehicleConfig::nudge_l_buffer() const {
  // @@protoc_insertion_point(field_get:apollo.planning.FrontVehicleConfig.nudge_l_buffer)
  return _internal_nudge_l_buffer();
}
inline void FrontVehicleConfig::_internal_set_nudge_l_buffer(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nudge_l_buffer_ = value;
}
inline void FrontVehicleConfig::set_nudge_l_buffer(double value) {
  _internal_set_nudge_l_buffer(value);
  // @@protoc_insertion_point(field_set:apollo.planning.FrontVehicleConfig.nudge_l_buffer)
}

// -------------------------------------------------------------------

// KeepClearConfig

// optional bool enable_keep_clear_zone = 1 [default = true];
inline bool KeepClearConfig::_internal_has_enable_keep_clear_zone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeepClearConfig::has_enable_keep_clear_zone() const {
  return _internal_has_enable_keep_clear_zone();
}
inline void KeepClearConfig::clear_enable_keep_clear_zone() {
  _impl_.enable_keep_clear_zone_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool KeepClearConfig::_internal_enable_keep_clear_zone() const {
  return _impl_.enable_keep_clear_zone_;
}
inline bool KeepClearConfig::enable_keep_clear_zone() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.enable_keep_clear_zone)
  return _internal_enable_keep_clear_zone();
}
inline void KeepClearConfig::_internal_set_enable_keep_clear_zone(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enable_keep_clear_zone_ = value;
}
inline void KeepClearConfig::set_enable_keep_clear_zone(bool value) {
  _internal_set_enable_keep_clear_zone(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.enable_keep_clear_zone)
}

// optional bool enable_junction = 2 [default = true];
inline bool KeepClearConfig::_internal_has_enable_junction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeepClearConfig::has_enable_junction() const {
  return _internal_has_enable_junction();
}
inline void KeepClearConfig::clear_enable_junction() {
  _impl_.enable_junction_ = true;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool KeepClearConfig::_internal_enable_junction() const {
  return _impl_.enable_junction_;
}
inline bool KeepClearConfig::enable_junction() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.enable_junction)
  return _internal_enable_junction();
}
inline void KeepClearConfig::_internal_set_enable_junction(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enable_junction_ = value;
}
inline void KeepClearConfig::set_enable_junction(bool value) {
  _internal_set_enable_junction(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.enable_junction)
}

// optional double min_pass_s_distance = 3 [default = 2];
inline bool KeepClearConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KeepClearConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void KeepClearConfig::clear_min_pass_s_distance() {
  _impl_.min_pass_s_distance_ = 2;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double KeepClearConfig::_internal_min_pass_s_distance() const {
  return _impl_.min_pass_s_distance_;
}
inline double KeepClearConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void KeepClearConfig::_internal_set_min_pass_s_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.min_pass_s_distance_ = value;
}
inline void KeepClearConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.min_pass_s_distance)
}

// -------------------------------------------------------------------

// PullOverConfig

// optional double stop_distance = 1 [default = 0.5];
inline bool PullOverConfig::_internal_has_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PullOverConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void PullOverConfig::clear_stop_distance() {
  _impl_.stop_distance_ = 0.5;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PullOverConfig::_internal_stop_distance() const {
  return _impl_.stop_distance_;
}
inline double PullOverConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.stop_distance)
  return _internal_stop_distance();
}
inline void PullOverConfig::_internal_set_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stop_distance_ = value;
}
inline void PullOverConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.stop_distance)
}

// optional double max_stop_speed = 2 [default = 0.3];
inline bool PullOverConfig::_internal_has_max_stop_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PullOverConfig::has_max_stop_speed() const {
  return _internal_has_max_stop_speed();
}
inline void PullOverConfig::clear_max_stop_speed() {
  _impl_.max_stop_speed_ = 0.3;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double PullOverConfig::_internal_max_stop_speed() const {
  return _impl_.max_stop_speed_;
}
inline double PullOverConfig::max_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.max_stop_speed)
  return _internal_max_stop_speed();
}
inline void PullOverConfig::_internal_set_max_stop_speed(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_stop_speed_ = value;
}
inline void PullOverConfig::set_max_stop_speed(double value) {
  _internal_set_max_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.max_stop_speed)
}

// optional double max_valid_stop_distance = 3 [default = 3];
inline bool PullOverConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PullOverConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void PullOverConfig::clear_max_valid_stop_distance() {
  _impl_.max_valid_stop_distance_ = 3;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double PullOverConfig::_internal_max_valid_stop_distance() const {
  return _impl_.max_valid_stop_distance_;
}
inline double PullOverConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void PullOverConfig::_internal_set_max_valid_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.max_valid_stop_distance_ = value;
}
inline void PullOverConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.max_valid_stop_distance)
}

// optional double buffer_to_boundary = 4 [default = 0.5];
inline bool PullOverConfig::_internal_has_buffer_to_boundary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PullOverConfig::has_buffer_to_boundary() const {
  return _internal_has_buffer_to_boundary();
}
inline void PullOverConfig::clear_buffer_to_boundary() {
  _impl_.buffer_to_boundary_ = 0.5;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double PullOverConfig::_internal_buffer_to_boundary() const {
  return _impl_.buffer_to_boundary_;
}
inline double PullOverConfig::buffer_to_boundary() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.buffer_to_boundary)
  return _internal_buffer_to_boundary();
}
inline void PullOverConfig::_internal_set_buffer_to_boundary(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.buffer_to_boundary_ = value;
}
inline void PullOverConfig::set_buffer_to_boundary(double value) {
  _internal_set_buffer_to_boundary(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.buffer_to_boundary)
}

// optional double plan_distance = 5 [default = 35];
inline bool PullOverConfig::_internal_has_plan_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PullOverConfig::has_plan_distance() const {
  return _internal_has_plan_distance();
}
inline void PullOverConfig::clear_plan_distance() {
  _impl_.plan_distance_ = 35;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double PullOverConfig::_internal_plan_distance() const {
  return _impl_.plan_distance_;
}
inline double PullOverConfig::plan_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.plan_distance)
  return _internal_plan_distance();
}
inline void PullOverConfig::_internal_set_plan_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.plan_distance_ = value;
}
inline void PullOverConfig::set_plan_distance(double value) {
  _internal_set_plan_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.plan_distance)
}

// optional double operation_length = 6 [default = 30];
inline bool PullOverConfig::_internal_has_operation_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PullOverConfig::has_operation_length() const {
  return _internal_has_operation_length();
}
inline void PullOverConfig::clear_operation_length() {
  _impl_.operation_length_ = 30;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double PullOverConfig::_internal_operation_length() const {
  return _impl_.operation_length_;
}
inline double PullOverConfig::operation_length() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.operation_length)
  return _internal_operation_length();
}
inline void PullOverConfig::_internal_set_operation_length(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.operation_length_ = value;
}
inline void PullOverConfig::set_operation_length(double value) {
  _internal_set_operation_length(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.operation_length)
}

// optional double max_check_distance = 7 [default = 60];
inline bool PullOverConfig::_internal_has_max_check_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PullOverConfig::has_max_check_distance() const {
  return _internal_has_max_check_distance();
}
inline void PullOverConfig::clear_max_check_distance() {
  _impl_.max_check_distance_ = 60;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double PullOverConfig::_internal_max_check_distance() const {
  return _impl_.max_check_distance_;
}
inline double PullOverConfig::max_check_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.max_check_distance)
  return _internal_max_check_distance();
}
inline void PullOverConfig::_internal_set_max_check_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.max_check_distance_ = value;
}
inline void PullOverConfig::set_max_check_distance(double value) {
  _internal_set_max_check_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.max_check_distance)
}

// optional uint32 max_failure_count = 8 [default = 10];
inline bool PullOverConfig::_internal_has_max_failure_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PullOverConfig::has_max_failure_count() const {
  return _internal_has_max_failure_count();
}
inline void PullOverConfig::clear_max_failure_count() {
  _impl_.max_failure_count_ = 10u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t PullOverConfig::_internal_max_failure_count() const {
  return _impl_.max_failure_count_;
}
inline uint32_t PullOverConfig::max_failure_count() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.max_failure_count)
  return _internal_max_failure_count();
}
inline void PullOverConfig::_internal_set_max_failure_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_failure_count_ = value;
}
inline void PullOverConfig::set_max_failure_count(uint32_t value) {
  _internal_set_max_failure_count(value);
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.max_failure_count)
}

// -------------------------------------------------------------------

// ReferenceLineEndConfig

// optional double stop_distance = 1 [default = 0.5];
inline bool ReferenceLineEndConfig::_internal_has_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReferenceLineEndConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void ReferenceLineEndConfig::clear_stop_distance() {
  _impl_.stop_distance_ = 0.5;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ReferenceLineEndConfig::_internal_stop_distance() const {
  return _impl_.stop_distance_;
}
inline double ReferenceLineEndConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReferenceLineEndConfig.stop_distance)
  return _internal_stop_distance();
}
inline void ReferenceLineEndConfig::_internal_set_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_distance_ = value;
}
inline void ReferenceLineEndConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReferenceLineEndConfig.stop_distance)
}

// optional double min_reference_line_remain_length = 2 [default = 50];
inline bool ReferenceLineEndConfig::_internal_has_min_reference_line_remain_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReferenceLineEndConfig::has_min_reference_line_remain_length() const {
  return _internal_has_min_reference_line_remain_length();
}
inline void ReferenceLineEndConfig::clear_min_reference_line_remain_length() {
  _impl_.min_reference_line_remain_length_ = 50;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ReferenceLineEndConfig::_internal_min_reference_line_remain_length() const {
  return _impl_.min_reference_line_remain_length_;
}
inline double ReferenceLineEndConfig::min_reference_line_remain_length() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReferenceLineEndConfig.min_reference_line_remain_length)
  return _internal_min_reference_line_remain_length();
}
inline void ReferenceLineEndConfig::_internal_set_min_reference_line_remain_length(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.min_reference_line_remain_length_ = value;
}
inline void ReferenceLineEndConfig::set_min_reference_line_remain_length(double value) {
  _internal_set_min_reference_line_remain_length(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReferenceLineEndConfig.min_reference_line_remain_length)
}

// -------------------------------------------------------------------

// ReroutingConfig

// optional double cooldown_time = 1 [default = 3];
inline bool ReroutingConfig::_internal_has_cooldown_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReroutingConfig::has_cooldown_time() const {
  return _internal_has_cooldown_time();
}
inline void ReroutingConfig::clear_cooldown_time() {
  _impl_.cooldown_time_ = 3;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ReroutingConfig::_internal_cooldown_time() const {
  return _impl_.cooldown_time_;
}
inline double ReroutingConfig::cooldown_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingConfig.cooldown_time)
  return _internal_cooldown_time();
}
inline void ReroutingConfig::_internal_set_cooldown_time(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cooldown_time_ = value;
}
inline void ReroutingConfig::set_cooldown_time(double value) {
  _internal_set_cooldown_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingConfig.cooldown_time)
}

// optional double prepare_rerouting_time = 2 [default = 2];
inline bool ReroutingConfig::_internal_has_prepare_rerouting_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReroutingConfig::has_prepare_rerouting_time() const {
  return _internal_has_prepare_rerouting_time();
}
inline void ReroutingConfig::clear_prepare_rerouting_time() {
  _impl_.prepare_rerouting_time_ = 2;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ReroutingConfig::_internal_prepare_rerouting_time() const {
  return _impl_.prepare_rerouting_time_;
}
inline double ReroutingConfig::prepare_rerouting_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingConfig.prepare_rerouting_time)
  return _internal_prepare_rerouting_time();
}
inline void ReroutingConfig::_internal_set_prepare_rerouting_time(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.prepare_rerouting_time_ = value;
}
inline void ReroutingConfig::set_prepare_rerouting_time(double value) {
  _internal_set_prepare_rerouting_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingConfig.prepare_rerouting_time)
}

// -------------------------------------------------------------------

// SignalLightConfig

// optional double stop_distance = 1 [default = 1];
inline bool SignalLightConfig::_internal_has_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SignalLightConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void SignalLightConfig::clear_stop_distance() {
  _impl_.stop_distance_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double SignalLightConfig::_internal_stop_distance() const {
  return _impl_.stop_distance_;
}
inline double SignalLightConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.stop_distance)
  return _internal_stop_distance();
}
inline void SignalLightConfig::_internal_set_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stop_distance_ = value;
}
inline void SignalLightConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.SignalLightConfig.stop_distance)
}

// optional double max_stop_deceleration = 2 [default = 6];
inline bool SignalLightConfig::_internal_has_max_stop_deceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SignalLightConfig::has_max_stop_deceleration() const {
  return _internal_has_max_stop_deceleration();
}
inline void SignalLightConfig::clear_max_stop_deceleration() {
  _impl_.max_stop_deceleration_ = 6;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double SignalLightConfig::_internal_max_stop_deceleration() const {
  return _impl_.max_stop_deceleration_;
}
inline double SignalLightConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.max_stop_deceleration)
  return _internal_max_stop_deceleration();
}
inline void SignalLightConfig::_internal_set_max_stop_deceleration(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_stop_deceleration_ = value;
}
inline void SignalLightConfig::set_max_stop_deceleration(double value) {
  _internal_set_max_stop_deceleration(value);
  // @@protoc_insertion_point(field_set:apollo.planning.SignalLightConfig.max_stop_deceleration)
}

// optional double min_pass_s_distance = 3 [default = 4];
inline bool SignalLightConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SignalLightConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void SignalLightConfig::clear_min_pass_s_distance() {
  _impl_.min_pass_s_distance_ = 4;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double SignalLightConfig::_internal_min_pass_s_distance() const {
  return _impl_.min_pass_s_distance_;
}
inline double SignalLightConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void SignalLightConfig::_internal_set_min_pass_s_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.min_pass_s_distance_ = value;
}
inline void SignalLightConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.SignalLightConfig.min_pass_s_distance)
}

// optional double max_stop_deacceleration_yellow_light = 4 [default = 3];
inline bool SignalLightConfig::_internal_has_max_stop_deacceleration_yellow_light() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SignalLightConfig::has_max_stop_deacceleration_yellow_light() const {
  return _internal_has_max_stop_deacceleration_yellow_light();
}
inline void SignalLightConfig::clear_max_stop_deacceleration_yellow_light() {
  _impl_.max_stop_deacceleration_yellow_light_ = 3;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double SignalLightConfig::_internal_max_stop_deacceleration_yellow_light() const {
  return _impl_.max_stop_deacceleration_yellow_light_;
}
inline double SignalLightConfig::max_stop_deacceleration_yellow_light() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.max_stop_deacceleration_yellow_light)
  return _internal_max_stop_deacceleration_yellow_light();
}
inline void SignalLightConfig::_internal_set_max_stop_deacceleration_yellow_light(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.max_stop_deacceleration_yellow_light_ = value;
}
inline void SignalLightConfig::set_max_stop_deacceleration_yellow_light(double value) {
  _internal_set_max_stop_deacceleration_yellow_light(value);
  // @@protoc_insertion_point(field_set:apollo.planning.SignalLightConfig.max_stop_deacceleration_yellow_light)
}

// optional double signal_expire_time_sec = 5 [default = 5];
inline bool SignalLightConfig::_internal_has_signal_expire_time_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SignalLightConfig::has_signal_expire_time_sec() const {
  return _internal_has_signal_expire_time_sec();
}
inline void SignalLightConfig::clear_signal_expire_time_sec() {
  _impl_.signal_expire_time_sec_ = 5;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double SignalLightConfig::_internal_signal_expire_time_sec() const {
  return _impl_.signal_expire_time_sec_;
}
inline double SignalLightConfig::signal_expire_time_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.signal_expire_time_sec)
  return _internal_signal_expire_time_sec();
}
inline void SignalLightConfig::_internal_set_signal_expire_time_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.signal_expire_time_sec_ = value;
}
inline void SignalLightConfig::set_signal_expire_time_sec(double value) {
  _internal_set_signal_expire_time_sec(value);
  // @@protoc_insertion_point(field_set:apollo.planning.SignalLightConfig.signal_expire_time_sec)
}

// optional .apollo.planning.CreepConfig righ_turn_creep = 6;
inline bool SignalLightConfig::_internal_has_righ_turn_creep() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.righ_turn_creep_ != nullptr);
  return value;
}
inline bool SignalLightConfig::has_righ_turn_creep() const {
  return _internal_has_righ_turn_creep();
}
inline void SignalLightConfig::clear_righ_turn_creep() {
  if (_impl_.righ_turn_creep_ != nullptr) _impl_.righ_turn_creep_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::CreepConfig& SignalLightConfig::_internal_righ_turn_creep() const {
  const ::apollo::planning::CreepConfig* p = _impl_.righ_turn_creep_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::CreepConfig&>(
      ::apollo::planning::_CreepConfig_default_instance_);
}
inline const ::apollo::planning::CreepConfig& SignalLightConfig::righ_turn_creep() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.righ_turn_creep)
  return _internal_righ_turn_creep();
}
inline void SignalLightConfig::unsafe_arena_set_allocated_righ_turn_creep(
    ::apollo::planning::CreepConfig* righ_turn_creep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.righ_turn_creep_);
  }
  _impl_.righ_turn_creep_ = righ_turn_creep;
  if (righ_turn_creep) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.SignalLightConfig.righ_turn_creep)
}
inline ::apollo::planning::CreepConfig* SignalLightConfig::release_righ_turn_creep() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::CreepConfig* temp = _impl_.righ_turn_creep_;
  _impl_.righ_turn_creep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::CreepConfig* SignalLightConfig::unsafe_arena_release_righ_turn_creep() {
  // @@protoc_insertion_point(field_release:apollo.planning.SignalLightConfig.righ_turn_creep)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::CreepConfig* temp = _impl_.righ_turn_creep_;
  _impl_.righ_turn_creep_ = nullptr;
  return temp;
}
inline ::apollo::planning::CreepConfig* SignalLightConfig::_internal_mutable_righ_turn_creep() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.righ_turn_creep_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::CreepConfig>(GetArenaForAllocation());
    _impl_.righ_turn_creep_ = p;
  }
  return _impl_.righ_turn_creep_;
}
inline ::apollo::planning::CreepConfig* SignalLightConfig::mutable_righ_turn_creep() {
  ::apollo::planning::CreepConfig* _msg = _internal_mutable_righ_turn_creep();
  // @@protoc_insertion_point(field_mutable:apollo.planning.SignalLightConfig.righ_turn_creep)
  return _msg;
}
inline void SignalLightConfig::set_allocated_righ_turn_creep(::apollo::planning::CreepConfig* righ_turn_creep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.righ_turn_creep_;
  }
  if (righ_turn_creep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(righ_turn_creep);
    if (message_arena != submessage_arena) {
      righ_turn_creep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, righ_turn_creep, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.righ_turn_creep_ = righ_turn_creep;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.SignalLightConfig.righ_turn_creep)
}

// -------------------------------------------------------------------

// StopSignConfig

// optional double stop_distance = 1 [default = 1];
inline bool StopSignConfig::_internal_has_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopSignConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void StopSignConfig::clear_stop_distance() {
  _impl_.stop_distance_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double StopSignConfig::_internal_stop_distance() const {
  return _impl_.stop_distance_;
}
inline double StopSignConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.stop_distance)
  return _internal_stop_distance();
}
inline void StopSignConfig::_internal_set_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stop_distance_ = value;
}
inline void StopSignConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.stop_distance)
}

// optional double min_pass_s_distance = 2 [default = 1];
inline bool StopSignConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StopSignConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void StopSignConfig::clear_min_pass_s_distance() {
  _impl_.min_pass_s_distance_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double StopSignConfig::_internal_min_pass_s_distance() const {
  return _impl_.min_pass_s_distance_;
}
inline double StopSignConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void StopSignConfig::_internal_set_min_pass_s_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.min_pass_s_distance_ = value;
}
inline void StopSignConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.min_pass_s_distance)
}

// optional double max_stop_speed = 3 [default = 0.3];
inline bool StopSignConfig::_internal_has_max_stop_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StopSignConfig::has_max_stop_speed() const {
  return _internal_has_max_stop_speed();
}
inline void StopSignConfig::clear_max_stop_speed() {
  _impl_.max_stop_speed_ = 0.3;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double StopSignConfig::_internal_max_stop_speed() const {
  return _impl_.max_stop_speed_;
}
inline double StopSignConfig::max_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.max_stop_speed)
  return _internal_max_stop_speed();
}
inline void StopSignConfig::_internal_set_max_stop_speed(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.max_stop_speed_ = value;
}
inline void StopSignConfig::set_max_stop_speed(double value) {
  _internal_set_max_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.max_stop_speed)
}

// optional double max_valid_stop_distance = 4 [default = 3];
inline bool StopSignConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StopSignConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void StopSignConfig::clear_max_valid_stop_distance() {
  _impl_.max_valid_stop_distance_ = 3;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double StopSignConfig::_internal_max_valid_stop_distance() const {
  return _impl_.max_valid_stop_distance_;
}
inline double StopSignConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void StopSignConfig::_internal_set_max_valid_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.max_valid_stop_distance_ = value;
}
inline void StopSignConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.max_valid_stop_distance)
}

// optional double stop_duration = 5 [default = 1];
inline bool StopSignConfig::_internal_has_stop_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StopSignConfig::has_stop_duration() const {
  return _internal_has_stop_duration();
}
inline void StopSignConfig::clear_stop_duration() {
  _impl_.stop_duration_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double StopSignConfig::_internal_stop_duration() const {
  return _impl_.stop_duration_;
}
inline double StopSignConfig::stop_duration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.stop_duration)
  return _internal_stop_duration();
}
inline void StopSignConfig::_internal_set_stop_duration(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.stop_duration_ = value;
}
inline void StopSignConfig::set_stop_duration(double value) {
  _internal_set_stop_duration(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.stop_duration)
}

// optional double watch_vehicle_max_valid_stop_speed = 6 [default = 0.5];
inline bool StopSignConfig::_internal_has_watch_vehicle_max_valid_stop_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StopSignConfig::has_watch_vehicle_max_valid_stop_speed() const {
  return _internal_has_watch_vehicle_max_valid_stop_speed();
}
inline void StopSignConfig::clear_watch_vehicle_max_valid_stop_speed() {
  _impl_.watch_vehicle_max_valid_stop_speed_ = 0.5;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double StopSignConfig::_internal_watch_vehicle_max_valid_stop_speed() const {
  return _impl_.watch_vehicle_max_valid_stop_speed_;
}
inline double StopSignConfig::watch_vehicle_max_valid_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.watch_vehicle_max_valid_stop_speed)
  return _internal_watch_vehicle_max_valid_stop_speed();
}
inline void StopSignConfig::_internal_set_watch_vehicle_max_valid_stop_speed(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.watch_vehicle_max_valid_stop_speed_ = value;
}
inline void StopSignConfig::set_watch_vehicle_max_valid_stop_speed(double value) {
  _internal_set_watch_vehicle_max_valid_stop_speed(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.watch_vehicle_max_valid_stop_speed)
}

// optional double watch_vehicle_max_valid_stop_distance = 7 [default = 5];
inline bool StopSignConfig::_internal_has_watch_vehicle_max_valid_stop_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StopSignConfig::has_watch_vehicle_max_valid_stop_distance() const {
  return _internal_has_watch_vehicle_max_valid_stop_distance();
}
inline void StopSignConfig::clear_watch_vehicle_max_valid_stop_distance() {
  _impl_.watch_vehicle_max_valid_stop_distance_ = 5;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double StopSignConfig::_internal_watch_vehicle_max_valid_stop_distance() const {
  return _impl_.watch_vehicle_max_valid_stop_distance_;
}
inline double StopSignConfig::watch_vehicle_max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.watch_vehicle_max_valid_stop_distance)
  return _internal_watch_vehicle_max_valid_stop_distance();
}
inline void StopSignConfig::_internal_set_watch_vehicle_max_valid_stop_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.watch_vehicle_max_valid_stop_distance_ = value;
}
inline void StopSignConfig::set_watch_vehicle_max_valid_stop_distance(double value) {
  _internal_set_watch_vehicle_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.watch_vehicle_max_valid_stop_distance)
}

// optional double wait_timeout = 8 [default = 8];
inline bool StopSignConfig::_internal_has_wait_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StopSignConfig::has_wait_timeout() const {
  return _internal_has_wait_timeout();
}
inline void StopSignConfig::clear_wait_timeout() {
  _impl_.wait_timeout_ = 8;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double StopSignConfig::_internal_wait_timeout() const {
  return _impl_.wait_timeout_;
}
inline double StopSignConfig::wait_timeout() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.wait_timeout)
  return _internal_wait_timeout();
}
inline void StopSignConfig::_internal_set_wait_timeout(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.wait_timeout_ = value;
}
inline void StopSignConfig::set_wait_timeout(double value) {
  _internal_set_wait_timeout(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.wait_timeout)
}

// optional .apollo.planning.CreepConfig creep = 9;
inline bool StopSignConfig::_internal_has_creep() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creep_ != nullptr);
  return value;
}
inline bool StopSignConfig::has_creep() const {
  return _internal_has_creep();
}
inline void StopSignConfig::clear_creep() {
  if (_impl_.creep_ != nullptr) _impl_.creep_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::CreepConfig& StopSignConfig::_internal_creep() const {
  const ::apollo::planning::CreepConfig* p = _impl_.creep_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::planning::CreepConfig&>(
      ::apollo::planning::_CreepConfig_default_instance_);
}
inline const ::apollo::planning::CreepConfig& StopSignConfig::creep() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.creep)
  return _internal_creep();
}
inline void StopSignConfig::unsafe_arena_set_allocated_creep(
    ::apollo::planning::CreepConfig* creep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creep_);
  }
  _impl_.creep_ = creep;
  if (creep) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.StopSignConfig.creep)
}
inline ::apollo::planning::CreepConfig* StopSignConfig::release_creep() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::CreepConfig* temp = _impl_.creep_;
  _impl_.creep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::planning::CreepConfig* StopSignConfig::unsafe_arena_release_creep() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopSignConfig.creep)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::planning::CreepConfig* temp = _impl_.creep_;
  _impl_.creep_ = nullptr;
  return temp;
}
inline ::apollo::planning::CreepConfig* StopSignConfig::_internal_mutable_creep() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.creep_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::planning::CreepConfig>(GetArenaForAllocation());
    _impl_.creep_ = p;
  }
  return _impl_.creep_;
}
inline ::apollo::planning::CreepConfig* StopSignConfig::mutable_creep() {
  ::apollo::planning::CreepConfig* _msg = _internal_mutable_creep();
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignConfig.creep)
  return _msg;
}
inline void StopSignConfig::set_allocated_creep(::apollo::planning::CreepConfig* creep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.creep_;
  }
  if (creep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(creep);
    if (message_arena != submessage_arena) {
      creep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creep, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.creep_ = creep;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopSignConfig.creep)
}

// -------------------------------------------------------------------

// TrafficRuleConfig

// optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
inline bool TrafficRuleConfig::_internal_has_rule_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficRuleConfig::has_rule_id() const {
  return _internal_has_rule_id();
}
inline void TrafficRuleConfig::clear_rule_id() {
  _impl_.rule_id_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::planning::TrafficRuleConfig_RuleId TrafficRuleConfig::_internal_rule_id() const {
  return static_cast< ::apollo::planning::TrafficRuleConfig_RuleId >(_impl_.rule_id_);
}
inline ::apollo::planning::TrafficRuleConfig_RuleId TrafficRuleConfig::rule_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.rule_id)
  return _internal_rule_id();
}
inline void TrafficRuleConfig::_internal_set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value) {
  assert(::apollo::planning::TrafficRuleConfig_RuleId_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rule_id_ = value;
}
inline void TrafficRuleConfig::set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value) {
  _internal_set_rule_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficRuleConfig.rule_id)
}

// optional bool enabled = 2;
inline bool TrafficRuleConfig::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficRuleConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void TrafficRuleConfig::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool TrafficRuleConfig::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool TrafficRuleConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.enabled)
  return _internal_enabled();
}
inline void TrafficRuleConfig::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void TrafficRuleConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficRuleConfig.enabled)
}

// .apollo.planning.BacksideVehicleConfig backside_vehicle = 3;
inline bool TrafficRuleConfig::_internal_has_backside_vehicle() const {
  return config_case() == kBacksideVehicle;
}
inline bool TrafficRuleConfig::has_backside_vehicle() const {
  return _internal_has_backside_vehicle();
}
inline void TrafficRuleConfig::set_has_backside_vehicle() {
  _impl_._oneof_case_[0] = kBacksideVehicle;
}
inline void TrafficRuleConfig::clear_backside_vehicle() {
  if (_internal_has_backside_vehicle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.backside_vehicle_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::release_backside_vehicle() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.backside_vehicle)
  if (_internal_has_backside_vehicle()) {
    clear_has_config();
    ::apollo::planning::BacksideVehicleConfig* temp = _impl_.config_.backside_vehicle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.backside_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::BacksideVehicleConfig& TrafficRuleConfig::_internal_backside_vehicle() const {
  return _internal_has_backside_vehicle()
      ? *_impl_.config_.backside_vehicle_
      : reinterpret_cast< ::apollo::planning::BacksideVehicleConfig&>(::apollo::planning::_BacksideVehicleConfig_default_instance_);
}
inline const ::apollo::planning::BacksideVehicleConfig& TrafficRuleConfig::backside_vehicle() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.backside_vehicle)
  return _internal_backside_vehicle();
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::unsafe_arena_release_backside_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.backside_vehicle)
  if (_internal_has_backside_vehicle()) {
    clear_has_config();
    ::apollo::planning::BacksideVehicleConfig* temp = _impl_.config_.backside_vehicle_;
    _impl_.config_.backside_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_backside_vehicle(::apollo::planning::BacksideVehicleConfig* backside_vehicle) {
  clear_config();
  if (backside_vehicle) {
    set_has_backside_vehicle();
    _impl_.config_.backside_vehicle_ = backside_vehicle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.backside_vehicle)
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::_internal_mutable_backside_vehicle() {
  if (!_internal_has_backside_vehicle()) {
    clear_config();
    set_has_backside_vehicle();
    _impl_.config_.backside_vehicle_ = CreateMaybeMessage< ::apollo::planning::BacksideVehicleConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.backside_vehicle_;
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::mutable_backside_vehicle() {
  ::apollo::planning::BacksideVehicleConfig* _msg = _internal_mutable_backside_vehicle();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.backside_vehicle)
  return _msg;
}

// .apollo.planning.ChangeLaneConfig change_lane = 4;
inline bool TrafficRuleConfig::_internal_has_change_lane() const {
  return config_case() == kChangeLane;
}
inline bool TrafficRuleConfig::has_change_lane() const {
  return _internal_has_change_lane();
}
inline void TrafficRuleConfig::set_has_change_lane() {
  _impl_._oneof_case_[0] = kChangeLane;
}
inline void TrafficRuleConfig::clear_change_lane() {
  if (_internal_has_change_lane()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.change_lane_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::ChangeLaneConfig* TrafficRuleConfig::release_change_lane() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.change_lane)
  if (_internal_has_change_lane()) {
    clear_has_config();
    ::apollo::planning::ChangeLaneConfig* temp = _impl_.config_.change_lane_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.change_lane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ChangeLaneConfig& TrafficRuleConfig::_internal_change_lane() const {
  return _internal_has_change_lane()
      ? *_impl_.config_.change_lane_
      : reinterpret_cast< ::apollo::planning::ChangeLaneConfig&>(::apollo::planning::_ChangeLaneConfig_default_instance_);
}
inline const ::apollo::planning::ChangeLaneConfig& TrafficRuleConfig::change_lane() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.change_lane)
  return _internal_change_lane();
}
inline ::apollo::planning::ChangeLaneConfig* TrafficRuleConfig::unsafe_arena_release_change_lane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.change_lane)
  if (_internal_has_change_lane()) {
    clear_has_config();
    ::apollo::planning::ChangeLaneConfig* temp = _impl_.config_.change_lane_;
    _impl_.config_.change_lane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_change_lane(::apollo::planning::ChangeLaneConfig* change_lane) {
  clear_config();
  if (change_lane) {
    set_has_change_lane();
    _impl_.config_.change_lane_ = change_lane;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.change_lane)
}
inline ::apollo::planning::ChangeLaneConfig* TrafficRuleConfig::_internal_mutable_change_lane() {
  if (!_internal_has_change_lane()) {
    clear_config();
    set_has_change_lane();
    _impl_.config_.change_lane_ = CreateMaybeMessage< ::apollo::planning::ChangeLaneConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.change_lane_;
}
inline ::apollo::planning::ChangeLaneConfig* TrafficRuleConfig::mutable_change_lane() {
  ::apollo::planning::ChangeLaneConfig* _msg = _internal_mutable_change_lane();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.change_lane)
  return _msg;
}

// .apollo.planning.CrosswalkConfig crosswalk = 5;
inline bool TrafficRuleConfig::_internal_has_crosswalk() const {
  return config_case() == kCrosswalk;
}
inline bool TrafficRuleConfig::has_crosswalk() const {
  return _internal_has_crosswalk();
}
inline void TrafficRuleConfig::set_has_crosswalk() {
  _impl_._oneof_case_[0] = kCrosswalk;
}
inline void TrafficRuleConfig::clear_crosswalk() {
  if (_internal_has_crosswalk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.crosswalk_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::release_crosswalk() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.crosswalk)
  if (_internal_has_crosswalk()) {
    clear_has_config();
    ::apollo::planning::CrosswalkConfig* temp = _impl_.config_.crosswalk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.crosswalk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::CrosswalkConfig& TrafficRuleConfig::_internal_crosswalk() const {
  return _internal_has_crosswalk()
      ? *_impl_.config_.crosswalk_
      : reinterpret_cast< ::apollo::planning::CrosswalkConfig&>(::apollo::planning::_CrosswalkConfig_default_instance_);
}
inline const ::apollo::planning::CrosswalkConfig& TrafficRuleConfig::crosswalk() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.crosswalk)
  return _internal_crosswalk();
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::unsafe_arena_release_crosswalk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.crosswalk)
  if (_internal_has_crosswalk()) {
    clear_has_config();
    ::apollo::planning::CrosswalkConfig* temp = _impl_.config_.crosswalk_;
    _impl_.config_.crosswalk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_crosswalk(::apollo::planning::CrosswalkConfig* crosswalk) {
  clear_config();
  if (crosswalk) {
    set_has_crosswalk();
    _impl_.config_.crosswalk_ = crosswalk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.crosswalk)
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::_internal_mutable_crosswalk() {
  if (!_internal_has_crosswalk()) {
    clear_config();
    set_has_crosswalk();
    _impl_.config_.crosswalk_ = CreateMaybeMessage< ::apollo::planning::CrosswalkConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.crosswalk_;
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::mutable_crosswalk() {
  ::apollo::planning::CrosswalkConfig* _msg = _internal_mutable_crosswalk();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.crosswalk)
  return _msg;
}

// .apollo.planning.DestinationConfig destination = 6;
inline bool TrafficRuleConfig::_internal_has_destination() const {
  return config_case() == kDestination;
}
inline bool TrafficRuleConfig::has_destination() const {
  return _internal_has_destination();
}
inline void TrafficRuleConfig::set_has_destination() {
  _impl_._oneof_case_[0] = kDestination;
}
inline void TrafficRuleConfig::clear_destination() {
  if (_internal_has_destination()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.destination_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::release_destination() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.destination)
  if (_internal_has_destination()) {
    clear_has_config();
    ::apollo::planning::DestinationConfig* temp = _impl_.config_.destination_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.destination_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::DestinationConfig& TrafficRuleConfig::_internal_destination() const {
  return _internal_has_destination()
      ? *_impl_.config_.destination_
      : reinterpret_cast< ::apollo::planning::DestinationConfig&>(::apollo::planning::_DestinationConfig_default_instance_);
}
inline const ::apollo::planning::DestinationConfig& TrafficRuleConfig::destination() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.destination)
  return _internal_destination();
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::unsafe_arena_release_destination() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.destination)
  if (_internal_has_destination()) {
    clear_has_config();
    ::apollo::planning::DestinationConfig* temp = _impl_.config_.destination_;
    _impl_.config_.destination_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_destination(::apollo::planning::DestinationConfig* destination) {
  clear_config();
  if (destination) {
    set_has_destination();
    _impl_.config_.destination_ = destination;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.destination)
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::_internal_mutable_destination() {
  if (!_internal_has_destination()) {
    clear_config();
    set_has_destination();
    _impl_.config_.destination_ = CreateMaybeMessage< ::apollo::planning::DestinationConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.destination_;
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::mutable_destination() {
  ::apollo::planning::DestinationConfig* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.destination)
  return _msg;
}

// .apollo.planning.FrontVehicleConfig front_vehicle = 7;
inline bool TrafficRuleConfig::_internal_has_front_vehicle() const {
  return config_case() == kFrontVehicle;
}
inline bool TrafficRuleConfig::has_front_vehicle() const {
  return _internal_has_front_vehicle();
}
inline void TrafficRuleConfig::set_has_front_vehicle() {
  _impl_._oneof_case_[0] = kFrontVehicle;
}
inline void TrafficRuleConfig::clear_front_vehicle() {
  if (_internal_has_front_vehicle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.front_vehicle_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::FrontVehicleConfig* TrafficRuleConfig::release_front_vehicle() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.front_vehicle)
  if (_internal_has_front_vehicle()) {
    clear_has_config();
    ::apollo::planning::FrontVehicleConfig* temp = _impl_.config_.front_vehicle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.front_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::FrontVehicleConfig& TrafficRuleConfig::_internal_front_vehicle() const {
  return _internal_has_front_vehicle()
      ? *_impl_.config_.front_vehicle_
      : reinterpret_cast< ::apollo::planning::FrontVehicleConfig&>(::apollo::planning::_FrontVehicleConfig_default_instance_);
}
inline const ::apollo::planning::FrontVehicleConfig& TrafficRuleConfig::front_vehicle() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.front_vehicle)
  return _internal_front_vehicle();
}
inline ::apollo::planning::FrontVehicleConfig* TrafficRuleConfig::unsafe_arena_release_front_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.front_vehicle)
  if (_internal_has_front_vehicle()) {
    clear_has_config();
    ::apollo::planning::FrontVehicleConfig* temp = _impl_.config_.front_vehicle_;
    _impl_.config_.front_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_front_vehicle(::apollo::planning::FrontVehicleConfig* front_vehicle) {
  clear_config();
  if (front_vehicle) {
    set_has_front_vehicle();
    _impl_.config_.front_vehicle_ = front_vehicle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.front_vehicle)
}
inline ::apollo::planning::FrontVehicleConfig* TrafficRuleConfig::_internal_mutable_front_vehicle() {
  if (!_internal_has_front_vehicle()) {
    clear_config();
    set_has_front_vehicle();
    _impl_.config_.front_vehicle_ = CreateMaybeMessage< ::apollo::planning::FrontVehicleConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.front_vehicle_;
}
inline ::apollo::planning::FrontVehicleConfig* TrafficRuleConfig::mutable_front_vehicle() {
  ::apollo::planning::FrontVehicleConfig* _msg = _internal_mutable_front_vehicle();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.front_vehicle)
  return _msg;
}

// .apollo.planning.KeepClearConfig keep_clear = 8;
inline bool TrafficRuleConfig::_internal_has_keep_clear() const {
  return config_case() == kKeepClear;
}
inline bool TrafficRuleConfig::has_keep_clear() const {
  return _internal_has_keep_clear();
}
inline void TrafficRuleConfig::set_has_keep_clear() {
  _impl_._oneof_case_[0] = kKeepClear;
}
inline void TrafficRuleConfig::clear_keep_clear() {
  if (_internal_has_keep_clear()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.keep_clear_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::release_keep_clear() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.keep_clear)
  if (_internal_has_keep_clear()) {
    clear_has_config();
    ::apollo::planning::KeepClearConfig* temp = _impl_.config_.keep_clear_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.keep_clear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::KeepClearConfig& TrafficRuleConfig::_internal_keep_clear() const {
  return _internal_has_keep_clear()
      ? *_impl_.config_.keep_clear_
      : reinterpret_cast< ::apollo::planning::KeepClearConfig&>(::apollo::planning::_KeepClearConfig_default_instance_);
}
inline const ::apollo::planning::KeepClearConfig& TrafficRuleConfig::keep_clear() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.keep_clear)
  return _internal_keep_clear();
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::unsafe_arena_release_keep_clear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.keep_clear)
  if (_internal_has_keep_clear()) {
    clear_has_config();
    ::apollo::planning::KeepClearConfig* temp = _impl_.config_.keep_clear_;
    _impl_.config_.keep_clear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_keep_clear(::apollo::planning::KeepClearConfig* keep_clear) {
  clear_config();
  if (keep_clear) {
    set_has_keep_clear();
    _impl_.config_.keep_clear_ = keep_clear;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.keep_clear)
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::_internal_mutable_keep_clear() {
  if (!_internal_has_keep_clear()) {
    clear_config();
    set_has_keep_clear();
    _impl_.config_.keep_clear_ = CreateMaybeMessage< ::apollo::planning::KeepClearConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.keep_clear_;
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::mutable_keep_clear() {
  ::apollo::planning::KeepClearConfig* _msg = _internal_mutable_keep_clear();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.keep_clear)
  return _msg;
}

// .apollo.planning.PullOverConfig pull_over = 9;
inline bool TrafficRuleConfig::_internal_has_pull_over() const {
  return config_case() == kPullOver;
}
inline bool TrafficRuleConfig::has_pull_over() const {
  return _internal_has_pull_over();
}
inline void TrafficRuleConfig::set_has_pull_over() {
  _impl_._oneof_case_[0] = kPullOver;
}
inline void TrafficRuleConfig::clear_pull_over() {
  if (_internal_has_pull_over()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.pull_over_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::PullOverConfig* TrafficRuleConfig::release_pull_over() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.pull_over)
  if (_internal_has_pull_over()) {
    clear_has_config();
    ::apollo::planning::PullOverConfig* temp = _impl_.config_.pull_over_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.pull_over_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::PullOverConfig& TrafficRuleConfig::_internal_pull_over() const {
  return _internal_has_pull_over()
      ? *_impl_.config_.pull_over_
      : reinterpret_cast< ::apollo::planning::PullOverConfig&>(::apollo::planning::_PullOverConfig_default_instance_);
}
inline const ::apollo::planning::PullOverConfig& TrafficRuleConfig::pull_over() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.pull_over)
  return _internal_pull_over();
}
inline ::apollo::planning::PullOverConfig* TrafficRuleConfig::unsafe_arena_release_pull_over() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.pull_over)
  if (_internal_has_pull_over()) {
    clear_has_config();
    ::apollo::planning::PullOverConfig* temp = _impl_.config_.pull_over_;
    _impl_.config_.pull_over_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_pull_over(::apollo::planning::PullOverConfig* pull_over) {
  clear_config();
  if (pull_over) {
    set_has_pull_over();
    _impl_.config_.pull_over_ = pull_over;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.pull_over)
}
inline ::apollo::planning::PullOverConfig* TrafficRuleConfig::_internal_mutable_pull_over() {
  if (!_internal_has_pull_over()) {
    clear_config();
    set_has_pull_over();
    _impl_.config_.pull_over_ = CreateMaybeMessage< ::apollo::planning::PullOverConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.pull_over_;
}
inline ::apollo::planning::PullOverConfig* TrafficRuleConfig::mutable_pull_over() {
  ::apollo::planning::PullOverConfig* _msg = _internal_mutable_pull_over();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.pull_over)
  return _msg;
}

// .apollo.planning.ReferenceLineEndConfig reference_line_end = 10;
inline bool TrafficRuleConfig::_internal_has_reference_line_end() const {
  return config_case() == kReferenceLineEnd;
}
inline bool TrafficRuleConfig::has_reference_line_end() const {
  return _internal_has_reference_line_end();
}
inline void TrafficRuleConfig::set_has_reference_line_end() {
  _impl_._oneof_case_[0] = kReferenceLineEnd;
}
inline void TrafficRuleConfig::clear_reference_line_end() {
  if (_internal_has_reference_line_end()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.reference_line_end_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::release_reference_line_end() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.reference_line_end)
  if (_internal_has_reference_line_end()) {
    clear_has_config();
    ::apollo::planning::ReferenceLineEndConfig* temp = _impl_.config_.reference_line_end_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.reference_line_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ReferenceLineEndConfig& TrafficRuleConfig::_internal_reference_line_end() const {
  return _internal_has_reference_line_end()
      ? *_impl_.config_.reference_line_end_
      : reinterpret_cast< ::apollo::planning::ReferenceLineEndConfig&>(::apollo::planning::_ReferenceLineEndConfig_default_instance_);
}
inline const ::apollo::planning::ReferenceLineEndConfig& TrafficRuleConfig::reference_line_end() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.reference_line_end)
  return _internal_reference_line_end();
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::unsafe_arena_release_reference_line_end() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.reference_line_end)
  if (_internal_has_reference_line_end()) {
    clear_has_config();
    ::apollo::planning::ReferenceLineEndConfig* temp = _impl_.config_.reference_line_end_;
    _impl_.config_.reference_line_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_reference_line_end(::apollo::planning::ReferenceLineEndConfig* reference_line_end) {
  clear_config();
  if (reference_line_end) {
    set_has_reference_line_end();
    _impl_.config_.reference_line_end_ = reference_line_end;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.reference_line_end)
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::_internal_mutable_reference_line_end() {
  if (!_internal_has_reference_line_end()) {
    clear_config();
    set_has_reference_line_end();
    _impl_.config_.reference_line_end_ = CreateMaybeMessage< ::apollo::planning::ReferenceLineEndConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.reference_line_end_;
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::mutable_reference_line_end() {
  ::apollo::planning::ReferenceLineEndConfig* _msg = _internal_mutable_reference_line_end();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.reference_line_end)
  return _msg;
}

// .apollo.planning.ReroutingConfig rerouting = 11;
inline bool TrafficRuleConfig::_internal_has_rerouting() const {
  return config_case() == kRerouting;
}
inline bool TrafficRuleConfig::has_rerouting() const {
  return _internal_has_rerouting();
}
inline void TrafficRuleConfig::set_has_rerouting() {
  _impl_._oneof_case_[0] = kRerouting;
}
inline void TrafficRuleConfig::clear_rerouting() {
  if (_internal_has_rerouting()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.rerouting_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::release_rerouting() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.rerouting)
  if (_internal_has_rerouting()) {
    clear_has_config();
    ::apollo::planning::ReroutingConfig* temp = _impl_.config_.rerouting_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.rerouting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ReroutingConfig& TrafficRuleConfig::_internal_rerouting() const {
  return _internal_has_rerouting()
      ? *_impl_.config_.rerouting_
      : reinterpret_cast< ::apollo::planning::ReroutingConfig&>(::apollo::planning::_ReroutingConfig_default_instance_);
}
inline const ::apollo::planning::ReroutingConfig& TrafficRuleConfig::rerouting() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.rerouting)
  return _internal_rerouting();
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::unsafe_arena_release_rerouting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.rerouting)
  if (_internal_has_rerouting()) {
    clear_has_config();
    ::apollo::planning::ReroutingConfig* temp = _impl_.config_.rerouting_;
    _impl_.config_.rerouting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_rerouting(::apollo::planning::ReroutingConfig* rerouting) {
  clear_config();
  if (rerouting) {
    set_has_rerouting();
    _impl_.config_.rerouting_ = rerouting;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.rerouting)
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::_internal_mutable_rerouting() {
  if (!_internal_has_rerouting()) {
    clear_config();
    set_has_rerouting();
    _impl_.config_.rerouting_ = CreateMaybeMessage< ::apollo::planning::ReroutingConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.rerouting_;
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::mutable_rerouting() {
  ::apollo::planning::ReroutingConfig* _msg = _internal_mutable_rerouting();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.rerouting)
  return _msg;
}

// .apollo.planning.SignalLightConfig signal_light = 12;
inline bool TrafficRuleConfig::_internal_has_signal_light() const {
  return config_case() == kSignalLight;
}
inline bool TrafficRuleConfig::has_signal_light() const {
  return _internal_has_signal_light();
}
inline void TrafficRuleConfig::set_has_signal_light() {
  _impl_._oneof_case_[0] = kSignalLight;
}
inline void TrafficRuleConfig::clear_signal_light() {
  if (_internal_has_signal_light()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.signal_light_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::SignalLightConfig* TrafficRuleConfig::release_signal_light() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.signal_light)
  if (_internal_has_signal_light()) {
    clear_has_config();
    ::apollo::planning::SignalLightConfig* temp = _impl_.config_.signal_light_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.signal_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::SignalLightConfig& TrafficRuleConfig::_internal_signal_light() const {
  return _internal_has_signal_light()
      ? *_impl_.config_.signal_light_
      : reinterpret_cast< ::apollo::planning::SignalLightConfig&>(::apollo::planning::_SignalLightConfig_default_instance_);
}
inline const ::apollo::planning::SignalLightConfig& TrafficRuleConfig::signal_light() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.signal_light)
  return _internal_signal_light();
}
inline ::apollo::planning::SignalLightConfig* TrafficRuleConfig::unsafe_arena_release_signal_light() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.signal_light)
  if (_internal_has_signal_light()) {
    clear_has_config();
    ::apollo::planning::SignalLightConfig* temp = _impl_.config_.signal_light_;
    _impl_.config_.signal_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_signal_light(::apollo::planning::SignalLightConfig* signal_light) {
  clear_config();
  if (signal_light) {
    set_has_signal_light();
    _impl_.config_.signal_light_ = signal_light;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.signal_light)
}
inline ::apollo::planning::SignalLightConfig* TrafficRuleConfig::_internal_mutable_signal_light() {
  if (!_internal_has_signal_light()) {
    clear_config();
    set_has_signal_light();
    _impl_.config_.signal_light_ = CreateMaybeMessage< ::apollo::planning::SignalLightConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.signal_light_;
}
inline ::apollo::planning::SignalLightConfig* TrafficRuleConfig::mutable_signal_light() {
  ::apollo::planning::SignalLightConfig* _msg = _internal_mutable_signal_light();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.signal_light)
  return _msg;
}

// .apollo.planning.StopSignConfig stop_sign = 13;
inline bool TrafficRuleConfig::_internal_has_stop_sign() const {
  return config_case() == kStopSign;
}
inline bool TrafficRuleConfig::has_stop_sign() const {
  return _internal_has_stop_sign();
}
inline void TrafficRuleConfig::set_has_stop_sign() {
  _impl_._oneof_case_[0] = kStopSign;
}
inline void TrafficRuleConfig::clear_stop_sign() {
  if (_internal_has_stop_sign()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.stop_sign_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::release_stop_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.stop_sign)
  if (_internal_has_stop_sign()) {
    clear_has_config();
    ::apollo::planning::StopSignConfig* temp = _impl_.config_.stop_sign_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.stop_sign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::StopSignConfig& TrafficRuleConfig::_internal_stop_sign() const {
  return _internal_has_stop_sign()
      ? *_impl_.config_.stop_sign_
      : reinterpret_cast< ::apollo::planning::StopSignConfig&>(::apollo::planning::_StopSignConfig_default_instance_);
}
inline const ::apollo::planning::StopSignConfig& TrafficRuleConfig::stop_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.stop_sign)
  return _internal_stop_sign();
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::unsafe_arena_release_stop_sign() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.stop_sign)
  if (_internal_has_stop_sign()) {
    clear_has_config();
    ::apollo::planning::StopSignConfig* temp = _impl_.config_.stop_sign_;
    _impl_.config_.stop_sign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_stop_sign(::apollo::planning::StopSignConfig* stop_sign) {
  clear_config();
  if (stop_sign) {
    set_has_stop_sign();
    _impl_.config_.stop_sign_ = stop_sign;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.stop_sign)
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::_internal_mutable_stop_sign() {
  if (!_internal_has_stop_sign()) {
    clear_config();
    set_has_stop_sign();
    _impl_.config_.stop_sign_ = CreateMaybeMessage< ::apollo::planning::StopSignConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.stop_sign_;
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::mutable_stop_sign() {
  ::apollo::planning::StopSignConfig* _msg = _internal_mutable_stop_sign();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.stop_sign)
  return _msg;
}

inline bool TrafficRuleConfig::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void TrafficRuleConfig::clear_has_config() {
  _impl_._oneof_case_[0] = CONFIG_NOT_SET;
}
inline TrafficRuleConfig::ConfigCase TrafficRuleConfig::config_case() const {
  return TrafficRuleConfig::ConfigCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrafficRuleConfigs

// repeated .apollo.planning.TrafficRuleConfig config = 1;
inline int TrafficRuleConfigs::_internal_config_size() const {
  return _impl_.config_.size();
}
inline int TrafficRuleConfigs::config_size() const {
  return _internal_config_size();
}
inline void TrafficRuleConfigs::clear_config() {
  _impl_.config_.Clear();
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfigs.config)
  return _impl_.config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >*
TrafficRuleConfigs::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TrafficRuleConfigs.config)
  return &_impl_.config_;
}
inline const ::apollo::planning::TrafficRuleConfig& TrafficRuleConfigs::_internal_config(int index) const {
  return _impl_.config_.Get(index);
}
inline const ::apollo::planning::TrafficRuleConfig& TrafficRuleConfigs::config(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfigs.config)
  return _internal_config(index);
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::_internal_add_config() {
  return _impl_.config_.Add();
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::add_config() {
  ::apollo::planning::TrafficRuleConfig* _add = _internal_add_config();
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficRuleConfigs.config)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >&
TrafficRuleConfigs::config() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TrafficRuleConfigs.config)
  return _impl_.config_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::planning::TrafficRuleConfig_RuleId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::TrafficRuleConfig_RuleId>() {
  return ::apollo::planning::TrafficRuleConfig_RuleId_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto
