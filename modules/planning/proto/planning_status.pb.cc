// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_status.proto

#include "modules/planning/proto/planning_status.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace apollo {
namespace planning {
PROTOBUF_CONSTEXPR BareIntersectionStatus::BareIntersectionStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.current_pnc_junction_overlap_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.done_pnc_junction_overlap_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.clear_counter_)*/0u} {}
struct BareIntersectionStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BareIntersectionStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BareIntersectionStatusDefaultTypeInternal() {}
  union {
    BareIntersectionStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BareIntersectionStatusDefaultTypeInternal _BareIntersectionStatus_default_instance_;
PROTOBUF_CONSTEXPR ChangeLaneStatus::ChangeLaneStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lane_change_start_position_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/0
  , /*decltype(_impl_.last_succeed_timestamp_)*/0
  , /*decltype(_impl_.exist_lane_change_start_position_)*/false
  , /*decltype(_impl_.is_current_opt_succeed_)*/false
  , /*decltype(_impl_.is_clear_to_change_lane_)*/false
  , /*decltype(_impl_.status_)*/1} {}
struct ChangeLaneStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeLaneStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeLaneStatusDefaultTypeInternal() {}
  union {
    ChangeLaneStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeLaneStatusDefaultTypeInternal _ChangeLaneStatus_default_instance_;
PROTOBUF_CONSTEXPR CreepDeciderStatus::CreepDeciderStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.creep_clear_counter_)*/0u} {}
struct CreepDeciderStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreepDeciderStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreepDeciderStatusDefaultTypeInternal() {}
  union {
    CreepDeciderStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreepDeciderStatusDefaultTypeInternal _CreepDeciderStatus_default_instance_;
PROTOBUF_CONSTEXPR StopTime::StopTime(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obstacle_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stop_timestamp_sec_)*/0} {}
struct StopTimeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StopTimeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StopTimeDefaultTypeInternal() {}
  union {
    StopTime _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StopTimeDefaultTypeInternal _StopTime_default_instance_;
PROTOBUF_CONSTEXPR CrosswalkStatus::CrosswalkStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stop_time_)*/{}
  , /*decltype(_impl_.finished_crosswalk_)*/{}
  , /*decltype(_impl_.crosswalk_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CrosswalkStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CrosswalkStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CrosswalkStatusDefaultTypeInternal() {}
  union {
    CrosswalkStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CrosswalkStatusDefaultTypeInternal _CrosswalkStatus_default_instance_;
PROTOBUF_CONSTEXPR DestinationStatus::DestinationStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.has_passed_destination_)*/false} {}
struct DestinationStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DestinationStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DestinationStatusDefaultTypeInternal() {}
  union {
    DestinationStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DestinationStatusDefaultTypeInternal _DestinationStatus_default_instance_;
PROTOBUF_CONSTEXPR EmergencyStopStatus::EmergencyStopStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stop_fence_point_)*/nullptr} {}
struct EmergencyStopStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmergencyStopStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmergencyStopStatusDefaultTypeInternal() {}
  union {
    EmergencyStopStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmergencyStopStatusDefaultTypeInternal _EmergencyStopStatus_default_instance_;
PROTOBUF_CONSTEXPR OpenSpaceStatus::OpenSpaceStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.partitioned_trajectories_index_history_)*/{}
  , /*decltype(_impl_.position_init_)*/false} {}
struct OpenSpaceStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpenSpaceStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpenSpaceStatusDefaultTypeInternal() {}
  union {
    OpenSpaceStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpenSpaceStatusDefaultTypeInternal _OpenSpaceStatus_default_instance_;
PROTOBUF_CONSTEXPR ParkAndGoStatus::ParkAndGoStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.adc_init_position_)*/nullptr
  , /*decltype(_impl_.adc_adjust_end_pose_)*/nullptr
  , /*decltype(_impl_.adc_init_heading_)*/0
  , /*decltype(_impl_.in_check_stage_)*/false} {}
struct ParkAndGoStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParkAndGoStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParkAndGoStatusDefaultTypeInternal() {}
  union {
    ParkAndGoStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParkAndGoStatusDefaultTypeInternal _ParkAndGoStatus_default_instance_;
PROTOBUF_CONSTEXPR PathDeciderStatus::PathDeciderStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.decided_side_pass_direction_)*/{}
  , /*decltype(_impl_.front_static_obstacle_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.front_static_obstacle_cycle_counter_)*/0
  , /*decltype(_impl_.able_to_use_self_lane_counter_)*/0
  , /*decltype(_impl_.is_in_path_lane_borrow_scenario_)*/false} {}
struct PathDeciderStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathDeciderStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathDeciderStatusDefaultTypeInternal() {}
  union {
    PathDeciderStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathDeciderStatusDefaultTypeInternal _PathDeciderStatus_default_instance_;
PROTOBUF_CONSTEXPR PullOverStatus::PullOverStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.theta_)*/0
  , /*decltype(_impl_.length_front_)*/0
  , /*decltype(_impl_.length_back_)*/0
  , /*decltype(_impl_.width_left_)*/0
  , /*decltype(_impl_.width_right_)*/0
  , /*decltype(_impl_.plan_pull_over_path_)*/false
  , /*decltype(_impl_.pull_over_type_)*/1} {}
struct PullOverStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PullOverStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PullOverStatusDefaultTypeInternal() {}
  union {
    PullOverStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PullOverStatusDefaultTypeInternal _PullOverStatus_default_instance_;
PROTOBUF_CONSTEXPR ReroutingStatus::ReroutingStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.routing_request_)*/nullptr
  , /*decltype(_impl_.last_rerouting_time_)*/0
  , /*decltype(_impl_.need_rerouting_)*/false} {}
struct ReroutingStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReroutingStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReroutingStatusDefaultTypeInternal() {}
  union {
    ReroutingStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReroutingStatusDefaultTypeInternal _ReroutingStatus_default_instance_;
PROTOBUF_CONSTEXPR SpeedDeciderStatus::SpeedDeciderStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pedestrian_stop_time_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpeedDeciderStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpeedDeciderStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpeedDeciderStatusDefaultTypeInternal() {}
  union {
    SpeedDeciderStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpeedDeciderStatusDefaultTypeInternal _SpeedDeciderStatus_default_instance_;
PROTOBUF_CONSTEXPR ScenarioStatus::ScenarioStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.scenario_type_)*/0
  , /*decltype(_impl_.stage_type_)*/0} {}
struct ScenarioStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScenarioStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScenarioStatusDefaultTypeInternal() {}
  union {
    ScenarioStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScenarioStatusDefaultTypeInternal _ScenarioStatus_default_instance_;
PROTOBUF_CONSTEXPR StopSignStatus::StopSignStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.wait_for_obstacle_id_)*/{}
  , /*decltype(_impl_.current_stop_sign_overlap_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.done_stop_sign_overlap_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct StopSignStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StopSignStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StopSignStatusDefaultTypeInternal() {}
  union {
    StopSignStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StopSignStatusDefaultTypeInternal _StopSignStatus_default_instance_;
PROTOBUF_CONSTEXPR TrafficLightStatus::TrafficLightStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.current_traffic_light_overlap_id_)*/{}
  , /*decltype(_impl_.done_traffic_light_overlap_id_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrafficLightStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrafficLightStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrafficLightStatusDefaultTypeInternal() {}
  union {
    TrafficLightStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrafficLightStatusDefaultTypeInternal _TrafficLightStatus_default_instance_;
PROTOBUF_CONSTEXPR YieldSignStatus::YieldSignStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.current_yield_sign_overlap_id_)*/{}
  , /*decltype(_impl_.done_yield_sign_overlap_id_)*/{}
  , /*decltype(_impl_.wait_for_obstacle_id_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct YieldSignStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR YieldSignStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~YieldSignStatusDefaultTypeInternal() {}
  union {
    YieldSignStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 YieldSignStatusDefaultTypeInternal _YieldSignStatus_default_instance_;
PROTOBUF_CONSTEXPR PlanningStatus::PlanningStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bare_intersection_)*/nullptr
  , /*decltype(_impl_.change_lane_)*/nullptr
  , /*decltype(_impl_.creep_decider_)*/nullptr
  , /*decltype(_impl_.crosswalk_)*/nullptr
  , /*decltype(_impl_.destination_)*/nullptr
  , /*decltype(_impl_.emergency_stop_)*/nullptr
  , /*decltype(_impl_.open_space_)*/nullptr
  , /*decltype(_impl_.park_and_go_)*/nullptr
  , /*decltype(_impl_.path_decider_)*/nullptr
  , /*decltype(_impl_.pull_over_)*/nullptr
  , /*decltype(_impl_.rerouting_)*/nullptr
  , /*decltype(_impl_.scenario_)*/nullptr
  , /*decltype(_impl_.speed_decider_)*/nullptr
  , /*decltype(_impl_.stop_sign_)*/nullptr
  , /*decltype(_impl_.traffic_light_)*/nullptr
  , /*decltype(_impl_.yield_sign_)*/nullptr} {}
struct PlanningStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanningStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanningStatusDefaultTypeInternal() {}
  union {
    PlanningStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanningStatusDefaultTypeInternal _PlanningStatus_default_instance_;
}  // namespace planning
}  // namespace apollo
static ::_pb::Metadata file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[18];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto = nullptr;

const uint32_t TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::apollo::planning::BareIntersectionStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::BareIntersectionStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::BareIntersectionStatus, _impl_.current_pnc_junction_overlap_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::BareIntersectionStatus, _impl_.done_pnc_junction_overlap_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::BareIntersectionStatus, _impl_.clear_counter_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneStatus, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneStatus, _impl_.path_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneStatus, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneStatus, _impl_.exist_lane_change_start_position_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneStatus, _impl_.lane_change_start_position_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneStatus, _impl_.last_succeed_timestamp_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneStatus, _impl_.is_current_opt_succeed_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ChangeLaneStatus, _impl_.is_clear_to_change_lane_),
  7,
  0,
  2,
  4,
  1,
  3,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepDeciderStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepDeciderStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CreepDeciderStatus, _impl_.creep_clear_counter_),
  0,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopTime, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopTime, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopTime, _impl_.obstacle_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopTime, _impl_.stop_timestamp_sec_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkStatus, _impl_.crosswalk_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkStatus, _impl_.stop_time_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::CrosswalkStatus, _impl_.finished_crosswalk_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::DestinationStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::DestinationStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::DestinationStatus, _impl_.has_passed_destination_),
  0,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::EmergencyStopStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::EmergencyStopStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::EmergencyStopStatus, _impl_.stop_fence_point_),
  0,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::OpenSpaceStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::OpenSpaceStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::OpenSpaceStatus, _impl_.partitioned_trajectories_index_history_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::OpenSpaceStatus, _impl_.position_init_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ParkAndGoStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ParkAndGoStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ParkAndGoStatus, _impl_.adc_init_position_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ParkAndGoStatus, _impl_.adc_init_heading_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ParkAndGoStatus, _impl_.in_check_stage_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ParkAndGoStatus, _impl_.adc_adjust_end_pose_),
  0,
  2,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PathDeciderStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PathDeciderStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PathDeciderStatus, _impl_.front_static_obstacle_cycle_counter_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PathDeciderStatus, _impl_.able_to_use_self_lane_counter_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PathDeciderStatus, _impl_.is_in_path_lane_borrow_scenario_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PathDeciderStatus, _impl_.front_static_obstacle_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PathDeciderStatus, _impl_.decided_side_pass_direction_),
  1,
  2,
  3,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverStatus, _impl_.pull_over_type_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverStatus, _impl_.plan_pull_over_path_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverStatus, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverStatus, _impl_.theta_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverStatus, _impl_.length_front_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverStatus, _impl_.length_back_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverStatus, _impl_.width_left_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PullOverStatus, _impl_.width_right_),
  7,
  6,
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReroutingStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReroutingStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReroutingStatus, _impl_.last_rerouting_time_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReroutingStatus, _impl_.need_rerouting_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ReroutingStatus, _impl_.routing_request_),
  1,
  2,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::SpeedDeciderStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::SpeedDeciderStatus, _impl_.pedestrian_stop_time_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ScenarioStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ScenarioStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ScenarioStatus, _impl_.scenario_type_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::ScenarioStatus, _impl_.stage_type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignStatus, _impl_.current_stop_sign_overlap_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignStatus, _impl_.done_stop_sign_overlap_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::StopSignStatus, _impl_.wait_for_obstacle_id_),
  0,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficLightStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficLightStatus, _impl_.current_traffic_light_overlap_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::TrafficLightStatus, _impl_.done_traffic_light_overlap_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::YieldSignStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::YieldSignStatus, _impl_.current_yield_sign_overlap_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::YieldSignStatus, _impl_.done_yield_sign_overlap_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::YieldSignStatus, _impl_.wait_for_obstacle_id_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.bare_intersection_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.change_lane_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.creep_decider_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.crosswalk_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.destination_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.emergency_stop_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.open_space_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.park_and_go_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.path_decider_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.pull_over_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.rerouting_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.scenario_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.speed_decider_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.stop_sign_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.traffic_light_),
  PROTOBUF_FIELD_OFFSET(::apollo::planning::PlanningStatus, _impl_.yield_sign_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::apollo::planning::BareIntersectionStatus)},
  { 12, 26, -1, sizeof(::apollo::planning::ChangeLaneStatus)},
  { 34, 41, -1, sizeof(::apollo::planning::CreepDeciderStatus)},
  { 42, 50, -1, sizeof(::apollo::planning::StopTime)},
  { 52, 61, -1, sizeof(::apollo::planning::CrosswalkStatus)},
  { 64, 71, -1, sizeof(::apollo::planning::DestinationStatus)},
  { 72, 79, -1, sizeof(::apollo::planning::EmergencyStopStatus)},
  { 80, 88, -1, sizeof(::apollo::planning::OpenSpaceStatus)},
  { 90, 100, -1, sizeof(::apollo::planning::ParkAndGoStatus)},
  { 104, 115, -1, sizeof(::apollo::planning::PathDeciderStatus)},
  { 120, 134, -1, sizeof(::apollo::planning::PullOverStatus)},
  { 142, 151, -1, sizeof(::apollo::planning::ReroutingStatus)},
  { 154, -1, -1, sizeof(::apollo::planning::SpeedDeciderStatus)},
  { 161, 169, -1, sizeof(::apollo::planning::ScenarioStatus)},
  { 171, 180, -1, sizeof(::apollo::planning::StopSignStatus)},
  { 183, -1, -1, sizeof(::apollo::planning::TrafficLightStatus)},
  { 191, -1, -1, sizeof(::apollo::planning::YieldSignStatus)},
  { 200, 222, -1, sizeof(::apollo::planning::PlanningStatus)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::apollo::planning::_BareIntersectionStatus_default_instance_._instance,
  &::apollo::planning::_ChangeLaneStatus_default_instance_._instance,
  &::apollo::planning::_CreepDeciderStatus_default_instance_._instance,
  &::apollo::planning::_StopTime_default_instance_._instance,
  &::apollo::planning::_CrosswalkStatus_default_instance_._instance,
  &::apollo::planning::_DestinationStatus_default_instance_._instance,
  &::apollo::planning::_EmergencyStopStatus_default_instance_._instance,
  &::apollo::planning::_OpenSpaceStatus_default_instance_._instance,
  &::apollo::planning::_ParkAndGoStatus_default_instance_._instance,
  &::apollo::planning::_PathDeciderStatus_default_instance_._instance,
  &::apollo::planning::_PullOverStatus_default_instance_._instance,
  &::apollo::planning::_ReroutingStatus_default_instance_._instance,
  &::apollo::planning::_SpeedDeciderStatus_default_instance_._instance,
  &::apollo::planning::_ScenarioStatus_default_instance_._instance,
  &::apollo::planning::_StopSignStatus_default_instance_._instance,
  &::apollo::planning::_TrafficLightStatus_default_instance_._instance,
  &::apollo::planning::_YieldSignStatus_default_instance_._instance,
  &::apollo::planning::_PlanningStatus_default_instance_._instance,
};

const char descriptor_table_protodef_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n,modules/planning/proto/planning_status"
  ".proto\022\017apollo.planning\032#modules/common/"
  "proto/geometry.proto\032,modules/planning/p"
  "roto/planning_config.proto\032#modules/rout"
  "ing/proto/routing.proto\"~\n\026BareIntersect"
  "ionStatus\022\'\n\037current_pnc_junction_overla"
  "p_id\030\001 \001(\t\022$\n\034done_pnc_junction_overlap_"
  "id\030\002 \001(\t\022\025\n\rclear_counter\030\003 \001(\r\"\234\003\n\020Chan"
  "geLaneStatus\0228\n\006status\030\001 \001(\0162(.apollo.pl"
  "anning.ChangeLaneStatus.Status\022\017\n\007path_i"
  "d\030\002 \001(\t\022\021\n\ttimestamp\030\003 \001(\001\022/\n exist_lane"
  "_change_start_position\030\004 \001(\010:\005false\022:\n\032l"
  "ane_change_start_position\030\005 \001(\0132\026.apollo"
  ".common.Point3D\022\036\n\026last_succeed_timestam"
  "p\030\006 \001(\001\022%\n\026is_current_opt_succeed\030\007 \001(\010:"
  "\005false\022&\n\027is_clear_to_change_lane\030\010 \001(\010:"
  "\005false\"N\n\006Status\022\022\n\016IN_CHANGE_LANE\020\001\022\026\n\022"
  "CHANGE_LANE_FAILED\020\002\022\030\n\024CHANGE_LANE_FINI"
  "SHED\020\003\"1\n\022CreepDeciderStatus\022\033\n\023creep_cl"
  "ear_counter\030\001 \001(\r\";\n\010StopTime\022\023\n\013obstacl"
  "e_id\030\001 \001(\t\022\032\n\022stop_timestamp_sec\030\002 \001(\001\"q"
  "\n\017CrosswalkStatus\022\024\n\014crosswalk_id\030\001 \001(\t\022"
  ",\n\tstop_time\030\002 \003(\0132\031.apollo.planning.Sto"
  "pTime\022\032\n\022finished_crosswalk\030\003 \003(\t\":\n\021Des"
  "tinationStatus\022%\n\026has_passed_destination"
  "\030\001 \001(\010:\005false\"H\n\023EmergencyStopStatus\0221\n\020"
  "stop_fence_point\030\001 \001(\0132\027.apollo.common.P"
  "ointENU\"_\n\017OpenSpaceStatus\022.\n&partitione"
  "d_trajectories_index_history\030\001 \003(\t\022\034\n\rpo"
  "sition_init\030\002 \001(\010:\005false\"\255\001\n\017ParkAndGoSt"
  "atus\0222\n\021adc_init_position\030\001 \001(\0132\027.apollo"
  ".common.PointENU\022\030\n\020adc_init_heading\030\002 \001"
  "(\001\022\026\n\016in_check_stage\030\003 \001(\010\0224\n\023adc_adjust"
  "_end_pose\030\004 \001(\0132\027.apollo.common.PointENU"
  "\"\330\002\n\021PathDeciderStatus\022.\n#front_static_o"
  "bstacle_cycle_counter\030\001 \001(\005:\0010\022(\n\035able_t"
  "o_use_self_lane_counter\030\002 \001(\005:\0010\022.\n\037is_i"
  "n_path_lane_borrow_scenario\030\003 \001(\010:\005false"
  "\022\"\n\030front_static_obstacle_id\030\004 \001(\t:\000\022[\n\033"
  "decided_side_pass_direction\030\005 \003(\01626.apol"
  "lo.planning.PathDeciderStatus.LaneBorrow"
  "Direction\"8\n\023LaneBorrowDirection\022\017\n\013LEFT"
  "_BORROW\020\001\022\020\n\014RIGHT_BORROW\020\002\"\300\002\n\016PullOver"
  "Status\022D\n\016pull_over_type\030\001 \001(\0162,.apollo."
  "planning.PullOverStatus.PullOverType\022\"\n\023"
  "plan_pull_over_path\030\002 \001(\010:\005false\022)\n\010posi"
  "tion\030\003 \001(\0132\027.apollo.common.PointENU\022\r\n\005t"
  "heta\030\004 \001(\001\022\024\n\014length_front\030\005 \001(\001\022\023\n\013leng"
  "th_back\030\006 \001(\001\022\022\n\nwidth_left\030\007 \001(\001\022\023\n\013wid"
  "th_right\030\010 \001(\001\"6\n\014PullOverType\022\r\n\tPULL_O"
  "VER\020\001\022\027\n\023EMERGENCY_PULL_OVER\020\002\"\206\001\n\017Rerou"
  "tingStatus\022\033\n\023last_rerouting_time\030\001 \001(\001\022"
  "\035\n\016need_rerouting\030\002 \001(\010:\005false\0227\n\017routin"
  "g_request\030\003 \001(\0132\036.apollo.routing.Routing"
  "Request\"M\n\022SpeedDeciderStatus\0227\n\024pedestr"
  "ian_stop_time\030\001 \003(\0132\031.apollo.planning.St"
  "opTime\"\224\001\n\016ScenarioStatus\022C\n\rscenario_ty"
  "pe\030\001 \001(\0162,.apollo.planning.ScenarioConfi"
  "g.ScenarioType\022=\n\nstage_type\030\002 \001(\0162).apo"
  "llo.planning.ScenarioConfig.StageType\"w\n"
  "\016StopSignStatus\022$\n\034current_stop_sign_ove"
  "rlap_id\030\001 \001(\t\022!\n\031done_stop_sign_overlap_"
  "id\030\002 \001(\t\022\034\n\024wait_for_obstacle_id\030\003 \003(\t\"e"
  "\n\022TrafficLightStatus\022(\n current_traffic_"
  "light_overlap_id\030\001 \003(\t\022%\n\035done_traffic_l"
  "ight_overlap_id\030\002 \003(\t\"z\n\017YieldSignStatus"
  "\022%\n\035current_yield_sign_overlap_id\030\001 \003(\t\022"
  "\"\n\032done_yield_sign_overlap_id\030\002 \003(\t\022\034\n\024w"
  "ait_for_obstacle_id\030\003 \003(\t\"\231\007\n\016PlanningSt"
  "atus\022B\n\021bare_intersection\030\001 \001(\0132\'.apollo"
  ".planning.BareIntersectionStatus\0226\n\013chan"
  "ge_lane\030\002 \001(\0132!.apollo.planning.ChangeLa"
  "neStatus\022:\n\rcreep_decider\030\003 \001(\0132#.apollo"
  ".planning.CreepDeciderStatus\0223\n\tcrosswal"
  "k\030\004 \001(\0132 .apollo.planning.CrosswalkStatu"
  "s\0227\n\013destination\030\005 \001(\0132\".apollo.planning"
  ".DestinationStatus\022<\n\016emergency_stop\030\006 \001"
  "(\0132$.apollo.planning.EmergencyStopStatus"
  "\0224\n\nopen_space\030\007 \001(\0132 .apollo.planning.O"
  "penSpaceStatus\0225\n\013park_and_go\030\010 \001(\0132 .ap"
  "ollo.planning.ParkAndGoStatus\0228\n\014path_de"
  "cider\030\t \001(\0132\".apollo.planning.PathDecide"
  "rStatus\0222\n\tpull_over\030\n \001(\0132\037.apollo.plan"
  "ning.PullOverStatus\0223\n\trerouting\030\013 \001(\0132 "
  ".apollo.planning.ReroutingStatus\0221\n\010scen"
  "ario\030\014 \001(\0132\037.apollo.planning.ScenarioSta"
  "tus\022:\n\rspeed_decider\030\r \001(\0132#.apollo.plan"
  "ning.SpeedDeciderStatus\0222\n\tstop_sign\030\016 \001"
  "(\0132\037.apollo.planning.StopSignStatus\022:\n\rt"
  "raffic_light\030\017 \001(\0132#.apollo.planning.Tra"
  "fficLightStatus\0224\n\nyield_sign\030\020 \001(\0132 .ap"
  "ollo.planning.YieldSignStatus"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_deps[3] = {
  &::descriptor_table_modules_2fcommon_2fproto_2fgeometry_2eproto,
  &::descriptor_table_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto,
  &::descriptor_table_modules_2frouting_2fproto_2frouting_2eproto,
};
static ::_pbi::once_flag descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto = {
    false, false, 3669, descriptor_table_protodef_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto,
    "modules/planning/proto/planning_status.proto",
    &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once, descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_deps, 3, 18,
    schemas, file_default_instances, TableStruct_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::offsets,
    file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto, file_level_enum_descriptors_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto,
    file_level_service_descriptors_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter() {
  return &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto(&descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
namespace apollo {
namespace planning {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeLaneStatus_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
  return file_level_enum_descriptors_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[0];
}
bool ChangeLaneStatus_Status_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChangeLaneStatus_Status ChangeLaneStatus::IN_CHANGE_LANE;
constexpr ChangeLaneStatus_Status ChangeLaneStatus::CHANGE_LANE_FAILED;
constexpr ChangeLaneStatus_Status ChangeLaneStatus::CHANGE_LANE_FINISHED;
constexpr ChangeLaneStatus_Status ChangeLaneStatus::Status_MIN;
constexpr ChangeLaneStatus_Status ChangeLaneStatus::Status_MAX;
constexpr int ChangeLaneStatus::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PathDeciderStatus_LaneBorrowDirection_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
  return file_level_enum_descriptors_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[1];
}
bool PathDeciderStatus_LaneBorrowDirection_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::LEFT_BORROW;
constexpr PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::RIGHT_BORROW;
constexpr PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::LaneBorrowDirection_MIN;
constexpr PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::LaneBorrowDirection_MAX;
constexpr int PathDeciderStatus::LaneBorrowDirection_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PullOverStatus_PullOverType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto);
  return file_level_enum_descriptors_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[2];
}
bool PullOverStatus_PullOverType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PullOverStatus_PullOverType PullOverStatus::PULL_OVER;
constexpr PullOverStatus_PullOverType PullOverStatus::EMERGENCY_PULL_OVER;
constexpr PullOverStatus_PullOverType PullOverStatus::PullOverType_MIN;
constexpr PullOverStatus_PullOverType PullOverStatus::PullOverType_MAX;
constexpr int PullOverStatus::PullOverType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class BareIntersectionStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<BareIntersectionStatus>()._impl_._has_bits_);
  static void set_has_current_pnc_junction_overlap_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_done_pnc_junction_overlap_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_clear_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BareIntersectionStatus::BareIntersectionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.BareIntersectionStatus)
}
BareIntersectionStatus::BareIntersectionStatus(const BareIntersectionStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.current_pnc_junction_overlap_id_){}
    , decltype(_impl_.done_pnc_junction_overlap_id_){}
    , decltype(_impl_.clear_counter_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.current_pnc_junction_overlap_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_pnc_junction_overlap_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_current_pnc_junction_overlap_id()) {
    _impl_.current_pnc_junction_overlap_id_.Set(from._internal_current_pnc_junction_overlap_id(), 
      GetArenaForAllocation());
  }
  _impl_.done_pnc_junction_overlap_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.done_pnc_junction_overlap_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_done_pnc_junction_overlap_id()) {
    _impl_.done_pnc_junction_overlap_id_.Set(from._internal_done_pnc_junction_overlap_id(), 
      GetArenaForAllocation());
  }
  _impl_.clear_counter_ = from._impl_.clear_counter_;
  // @@protoc_insertion_point(copy_constructor:apollo.planning.BareIntersectionStatus)
}

inline void BareIntersectionStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.current_pnc_junction_overlap_id_){}
    , decltype(_impl_.done_pnc_junction_overlap_id_){}
    , decltype(_impl_.clear_counter_){0u}
  };
  _impl_.current_pnc_junction_overlap_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_pnc_junction_overlap_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.done_pnc_junction_overlap_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.done_pnc_junction_overlap_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BareIntersectionStatus::~BareIntersectionStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.BareIntersectionStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BareIntersectionStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.current_pnc_junction_overlap_id_.Destroy();
  _impl_.done_pnc_junction_overlap_id_.Destroy();
}

void BareIntersectionStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BareIntersectionStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.BareIntersectionStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.current_pnc_junction_overlap_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.done_pnc_junction_overlap_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.clear_counter_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BareIntersectionStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string current_pnc_junction_overlap_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_current_pnc_junction_overlap_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string done_pnc_junction_overlap_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_done_pnc_junction_overlap_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 clear_counter = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_clear_counter(&has_bits);
          _impl_.clear_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BareIntersectionStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.BareIntersectionStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string current_pnc_junction_overlap_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_current_pnc_junction_overlap_id().data(), static_cast<int>(this->_internal_current_pnc_junction_overlap_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.BareIntersectionStatus.current_pnc_junction_overlap_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_current_pnc_junction_overlap_id(), target);
  }

  // optional string done_pnc_junction_overlap_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_done_pnc_junction_overlap_id().data(), static_cast<int>(this->_internal_done_pnc_junction_overlap_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.BareIntersectionStatus.done_pnc_junction_overlap_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_done_pnc_junction_overlap_id(), target);
  }

  // optional uint32 clear_counter = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_clear_counter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.BareIntersectionStatus)
  return target;
}

size_t BareIntersectionStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.BareIntersectionStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string current_pnc_junction_overlap_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_current_pnc_junction_overlap_id());
    }

    // optional string done_pnc_junction_overlap_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_done_pnc_junction_overlap_id());
    }

    // optional uint32 clear_counter = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_clear_counter());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BareIntersectionStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BareIntersectionStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BareIntersectionStatus::GetClassData() const { return &_class_data_; }

void BareIntersectionStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BareIntersectionStatus *>(to)->MergeFrom(
      static_cast<const BareIntersectionStatus &>(from));
}


void BareIntersectionStatus::MergeFrom(const BareIntersectionStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.BareIntersectionStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_current_pnc_junction_overlap_id(from._internal_current_pnc_junction_overlap_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_done_pnc_junction_overlap_id(from._internal_done_pnc_junction_overlap_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.clear_counter_ = from._impl_.clear_counter_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BareIntersectionStatus::CopyFrom(const BareIntersectionStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.BareIntersectionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BareIntersectionStatus::IsInitialized() const {
  return true;
}

void BareIntersectionStatus::InternalSwap(BareIntersectionStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.current_pnc_junction_overlap_id_, lhs_arena,
      &other->_impl_.current_pnc_junction_overlap_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.done_pnc_junction_overlap_id_, lhs_arena,
      &other->_impl_.done_pnc_junction_overlap_id_, rhs_arena
  );
  swap(_impl_.clear_counter_, other->_impl_.clear_counter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BareIntersectionStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[0]);
}

// ===================================================================

class ChangeLaneStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeLaneStatus>()._impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_path_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_exist_lane_change_start_position(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::apollo::common::Point3D& lane_change_start_position(const ChangeLaneStatus* msg);
  static void set_has_lane_change_start_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_last_succeed_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_current_opt_succeed(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_clear_to_change_lane(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::apollo::common::Point3D&
ChangeLaneStatus::_Internal::lane_change_start_position(const ChangeLaneStatus* msg) {
  return *msg->_impl_.lane_change_start_position_;
}
void ChangeLaneStatus::clear_lane_change_start_position() {
  if (_impl_.lane_change_start_position_ != nullptr) _impl_.lane_change_start_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ChangeLaneStatus::ChangeLaneStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.ChangeLaneStatus)
}
ChangeLaneStatus::ChangeLaneStatus(const ChangeLaneStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_id_){}
    , decltype(_impl_.lane_change_start_position_){nullptr}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.last_succeed_timestamp_){}
    , decltype(_impl_.exist_lane_change_start_position_){}
    , decltype(_impl_.is_current_opt_succeed_){}
    , decltype(_impl_.is_clear_to_change_lane_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path_id()) {
    _impl_.path_id_.Set(from._internal_path_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_lane_change_start_position()) {
    _impl_.lane_change_start_position_ = new ::apollo::common::Point3D(*from._impl_.lane_change_start_position_);
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.ChangeLaneStatus)
}

inline void ChangeLaneStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_id_){}
    , decltype(_impl_.lane_change_start_position_){nullptr}
    , decltype(_impl_.timestamp_){0}
    , decltype(_impl_.last_succeed_timestamp_){0}
    , decltype(_impl_.exist_lane_change_start_position_){false}
    , decltype(_impl_.is_current_opt_succeed_){false}
    , decltype(_impl_.is_clear_to_change_lane_){false}
    , decltype(_impl_.status_){1}
  };
  _impl_.path_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChangeLaneStatus::~ChangeLaneStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.ChangeLaneStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeLaneStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.lane_change_start_position_;
}

void ChangeLaneStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeLaneStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.ChangeLaneStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.lane_change_start_position_ != nullptr);
      _impl_.lane_change_start_position_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_clear_to_change_lane_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.is_clear_to_change_lane_));
    _impl_.status_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeLaneStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.planning.ChangeLaneStatus.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::apollo::planning::ChangeLaneStatus_Status_IsValid(val))) {
            _internal_set_status(static_cast<::apollo::planning::ChangeLaneStatus_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string path_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_path_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "apollo.planning.ChangeLaneStatus.path_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool exist_lane_change_start_position = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_exist_lane_change_start_position(&has_bits);
          _impl_.exist_lane_change_start_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.common.Point3D lane_change_start_position = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_lane_change_start_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double last_succeed_timestamp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_last_succeed_timestamp(&has_bits);
          _impl_.last_succeed_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_current_opt_succeed = 7 [default = false];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_current_opt_succeed(&has_bits);
          _impl_.is_current_opt_succeed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_clear_to_change_lane = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is_clear_to_change_lane(&has_bits);
          _impl_.is_clear_to_change_lane_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeLaneStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.ChangeLaneStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.planning.ChangeLaneStatus.Status status = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // optional string path_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_path_id().data(), static_cast<int>(this->_internal_path_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.ChangeLaneStatus.path_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_path_id(), target);
  }

  // optional double timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_timestamp(), target);
  }

  // optional bool exist_lane_change_start_position = 4 [default = false];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_exist_lane_change_start_position(), target);
  }

  // optional .apollo.common.Point3D lane_change_start_position = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::lane_change_start_position(this),
        _Internal::lane_change_start_position(this).GetCachedSize(), target, stream);
  }

  // optional double last_succeed_timestamp = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_last_succeed_timestamp(), target);
  }

  // optional bool is_current_opt_succeed = 7 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_current_opt_succeed(), target);
  }

  // optional bool is_clear_to_change_lane = 8 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_is_clear_to_change_lane(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.ChangeLaneStatus)
  return target;
}

size_t ChangeLaneStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.ChangeLaneStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string path_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path_id());
    }

    // optional .apollo.common.Point3D lane_change_start_position = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lane_change_start_position_);
    }

    // optional double timestamp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double last_succeed_timestamp = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional bool exist_lane_change_start_position = 4 [default = false];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool is_current_opt_succeed = 7 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_clear_to_change_lane = 8 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional .apollo.planning.ChangeLaneStatus.Status status = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeLaneStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ChangeLaneStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeLaneStatus::GetClassData() const { return &_class_data_; }

void ChangeLaneStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ChangeLaneStatus *>(to)->MergeFrom(
      static_cast<const ChangeLaneStatus &>(from));
}


void ChangeLaneStatus::MergeFrom(const ChangeLaneStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.ChangeLaneStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_path_id(from._internal_path_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_lane_change_start_position()->::apollo::common::Point3D::MergeFrom(from._internal_lane_change_start_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.last_succeed_timestamp_ = from._impl_.last_succeed_timestamp_;
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.exist_lane_change_start_position_ = from._impl_.exist_lane_change_start_position_;
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.is_current_opt_succeed_ = from._impl_.is_current_opt_succeed_;
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.is_clear_to_change_lane_ = from._impl_.is_clear_to_change_lane_;
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.status_ = from._impl_.status_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeLaneStatus::CopyFrom(const ChangeLaneStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.ChangeLaneStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeLaneStatus::IsInitialized() const {
  return true;
}

void ChangeLaneStatus::InternalSwap(ChangeLaneStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_id_, lhs_arena,
      &other->_impl_.path_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangeLaneStatus, _impl_.is_clear_to_change_lane_)
      + sizeof(ChangeLaneStatus::_impl_.is_clear_to_change_lane_)
      - PROTOBUF_FIELD_OFFSET(ChangeLaneStatus, _impl_.lane_change_start_position_)>(
          reinterpret_cast<char*>(&_impl_.lane_change_start_position_),
          reinterpret_cast<char*>(&other->_impl_.lane_change_start_position_));
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeLaneStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[1]);
}

// ===================================================================

class CreepDeciderStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CreepDeciderStatus>()._impl_._has_bits_);
  static void set_has_creep_clear_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CreepDeciderStatus::CreepDeciderStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.CreepDeciderStatus)
}
CreepDeciderStatus::CreepDeciderStatus(const CreepDeciderStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.creep_clear_counter_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.creep_clear_counter_ = from._impl_.creep_clear_counter_;
  // @@protoc_insertion_point(copy_constructor:apollo.planning.CreepDeciderStatus)
}

inline void CreepDeciderStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.creep_clear_counter_){0u}
  };
}

CreepDeciderStatus::~CreepDeciderStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.CreepDeciderStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreepDeciderStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CreepDeciderStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreepDeciderStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.CreepDeciderStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.creep_clear_counter_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreepDeciderStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 creep_clear_counter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_creep_clear_counter(&has_bits);
          _impl_.creep_clear_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreepDeciderStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.CreepDeciderStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 creep_clear_counter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_creep_clear_counter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.CreepDeciderStatus)
  return target;
}

size_t CreepDeciderStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.CreepDeciderStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 creep_clear_counter = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_creep_clear_counter());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreepDeciderStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreepDeciderStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreepDeciderStatus::GetClassData() const { return &_class_data_; }

void CreepDeciderStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreepDeciderStatus *>(to)->MergeFrom(
      static_cast<const CreepDeciderStatus &>(from));
}


void CreepDeciderStatus::MergeFrom(const CreepDeciderStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.CreepDeciderStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_creep_clear_counter()) {
    _internal_set_creep_clear_counter(from._internal_creep_clear_counter());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreepDeciderStatus::CopyFrom(const CreepDeciderStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.CreepDeciderStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreepDeciderStatus::IsInitialized() const {
  return true;
}

void CreepDeciderStatus::InternalSwap(CreepDeciderStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.creep_clear_counter_, other->_impl_.creep_clear_counter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreepDeciderStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[2]);
}

// ===================================================================

class StopTime::_Internal {
 public:
  using HasBits = decltype(std::declval<StopTime>()._impl_._has_bits_);
  static void set_has_obstacle_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stop_timestamp_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StopTime::StopTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.StopTime)
}
StopTime::StopTime(const StopTime& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obstacle_id_){}
    , decltype(_impl_.stop_timestamp_sec_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.obstacle_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obstacle_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obstacle_id()) {
    _impl_.obstacle_id_.Set(from._internal_obstacle_id(), 
      GetArenaForAllocation());
  }
  _impl_.stop_timestamp_sec_ = from._impl_.stop_timestamp_sec_;
  // @@protoc_insertion_point(copy_constructor:apollo.planning.StopTime)
}

inline void StopTime::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obstacle_id_){}
    , decltype(_impl_.stop_timestamp_sec_){0}
  };
  _impl_.obstacle_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obstacle_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StopTime::~StopTime() {
  // @@protoc_insertion_point(destructor:apollo.planning.StopTime)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StopTime::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obstacle_id_.Destroy();
}

void StopTime::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StopTime::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.StopTime)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.obstacle_id_.ClearNonDefaultToEmpty();
  }
  _impl_.stop_timestamp_sec_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StopTime::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string obstacle_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_obstacle_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "apollo.planning.StopTime.obstacle_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double stop_timestamp_sec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_stop_timestamp_sec(&has_bits);
          _impl_.stop_timestamp_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StopTime::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.StopTime)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string obstacle_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_obstacle_id().data(), static_cast<int>(this->_internal_obstacle_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.StopTime.obstacle_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_obstacle_id(), target);
  }

  // optional double stop_timestamp_sec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_stop_timestamp_sec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.StopTime)
  return target;
}

size_t StopTime::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.StopTime)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string obstacle_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obstacle_id());
    }

    // optional double stop_timestamp_sec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StopTime::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StopTime::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StopTime::GetClassData() const { return &_class_data_; }

void StopTime::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StopTime *>(to)->MergeFrom(
      static_cast<const StopTime &>(from));
}


void StopTime::MergeFrom(const StopTime& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.StopTime)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_obstacle_id(from._internal_obstacle_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.stop_timestamp_sec_ = from._impl_.stop_timestamp_sec_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StopTime::CopyFrom(const StopTime& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.StopTime)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopTime::IsInitialized() const {
  return true;
}

void StopTime::InternalSwap(StopTime* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obstacle_id_, lhs_arena,
      &other->_impl_.obstacle_id_, rhs_arena
  );
  swap(_impl_.stop_timestamp_sec_, other->_impl_.stop_timestamp_sec_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StopTime::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[3]);
}

// ===================================================================

class CrosswalkStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CrosswalkStatus>()._impl_._has_bits_);
  static void set_has_crosswalk_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CrosswalkStatus::CrosswalkStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.CrosswalkStatus)
}
CrosswalkStatus::CrosswalkStatus(const CrosswalkStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_time_){from._impl_.stop_time_}
    , decltype(_impl_.finished_crosswalk_){from._impl_.finished_crosswalk_}
    , decltype(_impl_.crosswalk_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.crosswalk_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.crosswalk_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_crosswalk_id()) {
    _impl_.crosswalk_id_.Set(from._internal_crosswalk_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:apollo.planning.CrosswalkStatus)
}

inline void CrosswalkStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_time_){arena}
    , decltype(_impl_.finished_crosswalk_){arena}
    , decltype(_impl_.crosswalk_id_){}
  };
  _impl_.crosswalk_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.crosswalk_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CrosswalkStatus::~CrosswalkStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.CrosswalkStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CrosswalkStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stop_time_.~RepeatedPtrField();
  _impl_.finished_crosswalk_.~RepeatedPtrField();
  _impl_.crosswalk_id_.Destroy();
}

void CrosswalkStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CrosswalkStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.CrosswalkStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stop_time_.Clear();
  _impl_.finished_crosswalk_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.crosswalk_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CrosswalkStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string crosswalk_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_crosswalk_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "apollo.planning.CrosswalkStatus.crosswalk_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .apollo.planning.StopTime stop_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stop_time(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string finished_crosswalk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_finished_crosswalk();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "apollo.planning.CrosswalkStatus.finished_crosswalk");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CrosswalkStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.CrosswalkStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string crosswalk_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_crosswalk_id().data(), static_cast<int>(this->_internal_crosswalk_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.CrosswalkStatus.crosswalk_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_crosswalk_id(), target);
  }

  // repeated .apollo.planning.StopTime stop_time = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stop_time_size()); i < n; i++) {
    const auto& repfield = this->_internal_stop_time(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string finished_crosswalk = 3;
  for (int i = 0, n = this->_internal_finished_crosswalk_size(); i < n; i++) {
    const auto& s = this->_internal_finished_crosswalk(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.CrosswalkStatus.finished_crosswalk");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.CrosswalkStatus)
  return target;
}

size_t CrosswalkStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.CrosswalkStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .apollo.planning.StopTime stop_time = 2;
  total_size += 1UL * this->_internal_stop_time_size();
  for (const auto& msg : this->_impl_.stop_time_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string finished_crosswalk = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.finished_crosswalk_.size());
  for (int i = 0, n = _impl_.finished_crosswalk_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.finished_crosswalk_.Get(i));
  }

  // optional string crosswalk_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_crosswalk_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CrosswalkStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CrosswalkStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CrosswalkStatus::GetClassData() const { return &_class_data_; }

void CrosswalkStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CrosswalkStatus *>(to)->MergeFrom(
      static_cast<const CrosswalkStatus &>(from));
}


void CrosswalkStatus::MergeFrom(const CrosswalkStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.CrosswalkStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.stop_time_.MergeFrom(from._impl_.stop_time_);
  _impl_.finished_crosswalk_.MergeFrom(from._impl_.finished_crosswalk_);
  if (from._internal_has_crosswalk_id()) {
    _internal_set_crosswalk_id(from._internal_crosswalk_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CrosswalkStatus::CopyFrom(const CrosswalkStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.CrosswalkStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrosswalkStatus::IsInitialized() const {
  return true;
}

void CrosswalkStatus::InternalSwap(CrosswalkStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.stop_time_.InternalSwap(&other->_impl_.stop_time_);
  _impl_.finished_crosswalk_.InternalSwap(&other->_impl_.finished_crosswalk_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.crosswalk_id_, lhs_arena,
      &other->_impl_.crosswalk_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CrosswalkStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[4]);
}

// ===================================================================

class DestinationStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<DestinationStatus>()._impl_._has_bits_);
  static void set_has_has_passed_destination(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DestinationStatus::DestinationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.DestinationStatus)
}
DestinationStatus::DestinationStatus(const DestinationStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.has_passed_destination_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.has_passed_destination_ = from._impl_.has_passed_destination_;
  // @@protoc_insertion_point(copy_constructor:apollo.planning.DestinationStatus)
}

inline void DestinationStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.has_passed_destination_){false}
  };
}

DestinationStatus::~DestinationStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.DestinationStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DestinationStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DestinationStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DestinationStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.DestinationStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.has_passed_destination_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DestinationStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool has_passed_destination = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_has_passed_destination(&has_bits);
          _impl_.has_passed_destination_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DestinationStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.DestinationStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool has_passed_destination = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_has_passed_destination(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.DestinationStatus)
  return target;
}

size_t DestinationStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.DestinationStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool has_passed_destination = 1 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DestinationStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DestinationStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DestinationStatus::GetClassData() const { return &_class_data_; }

void DestinationStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DestinationStatus *>(to)->MergeFrom(
      static_cast<const DestinationStatus &>(from));
}


void DestinationStatus::MergeFrom(const DestinationStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.DestinationStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_has_passed_destination()) {
    _internal_set_has_passed_destination(from._internal_has_passed_destination());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DestinationStatus::CopyFrom(const DestinationStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.DestinationStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DestinationStatus::IsInitialized() const {
  return true;
}

void DestinationStatus::InternalSwap(DestinationStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.has_passed_destination_, other->_impl_.has_passed_destination_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DestinationStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[5]);
}

// ===================================================================

class EmergencyStopStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<EmergencyStopStatus>()._impl_._has_bits_);
  static const ::apollo::common::PointENU& stop_fence_point(const EmergencyStopStatus* msg);
  static void set_has_stop_fence_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::apollo::common::PointENU&
EmergencyStopStatus::_Internal::stop_fence_point(const EmergencyStopStatus* msg) {
  return *msg->_impl_.stop_fence_point_;
}
void EmergencyStopStatus::clear_stop_fence_point() {
  if (_impl_.stop_fence_point_ != nullptr) _impl_.stop_fence_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EmergencyStopStatus::EmergencyStopStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.EmergencyStopStatus)
}
EmergencyStopStatus::EmergencyStopStatus(const EmergencyStopStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_fence_point_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stop_fence_point()) {
    _impl_.stop_fence_point_ = new ::apollo::common::PointENU(*from._impl_.stop_fence_point_);
  }
  // @@protoc_insertion_point(copy_constructor:apollo.planning.EmergencyStopStatus)
}

inline void EmergencyStopStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_fence_point_){nullptr}
  };
}

EmergencyStopStatus::~EmergencyStopStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.EmergencyStopStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmergencyStopStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stop_fence_point_;
}

void EmergencyStopStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmergencyStopStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.EmergencyStopStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.stop_fence_point_ != nullptr);
    _impl_.stop_fence_point_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmergencyStopStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.common.PointENU stop_fence_point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_fence_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmergencyStopStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.EmergencyStopStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.common.PointENU stop_fence_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stop_fence_point(this),
        _Internal::stop_fence_point(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.EmergencyStopStatus)
  return target;
}

size_t EmergencyStopStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.EmergencyStopStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .apollo.common.PointENU stop_fence_point = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stop_fence_point_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmergencyStopStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EmergencyStopStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmergencyStopStatus::GetClassData() const { return &_class_data_; }

void EmergencyStopStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EmergencyStopStatus *>(to)->MergeFrom(
      static_cast<const EmergencyStopStatus &>(from));
}


void EmergencyStopStatus::MergeFrom(const EmergencyStopStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.EmergencyStopStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stop_fence_point()) {
    _internal_mutable_stop_fence_point()->::apollo::common::PointENU::MergeFrom(from._internal_stop_fence_point());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmergencyStopStatus::CopyFrom(const EmergencyStopStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.EmergencyStopStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmergencyStopStatus::IsInitialized() const {
  return true;
}

void EmergencyStopStatus::InternalSwap(EmergencyStopStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stop_fence_point_, other->_impl_.stop_fence_point_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EmergencyStopStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[6]);
}

// ===================================================================

class OpenSpaceStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<OpenSpaceStatus>()._impl_._has_bits_);
  static void set_has_position_init(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OpenSpaceStatus::OpenSpaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.OpenSpaceStatus)
}
OpenSpaceStatus::OpenSpaceStatus(const OpenSpaceStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partitioned_trajectories_index_history_){from._impl_.partitioned_trajectories_index_history_}
    , decltype(_impl_.position_init_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.position_init_ = from._impl_.position_init_;
  // @@protoc_insertion_point(copy_constructor:apollo.planning.OpenSpaceStatus)
}

inline void OpenSpaceStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partitioned_trajectories_index_history_){arena}
    , decltype(_impl_.position_init_){false}
  };
}

OpenSpaceStatus::~OpenSpaceStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.OpenSpaceStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OpenSpaceStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.partitioned_trajectories_index_history_.~RepeatedPtrField();
}

void OpenSpaceStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OpenSpaceStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.OpenSpaceStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.partitioned_trajectories_index_history_.Clear();
  _impl_.position_init_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpenSpaceStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string partitioned_trajectories_index_history = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_partitioned_trajectories_index_history();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool position_init = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_position_init(&has_bits);
          _impl_.position_init_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OpenSpaceStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.OpenSpaceStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string partitioned_trajectories_index_history = 1;
  for (int i = 0, n = this->_internal_partitioned_trajectories_index_history_size(); i < n; i++) {
    const auto& s = this->_internal_partitioned_trajectories_index_history(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.OpenSpaceStatus.partitioned_trajectories_index_history");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool position_init = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_position_init(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.OpenSpaceStatus)
  return target;
}

size_t OpenSpaceStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.OpenSpaceStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string partitioned_trajectories_index_history = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.partitioned_trajectories_index_history_.size());
  for (int i = 0, n = _impl_.partitioned_trajectories_index_history_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.partitioned_trajectories_index_history_.Get(i));
  }

  // optional bool position_init = 2 [default = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OpenSpaceStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    OpenSpaceStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OpenSpaceStatus::GetClassData() const { return &_class_data_; }

void OpenSpaceStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<OpenSpaceStatus *>(to)->MergeFrom(
      static_cast<const OpenSpaceStatus &>(from));
}


void OpenSpaceStatus::MergeFrom(const OpenSpaceStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.OpenSpaceStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.partitioned_trajectories_index_history_.MergeFrom(from._impl_.partitioned_trajectories_index_history_);
  if (from._internal_has_position_init()) {
    _internal_set_position_init(from._internal_position_init());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OpenSpaceStatus::CopyFrom(const OpenSpaceStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.OpenSpaceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenSpaceStatus::IsInitialized() const {
  return true;
}

void OpenSpaceStatus::InternalSwap(OpenSpaceStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.partitioned_trajectories_index_history_.InternalSwap(&other->_impl_.partitioned_trajectories_index_history_);
  swap(_impl_.position_init_, other->_impl_.position_init_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OpenSpaceStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[7]);
}

// ===================================================================

class ParkAndGoStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ParkAndGoStatus>()._impl_._has_bits_);
  static const ::apollo::common::PointENU& adc_init_position(const ParkAndGoStatus* msg);
  static void set_has_adc_init_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_adc_init_heading(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_in_check_stage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::apollo::common::PointENU& adc_adjust_end_pose(const ParkAndGoStatus* msg);
  static void set_has_adc_adjust_end_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::apollo::common::PointENU&
ParkAndGoStatus::_Internal::adc_init_position(const ParkAndGoStatus* msg) {
  return *msg->_impl_.adc_init_position_;
}
const ::apollo::common::PointENU&
ParkAndGoStatus::_Internal::adc_adjust_end_pose(const ParkAndGoStatus* msg) {
  return *msg->_impl_.adc_adjust_end_pose_;
}
void ParkAndGoStatus::clear_adc_init_position() {
  if (_impl_.adc_init_position_ != nullptr) _impl_.adc_init_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ParkAndGoStatus::clear_adc_adjust_end_pose() {
  if (_impl_.adc_adjust_end_pose_ != nullptr) _impl_.adc_adjust_end_pose_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ParkAndGoStatus::ParkAndGoStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.ParkAndGoStatus)
}
ParkAndGoStatus::ParkAndGoStatus(const ParkAndGoStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.adc_init_position_){nullptr}
    , decltype(_impl_.adc_adjust_end_pose_){nullptr}
    , decltype(_impl_.adc_init_heading_){}
    , decltype(_impl_.in_check_stage_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_adc_init_position()) {
    _impl_.adc_init_position_ = new ::apollo::common::PointENU(*from._impl_.adc_init_position_);
  }
  if (from._internal_has_adc_adjust_end_pose()) {
    _impl_.adc_adjust_end_pose_ = new ::apollo::common::PointENU(*from._impl_.adc_adjust_end_pose_);
  }
  ::memcpy(&_impl_.adc_init_heading_, &from._impl_.adc_init_heading_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.in_check_stage_) -
    reinterpret_cast<char*>(&_impl_.adc_init_heading_)) + sizeof(_impl_.in_check_stage_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.ParkAndGoStatus)
}

inline void ParkAndGoStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.adc_init_position_){nullptr}
    , decltype(_impl_.adc_adjust_end_pose_){nullptr}
    , decltype(_impl_.adc_init_heading_){0}
    , decltype(_impl_.in_check_stage_){false}
  };
}

ParkAndGoStatus::~ParkAndGoStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.ParkAndGoStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ParkAndGoStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.adc_init_position_;
  if (this != internal_default_instance()) delete _impl_.adc_adjust_end_pose_;
}

void ParkAndGoStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ParkAndGoStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.ParkAndGoStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.adc_init_position_ != nullptr);
      _impl_.adc_init_position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.adc_adjust_end_pose_ != nullptr);
      _impl_.adc_adjust_end_pose_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.adc_init_heading_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.in_check_stage_) -
        reinterpret_cast<char*>(&_impl_.adc_init_heading_)) + sizeof(_impl_.in_check_stage_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ParkAndGoStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.common.PointENU adc_init_position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_adc_init_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double adc_init_heading = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_adc_init_heading(&has_bits);
          _impl_.adc_init_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool in_check_stage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_in_check_stage(&has_bits);
          _impl_.in_check_stage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.common.PointENU adc_adjust_end_pose = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_adc_adjust_end_pose(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ParkAndGoStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.ParkAndGoStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.common.PointENU adc_init_position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::adc_init_position(this),
        _Internal::adc_init_position(this).GetCachedSize(), target, stream);
  }

  // optional double adc_init_heading = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_adc_init_heading(), target);
  }

  // optional bool in_check_stage = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_in_check_stage(), target);
  }

  // optional .apollo.common.PointENU adc_adjust_end_pose = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::adc_adjust_end_pose(this),
        _Internal::adc_adjust_end_pose(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.ParkAndGoStatus)
  return target;
}

size_t ParkAndGoStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.ParkAndGoStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .apollo.common.PointENU adc_init_position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.adc_init_position_);
    }

    // optional .apollo.common.PointENU adc_adjust_end_pose = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.adc_adjust_end_pose_);
    }

    // optional double adc_init_heading = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional bool in_check_stage = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ParkAndGoStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ParkAndGoStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ParkAndGoStatus::GetClassData() const { return &_class_data_; }

void ParkAndGoStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ParkAndGoStatus *>(to)->MergeFrom(
      static_cast<const ParkAndGoStatus &>(from));
}


void ParkAndGoStatus::MergeFrom(const ParkAndGoStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.ParkAndGoStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_adc_init_position()->::apollo::common::PointENU::MergeFrom(from._internal_adc_init_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_adc_adjust_end_pose()->::apollo::common::PointENU::MergeFrom(from._internal_adc_adjust_end_pose());
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.adc_init_heading_ = from._impl_.adc_init_heading_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.in_check_stage_ = from._impl_.in_check_stage_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ParkAndGoStatus::CopyFrom(const ParkAndGoStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.ParkAndGoStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParkAndGoStatus::IsInitialized() const {
  return true;
}

void ParkAndGoStatus::InternalSwap(ParkAndGoStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ParkAndGoStatus, _impl_.in_check_stage_)
      + sizeof(ParkAndGoStatus::_impl_.in_check_stage_)
      - PROTOBUF_FIELD_OFFSET(ParkAndGoStatus, _impl_.adc_init_position_)>(
          reinterpret_cast<char*>(&_impl_.adc_init_position_),
          reinterpret_cast<char*>(&other->_impl_.adc_init_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ParkAndGoStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[8]);
}

// ===================================================================

class PathDeciderStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PathDeciderStatus>()._impl_._has_bits_);
  static void set_has_front_static_obstacle_cycle_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_able_to_use_self_lane_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_in_path_lane_borrow_scenario(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_front_static_obstacle_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PathDeciderStatus::PathDeciderStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.PathDeciderStatus)
}
PathDeciderStatus::PathDeciderStatus(const PathDeciderStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.decided_side_pass_direction_){from._impl_.decided_side_pass_direction_}
    , decltype(_impl_.front_static_obstacle_id_){}
    , decltype(_impl_.front_static_obstacle_cycle_counter_){}
    , decltype(_impl_.able_to_use_self_lane_counter_){}
    , decltype(_impl_.is_in_path_lane_borrow_scenario_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.front_static_obstacle_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.front_static_obstacle_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_front_static_obstacle_id()) {
    _impl_.front_static_obstacle_id_.Set(from._internal_front_static_obstacle_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&_impl_.front_static_obstacle_cycle_counter_, &from._impl_.front_static_obstacle_cycle_counter_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_in_path_lane_borrow_scenario_) -
    reinterpret_cast<char*>(&_impl_.front_static_obstacle_cycle_counter_)) + sizeof(_impl_.is_in_path_lane_borrow_scenario_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.PathDeciderStatus)
}

inline void PathDeciderStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.decided_side_pass_direction_){arena}
    , decltype(_impl_.front_static_obstacle_id_){}
    , decltype(_impl_.front_static_obstacle_cycle_counter_){0}
    , decltype(_impl_.able_to_use_self_lane_counter_){0}
    , decltype(_impl_.is_in_path_lane_borrow_scenario_){false}
  };
  _impl_.front_static_obstacle_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.front_static_obstacle_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PathDeciderStatus::~PathDeciderStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.PathDeciderStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PathDeciderStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.decided_side_pass_direction_.~RepeatedField();
  _impl_.front_static_obstacle_id_.Destroy();
}

void PathDeciderStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PathDeciderStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.PathDeciderStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.decided_side_pass_direction_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.front_static_obstacle_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.front_static_obstacle_cycle_counter_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_in_path_lane_borrow_scenario_) -
        reinterpret_cast<char*>(&_impl_.front_static_obstacle_cycle_counter_)) + sizeof(_impl_.is_in_path_lane_borrow_scenario_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PathDeciderStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_front_static_obstacle_cycle_counter(&has_bits);
          _impl_.front_static_obstacle_cycle_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 able_to_use_self_lane_counter = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_able_to_use_self_lane_counter(&has_bits);
          _impl_.able_to_use_self_lane_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_in_path_lane_borrow_scenario(&has_bits);
          _impl_.is_in_path_lane_borrow_scenario_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string front_static_obstacle_id = 4 [default = ""];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_front_static_obstacle_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "apollo.planning.PathDeciderStatus.front_static_obstacle_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .apollo.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::apollo::planning::PathDeciderStatus_LaneBorrowDirection_IsValid(val))) {
              _internal_add_decided_side_pass_direction(static_cast<::apollo::planning::PathDeciderStatus_LaneBorrowDirection>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_decided_side_pass_direction(), ptr, ctx, ::apollo::planning::PathDeciderStatus_LaneBorrowDirection_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PathDeciderStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.PathDeciderStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_front_static_obstacle_cycle_counter(), target);
  }

  // optional int32 able_to_use_self_lane_counter = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_able_to_use_self_lane_counter(), target);
  }

  // optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_in_path_lane_borrow_scenario(), target);
  }

  // optional string front_static_obstacle_id = 4 [default = ""];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_front_static_obstacle_id().data(), static_cast<int>(this->_internal_front_static_obstacle_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.PathDeciderStatus.front_static_obstacle_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_front_static_obstacle_id(), target);
  }

  // repeated .apollo.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
  for (int i = 0, n = this->_internal_decided_side_pass_direction_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_decided_side_pass_direction(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.PathDeciderStatus)
  return target;
}

size_t PathDeciderStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.PathDeciderStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .apollo.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_decided_side_pass_direction_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_decided_side_pass_direction(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string front_static_obstacle_id = 4 [default = ""];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_front_static_obstacle_id());
    }

    // optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_front_static_obstacle_cycle_counter());
    }

    // optional int32 able_to_use_self_lane_counter = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_able_to_use_self_lane_counter());
    }

    // optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PathDeciderStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PathDeciderStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PathDeciderStatus::GetClassData() const { return &_class_data_; }

void PathDeciderStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PathDeciderStatus *>(to)->MergeFrom(
      static_cast<const PathDeciderStatus &>(from));
}


void PathDeciderStatus::MergeFrom(const PathDeciderStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.PathDeciderStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.decided_side_pass_direction_.MergeFrom(from._impl_.decided_side_pass_direction_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_front_static_obstacle_id(from._internal_front_static_obstacle_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.front_static_obstacle_cycle_counter_ = from._impl_.front_static_obstacle_cycle_counter_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.able_to_use_self_lane_counter_ = from._impl_.able_to_use_self_lane_counter_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.is_in_path_lane_borrow_scenario_ = from._impl_.is_in_path_lane_borrow_scenario_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PathDeciderStatus::CopyFrom(const PathDeciderStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.PathDeciderStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathDeciderStatus::IsInitialized() const {
  return true;
}

void PathDeciderStatus::InternalSwap(PathDeciderStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.decided_side_pass_direction_.InternalSwap(&other->_impl_.decided_side_pass_direction_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.front_static_obstacle_id_, lhs_arena,
      &other->_impl_.front_static_obstacle_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PathDeciderStatus, _impl_.is_in_path_lane_borrow_scenario_)
      + sizeof(PathDeciderStatus::_impl_.is_in_path_lane_borrow_scenario_)
      - PROTOBUF_FIELD_OFFSET(PathDeciderStatus, _impl_.front_static_obstacle_cycle_counter_)>(
          reinterpret_cast<char*>(&_impl_.front_static_obstacle_cycle_counter_),
          reinterpret_cast<char*>(&other->_impl_.front_static_obstacle_cycle_counter_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PathDeciderStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[9]);
}

// ===================================================================

class PullOverStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PullOverStatus>()._impl_._has_bits_);
  static void set_has_pull_over_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_plan_pull_over_path(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::apollo::common::PointENU& position(const PullOverStatus* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_theta(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_length_front(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_length_back(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_width_left(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_width_right(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::apollo::common::PointENU&
PullOverStatus::_Internal::position(const PullOverStatus* msg) {
  return *msg->_impl_.position_;
}
void PullOverStatus::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PullOverStatus::PullOverStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.PullOverStatus)
}
PullOverStatus::PullOverStatus(const PullOverStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.theta_){}
    , decltype(_impl_.length_front_){}
    , decltype(_impl_.length_back_){}
    , decltype(_impl_.width_left_){}
    , decltype(_impl_.width_right_){}
    , decltype(_impl_.plan_pull_over_path_){}
    , decltype(_impl_.pull_over_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _impl_.position_ = new ::apollo::common::PointENU(*from._impl_.position_);
  }
  ::memcpy(&_impl_.theta_, &from._impl_.theta_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pull_over_type_) -
    reinterpret_cast<char*>(&_impl_.theta_)) + sizeof(_impl_.pull_over_type_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.PullOverStatus)
}

inline void PullOverStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.theta_){0}
    , decltype(_impl_.length_front_){0}
    , decltype(_impl_.length_back_){0}
    , decltype(_impl_.width_left_){0}
    , decltype(_impl_.width_right_){0}
    , decltype(_impl_.plan_pull_over_path_){false}
    , decltype(_impl_.pull_over_type_){1}
  };
}

PullOverStatus::~PullOverStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.PullOverStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PullOverStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void PullOverStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PullOverStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.PullOverStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.theta_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.plan_pull_over_path_) -
        reinterpret_cast<char*>(&_impl_.theta_)) + sizeof(_impl_.plan_pull_over_path_));
    _impl_.pull_over_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PullOverStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.planning.PullOverStatus.PullOverType pull_over_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::apollo::planning::PullOverStatus_PullOverType_IsValid(val))) {
            _internal_set_pull_over_type(static_cast<::apollo::planning::PullOverStatus_PullOverType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool plan_pull_over_path = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_plan_pull_over_path(&has_bits);
          _impl_.plan_pull_over_path_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.common.PointENU position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double theta = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_theta(&has_bits);
          _impl_.theta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double length_front = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_length_front(&has_bits);
          _impl_.length_front_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double length_back = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_length_back(&has_bits);
          _impl_.length_back_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double width_left = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_width_left(&has_bits);
          _impl_.width_left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double width_right = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_width_right(&has_bits);
          _impl_.width_right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PullOverStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.PullOverStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.planning.PullOverStatus.PullOverType pull_over_type = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_pull_over_type(), target);
  }

  // optional bool plan_pull_over_path = 2 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_plan_pull_over_path(), target);
  }

  // optional .apollo.common.PointENU position = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional double theta = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_theta(), target);
  }

  // optional double length_front = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_length_front(), target);
  }

  // optional double length_back = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_length_back(), target);
  }

  // optional double width_left = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_width_left(), target);
  }

  // optional double width_right = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_width_right(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.PullOverStatus)
  return target;
}

size_t PullOverStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.PullOverStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .apollo.common.PointENU position = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional double theta = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double length_front = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double length_back = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double width_left = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double width_right = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional bool plan_pull_over_path = 2 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional .apollo.planning.PullOverStatus.PullOverType pull_over_type = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_pull_over_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PullOverStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PullOverStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PullOverStatus::GetClassData() const { return &_class_data_; }

void PullOverStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PullOverStatus *>(to)->MergeFrom(
      static_cast<const PullOverStatus &>(from));
}


void PullOverStatus::MergeFrom(const PullOverStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.PullOverStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_position()->::apollo::common::PointENU::MergeFrom(from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.theta_ = from._impl_.theta_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.length_front_ = from._impl_.length_front_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.length_back_ = from._impl_.length_back_;
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.width_left_ = from._impl_.width_left_;
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.width_right_ = from._impl_.width_right_;
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.plan_pull_over_path_ = from._impl_.plan_pull_over_path_;
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.pull_over_type_ = from._impl_.pull_over_type_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PullOverStatus::CopyFrom(const PullOverStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.PullOverStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PullOverStatus::IsInitialized() const {
  return true;
}

void PullOverStatus::InternalSwap(PullOverStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PullOverStatus, _impl_.plan_pull_over_path_)
      + sizeof(PullOverStatus::_impl_.plan_pull_over_path_)
      - PROTOBUF_FIELD_OFFSET(PullOverStatus, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
  swap(_impl_.pull_over_type_, other->_impl_.pull_over_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PullOverStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[10]);
}

// ===================================================================

class ReroutingStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ReroutingStatus>()._impl_._has_bits_);
  static void set_has_last_rerouting_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_need_rerouting(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::apollo::routing::RoutingRequest& routing_request(const ReroutingStatus* msg);
  static void set_has_routing_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::apollo::routing::RoutingRequest&
ReroutingStatus::_Internal::routing_request(const ReroutingStatus* msg) {
  return *msg->_impl_.routing_request_;
}
void ReroutingStatus::clear_routing_request() {
  if (_impl_.routing_request_ != nullptr) _impl_.routing_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ReroutingStatus::ReroutingStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.ReroutingStatus)
}
ReroutingStatus::ReroutingStatus(const ReroutingStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.routing_request_){nullptr}
    , decltype(_impl_.last_rerouting_time_){}
    , decltype(_impl_.need_rerouting_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_routing_request()) {
    _impl_.routing_request_ = new ::apollo::routing::RoutingRequest(*from._impl_.routing_request_);
  }
  ::memcpy(&_impl_.last_rerouting_time_, &from._impl_.last_rerouting_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.need_rerouting_) -
    reinterpret_cast<char*>(&_impl_.last_rerouting_time_)) + sizeof(_impl_.need_rerouting_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.ReroutingStatus)
}

inline void ReroutingStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.routing_request_){nullptr}
    , decltype(_impl_.last_rerouting_time_){0}
    , decltype(_impl_.need_rerouting_){false}
  };
}

ReroutingStatus::~ReroutingStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.ReroutingStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReroutingStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.routing_request_;
}

void ReroutingStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReroutingStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.ReroutingStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.routing_request_ != nullptr);
    _impl_.routing_request_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.last_rerouting_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.need_rerouting_) -
        reinterpret_cast<char*>(&_impl_.last_rerouting_time_)) + sizeof(_impl_.need_rerouting_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReroutingStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double last_rerouting_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_last_rerouting_time(&has_bits);
          _impl_.last_rerouting_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool need_rerouting = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_need_rerouting(&has_bits);
          _impl_.need_rerouting_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.routing.RoutingRequest routing_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_routing_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReroutingStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.ReroutingStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double last_rerouting_time = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_last_rerouting_time(), target);
  }

  // optional bool need_rerouting = 2 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_need_rerouting(), target);
  }

  // optional .apollo.routing.RoutingRequest routing_request = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::routing_request(this),
        _Internal::routing_request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.ReroutingStatus)
  return target;
}

size_t ReroutingStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.ReroutingStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .apollo.routing.RoutingRequest routing_request = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.routing_request_);
    }

    // optional double last_rerouting_time = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool need_rerouting = 2 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReroutingStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ReroutingStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReroutingStatus::GetClassData() const { return &_class_data_; }

void ReroutingStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ReroutingStatus *>(to)->MergeFrom(
      static_cast<const ReroutingStatus &>(from));
}


void ReroutingStatus::MergeFrom(const ReroutingStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.ReroutingStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_routing_request()->::apollo::routing::RoutingRequest::MergeFrom(from._internal_routing_request());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.last_rerouting_time_ = from._impl_.last_rerouting_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.need_rerouting_ = from._impl_.need_rerouting_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReroutingStatus::CopyFrom(const ReroutingStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.ReroutingStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReroutingStatus::IsInitialized() const {
  return true;
}

void ReroutingStatus::InternalSwap(ReroutingStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReroutingStatus, _impl_.need_rerouting_)
      + sizeof(ReroutingStatus::_impl_.need_rerouting_)
      - PROTOBUF_FIELD_OFFSET(ReroutingStatus, _impl_.routing_request_)>(
          reinterpret_cast<char*>(&_impl_.routing_request_),
          reinterpret_cast<char*>(&other->_impl_.routing_request_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReroutingStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[11]);
}

// ===================================================================

class SpeedDeciderStatus::_Internal {
 public:
};

SpeedDeciderStatus::SpeedDeciderStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.SpeedDeciderStatus)
}
SpeedDeciderStatus::SpeedDeciderStatus(const SpeedDeciderStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_.pedestrian_stop_time_){from._impl_.pedestrian_stop_time_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.planning.SpeedDeciderStatus)
}

inline void SpeedDeciderStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pedestrian_stop_time_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SpeedDeciderStatus::~SpeedDeciderStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.SpeedDeciderStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpeedDeciderStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pedestrian_stop_time_.~RepeatedPtrField();
}

void SpeedDeciderStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpeedDeciderStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.SpeedDeciderStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pedestrian_stop_time_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpeedDeciderStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .apollo.planning.StopTime pedestrian_stop_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pedestrian_stop_time(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpeedDeciderStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.SpeedDeciderStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .apollo.planning.StopTime pedestrian_stop_time = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pedestrian_stop_time_size()); i < n; i++) {
    const auto& repfield = this->_internal_pedestrian_stop_time(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.SpeedDeciderStatus)
  return target;
}

size_t SpeedDeciderStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.SpeedDeciderStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .apollo.planning.StopTime pedestrian_stop_time = 1;
  total_size += 1UL * this->_internal_pedestrian_stop_time_size();
  for (const auto& msg : this->_impl_.pedestrian_stop_time_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpeedDeciderStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SpeedDeciderStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpeedDeciderStatus::GetClassData() const { return &_class_data_; }

void SpeedDeciderStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SpeedDeciderStatus *>(to)->MergeFrom(
      static_cast<const SpeedDeciderStatus &>(from));
}


void SpeedDeciderStatus::MergeFrom(const SpeedDeciderStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.SpeedDeciderStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.pedestrian_stop_time_.MergeFrom(from._impl_.pedestrian_stop_time_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpeedDeciderStatus::CopyFrom(const SpeedDeciderStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.SpeedDeciderStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpeedDeciderStatus::IsInitialized() const {
  return true;
}

void SpeedDeciderStatus::InternalSwap(SpeedDeciderStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.pedestrian_stop_time_.InternalSwap(&other->_impl_.pedestrian_stop_time_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpeedDeciderStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[12]);
}

// ===================================================================

class ScenarioStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ScenarioStatus>()._impl_._has_bits_);
  static void set_has_scenario_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stage_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ScenarioStatus::ScenarioStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.ScenarioStatus)
}
ScenarioStatus::ScenarioStatus(const ScenarioStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.scenario_type_){}
    , decltype(_impl_.stage_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.scenario_type_, &from._impl_.scenario_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stage_type_) -
    reinterpret_cast<char*>(&_impl_.scenario_type_)) + sizeof(_impl_.stage_type_));
  // @@protoc_insertion_point(copy_constructor:apollo.planning.ScenarioStatus)
}

inline void ScenarioStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.scenario_type_){0}
    , decltype(_impl_.stage_type_){0}
  };
}

ScenarioStatus::~ScenarioStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.ScenarioStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScenarioStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ScenarioStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScenarioStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.ScenarioStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.scenario_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.stage_type_) -
        reinterpret_cast<char*>(&_impl_.scenario_type_)) + sizeof(_impl_.stage_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScenarioStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::apollo::planning::ScenarioConfig_ScenarioType_IsValid(val))) {
            _internal_set_scenario_type(static_cast<::apollo::planning::ScenarioConfig_ScenarioType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.ScenarioConfig.StageType stage_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::apollo::planning::ScenarioConfig_StageType_IsValid(val))) {
            _internal_set_stage_type(static_cast<::apollo::planning::ScenarioConfig_StageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScenarioStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.ScenarioStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_scenario_type(), target);
  }

  // optional .apollo.planning.ScenarioConfig.StageType stage_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_stage_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.ScenarioStatus)
  return target;
}

size_t ScenarioStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.ScenarioStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_scenario_type());
    }

    // optional .apollo.planning.ScenarioConfig.StageType stage_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_stage_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScenarioStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ScenarioStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScenarioStatus::GetClassData() const { return &_class_data_; }

void ScenarioStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ScenarioStatus *>(to)->MergeFrom(
      static_cast<const ScenarioStatus &>(from));
}


void ScenarioStatus::MergeFrom(const ScenarioStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.ScenarioStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.scenario_type_ = from._impl_.scenario_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.stage_type_ = from._impl_.stage_type_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScenarioStatus::CopyFrom(const ScenarioStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.ScenarioStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioStatus::IsInitialized() const {
  return true;
}

void ScenarioStatus::InternalSwap(ScenarioStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScenarioStatus, _impl_.stage_type_)
      + sizeof(ScenarioStatus::_impl_.stage_type_)
      - PROTOBUF_FIELD_OFFSET(ScenarioStatus, _impl_.scenario_type_)>(
          reinterpret_cast<char*>(&_impl_.scenario_type_),
          reinterpret_cast<char*>(&other->_impl_.scenario_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ScenarioStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[13]);
}

// ===================================================================

class StopSignStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<StopSignStatus>()._impl_._has_bits_);
  static void set_has_current_stop_sign_overlap_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_done_stop_sign_overlap_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StopSignStatus::StopSignStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.StopSignStatus)
}
StopSignStatus::StopSignStatus(const StopSignStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wait_for_obstacle_id_){from._impl_.wait_for_obstacle_id_}
    , decltype(_impl_.current_stop_sign_overlap_id_){}
    , decltype(_impl_.done_stop_sign_overlap_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.current_stop_sign_overlap_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_stop_sign_overlap_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_current_stop_sign_overlap_id()) {
    _impl_.current_stop_sign_overlap_id_.Set(from._internal_current_stop_sign_overlap_id(), 
      GetArenaForAllocation());
  }
  _impl_.done_stop_sign_overlap_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.done_stop_sign_overlap_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_done_stop_sign_overlap_id()) {
    _impl_.done_stop_sign_overlap_id_.Set(from._internal_done_stop_sign_overlap_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:apollo.planning.StopSignStatus)
}

inline void StopSignStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wait_for_obstacle_id_){arena}
    , decltype(_impl_.current_stop_sign_overlap_id_){}
    , decltype(_impl_.done_stop_sign_overlap_id_){}
  };
  _impl_.current_stop_sign_overlap_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_stop_sign_overlap_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.done_stop_sign_overlap_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.done_stop_sign_overlap_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StopSignStatus::~StopSignStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.StopSignStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StopSignStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.wait_for_obstacle_id_.~RepeatedPtrField();
  _impl_.current_stop_sign_overlap_id_.Destroy();
  _impl_.done_stop_sign_overlap_id_.Destroy();
}

void StopSignStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StopSignStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.StopSignStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wait_for_obstacle_id_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.current_stop_sign_overlap_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.done_stop_sign_overlap_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StopSignStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string current_stop_sign_overlap_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_current_stop_sign_overlap_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "apollo.planning.StopSignStatus.current_stop_sign_overlap_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string done_stop_sign_overlap_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_done_stop_sign_overlap_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "apollo.planning.StopSignStatus.done_stop_sign_overlap_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string wait_for_obstacle_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_wait_for_obstacle_id();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "apollo.planning.StopSignStatus.wait_for_obstacle_id");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StopSignStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.StopSignStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string current_stop_sign_overlap_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_current_stop_sign_overlap_id().data(), static_cast<int>(this->_internal_current_stop_sign_overlap_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.StopSignStatus.current_stop_sign_overlap_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_current_stop_sign_overlap_id(), target);
  }

  // optional string done_stop_sign_overlap_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_done_stop_sign_overlap_id().data(), static_cast<int>(this->_internal_done_stop_sign_overlap_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.StopSignStatus.done_stop_sign_overlap_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_done_stop_sign_overlap_id(), target);
  }

  // repeated string wait_for_obstacle_id = 3;
  for (int i = 0, n = this->_internal_wait_for_obstacle_id_size(); i < n; i++) {
    const auto& s = this->_internal_wait_for_obstacle_id(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.StopSignStatus.wait_for_obstacle_id");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.StopSignStatus)
  return target;
}

size_t StopSignStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.StopSignStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string wait_for_obstacle_id = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.wait_for_obstacle_id_.size());
  for (int i = 0, n = _impl_.wait_for_obstacle_id_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.wait_for_obstacle_id_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string current_stop_sign_overlap_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_current_stop_sign_overlap_id());
    }

    // optional string done_stop_sign_overlap_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_done_stop_sign_overlap_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StopSignStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StopSignStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StopSignStatus::GetClassData() const { return &_class_data_; }

void StopSignStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StopSignStatus *>(to)->MergeFrom(
      static_cast<const StopSignStatus &>(from));
}


void StopSignStatus::MergeFrom(const StopSignStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.StopSignStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.wait_for_obstacle_id_.MergeFrom(from._impl_.wait_for_obstacle_id_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_current_stop_sign_overlap_id(from._internal_current_stop_sign_overlap_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_done_stop_sign_overlap_id(from._internal_done_stop_sign_overlap_id());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StopSignStatus::CopyFrom(const StopSignStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.StopSignStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopSignStatus::IsInitialized() const {
  return true;
}

void StopSignStatus::InternalSwap(StopSignStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.wait_for_obstacle_id_.InternalSwap(&other->_impl_.wait_for_obstacle_id_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.current_stop_sign_overlap_id_, lhs_arena,
      &other->_impl_.current_stop_sign_overlap_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.done_stop_sign_overlap_id_, lhs_arena,
      &other->_impl_.done_stop_sign_overlap_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StopSignStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[14]);
}

// ===================================================================

class TrafficLightStatus::_Internal {
 public:
};

TrafficLightStatus::TrafficLightStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.TrafficLightStatus)
}
TrafficLightStatus::TrafficLightStatus(const TrafficLightStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_.current_traffic_light_overlap_id_){from._impl_.current_traffic_light_overlap_id_}
    , decltype(_impl_.done_traffic_light_overlap_id_){from._impl_.done_traffic_light_overlap_id_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.planning.TrafficLightStatus)
}

inline void TrafficLightStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.current_traffic_light_overlap_id_){arena}
    , decltype(_impl_.done_traffic_light_overlap_id_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrafficLightStatus::~TrafficLightStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.TrafficLightStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrafficLightStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.current_traffic_light_overlap_id_.~RepeatedPtrField();
  _impl_.done_traffic_light_overlap_id_.~RepeatedPtrField();
}

void TrafficLightStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrafficLightStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.TrafficLightStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.current_traffic_light_overlap_id_.Clear();
  _impl_.done_traffic_light_overlap_id_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrafficLightStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string current_traffic_light_overlap_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_current_traffic_light_overlap_id();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string done_traffic_light_overlap_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_done_traffic_light_overlap_id();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrafficLightStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.TrafficLightStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string current_traffic_light_overlap_id = 1;
  for (int i = 0, n = this->_internal_current_traffic_light_overlap_id_size(); i < n; i++) {
    const auto& s = this->_internal_current_traffic_light_overlap_id(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.TrafficLightStatus.current_traffic_light_overlap_id");
    target = stream->WriteString(1, s, target);
  }

  // repeated string done_traffic_light_overlap_id = 2;
  for (int i = 0, n = this->_internal_done_traffic_light_overlap_id_size(); i < n; i++) {
    const auto& s = this->_internal_done_traffic_light_overlap_id(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.TrafficLightStatus.done_traffic_light_overlap_id");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.TrafficLightStatus)
  return target;
}

size_t TrafficLightStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.TrafficLightStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string current_traffic_light_overlap_id = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.current_traffic_light_overlap_id_.size());
  for (int i = 0, n = _impl_.current_traffic_light_overlap_id_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.current_traffic_light_overlap_id_.Get(i));
  }

  // repeated string done_traffic_light_overlap_id = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.done_traffic_light_overlap_id_.size());
  for (int i = 0, n = _impl_.done_traffic_light_overlap_id_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.done_traffic_light_overlap_id_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrafficLightStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TrafficLightStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrafficLightStatus::GetClassData() const { return &_class_data_; }

void TrafficLightStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TrafficLightStatus *>(to)->MergeFrom(
      static_cast<const TrafficLightStatus &>(from));
}


void TrafficLightStatus::MergeFrom(const TrafficLightStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.TrafficLightStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.current_traffic_light_overlap_id_.MergeFrom(from._impl_.current_traffic_light_overlap_id_);
  _impl_.done_traffic_light_overlap_id_.MergeFrom(from._impl_.done_traffic_light_overlap_id_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrafficLightStatus::CopyFrom(const TrafficLightStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.TrafficLightStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficLightStatus::IsInitialized() const {
  return true;
}

void TrafficLightStatus::InternalSwap(TrafficLightStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.current_traffic_light_overlap_id_.InternalSwap(&other->_impl_.current_traffic_light_overlap_id_);
  _impl_.done_traffic_light_overlap_id_.InternalSwap(&other->_impl_.done_traffic_light_overlap_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TrafficLightStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[15]);
}

// ===================================================================

class YieldSignStatus::_Internal {
 public:
};

YieldSignStatus::YieldSignStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.YieldSignStatus)
}
YieldSignStatus::YieldSignStatus(const YieldSignStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_.current_yield_sign_overlap_id_){from._impl_.current_yield_sign_overlap_id_}
    , decltype(_impl_.done_yield_sign_overlap_id_){from._impl_.done_yield_sign_overlap_id_}
    , decltype(_impl_.wait_for_obstacle_id_){from._impl_.wait_for_obstacle_id_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.planning.YieldSignStatus)
}

inline void YieldSignStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.current_yield_sign_overlap_id_){arena}
    , decltype(_impl_.done_yield_sign_overlap_id_){arena}
    , decltype(_impl_.wait_for_obstacle_id_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

YieldSignStatus::~YieldSignStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.YieldSignStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void YieldSignStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.current_yield_sign_overlap_id_.~RepeatedPtrField();
  _impl_.done_yield_sign_overlap_id_.~RepeatedPtrField();
  _impl_.wait_for_obstacle_id_.~RepeatedPtrField();
}

void YieldSignStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void YieldSignStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.YieldSignStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.current_yield_sign_overlap_id_.Clear();
  _impl_.done_yield_sign_overlap_id_.Clear();
  _impl_.wait_for_obstacle_id_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* YieldSignStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string current_yield_sign_overlap_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_current_yield_sign_overlap_id();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "apollo.planning.YieldSignStatus.current_yield_sign_overlap_id");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string done_yield_sign_overlap_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_done_yield_sign_overlap_id();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "apollo.planning.YieldSignStatus.done_yield_sign_overlap_id");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string wait_for_obstacle_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_wait_for_obstacle_id();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "apollo.planning.YieldSignStatus.wait_for_obstacle_id");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* YieldSignStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.YieldSignStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string current_yield_sign_overlap_id = 1;
  for (int i = 0, n = this->_internal_current_yield_sign_overlap_id_size(); i < n; i++) {
    const auto& s = this->_internal_current_yield_sign_overlap_id(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.YieldSignStatus.current_yield_sign_overlap_id");
    target = stream->WriteString(1, s, target);
  }

  // repeated string done_yield_sign_overlap_id = 2;
  for (int i = 0, n = this->_internal_done_yield_sign_overlap_id_size(); i < n; i++) {
    const auto& s = this->_internal_done_yield_sign_overlap_id(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.YieldSignStatus.done_yield_sign_overlap_id");
    target = stream->WriteString(2, s, target);
  }

  // repeated string wait_for_obstacle_id = 3;
  for (int i = 0, n = this->_internal_wait_for_obstacle_id_size(); i < n; i++) {
    const auto& s = this->_internal_wait_for_obstacle_id(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "apollo.planning.YieldSignStatus.wait_for_obstacle_id");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.YieldSignStatus)
  return target;
}

size_t YieldSignStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.YieldSignStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string current_yield_sign_overlap_id = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.current_yield_sign_overlap_id_.size());
  for (int i = 0, n = _impl_.current_yield_sign_overlap_id_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.current_yield_sign_overlap_id_.Get(i));
  }

  // repeated string done_yield_sign_overlap_id = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.done_yield_sign_overlap_id_.size());
  for (int i = 0, n = _impl_.done_yield_sign_overlap_id_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.done_yield_sign_overlap_id_.Get(i));
  }

  // repeated string wait_for_obstacle_id = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.wait_for_obstacle_id_.size());
  for (int i = 0, n = _impl_.wait_for_obstacle_id_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.wait_for_obstacle_id_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData YieldSignStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    YieldSignStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*YieldSignStatus::GetClassData() const { return &_class_data_; }

void YieldSignStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<YieldSignStatus *>(to)->MergeFrom(
      static_cast<const YieldSignStatus &>(from));
}


void YieldSignStatus::MergeFrom(const YieldSignStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.YieldSignStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.current_yield_sign_overlap_id_.MergeFrom(from._impl_.current_yield_sign_overlap_id_);
  _impl_.done_yield_sign_overlap_id_.MergeFrom(from._impl_.done_yield_sign_overlap_id_);
  _impl_.wait_for_obstacle_id_.MergeFrom(from._impl_.wait_for_obstacle_id_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void YieldSignStatus::CopyFrom(const YieldSignStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.YieldSignStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool YieldSignStatus::IsInitialized() const {
  return true;
}

void YieldSignStatus::InternalSwap(YieldSignStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.current_yield_sign_overlap_id_.InternalSwap(&other->_impl_.current_yield_sign_overlap_id_);
  _impl_.done_yield_sign_overlap_id_.InternalSwap(&other->_impl_.done_yield_sign_overlap_id_);
  _impl_.wait_for_obstacle_id_.InternalSwap(&other->_impl_.wait_for_obstacle_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata YieldSignStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[16]);
}

// ===================================================================

class PlanningStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PlanningStatus>()._impl_._has_bits_);
  static const ::apollo::planning::BareIntersectionStatus& bare_intersection(const PlanningStatus* msg);
  static void set_has_bare_intersection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::apollo::planning::ChangeLaneStatus& change_lane(const PlanningStatus* msg);
  static void set_has_change_lane(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::apollo::planning::CreepDeciderStatus& creep_decider(const PlanningStatus* msg);
  static void set_has_creep_decider(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::apollo::planning::CrosswalkStatus& crosswalk(const PlanningStatus* msg);
  static void set_has_crosswalk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::apollo::planning::DestinationStatus& destination(const PlanningStatus* msg);
  static void set_has_destination(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::apollo::planning::EmergencyStopStatus& emergency_stop(const PlanningStatus* msg);
  static void set_has_emergency_stop(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::apollo::planning::OpenSpaceStatus& open_space(const PlanningStatus* msg);
  static void set_has_open_space(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::apollo::planning::ParkAndGoStatus& park_and_go(const PlanningStatus* msg);
  static void set_has_park_and_go(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::apollo::planning::PathDeciderStatus& path_decider(const PlanningStatus* msg);
  static void set_has_path_decider(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::apollo::planning::PullOverStatus& pull_over(const PlanningStatus* msg);
  static void set_has_pull_over(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::apollo::planning::ReroutingStatus& rerouting(const PlanningStatus* msg);
  static void set_has_rerouting(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::apollo::planning::ScenarioStatus& scenario(const PlanningStatus* msg);
  static void set_has_scenario(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::apollo::planning::SpeedDeciderStatus& speed_decider(const PlanningStatus* msg);
  static void set_has_speed_decider(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::apollo::planning::StopSignStatus& stop_sign(const PlanningStatus* msg);
  static void set_has_stop_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::apollo::planning::TrafficLightStatus& traffic_light(const PlanningStatus* msg);
  static void set_has_traffic_light(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::apollo::planning::YieldSignStatus& yield_sign(const PlanningStatus* msg);
  static void set_has_yield_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::apollo::planning::BareIntersectionStatus&
PlanningStatus::_Internal::bare_intersection(const PlanningStatus* msg) {
  return *msg->_impl_.bare_intersection_;
}
const ::apollo::planning::ChangeLaneStatus&
PlanningStatus::_Internal::change_lane(const PlanningStatus* msg) {
  return *msg->_impl_.change_lane_;
}
const ::apollo::planning::CreepDeciderStatus&
PlanningStatus::_Internal::creep_decider(const PlanningStatus* msg) {
  return *msg->_impl_.creep_decider_;
}
const ::apollo::planning::CrosswalkStatus&
PlanningStatus::_Internal::crosswalk(const PlanningStatus* msg) {
  return *msg->_impl_.crosswalk_;
}
const ::apollo::planning::DestinationStatus&
PlanningStatus::_Internal::destination(const PlanningStatus* msg) {
  return *msg->_impl_.destination_;
}
const ::apollo::planning::EmergencyStopStatus&
PlanningStatus::_Internal::emergency_stop(const PlanningStatus* msg) {
  return *msg->_impl_.emergency_stop_;
}
const ::apollo::planning::OpenSpaceStatus&
PlanningStatus::_Internal::open_space(const PlanningStatus* msg) {
  return *msg->_impl_.open_space_;
}
const ::apollo::planning::ParkAndGoStatus&
PlanningStatus::_Internal::park_and_go(const PlanningStatus* msg) {
  return *msg->_impl_.park_and_go_;
}
const ::apollo::planning::PathDeciderStatus&
PlanningStatus::_Internal::path_decider(const PlanningStatus* msg) {
  return *msg->_impl_.path_decider_;
}
const ::apollo::planning::PullOverStatus&
PlanningStatus::_Internal::pull_over(const PlanningStatus* msg) {
  return *msg->_impl_.pull_over_;
}
const ::apollo::planning::ReroutingStatus&
PlanningStatus::_Internal::rerouting(const PlanningStatus* msg) {
  return *msg->_impl_.rerouting_;
}
const ::apollo::planning::ScenarioStatus&
PlanningStatus::_Internal::scenario(const PlanningStatus* msg) {
  return *msg->_impl_.scenario_;
}
const ::apollo::planning::SpeedDeciderStatus&
PlanningStatus::_Internal::speed_decider(const PlanningStatus* msg) {
  return *msg->_impl_.speed_decider_;
}
const ::apollo::planning::StopSignStatus&
PlanningStatus::_Internal::stop_sign(const PlanningStatus* msg) {
  return *msg->_impl_.stop_sign_;
}
const ::apollo::planning::TrafficLightStatus&
PlanningStatus::_Internal::traffic_light(const PlanningStatus* msg) {
  return *msg->_impl_.traffic_light_;
}
const ::apollo::planning::YieldSignStatus&
PlanningStatus::_Internal::yield_sign(const PlanningStatus* msg) {
  return *msg->_impl_.yield_sign_;
}
PlanningStatus::PlanningStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.planning.PlanningStatus)
}
PlanningStatus::PlanningStatus(const PlanningStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bare_intersection_){nullptr}
    , decltype(_impl_.change_lane_){nullptr}
    , decltype(_impl_.creep_decider_){nullptr}
    , decltype(_impl_.crosswalk_){nullptr}
    , decltype(_impl_.destination_){nullptr}
    , decltype(_impl_.emergency_stop_){nullptr}
    , decltype(_impl_.open_space_){nullptr}
    , decltype(_impl_.park_and_go_){nullptr}
    , decltype(_impl_.path_decider_){nullptr}
    , decltype(_impl_.pull_over_){nullptr}
    , decltype(_impl_.rerouting_){nullptr}
    , decltype(_impl_.scenario_){nullptr}
    , decltype(_impl_.speed_decider_){nullptr}
    , decltype(_impl_.stop_sign_){nullptr}
    , decltype(_impl_.traffic_light_){nullptr}
    , decltype(_impl_.yield_sign_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_bare_intersection()) {
    _impl_.bare_intersection_ = new ::apollo::planning::BareIntersectionStatus(*from._impl_.bare_intersection_);
  }
  if (from._internal_has_change_lane()) {
    _impl_.change_lane_ = new ::apollo::planning::ChangeLaneStatus(*from._impl_.change_lane_);
  }
  if (from._internal_has_creep_decider()) {
    _impl_.creep_decider_ = new ::apollo::planning::CreepDeciderStatus(*from._impl_.creep_decider_);
  }
  if (from._internal_has_crosswalk()) {
    _impl_.crosswalk_ = new ::apollo::planning::CrosswalkStatus(*from._impl_.crosswalk_);
  }
  if (from._internal_has_destination()) {
    _impl_.destination_ = new ::apollo::planning::DestinationStatus(*from._impl_.destination_);
  }
  if (from._internal_has_emergency_stop()) {
    _impl_.emergency_stop_ = new ::apollo::planning::EmergencyStopStatus(*from._impl_.emergency_stop_);
  }
  if (from._internal_has_open_space()) {
    _impl_.open_space_ = new ::apollo::planning::OpenSpaceStatus(*from._impl_.open_space_);
  }
  if (from._internal_has_park_and_go()) {
    _impl_.park_and_go_ = new ::apollo::planning::ParkAndGoStatus(*from._impl_.park_and_go_);
  }
  if (from._internal_has_path_decider()) {
    _impl_.path_decider_ = new ::apollo::planning::PathDeciderStatus(*from._impl_.path_decider_);
  }
  if (from._internal_has_pull_over()) {
    _impl_.pull_over_ = new ::apollo::planning::PullOverStatus(*from._impl_.pull_over_);
  }
  if (from._internal_has_rerouting()) {
    _impl_.rerouting_ = new ::apollo::planning::ReroutingStatus(*from._impl_.rerouting_);
  }
  if (from._internal_has_scenario()) {
    _impl_.scenario_ = new ::apollo::planning::ScenarioStatus(*from._impl_.scenario_);
  }
  if (from._internal_has_speed_decider()) {
    _impl_.speed_decider_ = new ::apollo::planning::SpeedDeciderStatus(*from._impl_.speed_decider_);
  }
  if (from._internal_has_stop_sign()) {
    _impl_.stop_sign_ = new ::apollo::planning::StopSignStatus(*from._impl_.stop_sign_);
  }
  if (from._internal_has_traffic_light()) {
    _impl_.traffic_light_ = new ::apollo::planning::TrafficLightStatus(*from._impl_.traffic_light_);
  }
  if (from._internal_has_yield_sign()) {
    _impl_.yield_sign_ = new ::apollo::planning::YieldSignStatus(*from._impl_.yield_sign_);
  }
  // @@protoc_insertion_point(copy_constructor:apollo.planning.PlanningStatus)
}

inline void PlanningStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bare_intersection_){nullptr}
    , decltype(_impl_.change_lane_){nullptr}
    , decltype(_impl_.creep_decider_){nullptr}
    , decltype(_impl_.crosswalk_){nullptr}
    , decltype(_impl_.destination_){nullptr}
    , decltype(_impl_.emergency_stop_){nullptr}
    , decltype(_impl_.open_space_){nullptr}
    , decltype(_impl_.park_and_go_){nullptr}
    , decltype(_impl_.path_decider_){nullptr}
    , decltype(_impl_.pull_over_){nullptr}
    , decltype(_impl_.rerouting_){nullptr}
    , decltype(_impl_.scenario_){nullptr}
    , decltype(_impl_.speed_decider_){nullptr}
    , decltype(_impl_.stop_sign_){nullptr}
    , decltype(_impl_.traffic_light_){nullptr}
    , decltype(_impl_.yield_sign_){nullptr}
  };
}

PlanningStatus::~PlanningStatus() {
  // @@protoc_insertion_point(destructor:apollo.planning.PlanningStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanningStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.bare_intersection_;
  if (this != internal_default_instance()) delete _impl_.change_lane_;
  if (this != internal_default_instance()) delete _impl_.creep_decider_;
  if (this != internal_default_instance()) delete _impl_.crosswalk_;
  if (this != internal_default_instance()) delete _impl_.destination_;
  if (this != internal_default_instance()) delete _impl_.emergency_stop_;
  if (this != internal_default_instance()) delete _impl_.open_space_;
  if (this != internal_default_instance()) delete _impl_.park_and_go_;
  if (this != internal_default_instance()) delete _impl_.path_decider_;
  if (this != internal_default_instance()) delete _impl_.pull_over_;
  if (this != internal_default_instance()) delete _impl_.rerouting_;
  if (this != internal_default_instance()) delete _impl_.scenario_;
  if (this != internal_default_instance()) delete _impl_.speed_decider_;
  if (this != internal_default_instance()) delete _impl_.stop_sign_;
  if (this != internal_default_instance()) delete _impl_.traffic_light_;
  if (this != internal_default_instance()) delete _impl_.yield_sign_;
}

void PlanningStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanningStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.planning.PlanningStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.bare_intersection_ != nullptr);
      _impl_.bare_intersection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.change_lane_ != nullptr);
      _impl_.change_lane_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.creep_decider_ != nullptr);
      _impl_.creep_decider_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.crosswalk_ != nullptr);
      _impl_.crosswalk_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.destination_ != nullptr);
      _impl_.destination_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.emergency_stop_ != nullptr);
      _impl_.emergency_stop_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.open_space_ != nullptr);
      _impl_.open_space_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.park_and_go_ != nullptr);
      _impl_.park_and_go_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.path_decider_ != nullptr);
      _impl_.path_decider_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.pull_over_ != nullptr);
      _impl_.pull_over_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.rerouting_ != nullptr);
      _impl_.rerouting_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.scenario_ != nullptr);
      _impl_.scenario_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.speed_decider_ != nullptr);
      _impl_.speed_decider_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.stop_sign_ != nullptr);
      _impl_.stop_sign_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.traffic_light_ != nullptr);
      _impl_.traffic_light_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.yield_sign_ != nullptr);
      _impl_.yield_sign_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanningStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.planning.BareIntersectionStatus bare_intersection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_bare_intersection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.ChangeLaneStatus change_lane = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_change_lane(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.CreepDeciderStatus creep_decider = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_creep_decider(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.CrosswalkStatus crosswalk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_crosswalk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.DestinationStatus destination = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_destination(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.EmergencyStopStatus emergency_stop = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_emergency_stop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.OpenSpaceStatus open_space = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_open_space(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.ParkAndGoStatus park_and_go = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_park_and_go(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.PathDeciderStatus path_decider = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_path_decider(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.PullOverStatus pull_over = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_pull_over(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.ReroutingStatus rerouting = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_rerouting(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.ScenarioStatus scenario = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_scenario(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.SpeedDeciderStatus speed_decider = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_speed_decider(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.StopSignStatus stop_sign = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_sign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.TrafficLightStatus traffic_light = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_traffic_light(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.planning.YieldSignStatus yield_sign = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_yield_sign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanningStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.planning.PlanningStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.planning.BareIntersectionStatus bare_intersection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::bare_intersection(this),
        _Internal::bare_intersection(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.ChangeLaneStatus change_lane = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::change_lane(this),
        _Internal::change_lane(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.CreepDeciderStatus creep_decider = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::creep_decider(this),
        _Internal::creep_decider(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.CrosswalkStatus crosswalk = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::crosswalk(this),
        _Internal::crosswalk(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.DestinationStatus destination = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::destination(this),
        _Internal::destination(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.EmergencyStopStatus emergency_stop = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::emergency_stop(this),
        _Internal::emergency_stop(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.OpenSpaceStatus open_space = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::open_space(this),
        _Internal::open_space(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.ParkAndGoStatus park_and_go = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::park_and_go(this),
        _Internal::park_and_go(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.PathDeciderStatus path_decider = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::path_decider(this),
        _Internal::path_decider(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.PullOverStatus pull_over = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::pull_over(this),
        _Internal::pull_over(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.ReroutingStatus rerouting = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::rerouting(this),
        _Internal::rerouting(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.ScenarioStatus scenario = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::scenario(this),
        _Internal::scenario(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.SpeedDeciderStatus speed_decider = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::speed_decider(this),
        _Internal::speed_decider(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.StopSignStatus stop_sign = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::stop_sign(this),
        _Internal::stop_sign(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.TrafficLightStatus traffic_light = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::traffic_light(this),
        _Internal::traffic_light(this).GetCachedSize(), target, stream);
  }

  // optional .apollo.planning.YieldSignStatus yield_sign = 16;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::yield_sign(this),
        _Internal::yield_sign(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.planning.PlanningStatus)
  return target;
}

size_t PlanningStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.planning.PlanningStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .apollo.planning.BareIntersectionStatus bare_intersection = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.bare_intersection_);
    }

    // optional .apollo.planning.ChangeLaneStatus change_lane = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.change_lane_);
    }

    // optional .apollo.planning.CreepDeciderStatus creep_decider = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.creep_decider_);
    }

    // optional .apollo.planning.CrosswalkStatus crosswalk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.crosswalk_);
    }

    // optional .apollo.planning.DestinationStatus destination = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.destination_);
    }

    // optional .apollo.planning.EmergencyStopStatus emergency_stop = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.emergency_stop_);
    }

    // optional .apollo.planning.OpenSpaceStatus open_space = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.open_space_);
    }

    // optional .apollo.planning.ParkAndGoStatus park_and_go = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.park_and_go_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .apollo.planning.PathDeciderStatus path_decider = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.path_decider_);
    }

    // optional .apollo.planning.PullOverStatus pull_over = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pull_over_);
    }

    // optional .apollo.planning.ReroutingStatus rerouting = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rerouting_);
    }

    // optional .apollo.planning.ScenarioStatus scenario = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scenario_);
    }

    // optional .apollo.planning.SpeedDeciderStatus speed_decider = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.speed_decider_);
    }

    // optional .apollo.planning.StopSignStatus stop_sign = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stop_sign_);
    }

    // optional .apollo.planning.TrafficLightStatus traffic_light = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.traffic_light_);
    }

    // optional .apollo.planning.YieldSignStatus yield_sign = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.yield_sign_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanningStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PlanningStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanningStatus::GetClassData() const { return &_class_data_; }

void PlanningStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PlanningStatus *>(to)->MergeFrom(
      static_cast<const PlanningStatus &>(from));
}


void PlanningStatus::MergeFrom(const PlanningStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.planning.PlanningStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_bare_intersection()->::apollo::planning::BareIntersectionStatus::MergeFrom(from._internal_bare_intersection());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_change_lane()->::apollo::planning::ChangeLaneStatus::MergeFrom(from._internal_change_lane());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_creep_decider()->::apollo::planning::CreepDeciderStatus::MergeFrom(from._internal_creep_decider());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_crosswalk()->::apollo::planning::CrosswalkStatus::MergeFrom(from._internal_crosswalk());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_destination()->::apollo::planning::DestinationStatus::MergeFrom(from._internal_destination());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_emergency_stop()->::apollo::planning::EmergencyStopStatus::MergeFrom(from._internal_emergency_stop());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_open_space()->::apollo::planning::OpenSpaceStatus::MergeFrom(from._internal_open_space());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_park_and_go()->::apollo::planning::ParkAndGoStatus::MergeFrom(from._internal_park_and_go());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_path_decider()->::apollo::planning::PathDeciderStatus::MergeFrom(from._internal_path_decider());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_pull_over()->::apollo::planning::PullOverStatus::MergeFrom(from._internal_pull_over());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_rerouting()->::apollo::planning::ReroutingStatus::MergeFrom(from._internal_rerouting());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_scenario()->::apollo::planning::ScenarioStatus::MergeFrom(from._internal_scenario());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_speed_decider()->::apollo::planning::SpeedDeciderStatus::MergeFrom(from._internal_speed_decider());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_stop_sign()->::apollo::planning::StopSignStatus::MergeFrom(from._internal_stop_sign());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_traffic_light()->::apollo::planning::TrafficLightStatus::MergeFrom(from._internal_traffic_light());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_yield_sign()->::apollo::planning::YieldSignStatus::MergeFrom(from._internal_yield_sign());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanningStatus::CopyFrom(const PlanningStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.planning.PlanningStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanningStatus::IsInitialized() const {
  return true;
}

void PlanningStatus::InternalSwap(PlanningStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlanningStatus, _impl_.yield_sign_)
      + sizeof(PlanningStatus::_impl_.yield_sign_)
      - PROTOBUF_FIELD_OFFSET(PlanningStatus, _impl_.bare_intersection_)>(
          reinterpret_cast<char*>(&_impl_.bare_intersection_),
          reinterpret_cast<char*>(&other->_impl_.bare_intersection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanningStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_getter, &descriptor_table_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto_once,
      file_level_metadata_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto[17]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace planning
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::apollo::planning::BareIntersectionStatus*
Arena::CreateMaybeMessage< ::apollo::planning::BareIntersectionStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::BareIntersectionStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::ChangeLaneStatus*
Arena::CreateMaybeMessage< ::apollo::planning::ChangeLaneStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::ChangeLaneStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::CreepDeciderStatus*
Arena::CreateMaybeMessage< ::apollo::planning::CreepDeciderStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::CreepDeciderStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::StopTime*
Arena::CreateMaybeMessage< ::apollo::planning::StopTime >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::StopTime >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::CrosswalkStatus*
Arena::CreateMaybeMessage< ::apollo::planning::CrosswalkStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::CrosswalkStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::DestinationStatus*
Arena::CreateMaybeMessage< ::apollo::planning::DestinationStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::DestinationStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::EmergencyStopStatus*
Arena::CreateMaybeMessage< ::apollo::planning::EmergencyStopStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::EmergencyStopStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::OpenSpaceStatus*
Arena::CreateMaybeMessage< ::apollo::planning::OpenSpaceStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::OpenSpaceStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::ParkAndGoStatus*
Arena::CreateMaybeMessage< ::apollo::planning::ParkAndGoStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::ParkAndGoStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::PathDeciderStatus*
Arena::CreateMaybeMessage< ::apollo::planning::PathDeciderStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::PathDeciderStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::PullOverStatus*
Arena::CreateMaybeMessage< ::apollo::planning::PullOverStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::PullOverStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::ReroutingStatus*
Arena::CreateMaybeMessage< ::apollo::planning::ReroutingStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::ReroutingStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::SpeedDeciderStatus*
Arena::CreateMaybeMessage< ::apollo::planning::SpeedDeciderStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::SpeedDeciderStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::ScenarioStatus*
Arena::CreateMaybeMessage< ::apollo::planning::ScenarioStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::ScenarioStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::StopSignStatus*
Arena::CreateMaybeMessage< ::apollo::planning::StopSignStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::StopSignStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::TrafficLightStatus*
Arena::CreateMaybeMessage< ::apollo::planning::TrafficLightStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::TrafficLightStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::YieldSignStatus*
Arena::CreateMaybeMessage< ::apollo::planning::YieldSignStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::YieldSignStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::planning::PlanningStatus*
Arena::CreateMaybeMessage< ::apollo::planning::PlanningStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::planning::PlanningStatus >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
