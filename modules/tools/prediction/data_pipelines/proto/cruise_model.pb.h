// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/tools/prediction/data_pipelines/proto/cruise_model.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
class ActivationParameter;
struct ActivationParameterDefaultTypeInternal;
extern ActivationParameterDefaultTypeInternal _ActivationParameter_default_instance_;
class AvgPool1dParameter;
struct AvgPool1dParameterDefaultTypeInternal;
extern AvgPool1dParameterDefaultTypeInternal _AvgPool1dParameter_default_instance_;
class ClassifyParameter;
struct ClassifyParameterDefaultTypeInternal;
extern ClassifyParameterDefaultTypeInternal _ClassifyParameter_default_instance_;
class Conv1dParameter;
struct Conv1dParameterDefaultTypeInternal;
extern Conv1dParameterDefaultTypeInternal _Conv1dParameter_default_instance_;
class CruiseModelParameter;
struct CruiseModelParameterDefaultTypeInternal;
extern CruiseModelParameterDefaultTypeInternal _CruiseModelParameter_default_instance_;
class DenseParameter;
struct DenseParameterDefaultTypeInternal;
extern DenseParameterDefaultTypeInternal _DenseParameter_default_instance_;
class InputParameter;
struct InputParameterDefaultTypeInternal;
extern InputParameterDefaultTypeInternal _InputParameter_default_instance_;
class LaneFeatureConvParameter;
struct LaneFeatureConvParameterDefaultTypeInternal;
extern LaneFeatureConvParameterDefaultTypeInternal _LaneFeatureConvParameter_default_instance_;
class MaxPool1dParameter;
struct MaxPool1dParameterDefaultTypeInternal;
extern MaxPool1dParameterDefaultTypeInternal _MaxPool1dParameter_default_instance_;
class ObsFeatureFCParameter;
struct ObsFeatureFCParameterDefaultTypeInternal;
extern ObsFeatureFCParameterDefaultTypeInternal _ObsFeatureFCParameter_default_instance_;
class RegressParameter;
struct RegressParameterDefaultTypeInternal;
extern RegressParameterDefaultTypeInternal _RegressParameter_default_instance_;
class TensorParameter;
struct TensorParameterDefaultTypeInternal;
extern TensorParameterDefaultTypeInternal _TensorParameter_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ActivationParameter* Arena::CreateMaybeMessage<::ActivationParameter>(Arena*);
template<> ::AvgPool1dParameter* Arena::CreateMaybeMessage<::AvgPool1dParameter>(Arena*);
template<> ::ClassifyParameter* Arena::CreateMaybeMessage<::ClassifyParameter>(Arena*);
template<> ::Conv1dParameter* Arena::CreateMaybeMessage<::Conv1dParameter>(Arena*);
template<> ::CruiseModelParameter* Arena::CreateMaybeMessage<::CruiseModelParameter>(Arena*);
template<> ::DenseParameter* Arena::CreateMaybeMessage<::DenseParameter>(Arena*);
template<> ::InputParameter* Arena::CreateMaybeMessage<::InputParameter>(Arena*);
template<> ::LaneFeatureConvParameter* Arena::CreateMaybeMessage<::LaneFeatureConvParameter>(Arena*);
template<> ::MaxPool1dParameter* Arena::CreateMaybeMessage<::MaxPool1dParameter>(Arena*);
template<> ::ObsFeatureFCParameter* Arena::CreateMaybeMessage<::ObsFeatureFCParameter>(Arena*);
template<> ::RegressParameter* Arena::CreateMaybeMessage<::RegressParameter>(Arena*);
template<> ::TensorParameter* Arena::CreateMaybeMessage<::TensorParameter>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class TensorParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TensorParameter) */ {
 public:
  inline TensorParameter() : TensorParameter(nullptr) {}
  ~TensorParameter() override;
  explicit PROTOBUF_CONSTEXPR TensorParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorParameter(const TensorParameter& from);
  TensorParameter(TensorParameter&& from) noexcept
    : TensorParameter() {
    *this = ::std::move(from);
  }

  inline TensorParameter& operator=(const TensorParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorParameter& operator=(TensorParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorParameter* internal_default_instance() {
    return reinterpret_cast<const TensorParameter*>(
               &_TensorParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TensorParameter& a, TensorParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TensorParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TensorParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TensorParameter";
  }
  protected:
  explicit TensorParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kShapeFieldNumber = 2,
  };
  // repeated float data = 1 [packed = true];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  float _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data() const;
  void _internal_add_data(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data();
  public:
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // repeated int32 shape = 2;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // @@protoc_insertion_point(class_scope:TensorParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class InputParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InputParameter) */ {
 public:
  inline InputParameter() : InputParameter(nullptr) {}
  ~InputParameter() override;
  explicit PROTOBUF_CONSTEXPR InputParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputParameter(const InputParameter& from);
  InputParameter(InputParameter&& from) noexcept
    : InputParameter() {
    *this = ::std::move(from);
  }

  inline InputParameter& operator=(const InputParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputParameter& operator=(InputParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputParameter* internal_default_instance() {
    return reinterpret_cast<const InputParameter*>(
               &_InputParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InputParameter& a, InputParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(InputParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InputParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InputParameter";
  }
  protected:
  explicit InputParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputShapeFieldNumber = 1,
    kDtypeFieldNumber = 2,
    kSparseFieldNumber = 3,
  };
  // repeated int32 input_shape = 1;
  int input_shape_size() const;
  private:
  int _internal_input_shape_size() const;
  public:
  void clear_input_shape();
  private:
  int32_t _internal_input_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_input_shape() const;
  void _internal_add_input_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_input_shape();
  public:
  int32_t input_shape(int index) const;
  void set_input_shape(int index, int32_t value);
  void add_input_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      input_shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_input_shape();

  // optional string dtype = 2;
  bool has_dtype() const;
  private:
  bool _internal_has_dtype() const;
  public:
  void clear_dtype();
  const std::string& dtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dtype();
  PROTOBUF_NODISCARD std::string* release_dtype();
  void set_allocated_dtype(std::string* dtype);
  private:
  const std::string& _internal_dtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dtype(const std::string& value);
  std::string* _internal_mutable_dtype();
  public:

  // optional bool sparse = 3;
  bool has_sparse() const;
  private:
  bool _internal_has_sparse() const;
  public:
  void clear_sparse();
  bool sparse() const;
  void set_sparse(bool value);
  private:
  bool _internal_sparse() const;
  void _internal_set_sparse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:InputParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > input_shape_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dtype_;
    bool sparse_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Conv1dParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Conv1dParameter) */ {
 public:
  inline Conv1dParameter() : Conv1dParameter(nullptr) {}
  ~Conv1dParameter() override;
  explicit PROTOBUF_CONSTEXPR Conv1dParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Conv1dParameter(const Conv1dParameter& from);
  Conv1dParameter(Conv1dParameter&& from) noexcept
    : Conv1dParameter() {
    *this = ::std::move(from);
  }

  inline Conv1dParameter& operator=(const Conv1dParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Conv1dParameter& operator=(Conv1dParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Conv1dParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Conv1dParameter* internal_default_instance() {
    return reinterpret_cast<const Conv1dParameter*>(
               &_Conv1dParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Conv1dParameter& a, Conv1dParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(Conv1dParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Conv1dParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Conv1dParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Conv1dParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Conv1dParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Conv1dParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Conv1dParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Conv1dParameter";
  }
  protected:
  explicit Conv1dParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 1,
    kKernelFieldNumber = 3,
    kBiasFieldNumber = 4,
    kUseBiasFieldNumber = 2,
    kStrideFieldNumber = 5,
  };
  // repeated int32 shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // optional .TensorParameter kernel = 3;
  bool has_kernel() const;
  private:
  bool _internal_has_kernel() const;
  public:
  void clear_kernel();
  const ::TensorParameter& kernel() const;
  PROTOBUF_NODISCARD ::TensorParameter* release_kernel();
  ::TensorParameter* mutable_kernel();
  void set_allocated_kernel(::TensorParameter* kernel);
  private:
  const ::TensorParameter& _internal_kernel() const;
  ::TensorParameter* _internal_mutable_kernel();
  public:
  void unsafe_arena_set_allocated_kernel(
      ::TensorParameter* kernel);
  ::TensorParameter* unsafe_arena_release_kernel();

  // optional .TensorParameter bias = 4;
  bool has_bias() const;
  private:
  bool _internal_has_bias() const;
  public:
  void clear_bias();
  const ::TensorParameter& bias() const;
  PROTOBUF_NODISCARD ::TensorParameter* release_bias();
  ::TensorParameter* mutable_bias();
  void set_allocated_bias(::TensorParameter* bias);
  private:
  const ::TensorParameter& _internal_bias() const;
  ::TensorParameter* _internal_mutable_bias();
  public:
  void unsafe_arena_set_allocated_bias(
      ::TensorParameter* bias);
  ::TensorParameter* unsafe_arena_release_bias();

  // optional bool use_bias = 2;
  bool has_use_bias() const;
  private:
  bool _internal_has_use_bias() const;
  public:
  void clear_use_bias();
  bool use_bias() const;
  void set_use_bias(bool value);
  private:
  bool _internal_use_bias() const;
  void _internal_set_use_bias(bool value);
  public:

  // optional int32 stride = 5;
  bool has_stride() const;
  private:
  bool _internal_has_stride() const;
  public:
  void clear_stride();
  int32_t stride() const;
  void set_stride(int32_t value);
  private:
  int32_t _internal_stride() const;
  void _internal_set_stride(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Conv1dParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
    ::TensorParameter* kernel_;
    ::TensorParameter* bias_;
    bool use_bias_;
    int32_t stride_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class DenseParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DenseParameter) */ {
 public:
  inline DenseParameter() : DenseParameter(nullptr) {}
  ~DenseParameter() override;
  explicit PROTOBUF_CONSTEXPR DenseParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DenseParameter(const DenseParameter& from);
  DenseParameter(DenseParameter&& from) noexcept
    : DenseParameter() {
    *this = ::std::move(from);
  }

  inline DenseParameter& operator=(const DenseParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline DenseParameter& operator=(DenseParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DenseParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const DenseParameter* internal_default_instance() {
    return reinterpret_cast<const DenseParameter*>(
               &_DenseParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DenseParameter& a, DenseParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(DenseParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DenseParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DenseParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DenseParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DenseParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DenseParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DenseParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DenseParameter";
  }
  protected:
  explicit DenseParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivationFieldNumber = 2,
    kWeightsFieldNumber = 4,
    kBiasFieldNumber = 5,
    kUnitsFieldNumber = 1,
    kUseBiasFieldNumber = 3,
  };
  // optional string activation = 2;
  bool has_activation() const;
  private:
  bool _internal_has_activation() const;
  public:
  void clear_activation();
  const std::string& activation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_activation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_activation();
  PROTOBUF_NODISCARD std::string* release_activation();
  void set_allocated_activation(std::string* activation);
  private:
  const std::string& _internal_activation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_activation(const std::string& value);
  std::string* _internal_mutable_activation();
  public:

  // optional .TensorParameter weights = 4;
  bool has_weights() const;
  private:
  bool _internal_has_weights() const;
  public:
  void clear_weights();
  const ::TensorParameter& weights() const;
  PROTOBUF_NODISCARD ::TensorParameter* release_weights();
  ::TensorParameter* mutable_weights();
  void set_allocated_weights(::TensorParameter* weights);
  private:
  const ::TensorParameter& _internal_weights() const;
  ::TensorParameter* _internal_mutable_weights();
  public:
  void unsafe_arena_set_allocated_weights(
      ::TensorParameter* weights);
  ::TensorParameter* unsafe_arena_release_weights();

  // optional .TensorParameter bias = 5;
  bool has_bias() const;
  private:
  bool _internal_has_bias() const;
  public:
  void clear_bias();
  const ::TensorParameter& bias() const;
  PROTOBUF_NODISCARD ::TensorParameter* release_bias();
  ::TensorParameter* mutable_bias();
  void set_allocated_bias(::TensorParameter* bias);
  private:
  const ::TensorParameter& _internal_bias() const;
  ::TensorParameter* _internal_mutable_bias();
  public:
  void unsafe_arena_set_allocated_bias(
      ::TensorParameter* bias);
  ::TensorParameter* unsafe_arena_release_bias();

  // optional int32 units = 1;
  bool has_units() const;
  private:
  bool _internal_has_units() const;
  public:
  void clear_units();
  int32_t units() const;
  void set_units(int32_t value);
  private:
  int32_t _internal_units() const;
  void _internal_set_units(int32_t value);
  public:

  // optional bool use_bias = 3;
  bool has_use_bias() const;
  private:
  bool _internal_has_use_bias() const;
  public:
  void clear_use_bias();
  bool use_bias() const;
  void set_use_bias(bool value);
  private:
  bool _internal_use_bias() const;
  void _internal_set_use_bias(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DenseParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr activation_;
    ::TensorParameter* weights_;
    ::TensorParameter* bias_;
    int32_t units_;
    bool use_bias_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class ActivationParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActivationParameter) */ {
 public:
  inline ActivationParameter() : ActivationParameter(nullptr) {}
  ~ActivationParameter() override;
  explicit PROTOBUF_CONSTEXPR ActivationParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActivationParameter(const ActivationParameter& from);
  ActivationParameter(ActivationParameter&& from) noexcept
    : ActivationParameter() {
    *this = ::std::move(from);
  }

  inline ActivationParameter& operator=(const ActivationParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivationParameter& operator=(ActivationParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivationParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActivationParameter* internal_default_instance() {
    return reinterpret_cast<const ActivationParameter*>(
               &_ActivationParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ActivationParameter& a, ActivationParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ActivationParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivationParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivationParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActivationParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActivationParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActivationParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActivationParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActivationParameter";
  }
  protected:
  explicit ActivationParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivationFieldNumber = 1,
  };
  // optional string activation = 1;
  bool has_activation() const;
  private:
  bool _internal_has_activation() const;
  public:
  void clear_activation();
  const std::string& activation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_activation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_activation();
  PROTOBUF_NODISCARD std::string* release_activation();
  void set_allocated_activation(std::string* activation);
  private:
  const std::string& _internal_activation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_activation(const std::string& value);
  std::string* _internal_mutable_activation();
  public:

  // @@protoc_insertion_point(class_scope:ActivationParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr activation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class MaxPool1dParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MaxPool1dParameter) */ {
 public:
  inline MaxPool1dParameter() : MaxPool1dParameter(nullptr) {}
  ~MaxPool1dParameter() override;
  explicit PROTOBUF_CONSTEXPR MaxPool1dParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaxPool1dParameter(const MaxPool1dParameter& from);
  MaxPool1dParameter(MaxPool1dParameter&& from) noexcept
    : MaxPool1dParameter() {
    *this = ::std::move(from);
  }

  inline MaxPool1dParameter& operator=(const MaxPool1dParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaxPool1dParameter& operator=(MaxPool1dParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaxPool1dParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaxPool1dParameter* internal_default_instance() {
    return reinterpret_cast<const MaxPool1dParameter*>(
               &_MaxPool1dParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MaxPool1dParameter& a, MaxPool1dParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(MaxPool1dParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaxPool1dParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaxPool1dParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MaxPool1dParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MaxPool1dParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MaxPool1dParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaxPool1dParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MaxPool1dParameter";
  }
  protected:
  explicit MaxPool1dParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKernelSizeFieldNumber = 1,
    kStrideFieldNumber = 2,
  };
  // optional int32 kernel_size = 1;
  bool has_kernel_size() const;
  private:
  bool _internal_has_kernel_size() const;
  public:
  void clear_kernel_size();
  int32_t kernel_size() const;
  void set_kernel_size(int32_t value);
  private:
  int32_t _internal_kernel_size() const;
  void _internal_set_kernel_size(int32_t value);
  public:

  // optional int32 stride = 2;
  bool has_stride() const;
  private:
  bool _internal_has_stride() const;
  public:
  void clear_stride();
  int32_t stride() const;
  void set_stride(int32_t value);
  private:
  int32_t _internal_stride() const;
  void _internal_set_stride(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MaxPool1dParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t kernel_size_;
    int32_t stride_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class AvgPool1dParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AvgPool1dParameter) */ {
 public:
  inline AvgPool1dParameter() : AvgPool1dParameter(nullptr) {}
  ~AvgPool1dParameter() override;
  explicit PROTOBUF_CONSTEXPR AvgPool1dParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvgPool1dParameter(const AvgPool1dParameter& from);
  AvgPool1dParameter(AvgPool1dParameter&& from) noexcept
    : AvgPool1dParameter() {
    *this = ::std::move(from);
  }

  inline AvgPool1dParameter& operator=(const AvgPool1dParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvgPool1dParameter& operator=(AvgPool1dParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvgPool1dParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvgPool1dParameter* internal_default_instance() {
    return reinterpret_cast<const AvgPool1dParameter*>(
               &_AvgPool1dParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AvgPool1dParameter& a, AvgPool1dParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(AvgPool1dParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvgPool1dParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvgPool1dParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvgPool1dParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvgPool1dParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AvgPool1dParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvgPool1dParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AvgPool1dParameter";
  }
  protected:
  explicit AvgPool1dParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKernelSizeFieldNumber = 1,
    kStrideFieldNumber = 2,
  };
  // optional int32 kernel_size = 1;
  bool has_kernel_size() const;
  private:
  bool _internal_has_kernel_size() const;
  public:
  void clear_kernel_size();
  int32_t kernel_size() const;
  void set_kernel_size(int32_t value);
  private:
  int32_t _internal_kernel_size() const;
  void _internal_set_kernel_size(int32_t value);
  public:

  // optional int32 stride = 2;
  bool has_stride() const;
  private:
  bool _internal_has_stride() const;
  public:
  void clear_stride();
  int32_t stride() const;
  void set_stride(int32_t value);
  private:
  int32_t _internal_stride() const;
  void _internal_set_stride(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AvgPool1dParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t kernel_size_;
    int32_t stride_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class LaneFeatureConvParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LaneFeatureConvParameter) */ {
 public:
  inline LaneFeatureConvParameter() : LaneFeatureConvParameter(nullptr) {}
  ~LaneFeatureConvParameter() override;
  explicit PROTOBUF_CONSTEXPR LaneFeatureConvParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneFeatureConvParameter(const LaneFeatureConvParameter& from);
  LaneFeatureConvParameter(LaneFeatureConvParameter&& from) noexcept
    : LaneFeatureConvParameter() {
    *this = ::std::move(from);
  }

  inline LaneFeatureConvParameter& operator=(const LaneFeatureConvParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneFeatureConvParameter& operator=(LaneFeatureConvParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneFeatureConvParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneFeatureConvParameter* internal_default_instance() {
    return reinterpret_cast<const LaneFeatureConvParameter*>(
               &_LaneFeatureConvParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LaneFeatureConvParameter& a, LaneFeatureConvParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneFeatureConvParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneFeatureConvParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneFeatureConvParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneFeatureConvParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneFeatureConvParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LaneFeatureConvParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneFeatureConvParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LaneFeatureConvParameter";
  }
  protected:
  explicit LaneFeatureConvParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConv1D0FieldNumber = 1,
    kActivation1FieldNumber = 2,
    kConv1D2FieldNumber = 3,
    kActivation3FieldNumber = 4,
    kConv1D4FieldNumber = 5,
  };
  // optional .Conv1dParameter conv1d_0 = 1;
  bool has_conv1d_0() const;
  private:
  bool _internal_has_conv1d_0() const;
  public:
  void clear_conv1d_0();
  const ::Conv1dParameter& conv1d_0() const;
  PROTOBUF_NODISCARD ::Conv1dParameter* release_conv1d_0();
  ::Conv1dParameter* mutable_conv1d_0();
  void set_allocated_conv1d_0(::Conv1dParameter* conv1d_0);
  private:
  const ::Conv1dParameter& _internal_conv1d_0() const;
  ::Conv1dParameter* _internal_mutable_conv1d_0();
  public:
  void unsafe_arena_set_allocated_conv1d_0(
      ::Conv1dParameter* conv1d_0);
  ::Conv1dParameter* unsafe_arena_release_conv1d_0();

  // optional .ActivationParameter activation_1 = 2;
  bool has_activation_1() const;
  private:
  bool _internal_has_activation_1() const;
  public:
  void clear_activation_1();
  const ::ActivationParameter& activation_1() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_1();
  ::ActivationParameter* mutable_activation_1();
  void set_allocated_activation_1(::ActivationParameter* activation_1);
  private:
  const ::ActivationParameter& _internal_activation_1() const;
  ::ActivationParameter* _internal_mutable_activation_1();
  public:
  void unsafe_arena_set_allocated_activation_1(
      ::ActivationParameter* activation_1);
  ::ActivationParameter* unsafe_arena_release_activation_1();

  // optional .Conv1dParameter conv1d_2 = 3;
  bool has_conv1d_2() const;
  private:
  bool _internal_has_conv1d_2() const;
  public:
  void clear_conv1d_2();
  const ::Conv1dParameter& conv1d_2() const;
  PROTOBUF_NODISCARD ::Conv1dParameter* release_conv1d_2();
  ::Conv1dParameter* mutable_conv1d_2();
  void set_allocated_conv1d_2(::Conv1dParameter* conv1d_2);
  private:
  const ::Conv1dParameter& _internal_conv1d_2() const;
  ::Conv1dParameter* _internal_mutable_conv1d_2();
  public:
  void unsafe_arena_set_allocated_conv1d_2(
      ::Conv1dParameter* conv1d_2);
  ::Conv1dParameter* unsafe_arena_release_conv1d_2();

  // optional .ActivationParameter activation_3 = 4;
  bool has_activation_3() const;
  private:
  bool _internal_has_activation_3() const;
  public:
  void clear_activation_3();
  const ::ActivationParameter& activation_3() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_3();
  ::ActivationParameter* mutable_activation_3();
  void set_allocated_activation_3(::ActivationParameter* activation_3);
  private:
  const ::ActivationParameter& _internal_activation_3() const;
  ::ActivationParameter* _internal_mutable_activation_3();
  public:
  void unsafe_arena_set_allocated_activation_3(
      ::ActivationParameter* activation_3);
  ::ActivationParameter* unsafe_arena_release_activation_3();

  // optional .Conv1dParameter conv1d_4 = 5;
  bool has_conv1d_4() const;
  private:
  bool _internal_has_conv1d_4() const;
  public:
  void clear_conv1d_4();
  const ::Conv1dParameter& conv1d_4() const;
  PROTOBUF_NODISCARD ::Conv1dParameter* release_conv1d_4();
  ::Conv1dParameter* mutable_conv1d_4();
  void set_allocated_conv1d_4(::Conv1dParameter* conv1d_4);
  private:
  const ::Conv1dParameter& _internal_conv1d_4() const;
  ::Conv1dParameter* _internal_mutable_conv1d_4();
  public:
  void unsafe_arena_set_allocated_conv1d_4(
      ::Conv1dParameter* conv1d_4);
  ::Conv1dParameter* unsafe_arena_release_conv1d_4();

  // @@protoc_insertion_point(class_scope:LaneFeatureConvParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Conv1dParameter* conv1d_0_;
    ::ActivationParameter* activation_1_;
    ::Conv1dParameter* conv1d_2_;
    ::ActivationParameter* activation_3_;
    ::Conv1dParameter* conv1d_4_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class ObsFeatureFCParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ObsFeatureFCParameter) */ {
 public:
  inline ObsFeatureFCParameter() : ObsFeatureFCParameter(nullptr) {}
  ~ObsFeatureFCParameter() override;
  explicit PROTOBUF_CONSTEXPR ObsFeatureFCParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObsFeatureFCParameter(const ObsFeatureFCParameter& from);
  ObsFeatureFCParameter(ObsFeatureFCParameter&& from) noexcept
    : ObsFeatureFCParameter() {
    *this = ::std::move(from);
  }

  inline ObsFeatureFCParameter& operator=(const ObsFeatureFCParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObsFeatureFCParameter& operator=(ObsFeatureFCParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObsFeatureFCParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObsFeatureFCParameter* internal_default_instance() {
    return reinterpret_cast<const ObsFeatureFCParameter*>(
               &_ObsFeatureFCParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ObsFeatureFCParameter& a, ObsFeatureFCParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ObsFeatureFCParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObsFeatureFCParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObsFeatureFCParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObsFeatureFCParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObsFeatureFCParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObsFeatureFCParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObsFeatureFCParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ObsFeatureFCParameter";
  }
  protected:
  explicit ObsFeatureFCParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinear0FieldNumber = 1,
    kActivation1FieldNumber = 2,
    kLinear3FieldNumber = 3,
    kActivation4FieldNumber = 4,
  };
  // optional .DenseParameter linear_0 = 1;
  bool has_linear_0() const;
  private:
  bool _internal_has_linear_0() const;
  public:
  void clear_linear_0();
  const ::DenseParameter& linear_0() const;
  PROTOBUF_NODISCARD ::DenseParameter* release_linear_0();
  ::DenseParameter* mutable_linear_0();
  void set_allocated_linear_0(::DenseParameter* linear_0);
  private:
  const ::DenseParameter& _internal_linear_0() const;
  ::DenseParameter* _internal_mutable_linear_0();
  public:
  void unsafe_arena_set_allocated_linear_0(
      ::DenseParameter* linear_0);
  ::DenseParameter* unsafe_arena_release_linear_0();

  // optional .ActivationParameter activation_1 = 2;
  bool has_activation_1() const;
  private:
  bool _internal_has_activation_1() const;
  public:
  void clear_activation_1();
  const ::ActivationParameter& activation_1() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_1();
  ::ActivationParameter* mutable_activation_1();
  void set_allocated_activation_1(::ActivationParameter* activation_1);
  private:
  const ::ActivationParameter& _internal_activation_1() const;
  ::ActivationParameter* _internal_mutable_activation_1();
  public:
  void unsafe_arena_set_allocated_activation_1(
      ::ActivationParameter* activation_1);
  ::ActivationParameter* unsafe_arena_release_activation_1();

  // optional .DenseParameter linear_3 = 3;
  bool has_linear_3() const;
  private:
  bool _internal_has_linear_3() const;
  public:
  void clear_linear_3();
  const ::DenseParameter& linear_3() const;
  PROTOBUF_NODISCARD ::DenseParameter* release_linear_3();
  ::DenseParameter* mutable_linear_3();
  void set_allocated_linear_3(::DenseParameter* linear_3);
  private:
  const ::DenseParameter& _internal_linear_3() const;
  ::DenseParameter* _internal_mutable_linear_3();
  public:
  void unsafe_arena_set_allocated_linear_3(
      ::DenseParameter* linear_3);
  ::DenseParameter* unsafe_arena_release_linear_3();

  // optional .ActivationParameter activation_4 = 4;
  bool has_activation_4() const;
  private:
  bool _internal_has_activation_4() const;
  public:
  void clear_activation_4();
  const ::ActivationParameter& activation_4() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_4();
  ::ActivationParameter* mutable_activation_4();
  void set_allocated_activation_4(::ActivationParameter* activation_4);
  private:
  const ::ActivationParameter& _internal_activation_4() const;
  ::ActivationParameter* _internal_mutable_activation_4();
  public:
  void unsafe_arena_set_allocated_activation_4(
      ::ActivationParameter* activation_4);
  ::ActivationParameter* unsafe_arena_release_activation_4();

  // @@protoc_insertion_point(class_scope:ObsFeatureFCParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::DenseParameter* linear_0_;
    ::ActivationParameter* activation_1_;
    ::DenseParameter* linear_3_;
    ::ActivationParameter* activation_4_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class ClassifyParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClassifyParameter) */ {
 public:
  inline ClassifyParameter() : ClassifyParameter(nullptr) {}
  ~ClassifyParameter() override;
  explicit PROTOBUF_CONSTEXPR ClassifyParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClassifyParameter(const ClassifyParameter& from);
  ClassifyParameter(ClassifyParameter&& from) noexcept
    : ClassifyParameter() {
    *this = ::std::move(from);
  }

  inline ClassifyParameter& operator=(const ClassifyParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassifyParameter& operator=(ClassifyParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClassifyParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClassifyParameter* internal_default_instance() {
    return reinterpret_cast<const ClassifyParameter*>(
               &_ClassifyParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClassifyParameter& a, ClassifyParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ClassifyParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassifyParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassifyParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClassifyParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClassifyParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClassifyParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassifyParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClassifyParameter";
  }
  protected:
  explicit ClassifyParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinear0FieldNumber = 1,
    kActivation1FieldNumber = 2,
    kLinear3FieldNumber = 3,
    kActivation4FieldNumber = 4,
    kLinear6FieldNumber = 5,
    kActivation7FieldNumber = 6,
    kLinear9FieldNumber = 7,
    kActivation10FieldNumber = 8,
  };
  // optional .DenseParameter linear_0 = 1;
  bool has_linear_0() const;
  private:
  bool _internal_has_linear_0() const;
  public:
  void clear_linear_0();
  const ::DenseParameter& linear_0() const;
  PROTOBUF_NODISCARD ::DenseParameter* release_linear_0();
  ::DenseParameter* mutable_linear_0();
  void set_allocated_linear_0(::DenseParameter* linear_0);
  private:
  const ::DenseParameter& _internal_linear_0() const;
  ::DenseParameter* _internal_mutable_linear_0();
  public:
  void unsafe_arena_set_allocated_linear_0(
      ::DenseParameter* linear_0);
  ::DenseParameter* unsafe_arena_release_linear_0();

  // optional .ActivationParameter activation_1 = 2;
  bool has_activation_1() const;
  private:
  bool _internal_has_activation_1() const;
  public:
  void clear_activation_1();
  const ::ActivationParameter& activation_1() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_1();
  ::ActivationParameter* mutable_activation_1();
  void set_allocated_activation_1(::ActivationParameter* activation_1);
  private:
  const ::ActivationParameter& _internal_activation_1() const;
  ::ActivationParameter* _internal_mutable_activation_1();
  public:
  void unsafe_arena_set_allocated_activation_1(
      ::ActivationParameter* activation_1);
  ::ActivationParameter* unsafe_arena_release_activation_1();

  // optional .DenseParameter linear_3 = 3;
  bool has_linear_3() const;
  private:
  bool _internal_has_linear_3() const;
  public:
  void clear_linear_3();
  const ::DenseParameter& linear_3() const;
  PROTOBUF_NODISCARD ::DenseParameter* release_linear_3();
  ::DenseParameter* mutable_linear_3();
  void set_allocated_linear_3(::DenseParameter* linear_3);
  private:
  const ::DenseParameter& _internal_linear_3() const;
  ::DenseParameter* _internal_mutable_linear_3();
  public:
  void unsafe_arena_set_allocated_linear_3(
      ::DenseParameter* linear_3);
  ::DenseParameter* unsafe_arena_release_linear_3();

  // optional .ActivationParameter activation_4 = 4;
  bool has_activation_4() const;
  private:
  bool _internal_has_activation_4() const;
  public:
  void clear_activation_4();
  const ::ActivationParameter& activation_4() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_4();
  ::ActivationParameter* mutable_activation_4();
  void set_allocated_activation_4(::ActivationParameter* activation_4);
  private:
  const ::ActivationParameter& _internal_activation_4() const;
  ::ActivationParameter* _internal_mutable_activation_4();
  public:
  void unsafe_arena_set_allocated_activation_4(
      ::ActivationParameter* activation_4);
  ::ActivationParameter* unsafe_arena_release_activation_4();

  // optional .DenseParameter linear_6 = 5;
  bool has_linear_6() const;
  private:
  bool _internal_has_linear_6() const;
  public:
  void clear_linear_6();
  const ::DenseParameter& linear_6() const;
  PROTOBUF_NODISCARD ::DenseParameter* release_linear_6();
  ::DenseParameter* mutable_linear_6();
  void set_allocated_linear_6(::DenseParameter* linear_6);
  private:
  const ::DenseParameter& _internal_linear_6() const;
  ::DenseParameter* _internal_mutable_linear_6();
  public:
  void unsafe_arena_set_allocated_linear_6(
      ::DenseParameter* linear_6);
  ::DenseParameter* unsafe_arena_release_linear_6();

  // optional .ActivationParameter activation_7 = 6;
  bool has_activation_7() const;
  private:
  bool _internal_has_activation_7() const;
  public:
  void clear_activation_7();
  const ::ActivationParameter& activation_7() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_7();
  ::ActivationParameter* mutable_activation_7();
  void set_allocated_activation_7(::ActivationParameter* activation_7);
  private:
  const ::ActivationParameter& _internal_activation_7() const;
  ::ActivationParameter* _internal_mutable_activation_7();
  public:
  void unsafe_arena_set_allocated_activation_7(
      ::ActivationParameter* activation_7);
  ::ActivationParameter* unsafe_arena_release_activation_7();

  // optional .DenseParameter linear_9 = 7;
  bool has_linear_9() const;
  private:
  bool _internal_has_linear_9() const;
  public:
  void clear_linear_9();
  const ::DenseParameter& linear_9() const;
  PROTOBUF_NODISCARD ::DenseParameter* release_linear_9();
  ::DenseParameter* mutable_linear_9();
  void set_allocated_linear_9(::DenseParameter* linear_9);
  private:
  const ::DenseParameter& _internal_linear_9() const;
  ::DenseParameter* _internal_mutable_linear_9();
  public:
  void unsafe_arena_set_allocated_linear_9(
      ::DenseParameter* linear_9);
  ::DenseParameter* unsafe_arena_release_linear_9();

  // optional .ActivationParameter activation_10 = 8;
  bool has_activation_10() const;
  private:
  bool _internal_has_activation_10() const;
  public:
  void clear_activation_10();
  const ::ActivationParameter& activation_10() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_10();
  ::ActivationParameter* mutable_activation_10();
  void set_allocated_activation_10(::ActivationParameter* activation_10);
  private:
  const ::ActivationParameter& _internal_activation_10() const;
  ::ActivationParameter* _internal_mutable_activation_10();
  public:
  void unsafe_arena_set_allocated_activation_10(
      ::ActivationParameter* activation_10);
  ::ActivationParameter* unsafe_arena_release_activation_10();

  // @@protoc_insertion_point(class_scope:ClassifyParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::DenseParameter* linear_0_;
    ::ActivationParameter* activation_1_;
    ::DenseParameter* linear_3_;
    ::ActivationParameter* activation_4_;
    ::DenseParameter* linear_6_;
    ::ActivationParameter* activation_7_;
    ::DenseParameter* linear_9_;
    ::ActivationParameter* activation_10_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class RegressParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegressParameter) */ {
 public:
  inline RegressParameter() : RegressParameter(nullptr) {}
  ~RegressParameter() override;
  explicit PROTOBUF_CONSTEXPR RegressParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegressParameter(const RegressParameter& from);
  RegressParameter(RegressParameter&& from) noexcept
    : RegressParameter() {
    *this = ::std::move(from);
  }

  inline RegressParameter& operator=(const RegressParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegressParameter& operator=(RegressParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegressParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegressParameter* internal_default_instance() {
    return reinterpret_cast<const RegressParameter*>(
               &_RegressParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RegressParameter& a, RegressParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(RegressParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegressParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegressParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegressParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegressParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegressParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegressParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegressParameter";
  }
  protected:
  explicit RegressParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinear0FieldNumber = 1,
    kActivation1FieldNumber = 2,
    kLinear3FieldNumber = 3,
    kActivation4FieldNumber = 4,
    kLinear6FieldNumber = 5,
    kActivation7FieldNumber = 6,
    kLinear9FieldNumber = 7,
    kActivation10FieldNumber = 8,
  };
  // optional .DenseParameter linear_0 = 1;
  bool has_linear_0() const;
  private:
  bool _internal_has_linear_0() const;
  public:
  void clear_linear_0();
  const ::DenseParameter& linear_0() const;
  PROTOBUF_NODISCARD ::DenseParameter* release_linear_0();
  ::DenseParameter* mutable_linear_0();
  void set_allocated_linear_0(::DenseParameter* linear_0);
  private:
  const ::DenseParameter& _internal_linear_0() const;
  ::DenseParameter* _internal_mutable_linear_0();
  public:
  void unsafe_arena_set_allocated_linear_0(
      ::DenseParameter* linear_0);
  ::DenseParameter* unsafe_arena_release_linear_0();

  // optional .ActivationParameter activation_1 = 2;
  bool has_activation_1() const;
  private:
  bool _internal_has_activation_1() const;
  public:
  void clear_activation_1();
  const ::ActivationParameter& activation_1() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_1();
  ::ActivationParameter* mutable_activation_1();
  void set_allocated_activation_1(::ActivationParameter* activation_1);
  private:
  const ::ActivationParameter& _internal_activation_1() const;
  ::ActivationParameter* _internal_mutable_activation_1();
  public:
  void unsafe_arena_set_allocated_activation_1(
      ::ActivationParameter* activation_1);
  ::ActivationParameter* unsafe_arena_release_activation_1();

  // optional .DenseParameter linear_3 = 3;
  bool has_linear_3() const;
  private:
  bool _internal_has_linear_3() const;
  public:
  void clear_linear_3();
  const ::DenseParameter& linear_3() const;
  PROTOBUF_NODISCARD ::DenseParameter* release_linear_3();
  ::DenseParameter* mutable_linear_3();
  void set_allocated_linear_3(::DenseParameter* linear_3);
  private:
  const ::DenseParameter& _internal_linear_3() const;
  ::DenseParameter* _internal_mutable_linear_3();
  public:
  void unsafe_arena_set_allocated_linear_3(
      ::DenseParameter* linear_3);
  ::DenseParameter* unsafe_arena_release_linear_3();

  // optional .ActivationParameter activation_4 = 4;
  bool has_activation_4() const;
  private:
  bool _internal_has_activation_4() const;
  public:
  void clear_activation_4();
  const ::ActivationParameter& activation_4() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_4();
  ::ActivationParameter* mutable_activation_4();
  void set_allocated_activation_4(::ActivationParameter* activation_4);
  private:
  const ::ActivationParameter& _internal_activation_4() const;
  ::ActivationParameter* _internal_mutable_activation_4();
  public:
  void unsafe_arena_set_allocated_activation_4(
      ::ActivationParameter* activation_4);
  ::ActivationParameter* unsafe_arena_release_activation_4();

  // optional .DenseParameter linear_6 = 5;
  bool has_linear_6() const;
  private:
  bool _internal_has_linear_6() const;
  public:
  void clear_linear_6();
  const ::DenseParameter& linear_6() const;
  PROTOBUF_NODISCARD ::DenseParameter* release_linear_6();
  ::DenseParameter* mutable_linear_6();
  void set_allocated_linear_6(::DenseParameter* linear_6);
  private:
  const ::DenseParameter& _internal_linear_6() const;
  ::DenseParameter* _internal_mutable_linear_6();
  public:
  void unsafe_arena_set_allocated_linear_6(
      ::DenseParameter* linear_6);
  ::DenseParameter* unsafe_arena_release_linear_6();

  // optional .ActivationParameter activation_7 = 6;
  bool has_activation_7() const;
  private:
  bool _internal_has_activation_7() const;
  public:
  void clear_activation_7();
  const ::ActivationParameter& activation_7() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_7();
  ::ActivationParameter* mutable_activation_7();
  void set_allocated_activation_7(::ActivationParameter* activation_7);
  private:
  const ::ActivationParameter& _internal_activation_7() const;
  ::ActivationParameter* _internal_mutable_activation_7();
  public:
  void unsafe_arena_set_allocated_activation_7(
      ::ActivationParameter* activation_7);
  ::ActivationParameter* unsafe_arena_release_activation_7();

  // optional .DenseParameter linear_9 = 7;
  bool has_linear_9() const;
  private:
  bool _internal_has_linear_9() const;
  public:
  void clear_linear_9();
  const ::DenseParameter& linear_9() const;
  PROTOBUF_NODISCARD ::DenseParameter* release_linear_9();
  ::DenseParameter* mutable_linear_9();
  void set_allocated_linear_9(::DenseParameter* linear_9);
  private:
  const ::DenseParameter& _internal_linear_9() const;
  ::DenseParameter* _internal_mutable_linear_9();
  public:
  void unsafe_arena_set_allocated_linear_9(
      ::DenseParameter* linear_9);
  ::DenseParameter* unsafe_arena_release_linear_9();

  // optional .ActivationParameter activation_10 = 8;
  bool has_activation_10() const;
  private:
  bool _internal_has_activation_10() const;
  public:
  void clear_activation_10();
  const ::ActivationParameter& activation_10() const;
  PROTOBUF_NODISCARD ::ActivationParameter* release_activation_10();
  ::ActivationParameter* mutable_activation_10();
  void set_allocated_activation_10(::ActivationParameter* activation_10);
  private:
  const ::ActivationParameter& _internal_activation_10() const;
  ::ActivationParameter* _internal_mutable_activation_10();
  public:
  void unsafe_arena_set_allocated_activation_10(
      ::ActivationParameter* activation_10);
  ::ActivationParameter* unsafe_arena_release_activation_10();

  // @@protoc_insertion_point(class_scope:RegressParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::DenseParameter* linear_0_;
    ::ActivationParameter* activation_1_;
    ::DenseParameter* linear_3_;
    ::ActivationParameter* activation_4_;
    ::DenseParameter* linear_6_;
    ::ActivationParameter* activation_7_;
    ::DenseParameter* linear_9_;
    ::ActivationParameter* activation_10_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class CruiseModelParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CruiseModelParameter) */ {
 public:
  inline CruiseModelParameter() : CruiseModelParameter(nullptr) {}
  ~CruiseModelParameter() override;
  explicit PROTOBUF_CONSTEXPR CruiseModelParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CruiseModelParameter(const CruiseModelParameter& from);
  CruiseModelParameter(CruiseModelParameter&& from) noexcept
    : CruiseModelParameter() {
    *this = ::std::move(from);
  }

  inline CruiseModelParameter& operator=(const CruiseModelParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CruiseModelParameter& operator=(CruiseModelParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CruiseModelParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CruiseModelParameter* internal_default_instance() {
    return reinterpret_cast<const CruiseModelParameter*>(
               &_CruiseModelParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CruiseModelParameter& a, CruiseModelParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(CruiseModelParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CruiseModelParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CruiseModelParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CruiseModelParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CruiseModelParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CruiseModelParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CruiseModelParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CruiseModelParameter";
  }
  protected:
  explicit CruiseModelParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneFeatureConvFieldNumber = 1,
    kLaneFeatureMaxpoolFieldNumber = 2,
    kLaneFeatureAvgpoolFieldNumber = 3,
    kObsFeatureFcFieldNumber = 5,
    kClassifyFieldNumber = 6,
    kRegressFieldNumber = 7,
  };
  // optional .LaneFeatureConvParameter lane_feature_conv = 1;
  bool has_lane_feature_conv() const;
  private:
  bool _internal_has_lane_feature_conv() const;
  public:
  void clear_lane_feature_conv();
  const ::LaneFeatureConvParameter& lane_feature_conv() const;
  PROTOBUF_NODISCARD ::LaneFeatureConvParameter* release_lane_feature_conv();
  ::LaneFeatureConvParameter* mutable_lane_feature_conv();
  void set_allocated_lane_feature_conv(::LaneFeatureConvParameter* lane_feature_conv);
  private:
  const ::LaneFeatureConvParameter& _internal_lane_feature_conv() const;
  ::LaneFeatureConvParameter* _internal_mutable_lane_feature_conv();
  public:
  void unsafe_arena_set_allocated_lane_feature_conv(
      ::LaneFeatureConvParameter* lane_feature_conv);
  ::LaneFeatureConvParameter* unsafe_arena_release_lane_feature_conv();

  // optional .MaxPool1dParameter lane_feature_maxpool = 2;
  bool has_lane_feature_maxpool() const;
  private:
  bool _internal_has_lane_feature_maxpool() const;
  public:
  void clear_lane_feature_maxpool();
  const ::MaxPool1dParameter& lane_feature_maxpool() const;
  PROTOBUF_NODISCARD ::MaxPool1dParameter* release_lane_feature_maxpool();
  ::MaxPool1dParameter* mutable_lane_feature_maxpool();
  void set_allocated_lane_feature_maxpool(::MaxPool1dParameter* lane_feature_maxpool);
  private:
  const ::MaxPool1dParameter& _internal_lane_feature_maxpool() const;
  ::MaxPool1dParameter* _internal_mutable_lane_feature_maxpool();
  public:
  void unsafe_arena_set_allocated_lane_feature_maxpool(
      ::MaxPool1dParameter* lane_feature_maxpool);
  ::MaxPool1dParameter* unsafe_arena_release_lane_feature_maxpool();

  // optional .AvgPool1dParameter lane_feature_avgpool = 3;
  bool has_lane_feature_avgpool() const;
  private:
  bool _internal_has_lane_feature_avgpool() const;
  public:
  void clear_lane_feature_avgpool();
  const ::AvgPool1dParameter& lane_feature_avgpool() const;
  PROTOBUF_NODISCARD ::AvgPool1dParameter* release_lane_feature_avgpool();
  ::AvgPool1dParameter* mutable_lane_feature_avgpool();
  void set_allocated_lane_feature_avgpool(::AvgPool1dParameter* lane_feature_avgpool);
  private:
  const ::AvgPool1dParameter& _internal_lane_feature_avgpool() const;
  ::AvgPool1dParameter* _internal_mutable_lane_feature_avgpool();
  public:
  void unsafe_arena_set_allocated_lane_feature_avgpool(
      ::AvgPool1dParameter* lane_feature_avgpool);
  ::AvgPool1dParameter* unsafe_arena_release_lane_feature_avgpool();

  // optional .ObsFeatureFCParameter obs_feature_fc = 5;
  bool has_obs_feature_fc() const;
  private:
  bool _internal_has_obs_feature_fc() const;
  public:
  void clear_obs_feature_fc();
  const ::ObsFeatureFCParameter& obs_feature_fc() const;
  PROTOBUF_NODISCARD ::ObsFeatureFCParameter* release_obs_feature_fc();
  ::ObsFeatureFCParameter* mutable_obs_feature_fc();
  void set_allocated_obs_feature_fc(::ObsFeatureFCParameter* obs_feature_fc);
  private:
  const ::ObsFeatureFCParameter& _internal_obs_feature_fc() const;
  ::ObsFeatureFCParameter* _internal_mutable_obs_feature_fc();
  public:
  void unsafe_arena_set_allocated_obs_feature_fc(
      ::ObsFeatureFCParameter* obs_feature_fc);
  ::ObsFeatureFCParameter* unsafe_arena_release_obs_feature_fc();

  // optional .ClassifyParameter classify = 6;
  bool has_classify() const;
  private:
  bool _internal_has_classify() const;
  public:
  void clear_classify();
  const ::ClassifyParameter& classify() const;
  PROTOBUF_NODISCARD ::ClassifyParameter* release_classify();
  ::ClassifyParameter* mutable_classify();
  void set_allocated_classify(::ClassifyParameter* classify);
  private:
  const ::ClassifyParameter& _internal_classify() const;
  ::ClassifyParameter* _internal_mutable_classify();
  public:
  void unsafe_arena_set_allocated_classify(
      ::ClassifyParameter* classify);
  ::ClassifyParameter* unsafe_arena_release_classify();

  // optional .RegressParameter regress = 7;
  bool has_regress() const;
  private:
  bool _internal_has_regress() const;
  public:
  void clear_regress();
  const ::RegressParameter& regress() const;
  PROTOBUF_NODISCARD ::RegressParameter* release_regress();
  ::RegressParameter* mutable_regress();
  void set_allocated_regress(::RegressParameter* regress);
  private:
  const ::RegressParameter& _internal_regress() const;
  ::RegressParameter* _internal_mutable_regress();
  public:
  void unsafe_arena_set_allocated_regress(
      ::RegressParameter* regress);
  ::RegressParameter* unsafe_arena_release_regress();

  // @@protoc_insertion_point(class_scope:CruiseModelParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::LaneFeatureConvParameter* lane_feature_conv_;
    ::MaxPool1dParameter* lane_feature_maxpool_;
    ::AvgPool1dParameter* lane_feature_avgpool_;
    ::ObsFeatureFCParameter* obs_feature_fc_;
    ::ClassifyParameter* classify_;
    ::RegressParameter* regress_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TensorParameter

// repeated float data = 1 [packed = true];
inline int TensorParameter::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int TensorParameter::data_size() const {
  return _internal_data_size();
}
inline void TensorParameter::clear_data() {
  _impl_.data_.Clear();
}
inline float TensorParameter::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline float TensorParameter::data(int index) const {
  // @@protoc_insertion_point(field_get:TensorParameter.data)
  return _internal_data(index);
}
inline void TensorParameter::set_data(int index, float value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:TensorParameter.data)
}
inline void TensorParameter::_internal_add_data(float value) {
  _impl_.data_.Add(value);
}
inline void TensorParameter::add_data(float value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:TensorParameter.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TensorParameter::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TensorParameter::data() const {
  // @@protoc_insertion_point(field_list:TensorParameter.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TensorParameter::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TensorParameter::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:TensorParameter.data)
  return _internal_mutable_data();
}

// repeated int32 shape = 2;
inline int TensorParameter::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int TensorParameter::shape_size() const {
  return _internal_shape_size();
}
inline void TensorParameter::clear_shape() {
  _impl_.shape_.Clear();
}
inline int32_t TensorParameter::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int32_t TensorParameter::shape(int index) const {
  // @@protoc_insertion_point(field_get:TensorParameter.shape)
  return _internal_shape(index);
}
inline void TensorParameter::set_shape(int index, int32_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:TensorParameter.shape)
}
inline void TensorParameter::_internal_add_shape(int32_t value) {
  _impl_.shape_.Add(value);
}
inline void TensorParameter::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:TensorParameter.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TensorParameter::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TensorParameter::shape() const {
  // @@protoc_insertion_point(field_list:TensorParameter.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TensorParameter::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TensorParameter::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:TensorParameter.shape)
  return _internal_mutable_shape();
}

// -------------------------------------------------------------------

// InputParameter

// repeated int32 input_shape = 1;
inline int InputParameter::_internal_input_shape_size() const {
  return _impl_.input_shape_.size();
}
inline int InputParameter::input_shape_size() const {
  return _internal_input_shape_size();
}
inline void InputParameter::clear_input_shape() {
  _impl_.input_shape_.Clear();
}
inline int32_t InputParameter::_internal_input_shape(int index) const {
  return _impl_.input_shape_.Get(index);
}
inline int32_t InputParameter::input_shape(int index) const {
  // @@protoc_insertion_point(field_get:InputParameter.input_shape)
  return _internal_input_shape(index);
}
inline void InputParameter::set_input_shape(int index, int32_t value) {
  _impl_.input_shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:InputParameter.input_shape)
}
inline void InputParameter::_internal_add_input_shape(int32_t value) {
  _impl_.input_shape_.Add(value);
}
inline void InputParameter::add_input_shape(int32_t value) {
  _internal_add_input_shape(value);
  // @@protoc_insertion_point(field_add:InputParameter.input_shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
InputParameter::_internal_input_shape() const {
  return _impl_.input_shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
InputParameter::input_shape() const {
  // @@protoc_insertion_point(field_list:InputParameter.input_shape)
  return _internal_input_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
InputParameter::_internal_mutable_input_shape() {
  return &_impl_.input_shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
InputParameter::mutable_input_shape() {
  // @@protoc_insertion_point(field_mutable_list:InputParameter.input_shape)
  return _internal_mutable_input_shape();
}

// optional string dtype = 2;
inline bool InputParameter::_internal_has_dtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InputParameter::has_dtype() const {
  return _internal_has_dtype();
}
inline void InputParameter::clear_dtype() {
  _impl_.dtype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputParameter::dtype() const {
  // @@protoc_insertion_point(field_get:InputParameter.dtype)
  return _internal_dtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputParameter::set_dtype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dtype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InputParameter.dtype)
}
inline std::string* InputParameter::mutable_dtype() {
  std::string* _s = _internal_mutable_dtype();
  // @@protoc_insertion_point(field_mutable:InputParameter.dtype)
  return _s;
}
inline const std::string& InputParameter::_internal_dtype() const {
  return _impl_.dtype_.Get();
}
inline void InputParameter::_internal_set_dtype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dtype_.Set(value, GetArenaForAllocation());
}
inline std::string* InputParameter::_internal_mutable_dtype() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dtype_.Mutable(GetArenaForAllocation());
}
inline std::string* InputParameter::release_dtype() {
  // @@protoc_insertion_point(field_release:InputParameter.dtype)
  if (!_internal_has_dtype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dtype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dtype_.IsDefault()) {
    _impl_.dtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InputParameter::set_allocated_dtype(std::string* dtype) {
  if (dtype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dtype_.SetAllocated(dtype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dtype_.IsDefault()) {
    _impl_.dtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InputParameter.dtype)
}

// optional bool sparse = 3;
inline bool InputParameter::_internal_has_sparse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InputParameter::has_sparse() const {
  return _internal_has_sparse();
}
inline void InputParameter::clear_sparse() {
  _impl_.sparse_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool InputParameter::_internal_sparse() const {
  return _impl_.sparse_;
}
inline bool InputParameter::sparse() const {
  // @@protoc_insertion_point(field_get:InputParameter.sparse)
  return _internal_sparse();
}
inline void InputParameter::_internal_set_sparse(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sparse_ = value;
}
inline void InputParameter::set_sparse(bool value) {
  _internal_set_sparse(value);
  // @@protoc_insertion_point(field_set:InputParameter.sparse)
}

// -------------------------------------------------------------------

// Conv1dParameter

// repeated int32 shape = 1;
inline int Conv1dParameter::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int Conv1dParameter::shape_size() const {
  return _internal_shape_size();
}
inline void Conv1dParameter::clear_shape() {
  _impl_.shape_.Clear();
}
inline int32_t Conv1dParameter::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline int32_t Conv1dParameter::shape(int index) const {
  // @@protoc_insertion_point(field_get:Conv1dParameter.shape)
  return _internal_shape(index);
}
inline void Conv1dParameter::set_shape(int index, int32_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:Conv1dParameter.shape)
}
inline void Conv1dParameter::_internal_add_shape(int32_t value) {
  _impl_.shape_.Add(value);
}
inline void Conv1dParameter::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:Conv1dParameter.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Conv1dParameter::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Conv1dParameter::shape() const {
  // @@protoc_insertion_point(field_list:Conv1dParameter.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Conv1dParameter::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Conv1dParameter::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:Conv1dParameter.shape)
  return _internal_mutable_shape();
}

// optional bool use_bias = 2;
inline bool Conv1dParameter::_internal_has_use_bias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Conv1dParameter::has_use_bias() const {
  return _internal_has_use_bias();
}
inline void Conv1dParameter::clear_use_bias() {
  _impl_.use_bias_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Conv1dParameter::_internal_use_bias() const {
  return _impl_.use_bias_;
}
inline bool Conv1dParameter::use_bias() const {
  // @@protoc_insertion_point(field_get:Conv1dParameter.use_bias)
  return _internal_use_bias();
}
inline void Conv1dParameter::_internal_set_use_bias(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.use_bias_ = value;
}
inline void Conv1dParameter::set_use_bias(bool value) {
  _internal_set_use_bias(value);
  // @@protoc_insertion_point(field_set:Conv1dParameter.use_bias)
}

// optional .TensorParameter kernel = 3;
inline bool Conv1dParameter::_internal_has_kernel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kernel_ != nullptr);
  return value;
}
inline bool Conv1dParameter::has_kernel() const {
  return _internal_has_kernel();
}
inline void Conv1dParameter::clear_kernel() {
  if (_impl_.kernel_ != nullptr) _impl_.kernel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TensorParameter& Conv1dParameter::_internal_kernel() const {
  const ::TensorParameter* p = _impl_.kernel_;
  return p != nullptr ? *p : reinterpret_cast<const ::TensorParameter&>(
      ::_TensorParameter_default_instance_);
}
inline const ::TensorParameter& Conv1dParameter::kernel() const {
  // @@protoc_insertion_point(field_get:Conv1dParameter.kernel)
  return _internal_kernel();
}
inline void Conv1dParameter::unsafe_arena_set_allocated_kernel(
    ::TensorParameter* kernel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kernel_);
  }
  _impl_.kernel_ = kernel;
  if (kernel) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Conv1dParameter.kernel)
}
inline ::TensorParameter* Conv1dParameter::release_kernel() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TensorParameter* temp = _impl_.kernel_;
  _impl_.kernel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TensorParameter* Conv1dParameter::unsafe_arena_release_kernel() {
  // @@protoc_insertion_point(field_release:Conv1dParameter.kernel)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TensorParameter* temp = _impl_.kernel_;
  _impl_.kernel_ = nullptr;
  return temp;
}
inline ::TensorParameter* Conv1dParameter::_internal_mutable_kernel() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.kernel_ == nullptr) {
    auto* p = CreateMaybeMessage<::TensorParameter>(GetArenaForAllocation());
    _impl_.kernel_ = p;
  }
  return _impl_.kernel_;
}
inline ::TensorParameter* Conv1dParameter::mutable_kernel() {
  ::TensorParameter* _msg = _internal_mutable_kernel();
  // @@protoc_insertion_point(field_mutable:Conv1dParameter.kernel)
  return _msg;
}
inline void Conv1dParameter::set_allocated_kernel(::TensorParameter* kernel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.kernel_;
  }
  if (kernel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kernel);
    if (message_arena != submessage_arena) {
      kernel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kernel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.kernel_ = kernel;
  // @@protoc_insertion_point(field_set_allocated:Conv1dParameter.kernel)
}

// optional .TensorParameter bias = 4;
inline bool Conv1dParameter::_internal_has_bias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bias_ != nullptr);
  return value;
}
inline bool Conv1dParameter::has_bias() const {
  return _internal_has_bias();
}
inline void Conv1dParameter::clear_bias() {
  if (_impl_.bias_ != nullptr) _impl_.bias_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TensorParameter& Conv1dParameter::_internal_bias() const {
  const ::TensorParameter* p = _impl_.bias_;
  return p != nullptr ? *p : reinterpret_cast<const ::TensorParameter&>(
      ::_TensorParameter_default_instance_);
}
inline const ::TensorParameter& Conv1dParameter::bias() const {
  // @@protoc_insertion_point(field_get:Conv1dParameter.bias)
  return _internal_bias();
}
inline void Conv1dParameter::unsafe_arena_set_allocated_bias(
    ::TensorParameter* bias) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bias_);
  }
  _impl_.bias_ = bias;
  if (bias) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Conv1dParameter.bias)
}
inline ::TensorParameter* Conv1dParameter::release_bias() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TensorParameter* temp = _impl_.bias_;
  _impl_.bias_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TensorParameter* Conv1dParameter::unsafe_arena_release_bias() {
  // @@protoc_insertion_point(field_release:Conv1dParameter.bias)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TensorParameter* temp = _impl_.bias_;
  _impl_.bias_ = nullptr;
  return temp;
}
inline ::TensorParameter* Conv1dParameter::_internal_mutable_bias() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.bias_ == nullptr) {
    auto* p = CreateMaybeMessage<::TensorParameter>(GetArenaForAllocation());
    _impl_.bias_ = p;
  }
  return _impl_.bias_;
}
inline ::TensorParameter* Conv1dParameter::mutable_bias() {
  ::TensorParameter* _msg = _internal_mutable_bias();
  // @@protoc_insertion_point(field_mutable:Conv1dParameter.bias)
  return _msg;
}
inline void Conv1dParameter::set_allocated_bias(::TensorParameter* bias) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bias_;
  }
  if (bias) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bias);
    if (message_arena != submessage_arena) {
      bias = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bias, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.bias_ = bias;
  // @@protoc_insertion_point(field_set_allocated:Conv1dParameter.bias)
}

// optional int32 stride = 5;
inline bool Conv1dParameter::_internal_has_stride() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Conv1dParameter::has_stride() const {
  return _internal_has_stride();
}
inline void Conv1dParameter::clear_stride() {
  _impl_.stride_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Conv1dParameter::_internal_stride() const {
  return _impl_.stride_;
}
inline int32_t Conv1dParameter::stride() const {
  // @@protoc_insertion_point(field_get:Conv1dParameter.stride)
  return _internal_stride();
}
inline void Conv1dParameter::_internal_set_stride(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stride_ = value;
}
inline void Conv1dParameter::set_stride(int32_t value) {
  _internal_set_stride(value);
  // @@protoc_insertion_point(field_set:Conv1dParameter.stride)
}

// -------------------------------------------------------------------

// DenseParameter

// optional int32 units = 1;
inline bool DenseParameter::_internal_has_units() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DenseParameter::has_units() const {
  return _internal_has_units();
}
inline void DenseParameter::clear_units() {
  _impl_.units_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t DenseParameter::_internal_units() const {
  return _impl_.units_;
}
inline int32_t DenseParameter::units() const {
  // @@protoc_insertion_point(field_get:DenseParameter.units)
  return _internal_units();
}
inline void DenseParameter::_internal_set_units(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.units_ = value;
}
inline void DenseParameter::set_units(int32_t value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:DenseParameter.units)
}

// optional string activation = 2;
inline bool DenseParameter::_internal_has_activation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DenseParameter::has_activation() const {
  return _internal_has_activation();
}
inline void DenseParameter::clear_activation() {
  _impl_.activation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DenseParameter::activation() const {
  // @@protoc_insertion_point(field_get:DenseParameter.activation)
  return _internal_activation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DenseParameter::set_activation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.activation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DenseParameter.activation)
}
inline std::string* DenseParameter::mutable_activation() {
  std::string* _s = _internal_mutable_activation();
  // @@protoc_insertion_point(field_mutable:DenseParameter.activation)
  return _s;
}
inline const std::string& DenseParameter::_internal_activation() const {
  return _impl_.activation_.Get();
}
inline void DenseParameter::_internal_set_activation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.activation_.Set(value, GetArenaForAllocation());
}
inline std::string* DenseParameter::_internal_mutable_activation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.activation_.Mutable(GetArenaForAllocation());
}
inline std::string* DenseParameter::release_activation() {
  // @@protoc_insertion_point(field_release:DenseParameter.activation)
  if (!_internal_has_activation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.activation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.activation_.IsDefault()) {
    _impl_.activation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DenseParameter::set_allocated_activation(std::string* activation) {
  if (activation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.activation_.SetAllocated(activation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.activation_.IsDefault()) {
    _impl_.activation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DenseParameter.activation)
}

// optional bool use_bias = 3;
inline bool DenseParameter::_internal_has_use_bias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DenseParameter::has_use_bias() const {
  return _internal_has_use_bias();
}
inline void DenseParameter::clear_use_bias() {
  _impl_.use_bias_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool DenseParameter::_internal_use_bias() const {
  return _impl_.use_bias_;
}
inline bool DenseParameter::use_bias() const {
  // @@protoc_insertion_point(field_get:DenseParameter.use_bias)
  return _internal_use_bias();
}
inline void DenseParameter::_internal_set_use_bias(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.use_bias_ = value;
}
inline void DenseParameter::set_use_bias(bool value) {
  _internal_set_use_bias(value);
  // @@protoc_insertion_point(field_set:DenseParameter.use_bias)
}

// optional .TensorParameter weights = 4;
inline bool DenseParameter::_internal_has_weights() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.weights_ != nullptr);
  return value;
}
inline bool DenseParameter::has_weights() const {
  return _internal_has_weights();
}
inline void DenseParameter::clear_weights() {
  if (_impl_.weights_ != nullptr) _impl_.weights_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TensorParameter& DenseParameter::_internal_weights() const {
  const ::TensorParameter* p = _impl_.weights_;
  return p != nullptr ? *p : reinterpret_cast<const ::TensorParameter&>(
      ::_TensorParameter_default_instance_);
}
inline const ::TensorParameter& DenseParameter::weights() const {
  // @@protoc_insertion_point(field_get:DenseParameter.weights)
  return _internal_weights();
}
inline void DenseParameter::unsafe_arena_set_allocated_weights(
    ::TensorParameter* weights) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.weights_);
  }
  _impl_.weights_ = weights;
  if (weights) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DenseParameter.weights)
}
inline ::TensorParameter* DenseParameter::release_weights() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TensorParameter* temp = _impl_.weights_;
  _impl_.weights_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TensorParameter* DenseParameter::unsafe_arena_release_weights() {
  // @@protoc_insertion_point(field_release:DenseParameter.weights)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TensorParameter* temp = _impl_.weights_;
  _impl_.weights_ = nullptr;
  return temp;
}
inline ::TensorParameter* DenseParameter::_internal_mutable_weights() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.weights_ == nullptr) {
    auto* p = CreateMaybeMessage<::TensorParameter>(GetArenaForAllocation());
    _impl_.weights_ = p;
  }
  return _impl_.weights_;
}
inline ::TensorParameter* DenseParameter::mutable_weights() {
  ::TensorParameter* _msg = _internal_mutable_weights();
  // @@protoc_insertion_point(field_mutable:DenseParameter.weights)
  return _msg;
}
inline void DenseParameter::set_allocated_weights(::TensorParameter* weights) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.weights_;
  }
  if (weights) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(weights);
    if (message_arena != submessage_arena) {
      weights = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, weights, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.weights_ = weights;
  // @@protoc_insertion_point(field_set_allocated:DenseParameter.weights)
}

// optional .TensorParameter bias = 5;
inline bool DenseParameter::_internal_has_bias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bias_ != nullptr);
  return value;
}
inline bool DenseParameter::has_bias() const {
  return _internal_has_bias();
}
inline void DenseParameter::clear_bias() {
  if (_impl_.bias_ != nullptr) _impl_.bias_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TensorParameter& DenseParameter::_internal_bias() const {
  const ::TensorParameter* p = _impl_.bias_;
  return p != nullptr ? *p : reinterpret_cast<const ::TensorParameter&>(
      ::_TensorParameter_default_instance_);
}
inline const ::TensorParameter& DenseParameter::bias() const {
  // @@protoc_insertion_point(field_get:DenseParameter.bias)
  return _internal_bias();
}
inline void DenseParameter::unsafe_arena_set_allocated_bias(
    ::TensorParameter* bias) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bias_);
  }
  _impl_.bias_ = bias;
  if (bias) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DenseParameter.bias)
}
inline ::TensorParameter* DenseParameter::release_bias() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TensorParameter* temp = _impl_.bias_;
  _impl_.bias_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TensorParameter* DenseParameter::unsafe_arena_release_bias() {
  // @@protoc_insertion_point(field_release:DenseParameter.bias)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TensorParameter* temp = _impl_.bias_;
  _impl_.bias_ = nullptr;
  return temp;
}
inline ::TensorParameter* DenseParameter::_internal_mutable_bias() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.bias_ == nullptr) {
    auto* p = CreateMaybeMessage<::TensorParameter>(GetArenaForAllocation());
    _impl_.bias_ = p;
  }
  return _impl_.bias_;
}
inline ::TensorParameter* DenseParameter::mutable_bias() {
  ::TensorParameter* _msg = _internal_mutable_bias();
  // @@protoc_insertion_point(field_mutable:DenseParameter.bias)
  return _msg;
}
inline void DenseParameter::set_allocated_bias(::TensorParameter* bias) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bias_;
  }
  if (bias) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bias);
    if (message_arena != submessage_arena) {
      bias = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bias, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.bias_ = bias;
  // @@protoc_insertion_point(field_set_allocated:DenseParameter.bias)
}

// -------------------------------------------------------------------

// ActivationParameter

// optional string activation = 1;
inline bool ActivationParameter::_internal_has_activation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActivationParameter::has_activation() const {
  return _internal_has_activation();
}
inline void ActivationParameter::clear_activation() {
  _impl_.activation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActivationParameter::activation() const {
  // @@protoc_insertion_point(field_get:ActivationParameter.activation)
  return _internal_activation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActivationParameter::set_activation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.activation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ActivationParameter.activation)
}
inline std::string* ActivationParameter::mutable_activation() {
  std::string* _s = _internal_mutable_activation();
  // @@protoc_insertion_point(field_mutable:ActivationParameter.activation)
  return _s;
}
inline const std::string& ActivationParameter::_internal_activation() const {
  return _impl_.activation_.Get();
}
inline void ActivationParameter::_internal_set_activation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.activation_.Set(value, GetArenaForAllocation());
}
inline std::string* ActivationParameter::_internal_mutable_activation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.activation_.Mutable(GetArenaForAllocation());
}
inline std::string* ActivationParameter::release_activation() {
  // @@protoc_insertion_point(field_release:ActivationParameter.activation)
  if (!_internal_has_activation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.activation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.activation_.IsDefault()) {
    _impl_.activation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActivationParameter::set_allocated_activation(std::string* activation) {
  if (activation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.activation_.SetAllocated(activation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.activation_.IsDefault()) {
    _impl_.activation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ActivationParameter.activation)
}

// -------------------------------------------------------------------

// MaxPool1dParameter

// optional int32 kernel_size = 1;
inline bool MaxPool1dParameter::_internal_has_kernel_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MaxPool1dParameter::has_kernel_size() const {
  return _internal_has_kernel_size();
}
inline void MaxPool1dParameter::clear_kernel_size() {
  _impl_.kernel_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t MaxPool1dParameter::_internal_kernel_size() const {
  return _impl_.kernel_size_;
}
inline int32_t MaxPool1dParameter::kernel_size() const {
  // @@protoc_insertion_point(field_get:MaxPool1dParameter.kernel_size)
  return _internal_kernel_size();
}
inline void MaxPool1dParameter::_internal_set_kernel_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.kernel_size_ = value;
}
inline void MaxPool1dParameter::set_kernel_size(int32_t value) {
  _internal_set_kernel_size(value);
  // @@protoc_insertion_point(field_set:MaxPool1dParameter.kernel_size)
}

// optional int32 stride = 2;
inline bool MaxPool1dParameter::_internal_has_stride() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MaxPool1dParameter::has_stride() const {
  return _internal_has_stride();
}
inline void MaxPool1dParameter::clear_stride() {
  _impl_.stride_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t MaxPool1dParameter::_internal_stride() const {
  return _impl_.stride_;
}
inline int32_t MaxPool1dParameter::stride() const {
  // @@protoc_insertion_point(field_get:MaxPool1dParameter.stride)
  return _internal_stride();
}
inline void MaxPool1dParameter::_internal_set_stride(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stride_ = value;
}
inline void MaxPool1dParameter::set_stride(int32_t value) {
  _internal_set_stride(value);
  // @@protoc_insertion_point(field_set:MaxPool1dParameter.stride)
}

// -------------------------------------------------------------------

// AvgPool1dParameter

// optional int32 kernel_size = 1;
inline bool AvgPool1dParameter::_internal_has_kernel_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AvgPool1dParameter::has_kernel_size() const {
  return _internal_has_kernel_size();
}
inline void AvgPool1dParameter::clear_kernel_size() {
  _impl_.kernel_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t AvgPool1dParameter::_internal_kernel_size() const {
  return _impl_.kernel_size_;
}
inline int32_t AvgPool1dParameter::kernel_size() const {
  // @@protoc_insertion_point(field_get:AvgPool1dParameter.kernel_size)
  return _internal_kernel_size();
}
inline void AvgPool1dParameter::_internal_set_kernel_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.kernel_size_ = value;
}
inline void AvgPool1dParameter::set_kernel_size(int32_t value) {
  _internal_set_kernel_size(value);
  // @@protoc_insertion_point(field_set:AvgPool1dParameter.kernel_size)
}

// optional int32 stride = 2;
inline bool AvgPool1dParameter::_internal_has_stride() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AvgPool1dParameter::has_stride() const {
  return _internal_has_stride();
}
inline void AvgPool1dParameter::clear_stride() {
  _impl_.stride_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t AvgPool1dParameter::_internal_stride() const {
  return _impl_.stride_;
}
inline int32_t AvgPool1dParameter::stride() const {
  // @@protoc_insertion_point(field_get:AvgPool1dParameter.stride)
  return _internal_stride();
}
inline void AvgPool1dParameter::_internal_set_stride(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stride_ = value;
}
inline void AvgPool1dParameter::set_stride(int32_t value) {
  _internal_set_stride(value);
  // @@protoc_insertion_point(field_set:AvgPool1dParameter.stride)
}

// -------------------------------------------------------------------

// LaneFeatureConvParameter

// optional .Conv1dParameter conv1d_0 = 1;
inline bool LaneFeatureConvParameter::_internal_has_conv1d_0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conv1d_0_ != nullptr);
  return value;
}
inline bool LaneFeatureConvParameter::has_conv1d_0() const {
  return _internal_has_conv1d_0();
}
inline void LaneFeatureConvParameter::clear_conv1d_0() {
  if (_impl_.conv1d_0_ != nullptr) _impl_.conv1d_0_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Conv1dParameter& LaneFeatureConvParameter::_internal_conv1d_0() const {
  const ::Conv1dParameter* p = _impl_.conv1d_0_;
  return p != nullptr ? *p : reinterpret_cast<const ::Conv1dParameter&>(
      ::_Conv1dParameter_default_instance_);
}
inline const ::Conv1dParameter& LaneFeatureConvParameter::conv1d_0() const {
  // @@protoc_insertion_point(field_get:LaneFeatureConvParameter.conv1d_0)
  return _internal_conv1d_0();
}
inline void LaneFeatureConvParameter::unsafe_arena_set_allocated_conv1d_0(
    ::Conv1dParameter* conv1d_0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conv1d_0_);
  }
  _impl_.conv1d_0_ = conv1d_0;
  if (conv1d_0) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LaneFeatureConvParameter.conv1d_0)
}
inline ::Conv1dParameter* LaneFeatureConvParameter::release_conv1d_0() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Conv1dParameter* temp = _impl_.conv1d_0_;
  _impl_.conv1d_0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Conv1dParameter* LaneFeatureConvParameter::unsafe_arena_release_conv1d_0() {
  // @@protoc_insertion_point(field_release:LaneFeatureConvParameter.conv1d_0)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Conv1dParameter* temp = _impl_.conv1d_0_;
  _impl_.conv1d_0_ = nullptr;
  return temp;
}
inline ::Conv1dParameter* LaneFeatureConvParameter::_internal_mutable_conv1d_0() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.conv1d_0_ == nullptr) {
    auto* p = CreateMaybeMessage<::Conv1dParameter>(GetArenaForAllocation());
    _impl_.conv1d_0_ = p;
  }
  return _impl_.conv1d_0_;
}
inline ::Conv1dParameter* LaneFeatureConvParameter::mutable_conv1d_0() {
  ::Conv1dParameter* _msg = _internal_mutable_conv1d_0();
  // @@protoc_insertion_point(field_mutable:LaneFeatureConvParameter.conv1d_0)
  return _msg;
}
inline void LaneFeatureConvParameter::set_allocated_conv1d_0(::Conv1dParameter* conv1d_0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conv1d_0_;
  }
  if (conv1d_0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conv1d_0);
    if (message_arena != submessage_arena) {
      conv1d_0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conv1d_0, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.conv1d_0_ = conv1d_0;
  // @@protoc_insertion_point(field_set_allocated:LaneFeatureConvParameter.conv1d_0)
}

// optional .ActivationParameter activation_1 = 2;
inline bool LaneFeatureConvParameter::_internal_has_activation_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_1_ != nullptr);
  return value;
}
inline bool LaneFeatureConvParameter::has_activation_1() const {
  return _internal_has_activation_1();
}
inline void LaneFeatureConvParameter::clear_activation_1() {
  if (_impl_.activation_1_ != nullptr) _impl_.activation_1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ActivationParameter& LaneFeatureConvParameter::_internal_activation_1() const {
  const ::ActivationParameter* p = _impl_.activation_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& LaneFeatureConvParameter::activation_1() const {
  // @@protoc_insertion_point(field_get:LaneFeatureConvParameter.activation_1)
  return _internal_activation_1();
}
inline void LaneFeatureConvParameter::unsafe_arena_set_allocated_activation_1(
    ::ActivationParameter* activation_1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_1_);
  }
  _impl_.activation_1_ = activation_1;
  if (activation_1) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LaneFeatureConvParameter.activation_1)
}
inline ::ActivationParameter* LaneFeatureConvParameter::release_activation_1() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ActivationParameter* temp = _impl_.activation_1_;
  _impl_.activation_1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* LaneFeatureConvParameter::unsafe_arena_release_activation_1() {
  // @@protoc_insertion_point(field_release:LaneFeatureConvParameter.activation_1)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ActivationParameter* temp = _impl_.activation_1_;
  _impl_.activation_1_ = nullptr;
  return temp;
}
inline ::ActivationParameter* LaneFeatureConvParameter::_internal_mutable_activation_1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.activation_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_1_ = p;
  }
  return _impl_.activation_1_;
}
inline ::ActivationParameter* LaneFeatureConvParameter::mutable_activation_1() {
  ::ActivationParameter* _msg = _internal_mutable_activation_1();
  // @@protoc_insertion_point(field_mutable:LaneFeatureConvParameter.activation_1)
  return _msg;
}
inline void LaneFeatureConvParameter::set_allocated_activation_1(::ActivationParameter* activation_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_1_;
  }
  if (activation_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_1);
    if (message_arena != submessage_arena) {
      activation_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.activation_1_ = activation_1;
  // @@protoc_insertion_point(field_set_allocated:LaneFeatureConvParameter.activation_1)
}

// optional .Conv1dParameter conv1d_2 = 3;
inline bool LaneFeatureConvParameter::_internal_has_conv1d_2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conv1d_2_ != nullptr);
  return value;
}
inline bool LaneFeatureConvParameter::has_conv1d_2() const {
  return _internal_has_conv1d_2();
}
inline void LaneFeatureConvParameter::clear_conv1d_2() {
  if (_impl_.conv1d_2_ != nullptr) _impl_.conv1d_2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Conv1dParameter& LaneFeatureConvParameter::_internal_conv1d_2() const {
  const ::Conv1dParameter* p = _impl_.conv1d_2_;
  return p != nullptr ? *p : reinterpret_cast<const ::Conv1dParameter&>(
      ::_Conv1dParameter_default_instance_);
}
inline const ::Conv1dParameter& LaneFeatureConvParameter::conv1d_2() const {
  // @@protoc_insertion_point(field_get:LaneFeatureConvParameter.conv1d_2)
  return _internal_conv1d_2();
}
inline void LaneFeatureConvParameter::unsafe_arena_set_allocated_conv1d_2(
    ::Conv1dParameter* conv1d_2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conv1d_2_);
  }
  _impl_.conv1d_2_ = conv1d_2;
  if (conv1d_2) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LaneFeatureConvParameter.conv1d_2)
}
inline ::Conv1dParameter* LaneFeatureConvParameter::release_conv1d_2() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Conv1dParameter* temp = _impl_.conv1d_2_;
  _impl_.conv1d_2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Conv1dParameter* LaneFeatureConvParameter::unsafe_arena_release_conv1d_2() {
  // @@protoc_insertion_point(field_release:LaneFeatureConvParameter.conv1d_2)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Conv1dParameter* temp = _impl_.conv1d_2_;
  _impl_.conv1d_2_ = nullptr;
  return temp;
}
inline ::Conv1dParameter* LaneFeatureConvParameter::_internal_mutable_conv1d_2() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.conv1d_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::Conv1dParameter>(GetArenaForAllocation());
    _impl_.conv1d_2_ = p;
  }
  return _impl_.conv1d_2_;
}
inline ::Conv1dParameter* LaneFeatureConvParameter::mutable_conv1d_2() {
  ::Conv1dParameter* _msg = _internal_mutable_conv1d_2();
  // @@protoc_insertion_point(field_mutable:LaneFeatureConvParameter.conv1d_2)
  return _msg;
}
inline void LaneFeatureConvParameter::set_allocated_conv1d_2(::Conv1dParameter* conv1d_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conv1d_2_;
  }
  if (conv1d_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conv1d_2);
    if (message_arena != submessage_arena) {
      conv1d_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conv1d_2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.conv1d_2_ = conv1d_2;
  // @@protoc_insertion_point(field_set_allocated:LaneFeatureConvParameter.conv1d_2)
}

// optional .ActivationParameter activation_3 = 4;
inline bool LaneFeatureConvParameter::_internal_has_activation_3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_3_ != nullptr);
  return value;
}
inline bool LaneFeatureConvParameter::has_activation_3() const {
  return _internal_has_activation_3();
}
inline void LaneFeatureConvParameter::clear_activation_3() {
  if (_impl_.activation_3_ != nullptr) _impl_.activation_3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::ActivationParameter& LaneFeatureConvParameter::_internal_activation_3() const {
  const ::ActivationParameter* p = _impl_.activation_3_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& LaneFeatureConvParameter::activation_3() const {
  // @@protoc_insertion_point(field_get:LaneFeatureConvParameter.activation_3)
  return _internal_activation_3();
}
inline void LaneFeatureConvParameter::unsafe_arena_set_allocated_activation_3(
    ::ActivationParameter* activation_3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_3_);
  }
  _impl_.activation_3_ = activation_3;
  if (activation_3) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LaneFeatureConvParameter.activation_3)
}
inline ::ActivationParameter* LaneFeatureConvParameter::release_activation_3() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ActivationParameter* temp = _impl_.activation_3_;
  _impl_.activation_3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* LaneFeatureConvParameter::unsafe_arena_release_activation_3() {
  // @@protoc_insertion_point(field_release:LaneFeatureConvParameter.activation_3)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ActivationParameter* temp = _impl_.activation_3_;
  _impl_.activation_3_ = nullptr;
  return temp;
}
inline ::ActivationParameter* LaneFeatureConvParameter::_internal_mutable_activation_3() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.activation_3_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_3_ = p;
  }
  return _impl_.activation_3_;
}
inline ::ActivationParameter* LaneFeatureConvParameter::mutable_activation_3() {
  ::ActivationParameter* _msg = _internal_mutable_activation_3();
  // @@protoc_insertion_point(field_mutable:LaneFeatureConvParameter.activation_3)
  return _msg;
}
inline void LaneFeatureConvParameter::set_allocated_activation_3(::ActivationParameter* activation_3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_3_;
  }
  if (activation_3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_3);
    if (message_arena != submessage_arena) {
      activation_3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_3, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.activation_3_ = activation_3;
  // @@protoc_insertion_point(field_set_allocated:LaneFeatureConvParameter.activation_3)
}

// optional .Conv1dParameter conv1d_4 = 5;
inline bool LaneFeatureConvParameter::_internal_has_conv1d_4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conv1d_4_ != nullptr);
  return value;
}
inline bool LaneFeatureConvParameter::has_conv1d_4() const {
  return _internal_has_conv1d_4();
}
inline void LaneFeatureConvParameter::clear_conv1d_4() {
  if (_impl_.conv1d_4_ != nullptr) _impl_.conv1d_4_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::Conv1dParameter& LaneFeatureConvParameter::_internal_conv1d_4() const {
  const ::Conv1dParameter* p = _impl_.conv1d_4_;
  return p != nullptr ? *p : reinterpret_cast<const ::Conv1dParameter&>(
      ::_Conv1dParameter_default_instance_);
}
inline const ::Conv1dParameter& LaneFeatureConvParameter::conv1d_4() const {
  // @@protoc_insertion_point(field_get:LaneFeatureConvParameter.conv1d_4)
  return _internal_conv1d_4();
}
inline void LaneFeatureConvParameter::unsafe_arena_set_allocated_conv1d_4(
    ::Conv1dParameter* conv1d_4) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conv1d_4_);
  }
  _impl_.conv1d_4_ = conv1d_4;
  if (conv1d_4) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LaneFeatureConvParameter.conv1d_4)
}
inline ::Conv1dParameter* LaneFeatureConvParameter::release_conv1d_4() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::Conv1dParameter* temp = _impl_.conv1d_4_;
  _impl_.conv1d_4_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Conv1dParameter* LaneFeatureConvParameter::unsafe_arena_release_conv1d_4() {
  // @@protoc_insertion_point(field_release:LaneFeatureConvParameter.conv1d_4)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::Conv1dParameter* temp = _impl_.conv1d_4_;
  _impl_.conv1d_4_ = nullptr;
  return temp;
}
inline ::Conv1dParameter* LaneFeatureConvParameter::_internal_mutable_conv1d_4() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.conv1d_4_ == nullptr) {
    auto* p = CreateMaybeMessage<::Conv1dParameter>(GetArenaForAllocation());
    _impl_.conv1d_4_ = p;
  }
  return _impl_.conv1d_4_;
}
inline ::Conv1dParameter* LaneFeatureConvParameter::mutable_conv1d_4() {
  ::Conv1dParameter* _msg = _internal_mutable_conv1d_4();
  // @@protoc_insertion_point(field_mutable:LaneFeatureConvParameter.conv1d_4)
  return _msg;
}
inline void LaneFeatureConvParameter::set_allocated_conv1d_4(::Conv1dParameter* conv1d_4) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conv1d_4_;
  }
  if (conv1d_4) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conv1d_4);
    if (message_arena != submessage_arena) {
      conv1d_4 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conv1d_4, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.conv1d_4_ = conv1d_4;
  // @@protoc_insertion_point(field_set_allocated:LaneFeatureConvParameter.conv1d_4)
}

// -------------------------------------------------------------------

// ObsFeatureFCParameter

// optional .DenseParameter linear_0 = 1;
inline bool ObsFeatureFCParameter::_internal_has_linear_0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_0_ != nullptr);
  return value;
}
inline bool ObsFeatureFCParameter::has_linear_0() const {
  return _internal_has_linear_0();
}
inline void ObsFeatureFCParameter::clear_linear_0() {
  if (_impl_.linear_0_ != nullptr) _impl_.linear_0_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DenseParameter& ObsFeatureFCParameter::_internal_linear_0() const {
  const ::DenseParameter* p = _impl_.linear_0_;
  return p != nullptr ? *p : reinterpret_cast<const ::DenseParameter&>(
      ::_DenseParameter_default_instance_);
}
inline const ::DenseParameter& ObsFeatureFCParameter::linear_0() const {
  // @@protoc_insertion_point(field_get:ObsFeatureFCParameter.linear_0)
  return _internal_linear_0();
}
inline void ObsFeatureFCParameter::unsafe_arena_set_allocated_linear_0(
    ::DenseParameter* linear_0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_0_);
  }
  _impl_.linear_0_ = linear_0;
  if (linear_0) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ObsFeatureFCParameter.linear_0)
}
inline ::DenseParameter* ObsFeatureFCParameter::release_linear_0() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DenseParameter* temp = _impl_.linear_0_;
  _impl_.linear_0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DenseParameter* ObsFeatureFCParameter::unsafe_arena_release_linear_0() {
  // @@protoc_insertion_point(field_release:ObsFeatureFCParameter.linear_0)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DenseParameter* temp = _impl_.linear_0_;
  _impl_.linear_0_ = nullptr;
  return temp;
}
inline ::DenseParameter* ObsFeatureFCParameter::_internal_mutable_linear_0() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.linear_0_ == nullptr) {
    auto* p = CreateMaybeMessage<::DenseParameter>(GetArenaForAllocation());
    _impl_.linear_0_ = p;
  }
  return _impl_.linear_0_;
}
inline ::DenseParameter* ObsFeatureFCParameter::mutable_linear_0() {
  ::DenseParameter* _msg = _internal_mutable_linear_0();
  // @@protoc_insertion_point(field_mutable:ObsFeatureFCParameter.linear_0)
  return _msg;
}
inline void ObsFeatureFCParameter::set_allocated_linear_0(::DenseParameter* linear_0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_0_;
  }
  if (linear_0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_0);
    if (message_arena != submessage_arena) {
      linear_0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_0, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.linear_0_ = linear_0;
  // @@protoc_insertion_point(field_set_allocated:ObsFeatureFCParameter.linear_0)
}

// optional .ActivationParameter activation_1 = 2;
inline bool ObsFeatureFCParameter::_internal_has_activation_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_1_ != nullptr);
  return value;
}
inline bool ObsFeatureFCParameter::has_activation_1() const {
  return _internal_has_activation_1();
}
inline void ObsFeatureFCParameter::clear_activation_1() {
  if (_impl_.activation_1_ != nullptr) _impl_.activation_1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ActivationParameter& ObsFeatureFCParameter::_internal_activation_1() const {
  const ::ActivationParameter* p = _impl_.activation_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& ObsFeatureFCParameter::activation_1() const {
  // @@protoc_insertion_point(field_get:ObsFeatureFCParameter.activation_1)
  return _internal_activation_1();
}
inline void ObsFeatureFCParameter::unsafe_arena_set_allocated_activation_1(
    ::ActivationParameter* activation_1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_1_);
  }
  _impl_.activation_1_ = activation_1;
  if (activation_1) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ObsFeatureFCParameter.activation_1)
}
inline ::ActivationParameter* ObsFeatureFCParameter::release_activation_1() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ActivationParameter* temp = _impl_.activation_1_;
  _impl_.activation_1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* ObsFeatureFCParameter::unsafe_arena_release_activation_1() {
  // @@protoc_insertion_point(field_release:ObsFeatureFCParameter.activation_1)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ActivationParameter* temp = _impl_.activation_1_;
  _impl_.activation_1_ = nullptr;
  return temp;
}
inline ::ActivationParameter* ObsFeatureFCParameter::_internal_mutable_activation_1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.activation_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_1_ = p;
  }
  return _impl_.activation_1_;
}
inline ::ActivationParameter* ObsFeatureFCParameter::mutable_activation_1() {
  ::ActivationParameter* _msg = _internal_mutable_activation_1();
  // @@protoc_insertion_point(field_mutable:ObsFeatureFCParameter.activation_1)
  return _msg;
}
inline void ObsFeatureFCParameter::set_allocated_activation_1(::ActivationParameter* activation_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_1_;
  }
  if (activation_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_1);
    if (message_arena != submessage_arena) {
      activation_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.activation_1_ = activation_1;
  // @@protoc_insertion_point(field_set_allocated:ObsFeatureFCParameter.activation_1)
}

// optional .DenseParameter linear_3 = 3;
inline bool ObsFeatureFCParameter::_internal_has_linear_3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_3_ != nullptr);
  return value;
}
inline bool ObsFeatureFCParameter::has_linear_3() const {
  return _internal_has_linear_3();
}
inline void ObsFeatureFCParameter::clear_linear_3() {
  if (_impl_.linear_3_ != nullptr) _impl_.linear_3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::DenseParameter& ObsFeatureFCParameter::_internal_linear_3() const {
  const ::DenseParameter* p = _impl_.linear_3_;
  return p != nullptr ? *p : reinterpret_cast<const ::DenseParameter&>(
      ::_DenseParameter_default_instance_);
}
inline const ::DenseParameter& ObsFeatureFCParameter::linear_3() const {
  // @@protoc_insertion_point(field_get:ObsFeatureFCParameter.linear_3)
  return _internal_linear_3();
}
inline void ObsFeatureFCParameter::unsafe_arena_set_allocated_linear_3(
    ::DenseParameter* linear_3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_3_);
  }
  _impl_.linear_3_ = linear_3;
  if (linear_3) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ObsFeatureFCParameter.linear_3)
}
inline ::DenseParameter* ObsFeatureFCParameter::release_linear_3() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DenseParameter* temp = _impl_.linear_3_;
  _impl_.linear_3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DenseParameter* ObsFeatureFCParameter::unsafe_arena_release_linear_3() {
  // @@protoc_insertion_point(field_release:ObsFeatureFCParameter.linear_3)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DenseParameter* temp = _impl_.linear_3_;
  _impl_.linear_3_ = nullptr;
  return temp;
}
inline ::DenseParameter* ObsFeatureFCParameter::_internal_mutable_linear_3() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.linear_3_ == nullptr) {
    auto* p = CreateMaybeMessage<::DenseParameter>(GetArenaForAllocation());
    _impl_.linear_3_ = p;
  }
  return _impl_.linear_3_;
}
inline ::DenseParameter* ObsFeatureFCParameter::mutable_linear_3() {
  ::DenseParameter* _msg = _internal_mutable_linear_3();
  // @@protoc_insertion_point(field_mutable:ObsFeatureFCParameter.linear_3)
  return _msg;
}
inline void ObsFeatureFCParameter::set_allocated_linear_3(::DenseParameter* linear_3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_3_;
  }
  if (linear_3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_3);
    if (message_arena != submessage_arena) {
      linear_3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_3, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.linear_3_ = linear_3;
  // @@protoc_insertion_point(field_set_allocated:ObsFeatureFCParameter.linear_3)
}

// optional .ActivationParameter activation_4 = 4;
inline bool ObsFeatureFCParameter::_internal_has_activation_4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_4_ != nullptr);
  return value;
}
inline bool ObsFeatureFCParameter::has_activation_4() const {
  return _internal_has_activation_4();
}
inline void ObsFeatureFCParameter::clear_activation_4() {
  if (_impl_.activation_4_ != nullptr) _impl_.activation_4_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::ActivationParameter& ObsFeatureFCParameter::_internal_activation_4() const {
  const ::ActivationParameter* p = _impl_.activation_4_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& ObsFeatureFCParameter::activation_4() const {
  // @@protoc_insertion_point(field_get:ObsFeatureFCParameter.activation_4)
  return _internal_activation_4();
}
inline void ObsFeatureFCParameter::unsafe_arena_set_allocated_activation_4(
    ::ActivationParameter* activation_4) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_4_);
  }
  _impl_.activation_4_ = activation_4;
  if (activation_4) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ObsFeatureFCParameter.activation_4)
}
inline ::ActivationParameter* ObsFeatureFCParameter::release_activation_4() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ActivationParameter* temp = _impl_.activation_4_;
  _impl_.activation_4_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* ObsFeatureFCParameter::unsafe_arena_release_activation_4() {
  // @@protoc_insertion_point(field_release:ObsFeatureFCParameter.activation_4)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ActivationParameter* temp = _impl_.activation_4_;
  _impl_.activation_4_ = nullptr;
  return temp;
}
inline ::ActivationParameter* ObsFeatureFCParameter::_internal_mutable_activation_4() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.activation_4_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_4_ = p;
  }
  return _impl_.activation_4_;
}
inline ::ActivationParameter* ObsFeatureFCParameter::mutable_activation_4() {
  ::ActivationParameter* _msg = _internal_mutable_activation_4();
  // @@protoc_insertion_point(field_mutable:ObsFeatureFCParameter.activation_4)
  return _msg;
}
inline void ObsFeatureFCParameter::set_allocated_activation_4(::ActivationParameter* activation_4) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_4_;
  }
  if (activation_4) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_4);
    if (message_arena != submessage_arena) {
      activation_4 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_4, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.activation_4_ = activation_4;
  // @@protoc_insertion_point(field_set_allocated:ObsFeatureFCParameter.activation_4)
}

// -------------------------------------------------------------------

// ClassifyParameter

// optional .DenseParameter linear_0 = 1;
inline bool ClassifyParameter::_internal_has_linear_0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_0_ != nullptr);
  return value;
}
inline bool ClassifyParameter::has_linear_0() const {
  return _internal_has_linear_0();
}
inline void ClassifyParameter::clear_linear_0() {
  if (_impl_.linear_0_ != nullptr) _impl_.linear_0_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DenseParameter& ClassifyParameter::_internal_linear_0() const {
  const ::DenseParameter* p = _impl_.linear_0_;
  return p != nullptr ? *p : reinterpret_cast<const ::DenseParameter&>(
      ::_DenseParameter_default_instance_);
}
inline const ::DenseParameter& ClassifyParameter::linear_0() const {
  // @@protoc_insertion_point(field_get:ClassifyParameter.linear_0)
  return _internal_linear_0();
}
inline void ClassifyParameter::unsafe_arena_set_allocated_linear_0(
    ::DenseParameter* linear_0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_0_);
  }
  _impl_.linear_0_ = linear_0;
  if (linear_0) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClassifyParameter.linear_0)
}
inline ::DenseParameter* ClassifyParameter::release_linear_0() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DenseParameter* temp = _impl_.linear_0_;
  _impl_.linear_0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DenseParameter* ClassifyParameter::unsafe_arena_release_linear_0() {
  // @@protoc_insertion_point(field_release:ClassifyParameter.linear_0)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DenseParameter* temp = _impl_.linear_0_;
  _impl_.linear_0_ = nullptr;
  return temp;
}
inline ::DenseParameter* ClassifyParameter::_internal_mutable_linear_0() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.linear_0_ == nullptr) {
    auto* p = CreateMaybeMessage<::DenseParameter>(GetArenaForAllocation());
    _impl_.linear_0_ = p;
  }
  return _impl_.linear_0_;
}
inline ::DenseParameter* ClassifyParameter::mutable_linear_0() {
  ::DenseParameter* _msg = _internal_mutable_linear_0();
  // @@protoc_insertion_point(field_mutable:ClassifyParameter.linear_0)
  return _msg;
}
inline void ClassifyParameter::set_allocated_linear_0(::DenseParameter* linear_0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_0_;
  }
  if (linear_0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_0);
    if (message_arena != submessage_arena) {
      linear_0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_0, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.linear_0_ = linear_0;
  // @@protoc_insertion_point(field_set_allocated:ClassifyParameter.linear_0)
}

// optional .ActivationParameter activation_1 = 2;
inline bool ClassifyParameter::_internal_has_activation_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_1_ != nullptr);
  return value;
}
inline bool ClassifyParameter::has_activation_1() const {
  return _internal_has_activation_1();
}
inline void ClassifyParameter::clear_activation_1() {
  if (_impl_.activation_1_ != nullptr) _impl_.activation_1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ActivationParameter& ClassifyParameter::_internal_activation_1() const {
  const ::ActivationParameter* p = _impl_.activation_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& ClassifyParameter::activation_1() const {
  // @@protoc_insertion_point(field_get:ClassifyParameter.activation_1)
  return _internal_activation_1();
}
inline void ClassifyParameter::unsafe_arena_set_allocated_activation_1(
    ::ActivationParameter* activation_1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_1_);
  }
  _impl_.activation_1_ = activation_1;
  if (activation_1) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClassifyParameter.activation_1)
}
inline ::ActivationParameter* ClassifyParameter::release_activation_1() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ActivationParameter* temp = _impl_.activation_1_;
  _impl_.activation_1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* ClassifyParameter::unsafe_arena_release_activation_1() {
  // @@protoc_insertion_point(field_release:ClassifyParameter.activation_1)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ActivationParameter* temp = _impl_.activation_1_;
  _impl_.activation_1_ = nullptr;
  return temp;
}
inline ::ActivationParameter* ClassifyParameter::_internal_mutable_activation_1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.activation_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_1_ = p;
  }
  return _impl_.activation_1_;
}
inline ::ActivationParameter* ClassifyParameter::mutable_activation_1() {
  ::ActivationParameter* _msg = _internal_mutable_activation_1();
  // @@protoc_insertion_point(field_mutable:ClassifyParameter.activation_1)
  return _msg;
}
inline void ClassifyParameter::set_allocated_activation_1(::ActivationParameter* activation_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_1_;
  }
  if (activation_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_1);
    if (message_arena != submessage_arena) {
      activation_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.activation_1_ = activation_1;
  // @@protoc_insertion_point(field_set_allocated:ClassifyParameter.activation_1)
}

// optional .DenseParameter linear_3 = 3;
inline bool ClassifyParameter::_internal_has_linear_3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_3_ != nullptr);
  return value;
}
inline bool ClassifyParameter::has_linear_3() const {
  return _internal_has_linear_3();
}
inline void ClassifyParameter::clear_linear_3() {
  if (_impl_.linear_3_ != nullptr) _impl_.linear_3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::DenseParameter& ClassifyParameter::_internal_linear_3() const {
  const ::DenseParameter* p = _impl_.linear_3_;
  return p != nullptr ? *p : reinterpret_cast<const ::DenseParameter&>(
      ::_DenseParameter_default_instance_);
}
inline const ::DenseParameter& ClassifyParameter::linear_3() const {
  // @@protoc_insertion_point(field_get:ClassifyParameter.linear_3)
  return _internal_linear_3();
}
inline void ClassifyParameter::unsafe_arena_set_allocated_linear_3(
    ::DenseParameter* linear_3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_3_);
  }
  _impl_.linear_3_ = linear_3;
  if (linear_3) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClassifyParameter.linear_3)
}
inline ::DenseParameter* ClassifyParameter::release_linear_3() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DenseParameter* temp = _impl_.linear_3_;
  _impl_.linear_3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DenseParameter* ClassifyParameter::unsafe_arena_release_linear_3() {
  // @@protoc_insertion_point(field_release:ClassifyParameter.linear_3)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DenseParameter* temp = _impl_.linear_3_;
  _impl_.linear_3_ = nullptr;
  return temp;
}
inline ::DenseParameter* ClassifyParameter::_internal_mutable_linear_3() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.linear_3_ == nullptr) {
    auto* p = CreateMaybeMessage<::DenseParameter>(GetArenaForAllocation());
    _impl_.linear_3_ = p;
  }
  return _impl_.linear_3_;
}
inline ::DenseParameter* ClassifyParameter::mutable_linear_3() {
  ::DenseParameter* _msg = _internal_mutable_linear_3();
  // @@protoc_insertion_point(field_mutable:ClassifyParameter.linear_3)
  return _msg;
}
inline void ClassifyParameter::set_allocated_linear_3(::DenseParameter* linear_3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_3_;
  }
  if (linear_3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_3);
    if (message_arena != submessage_arena) {
      linear_3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_3, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.linear_3_ = linear_3;
  // @@protoc_insertion_point(field_set_allocated:ClassifyParameter.linear_3)
}

// optional .ActivationParameter activation_4 = 4;
inline bool ClassifyParameter::_internal_has_activation_4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_4_ != nullptr);
  return value;
}
inline bool ClassifyParameter::has_activation_4() const {
  return _internal_has_activation_4();
}
inline void ClassifyParameter::clear_activation_4() {
  if (_impl_.activation_4_ != nullptr) _impl_.activation_4_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::ActivationParameter& ClassifyParameter::_internal_activation_4() const {
  const ::ActivationParameter* p = _impl_.activation_4_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& ClassifyParameter::activation_4() const {
  // @@protoc_insertion_point(field_get:ClassifyParameter.activation_4)
  return _internal_activation_4();
}
inline void ClassifyParameter::unsafe_arena_set_allocated_activation_4(
    ::ActivationParameter* activation_4) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_4_);
  }
  _impl_.activation_4_ = activation_4;
  if (activation_4) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClassifyParameter.activation_4)
}
inline ::ActivationParameter* ClassifyParameter::release_activation_4() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ActivationParameter* temp = _impl_.activation_4_;
  _impl_.activation_4_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* ClassifyParameter::unsafe_arena_release_activation_4() {
  // @@protoc_insertion_point(field_release:ClassifyParameter.activation_4)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ActivationParameter* temp = _impl_.activation_4_;
  _impl_.activation_4_ = nullptr;
  return temp;
}
inline ::ActivationParameter* ClassifyParameter::_internal_mutable_activation_4() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.activation_4_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_4_ = p;
  }
  return _impl_.activation_4_;
}
inline ::ActivationParameter* ClassifyParameter::mutable_activation_4() {
  ::ActivationParameter* _msg = _internal_mutable_activation_4();
  // @@protoc_insertion_point(field_mutable:ClassifyParameter.activation_4)
  return _msg;
}
inline void ClassifyParameter::set_allocated_activation_4(::ActivationParameter* activation_4) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_4_;
  }
  if (activation_4) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_4);
    if (message_arena != submessage_arena) {
      activation_4 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_4, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.activation_4_ = activation_4;
  // @@protoc_insertion_point(field_set_allocated:ClassifyParameter.activation_4)
}

// optional .DenseParameter linear_6 = 5;
inline bool ClassifyParameter::_internal_has_linear_6() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_6_ != nullptr);
  return value;
}
inline bool ClassifyParameter::has_linear_6() const {
  return _internal_has_linear_6();
}
inline void ClassifyParameter::clear_linear_6() {
  if (_impl_.linear_6_ != nullptr) _impl_.linear_6_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::DenseParameter& ClassifyParameter::_internal_linear_6() const {
  const ::DenseParameter* p = _impl_.linear_6_;
  return p != nullptr ? *p : reinterpret_cast<const ::DenseParameter&>(
      ::_DenseParameter_default_instance_);
}
inline const ::DenseParameter& ClassifyParameter::linear_6() const {
  // @@protoc_insertion_point(field_get:ClassifyParameter.linear_6)
  return _internal_linear_6();
}
inline void ClassifyParameter::unsafe_arena_set_allocated_linear_6(
    ::DenseParameter* linear_6) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_6_);
  }
  _impl_.linear_6_ = linear_6;
  if (linear_6) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClassifyParameter.linear_6)
}
inline ::DenseParameter* ClassifyParameter::release_linear_6() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::DenseParameter* temp = _impl_.linear_6_;
  _impl_.linear_6_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DenseParameter* ClassifyParameter::unsafe_arena_release_linear_6() {
  // @@protoc_insertion_point(field_release:ClassifyParameter.linear_6)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::DenseParameter* temp = _impl_.linear_6_;
  _impl_.linear_6_ = nullptr;
  return temp;
}
inline ::DenseParameter* ClassifyParameter::_internal_mutable_linear_6() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.linear_6_ == nullptr) {
    auto* p = CreateMaybeMessage<::DenseParameter>(GetArenaForAllocation());
    _impl_.linear_6_ = p;
  }
  return _impl_.linear_6_;
}
inline ::DenseParameter* ClassifyParameter::mutable_linear_6() {
  ::DenseParameter* _msg = _internal_mutable_linear_6();
  // @@protoc_insertion_point(field_mutable:ClassifyParameter.linear_6)
  return _msg;
}
inline void ClassifyParameter::set_allocated_linear_6(::DenseParameter* linear_6) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_6_;
  }
  if (linear_6) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_6);
    if (message_arena != submessage_arena) {
      linear_6 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_6, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.linear_6_ = linear_6;
  // @@protoc_insertion_point(field_set_allocated:ClassifyParameter.linear_6)
}

// optional .ActivationParameter activation_7 = 6;
inline bool ClassifyParameter::_internal_has_activation_7() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_7_ != nullptr);
  return value;
}
inline bool ClassifyParameter::has_activation_7() const {
  return _internal_has_activation_7();
}
inline void ClassifyParameter::clear_activation_7() {
  if (_impl_.activation_7_ != nullptr) _impl_.activation_7_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::ActivationParameter& ClassifyParameter::_internal_activation_7() const {
  const ::ActivationParameter* p = _impl_.activation_7_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& ClassifyParameter::activation_7() const {
  // @@protoc_insertion_point(field_get:ClassifyParameter.activation_7)
  return _internal_activation_7();
}
inline void ClassifyParameter::unsafe_arena_set_allocated_activation_7(
    ::ActivationParameter* activation_7) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_7_);
  }
  _impl_.activation_7_ = activation_7;
  if (activation_7) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClassifyParameter.activation_7)
}
inline ::ActivationParameter* ClassifyParameter::release_activation_7() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ActivationParameter* temp = _impl_.activation_7_;
  _impl_.activation_7_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* ClassifyParameter::unsafe_arena_release_activation_7() {
  // @@protoc_insertion_point(field_release:ClassifyParameter.activation_7)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ActivationParameter* temp = _impl_.activation_7_;
  _impl_.activation_7_ = nullptr;
  return temp;
}
inline ::ActivationParameter* ClassifyParameter::_internal_mutable_activation_7() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.activation_7_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_7_ = p;
  }
  return _impl_.activation_7_;
}
inline ::ActivationParameter* ClassifyParameter::mutable_activation_7() {
  ::ActivationParameter* _msg = _internal_mutable_activation_7();
  // @@protoc_insertion_point(field_mutable:ClassifyParameter.activation_7)
  return _msg;
}
inline void ClassifyParameter::set_allocated_activation_7(::ActivationParameter* activation_7) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_7_;
  }
  if (activation_7) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_7);
    if (message_arena != submessage_arena) {
      activation_7 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_7, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.activation_7_ = activation_7;
  // @@protoc_insertion_point(field_set_allocated:ClassifyParameter.activation_7)
}

// optional .DenseParameter linear_9 = 7;
inline bool ClassifyParameter::_internal_has_linear_9() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_9_ != nullptr);
  return value;
}
inline bool ClassifyParameter::has_linear_9() const {
  return _internal_has_linear_9();
}
inline void ClassifyParameter::clear_linear_9() {
  if (_impl_.linear_9_ != nullptr) _impl_.linear_9_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::DenseParameter& ClassifyParameter::_internal_linear_9() const {
  const ::DenseParameter* p = _impl_.linear_9_;
  return p != nullptr ? *p : reinterpret_cast<const ::DenseParameter&>(
      ::_DenseParameter_default_instance_);
}
inline const ::DenseParameter& ClassifyParameter::linear_9() const {
  // @@protoc_insertion_point(field_get:ClassifyParameter.linear_9)
  return _internal_linear_9();
}
inline void ClassifyParameter::unsafe_arena_set_allocated_linear_9(
    ::DenseParameter* linear_9) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_9_);
  }
  _impl_.linear_9_ = linear_9;
  if (linear_9) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClassifyParameter.linear_9)
}
inline ::DenseParameter* ClassifyParameter::release_linear_9() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::DenseParameter* temp = _impl_.linear_9_;
  _impl_.linear_9_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DenseParameter* ClassifyParameter::unsafe_arena_release_linear_9() {
  // @@protoc_insertion_point(field_release:ClassifyParameter.linear_9)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::DenseParameter* temp = _impl_.linear_9_;
  _impl_.linear_9_ = nullptr;
  return temp;
}
inline ::DenseParameter* ClassifyParameter::_internal_mutable_linear_9() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.linear_9_ == nullptr) {
    auto* p = CreateMaybeMessage<::DenseParameter>(GetArenaForAllocation());
    _impl_.linear_9_ = p;
  }
  return _impl_.linear_9_;
}
inline ::DenseParameter* ClassifyParameter::mutable_linear_9() {
  ::DenseParameter* _msg = _internal_mutable_linear_9();
  // @@protoc_insertion_point(field_mutable:ClassifyParameter.linear_9)
  return _msg;
}
inline void ClassifyParameter::set_allocated_linear_9(::DenseParameter* linear_9) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_9_;
  }
  if (linear_9) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_9);
    if (message_arena != submessage_arena) {
      linear_9 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_9, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.linear_9_ = linear_9;
  // @@protoc_insertion_point(field_set_allocated:ClassifyParameter.linear_9)
}

// optional .ActivationParameter activation_10 = 8;
inline bool ClassifyParameter::_internal_has_activation_10() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_10_ != nullptr);
  return value;
}
inline bool ClassifyParameter::has_activation_10() const {
  return _internal_has_activation_10();
}
inline void ClassifyParameter::clear_activation_10() {
  if (_impl_.activation_10_ != nullptr) _impl_.activation_10_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::ActivationParameter& ClassifyParameter::_internal_activation_10() const {
  const ::ActivationParameter* p = _impl_.activation_10_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& ClassifyParameter::activation_10() const {
  // @@protoc_insertion_point(field_get:ClassifyParameter.activation_10)
  return _internal_activation_10();
}
inline void ClassifyParameter::unsafe_arena_set_allocated_activation_10(
    ::ActivationParameter* activation_10) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_10_);
  }
  _impl_.activation_10_ = activation_10;
  if (activation_10) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClassifyParameter.activation_10)
}
inline ::ActivationParameter* ClassifyParameter::release_activation_10() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::ActivationParameter* temp = _impl_.activation_10_;
  _impl_.activation_10_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* ClassifyParameter::unsafe_arena_release_activation_10() {
  // @@protoc_insertion_point(field_release:ClassifyParameter.activation_10)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::ActivationParameter* temp = _impl_.activation_10_;
  _impl_.activation_10_ = nullptr;
  return temp;
}
inline ::ActivationParameter* ClassifyParameter::_internal_mutable_activation_10() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.activation_10_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_10_ = p;
  }
  return _impl_.activation_10_;
}
inline ::ActivationParameter* ClassifyParameter::mutable_activation_10() {
  ::ActivationParameter* _msg = _internal_mutable_activation_10();
  // @@protoc_insertion_point(field_mutable:ClassifyParameter.activation_10)
  return _msg;
}
inline void ClassifyParameter::set_allocated_activation_10(::ActivationParameter* activation_10) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_10_;
  }
  if (activation_10) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_10);
    if (message_arena != submessage_arena) {
      activation_10 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_10, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.activation_10_ = activation_10;
  // @@protoc_insertion_point(field_set_allocated:ClassifyParameter.activation_10)
}

// -------------------------------------------------------------------

// RegressParameter

// optional .DenseParameter linear_0 = 1;
inline bool RegressParameter::_internal_has_linear_0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_0_ != nullptr);
  return value;
}
inline bool RegressParameter::has_linear_0() const {
  return _internal_has_linear_0();
}
inline void RegressParameter::clear_linear_0() {
  if (_impl_.linear_0_ != nullptr) _impl_.linear_0_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DenseParameter& RegressParameter::_internal_linear_0() const {
  const ::DenseParameter* p = _impl_.linear_0_;
  return p != nullptr ? *p : reinterpret_cast<const ::DenseParameter&>(
      ::_DenseParameter_default_instance_);
}
inline const ::DenseParameter& RegressParameter::linear_0() const {
  // @@protoc_insertion_point(field_get:RegressParameter.linear_0)
  return _internal_linear_0();
}
inline void RegressParameter::unsafe_arena_set_allocated_linear_0(
    ::DenseParameter* linear_0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_0_);
  }
  _impl_.linear_0_ = linear_0;
  if (linear_0) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegressParameter.linear_0)
}
inline ::DenseParameter* RegressParameter::release_linear_0() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DenseParameter* temp = _impl_.linear_0_;
  _impl_.linear_0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DenseParameter* RegressParameter::unsafe_arena_release_linear_0() {
  // @@protoc_insertion_point(field_release:RegressParameter.linear_0)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DenseParameter* temp = _impl_.linear_0_;
  _impl_.linear_0_ = nullptr;
  return temp;
}
inline ::DenseParameter* RegressParameter::_internal_mutable_linear_0() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.linear_0_ == nullptr) {
    auto* p = CreateMaybeMessage<::DenseParameter>(GetArenaForAllocation());
    _impl_.linear_0_ = p;
  }
  return _impl_.linear_0_;
}
inline ::DenseParameter* RegressParameter::mutable_linear_0() {
  ::DenseParameter* _msg = _internal_mutable_linear_0();
  // @@protoc_insertion_point(field_mutable:RegressParameter.linear_0)
  return _msg;
}
inline void RegressParameter::set_allocated_linear_0(::DenseParameter* linear_0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_0_;
  }
  if (linear_0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_0);
    if (message_arena != submessage_arena) {
      linear_0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_0, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.linear_0_ = linear_0;
  // @@protoc_insertion_point(field_set_allocated:RegressParameter.linear_0)
}

// optional .ActivationParameter activation_1 = 2;
inline bool RegressParameter::_internal_has_activation_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_1_ != nullptr);
  return value;
}
inline bool RegressParameter::has_activation_1() const {
  return _internal_has_activation_1();
}
inline void RegressParameter::clear_activation_1() {
  if (_impl_.activation_1_ != nullptr) _impl_.activation_1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ActivationParameter& RegressParameter::_internal_activation_1() const {
  const ::ActivationParameter* p = _impl_.activation_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& RegressParameter::activation_1() const {
  // @@protoc_insertion_point(field_get:RegressParameter.activation_1)
  return _internal_activation_1();
}
inline void RegressParameter::unsafe_arena_set_allocated_activation_1(
    ::ActivationParameter* activation_1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_1_);
  }
  _impl_.activation_1_ = activation_1;
  if (activation_1) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegressParameter.activation_1)
}
inline ::ActivationParameter* RegressParameter::release_activation_1() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ActivationParameter* temp = _impl_.activation_1_;
  _impl_.activation_1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* RegressParameter::unsafe_arena_release_activation_1() {
  // @@protoc_insertion_point(field_release:RegressParameter.activation_1)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ActivationParameter* temp = _impl_.activation_1_;
  _impl_.activation_1_ = nullptr;
  return temp;
}
inline ::ActivationParameter* RegressParameter::_internal_mutable_activation_1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.activation_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_1_ = p;
  }
  return _impl_.activation_1_;
}
inline ::ActivationParameter* RegressParameter::mutable_activation_1() {
  ::ActivationParameter* _msg = _internal_mutable_activation_1();
  // @@protoc_insertion_point(field_mutable:RegressParameter.activation_1)
  return _msg;
}
inline void RegressParameter::set_allocated_activation_1(::ActivationParameter* activation_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_1_;
  }
  if (activation_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_1);
    if (message_arena != submessage_arena) {
      activation_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.activation_1_ = activation_1;
  // @@protoc_insertion_point(field_set_allocated:RegressParameter.activation_1)
}

// optional .DenseParameter linear_3 = 3;
inline bool RegressParameter::_internal_has_linear_3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_3_ != nullptr);
  return value;
}
inline bool RegressParameter::has_linear_3() const {
  return _internal_has_linear_3();
}
inline void RegressParameter::clear_linear_3() {
  if (_impl_.linear_3_ != nullptr) _impl_.linear_3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::DenseParameter& RegressParameter::_internal_linear_3() const {
  const ::DenseParameter* p = _impl_.linear_3_;
  return p != nullptr ? *p : reinterpret_cast<const ::DenseParameter&>(
      ::_DenseParameter_default_instance_);
}
inline const ::DenseParameter& RegressParameter::linear_3() const {
  // @@protoc_insertion_point(field_get:RegressParameter.linear_3)
  return _internal_linear_3();
}
inline void RegressParameter::unsafe_arena_set_allocated_linear_3(
    ::DenseParameter* linear_3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_3_);
  }
  _impl_.linear_3_ = linear_3;
  if (linear_3) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegressParameter.linear_3)
}
inline ::DenseParameter* RegressParameter::release_linear_3() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DenseParameter* temp = _impl_.linear_3_;
  _impl_.linear_3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DenseParameter* RegressParameter::unsafe_arena_release_linear_3() {
  // @@protoc_insertion_point(field_release:RegressParameter.linear_3)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DenseParameter* temp = _impl_.linear_3_;
  _impl_.linear_3_ = nullptr;
  return temp;
}
inline ::DenseParameter* RegressParameter::_internal_mutable_linear_3() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.linear_3_ == nullptr) {
    auto* p = CreateMaybeMessage<::DenseParameter>(GetArenaForAllocation());
    _impl_.linear_3_ = p;
  }
  return _impl_.linear_3_;
}
inline ::DenseParameter* RegressParameter::mutable_linear_3() {
  ::DenseParameter* _msg = _internal_mutable_linear_3();
  // @@protoc_insertion_point(field_mutable:RegressParameter.linear_3)
  return _msg;
}
inline void RegressParameter::set_allocated_linear_3(::DenseParameter* linear_3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_3_;
  }
  if (linear_3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_3);
    if (message_arena != submessage_arena) {
      linear_3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_3, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.linear_3_ = linear_3;
  // @@protoc_insertion_point(field_set_allocated:RegressParameter.linear_3)
}

// optional .ActivationParameter activation_4 = 4;
inline bool RegressParameter::_internal_has_activation_4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_4_ != nullptr);
  return value;
}
inline bool RegressParameter::has_activation_4() const {
  return _internal_has_activation_4();
}
inline void RegressParameter::clear_activation_4() {
  if (_impl_.activation_4_ != nullptr) _impl_.activation_4_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::ActivationParameter& RegressParameter::_internal_activation_4() const {
  const ::ActivationParameter* p = _impl_.activation_4_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& RegressParameter::activation_4() const {
  // @@protoc_insertion_point(field_get:RegressParameter.activation_4)
  return _internal_activation_4();
}
inline void RegressParameter::unsafe_arena_set_allocated_activation_4(
    ::ActivationParameter* activation_4) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_4_);
  }
  _impl_.activation_4_ = activation_4;
  if (activation_4) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegressParameter.activation_4)
}
inline ::ActivationParameter* RegressParameter::release_activation_4() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ActivationParameter* temp = _impl_.activation_4_;
  _impl_.activation_4_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* RegressParameter::unsafe_arena_release_activation_4() {
  // @@protoc_insertion_point(field_release:RegressParameter.activation_4)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ActivationParameter* temp = _impl_.activation_4_;
  _impl_.activation_4_ = nullptr;
  return temp;
}
inline ::ActivationParameter* RegressParameter::_internal_mutable_activation_4() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.activation_4_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_4_ = p;
  }
  return _impl_.activation_4_;
}
inline ::ActivationParameter* RegressParameter::mutable_activation_4() {
  ::ActivationParameter* _msg = _internal_mutable_activation_4();
  // @@protoc_insertion_point(field_mutable:RegressParameter.activation_4)
  return _msg;
}
inline void RegressParameter::set_allocated_activation_4(::ActivationParameter* activation_4) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_4_;
  }
  if (activation_4) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_4);
    if (message_arena != submessage_arena) {
      activation_4 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_4, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.activation_4_ = activation_4;
  // @@protoc_insertion_point(field_set_allocated:RegressParameter.activation_4)
}

// optional .DenseParameter linear_6 = 5;
inline bool RegressParameter::_internal_has_linear_6() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_6_ != nullptr);
  return value;
}
inline bool RegressParameter::has_linear_6() const {
  return _internal_has_linear_6();
}
inline void RegressParameter::clear_linear_6() {
  if (_impl_.linear_6_ != nullptr) _impl_.linear_6_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::DenseParameter& RegressParameter::_internal_linear_6() const {
  const ::DenseParameter* p = _impl_.linear_6_;
  return p != nullptr ? *p : reinterpret_cast<const ::DenseParameter&>(
      ::_DenseParameter_default_instance_);
}
inline const ::DenseParameter& RegressParameter::linear_6() const {
  // @@protoc_insertion_point(field_get:RegressParameter.linear_6)
  return _internal_linear_6();
}
inline void RegressParameter::unsafe_arena_set_allocated_linear_6(
    ::DenseParameter* linear_6) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_6_);
  }
  _impl_.linear_6_ = linear_6;
  if (linear_6) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegressParameter.linear_6)
}
inline ::DenseParameter* RegressParameter::release_linear_6() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::DenseParameter* temp = _impl_.linear_6_;
  _impl_.linear_6_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DenseParameter* RegressParameter::unsafe_arena_release_linear_6() {
  // @@protoc_insertion_point(field_release:RegressParameter.linear_6)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::DenseParameter* temp = _impl_.linear_6_;
  _impl_.linear_6_ = nullptr;
  return temp;
}
inline ::DenseParameter* RegressParameter::_internal_mutable_linear_6() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.linear_6_ == nullptr) {
    auto* p = CreateMaybeMessage<::DenseParameter>(GetArenaForAllocation());
    _impl_.linear_6_ = p;
  }
  return _impl_.linear_6_;
}
inline ::DenseParameter* RegressParameter::mutable_linear_6() {
  ::DenseParameter* _msg = _internal_mutable_linear_6();
  // @@protoc_insertion_point(field_mutable:RegressParameter.linear_6)
  return _msg;
}
inline void RegressParameter::set_allocated_linear_6(::DenseParameter* linear_6) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_6_;
  }
  if (linear_6) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_6);
    if (message_arena != submessage_arena) {
      linear_6 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_6, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.linear_6_ = linear_6;
  // @@protoc_insertion_point(field_set_allocated:RegressParameter.linear_6)
}

// optional .ActivationParameter activation_7 = 6;
inline bool RegressParameter::_internal_has_activation_7() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_7_ != nullptr);
  return value;
}
inline bool RegressParameter::has_activation_7() const {
  return _internal_has_activation_7();
}
inline void RegressParameter::clear_activation_7() {
  if (_impl_.activation_7_ != nullptr) _impl_.activation_7_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::ActivationParameter& RegressParameter::_internal_activation_7() const {
  const ::ActivationParameter* p = _impl_.activation_7_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& RegressParameter::activation_7() const {
  // @@protoc_insertion_point(field_get:RegressParameter.activation_7)
  return _internal_activation_7();
}
inline void RegressParameter::unsafe_arena_set_allocated_activation_7(
    ::ActivationParameter* activation_7) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_7_);
  }
  _impl_.activation_7_ = activation_7;
  if (activation_7) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegressParameter.activation_7)
}
inline ::ActivationParameter* RegressParameter::release_activation_7() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ActivationParameter* temp = _impl_.activation_7_;
  _impl_.activation_7_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* RegressParameter::unsafe_arena_release_activation_7() {
  // @@protoc_insertion_point(field_release:RegressParameter.activation_7)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ActivationParameter* temp = _impl_.activation_7_;
  _impl_.activation_7_ = nullptr;
  return temp;
}
inline ::ActivationParameter* RegressParameter::_internal_mutable_activation_7() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.activation_7_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_7_ = p;
  }
  return _impl_.activation_7_;
}
inline ::ActivationParameter* RegressParameter::mutable_activation_7() {
  ::ActivationParameter* _msg = _internal_mutable_activation_7();
  // @@protoc_insertion_point(field_mutable:RegressParameter.activation_7)
  return _msg;
}
inline void RegressParameter::set_allocated_activation_7(::ActivationParameter* activation_7) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_7_;
  }
  if (activation_7) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_7);
    if (message_arena != submessage_arena) {
      activation_7 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_7, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.activation_7_ = activation_7;
  // @@protoc_insertion_point(field_set_allocated:RegressParameter.activation_7)
}

// optional .DenseParameter linear_9 = 7;
inline bool RegressParameter::_internal_has_linear_9() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linear_9_ != nullptr);
  return value;
}
inline bool RegressParameter::has_linear_9() const {
  return _internal_has_linear_9();
}
inline void RegressParameter::clear_linear_9() {
  if (_impl_.linear_9_ != nullptr) _impl_.linear_9_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::DenseParameter& RegressParameter::_internal_linear_9() const {
  const ::DenseParameter* p = _impl_.linear_9_;
  return p != nullptr ? *p : reinterpret_cast<const ::DenseParameter&>(
      ::_DenseParameter_default_instance_);
}
inline const ::DenseParameter& RegressParameter::linear_9() const {
  // @@protoc_insertion_point(field_get:RegressParameter.linear_9)
  return _internal_linear_9();
}
inline void RegressParameter::unsafe_arena_set_allocated_linear_9(
    ::DenseParameter* linear_9) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linear_9_);
  }
  _impl_.linear_9_ = linear_9;
  if (linear_9) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegressParameter.linear_9)
}
inline ::DenseParameter* RegressParameter::release_linear_9() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::DenseParameter* temp = _impl_.linear_9_;
  _impl_.linear_9_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DenseParameter* RegressParameter::unsafe_arena_release_linear_9() {
  // @@protoc_insertion_point(field_release:RegressParameter.linear_9)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::DenseParameter* temp = _impl_.linear_9_;
  _impl_.linear_9_ = nullptr;
  return temp;
}
inline ::DenseParameter* RegressParameter::_internal_mutable_linear_9() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.linear_9_ == nullptr) {
    auto* p = CreateMaybeMessage<::DenseParameter>(GetArenaForAllocation());
    _impl_.linear_9_ = p;
  }
  return _impl_.linear_9_;
}
inline ::DenseParameter* RegressParameter::mutable_linear_9() {
  ::DenseParameter* _msg = _internal_mutable_linear_9();
  // @@protoc_insertion_point(field_mutable:RegressParameter.linear_9)
  return _msg;
}
inline void RegressParameter::set_allocated_linear_9(::DenseParameter* linear_9) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linear_9_;
  }
  if (linear_9) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_9);
    if (message_arena != submessage_arena) {
      linear_9 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_9, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.linear_9_ = linear_9;
  // @@protoc_insertion_point(field_set_allocated:RegressParameter.linear_9)
}

// optional .ActivationParameter activation_10 = 8;
inline bool RegressParameter::_internal_has_activation_10() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activation_10_ != nullptr);
  return value;
}
inline bool RegressParameter::has_activation_10() const {
  return _internal_has_activation_10();
}
inline void RegressParameter::clear_activation_10() {
  if (_impl_.activation_10_ != nullptr) _impl_.activation_10_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::ActivationParameter& RegressParameter::_internal_activation_10() const {
  const ::ActivationParameter* p = _impl_.activation_10_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActivationParameter&>(
      ::_ActivationParameter_default_instance_);
}
inline const ::ActivationParameter& RegressParameter::activation_10() const {
  // @@protoc_insertion_point(field_get:RegressParameter.activation_10)
  return _internal_activation_10();
}
inline void RegressParameter::unsafe_arena_set_allocated_activation_10(
    ::ActivationParameter* activation_10) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activation_10_);
  }
  _impl_.activation_10_ = activation_10;
  if (activation_10) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegressParameter.activation_10)
}
inline ::ActivationParameter* RegressParameter::release_activation_10() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::ActivationParameter* temp = _impl_.activation_10_;
  _impl_.activation_10_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActivationParameter* RegressParameter::unsafe_arena_release_activation_10() {
  // @@protoc_insertion_point(field_release:RegressParameter.activation_10)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::ActivationParameter* temp = _impl_.activation_10_;
  _impl_.activation_10_ = nullptr;
  return temp;
}
inline ::ActivationParameter* RegressParameter::_internal_mutable_activation_10() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.activation_10_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActivationParameter>(GetArenaForAllocation());
    _impl_.activation_10_ = p;
  }
  return _impl_.activation_10_;
}
inline ::ActivationParameter* RegressParameter::mutable_activation_10() {
  ::ActivationParameter* _msg = _internal_mutable_activation_10();
  // @@protoc_insertion_point(field_mutable:RegressParameter.activation_10)
  return _msg;
}
inline void RegressParameter::set_allocated_activation_10(::ActivationParameter* activation_10) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activation_10_;
  }
  if (activation_10) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activation_10);
    if (message_arena != submessage_arena) {
      activation_10 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activation_10, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.activation_10_ = activation_10;
  // @@protoc_insertion_point(field_set_allocated:RegressParameter.activation_10)
}

// -------------------------------------------------------------------

// CruiseModelParameter

// optional .LaneFeatureConvParameter lane_feature_conv = 1;
inline bool CruiseModelParameter::_internal_has_lane_feature_conv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lane_feature_conv_ != nullptr);
  return value;
}
inline bool CruiseModelParameter::has_lane_feature_conv() const {
  return _internal_has_lane_feature_conv();
}
inline void CruiseModelParameter::clear_lane_feature_conv() {
  if (_impl_.lane_feature_conv_ != nullptr) _impl_.lane_feature_conv_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::LaneFeatureConvParameter& CruiseModelParameter::_internal_lane_feature_conv() const {
  const ::LaneFeatureConvParameter* p = _impl_.lane_feature_conv_;
  return p != nullptr ? *p : reinterpret_cast<const ::LaneFeatureConvParameter&>(
      ::_LaneFeatureConvParameter_default_instance_);
}
inline const ::LaneFeatureConvParameter& CruiseModelParameter::lane_feature_conv() const {
  // @@protoc_insertion_point(field_get:CruiseModelParameter.lane_feature_conv)
  return _internal_lane_feature_conv();
}
inline void CruiseModelParameter::unsafe_arena_set_allocated_lane_feature_conv(
    ::LaneFeatureConvParameter* lane_feature_conv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lane_feature_conv_);
  }
  _impl_.lane_feature_conv_ = lane_feature_conv;
  if (lane_feature_conv) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CruiseModelParameter.lane_feature_conv)
}
inline ::LaneFeatureConvParameter* CruiseModelParameter::release_lane_feature_conv() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::LaneFeatureConvParameter* temp = _impl_.lane_feature_conv_;
  _impl_.lane_feature_conv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LaneFeatureConvParameter* CruiseModelParameter::unsafe_arena_release_lane_feature_conv() {
  // @@protoc_insertion_point(field_release:CruiseModelParameter.lane_feature_conv)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::LaneFeatureConvParameter* temp = _impl_.lane_feature_conv_;
  _impl_.lane_feature_conv_ = nullptr;
  return temp;
}
inline ::LaneFeatureConvParameter* CruiseModelParameter::_internal_mutable_lane_feature_conv() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lane_feature_conv_ == nullptr) {
    auto* p = CreateMaybeMessage<::LaneFeatureConvParameter>(GetArenaForAllocation());
    _impl_.lane_feature_conv_ = p;
  }
  return _impl_.lane_feature_conv_;
}
inline ::LaneFeatureConvParameter* CruiseModelParameter::mutable_lane_feature_conv() {
  ::LaneFeatureConvParameter* _msg = _internal_mutable_lane_feature_conv();
  // @@protoc_insertion_point(field_mutable:CruiseModelParameter.lane_feature_conv)
  return _msg;
}
inline void CruiseModelParameter::set_allocated_lane_feature_conv(::LaneFeatureConvParameter* lane_feature_conv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lane_feature_conv_;
  }
  if (lane_feature_conv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lane_feature_conv);
    if (message_arena != submessage_arena) {
      lane_feature_conv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lane_feature_conv, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lane_feature_conv_ = lane_feature_conv;
  // @@protoc_insertion_point(field_set_allocated:CruiseModelParameter.lane_feature_conv)
}

// optional .MaxPool1dParameter lane_feature_maxpool = 2;
inline bool CruiseModelParameter::_internal_has_lane_feature_maxpool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lane_feature_maxpool_ != nullptr);
  return value;
}
inline bool CruiseModelParameter::has_lane_feature_maxpool() const {
  return _internal_has_lane_feature_maxpool();
}
inline void CruiseModelParameter::clear_lane_feature_maxpool() {
  if (_impl_.lane_feature_maxpool_ != nullptr) _impl_.lane_feature_maxpool_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::MaxPool1dParameter& CruiseModelParameter::_internal_lane_feature_maxpool() const {
  const ::MaxPool1dParameter* p = _impl_.lane_feature_maxpool_;
  return p != nullptr ? *p : reinterpret_cast<const ::MaxPool1dParameter&>(
      ::_MaxPool1dParameter_default_instance_);
}
inline const ::MaxPool1dParameter& CruiseModelParameter::lane_feature_maxpool() const {
  // @@protoc_insertion_point(field_get:CruiseModelParameter.lane_feature_maxpool)
  return _internal_lane_feature_maxpool();
}
inline void CruiseModelParameter::unsafe_arena_set_allocated_lane_feature_maxpool(
    ::MaxPool1dParameter* lane_feature_maxpool) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lane_feature_maxpool_);
  }
  _impl_.lane_feature_maxpool_ = lane_feature_maxpool;
  if (lane_feature_maxpool) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CruiseModelParameter.lane_feature_maxpool)
}
inline ::MaxPool1dParameter* CruiseModelParameter::release_lane_feature_maxpool() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MaxPool1dParameter* temp = _impl_.lane_feature_maxpool_;
  _impl_.lane_feature_maxpool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MaxPool1dParameter* CruiseModelParameter::unsafe_arena_release_lane_feature_maxpool() {
  // @@protoc_insertion_point(field_release:CruiseModelParameter.lane_feature_maxpool)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MaxPool1dParameter* temp = _impl_.lane_feature_maxpool_;
  _impl_.lane_feature_maxpool_ = nullptr;
  return temp;
}
inline ::MaxPool1dParameter* CruiseModelParameter::_internal_mutable_lane_feature_maxpool() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lane_feature_maxpool_ == nullptr) {
    auto* p = CreateMaybeMessage<::MaxPool1dParameter>(GetArenaForAllocation());
    _impl_.lane_feature_maxpool_ = p;
  }
  return _impl_.lane_feature_maxpool_;
}
inline ::MaxPool1dParameter* CruiseModelParameter::mutable_lane_feature_maxpool() {
  ::MaxPool1dParameter* _msg = _internal_mutable_lane_feature_maxpool();
  // @@protoc_insertion_point(field_mutable:CruiseModelParameter.lane_feature_maxpool)
  return _msg;
}
inline void CruiseModelParameter::set_allocated_lane_feature_maxpool(::MaxPool1dParameter* lane_feature_maxpool) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lane_feature_maxpool_;
  }
  if (lane_feature_maxpool) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lane_feature_maxpool);
    if (message_arena != submessage_arena) {
      lane_feature_maxpool = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lane_feature_maxpool, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.lane_feature_maxpool_ = lane_feature_maxpool;
  // @@protoc_insertion_point(field_set_allocated:CruiseModelParameter.lane_feature_maxpool)
}

// optional .AvgPool1dParameter lane_feature_avgpool = 3;
inline bool CruiseModelParameter::_internal_has_lane_feature_avgpool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lane_feature_avgpool_ != nullptr);
  return value;
}
inline bool CruiseModelParameter::has_lane_feature_avgpool() const {
  return _internal_has_lane_feature_avgpool();
}
inline void CruiseModelParameter::clear_lane_feature_avgpool() {
  if (_impl_.lane_feature_avgpool_ != nullptr) _impl_.lane_feature_avgpool_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::AvgPool1dParameter& CruiseModelParameter::_internal_lane_feature_avgpool() const {
  const ::AvgPool1dParameter* p = _impl_.lane_feature_avgpool_;
  return p != nullptr ? *p : reinterpret_cast<const ::AvgPool1dParameter&>(
      ::_AvgPool1dParameter_default_instance_);
}
inline const ::AvgPool1dParameter& CruiseModelParameter::lane_feature_avgpool() const {
  // @@protoc_insertion_point(field_get:CruiseModelParameter.lane_feature_avgpool)
  return _internal_lane_feature_avgpool();
}
inline void CruiseModelParameter::unsafe_arena_set_allocated_lane_feature_avgpool(
    ::AvgPool1dParameter* lane_feature_avgpool) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lane_feature_avgpool_);
  }
  _impl_.lane_feature_avgpool_ = lane_feature_avgpool;
  if (lane_feature_avgpool) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CruiseModelParameter.lane_feature_avgpool)
}
inline ::AvgPool1dParameter* CruiseModelParameter::release_lane_feature_avgpool() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::AvgPool1dParameter* temp = _impl_.lane_feature_avgpool_;
  _impl_.lane_feature_avgpool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AvgPool1dParameter* CruiseModelParameter::unsafe_arena_release_lane_feature_avgpool() {
  // @@protoc_insertion_point(field_release:CruiseModelParameter.lane_feature_avgpool)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::AvgPool1dParameter* temp = _impl_.lane_feature_avgpool_;
  _impl_.lane_feature_avgpool_ = nullptr;
  return temp;
}
inline ::AvgPool1dParameter* CruiseModelParameter::_internal_mutable_lane_feature_avgpool() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.lane_feature_avgpool_ == nullptr) {
    auto* p = CreateMaybeMessage<::AvgPool1dParameter>(GetArenaForAllocation());
    _impl_.lane_feature_avgpool_ = p;
  }
  return _impl_.lane_feature_avgpool_;
}
inline ::AvgPool1dParameter* CruiseModelParameter::mutable_lane_feature_avgpool() {
  ::AvgPool1dParameter* _msg = _internal_mutable_lane_feature_avgpool();
  // @@protoc_insertion_point(field_mutable:CruiseModelParameter.lane_feature_avgpool)
  return _msg;
}
inline void CruiseModelParameter::set_allocated_lane_feature_avgpool(::AvgPool1dParameter* lane_feature_avgpool) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lane_feature_avgpool_;
  }
  if (lane_feature_avgpool) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lane_feature_avgpool);
    if (message_arena != submessage_arena) {
      lane_feature_avgpool = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lane_feature_avgpool, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.lane_feature_avgpool_ = lane_feature_avgpool;
  // @@protoc_insertion_point(field_set_allocated:CruiseModelParameter.lane_feature_avgpool)
}

// optional .ObsFeatureFCParameter obs_feature_fc = 5;
inline bool CruiseModelParameter::_internal_has_obs_feature_fc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obs_feature_fc_ != nullptr);
  return value;
}
inline bool CruiseModelParameter::has_obs_feature_fc() const {
  return _internal_has_obs_feature_fc();
}
inline void CruiseModelParameter::clear_obs_feature_fc() {
  if (_impl_.obs_feature_fc_ != nullptr) _impl_.obs_feature_fc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::ObsFeatureFCParameter& CruiseModelParameter::_internal_obs_feature_fc() const {
  const ::ObsFeatureFCParameter* p = _impl_.obs_feature_fc_;
  return p != nullptr ? *p : reinterpret_cast<const ::ObsFeatureFCParameter&>(
      ::_ObsFeatureFCParameter_default_instance_);
}
inline const ::ObsFeatureFCParameter& CruiseModelParameter::obs_feature_fc() const {
  // @@protoc_insertion_point(field_get:CruiseModelParameter.obs_feature_fc)
  return _internal_obs_feature_fc();
}
inline void CruiseModelParameter::unsafe_arena_set_allocated_obs_feature_fc(
    ::ObsFeatureFCParameter* obs_feature_fc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obs_feature_fc_);
  }
  _impl_.obs_feature_fc_ = obs_feature_fc;
  if (obs_feature_fc) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CruiseModelParameter.obs_feature_fc)
}
inline ::ObsFeatureFCParameter* CruiseModelParameter::release_obs_feature_fc() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ObsFeatureFCParameter* temp = _impl_.obs_feature_fc_;
  _impl_.obs_feature_fc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ObsFeatureFCParameter* CruiseModelParameter::unsafe_arena_release_obs_feature_fc() {
  // @@protoc_insertion_point(field_release:CruiseModelParameter.obs_feature_fc)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ObsFeatureFCParameter* temp = _impl_.obs_feature_fc_;
  _impl_.obs_feature_fc_ = nullptr;
  return temp;
}
inline ::ObsFeatureFCParameter* CruiseModelParameter::_internal_mutable_obs_feature_fc() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.obs_feature_fc_ == nullptr) {
    auto* p = CreateMaybeMessage<::ObsFeatureFCParameter>(GetArenaForAllocation());
    _impl_.obs_feature_fc_ = p;
  }
  return _impl_.obs_feature_fc_;
}
inline ::ObsFeatureFCParameter* CruiseModelParameter::mutable_obs_feature_fc() {
  ::ObsFeatureFCParameter* _msg = _internal_mutable_obs_feature_fc();
  // @@protoc_insertion_point(field_mutable:CruiseModelParameter.obs_feature_fc)
  return _msg;
}
inline void CruiseModelParameter::set_allocated_obs_feature_fc(::ObsFeatureFCParameter* obs_feature_fc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obs_feature_fc_;
  }
  if (obs_feature_fc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obs_feature_fc);
    if (message_arena != submessage_arena) {
      obs_feature_fc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obs_feature_fc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.obs_feature_fc_ = obs_feature_fc;
  // @@protoc_insertion_point(field_set_allocated:CruiseModelParameter.obs_feature_fc)
}

// optional .ClassifyParameter classify = 6;
inline bool CruiseModelParameter::_internal_has_classify() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.classify_ != nullptr);
  return value;
}
inline bool CruiseModelParameter::has_classify() const {
  return _internal_has_classify();
}
inline void CruiseModelParameter::clear_classify() {
  if (_impl_.classify_ != nullptr) _impl_.classify_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::ClassifyParameter& CruiseModelParameter::_internal_classify() const {
  const ::ClassifyParameter* p = _impl_.classify_;
  return p != nullptr ? *p : reinterpret_cast<const ::ClassifyParameter&>(
      ::_ClassifyParameter_default_instance_);
}
inline const ::ClassifyParameter& CruiseModelParameter::classify() const {
  // @@protoc_insertion_point(field_get:CruiseModelParameter.classify)
  return _internal_classify();
}
inline void CruiseModelParameter::unsafe_arena_set_allocated_classify(
    ::ClassifyParameter* classify) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classify_);
  }
  _impl_.classify_ = classify;
  if (classify) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CruiseModelParameter.classify)
}
inline ::ClassifyParameter* CruiseModelParameter::release_classify() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::ClassifyParameter* temp = _impl_.classify_;
  _impl_.classify_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ClassifyParameter* CruiseModelParameter::unsafe_arena_release_classify() {
  // @@protoc_insertion_point(field_release:CruiseModelParameter.classify)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::ClassifyParameter* temp = _impl_.classify_;
  _impl_.classify_ = nullptr;
  return temp;
}
inline ::ClassifyParameter* CruiseModelParameter::_internal_mutable_classify() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.classify_ == nullptr) {
    auto* p = CreateMaybeMessage<::ClassifyParameter>(GetArenaForAllocation());
    _impl_.classify_ = p;
  }
  return _impl_.classify_;
}
inline ::ClassifyParameter* CruiseModelParameter::mutable_classify() {
  ::ClassifyParameter* _msg = _internal_mutable_classify();
  // @@protoc_insertion_point(field_mutable:CruiseModelParameter.classify)
  return _msg;
}
inline void CruiseModelParameter::set_allocated_classify(::ClassifyParameter* classify) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.classify_;
  }
  if (classify) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(classify);
    if (message_arena != submessage_arena) {
      classify = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classify, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.classify_ = classify;
  // @@protoc_insertion_point(field_set_allocated:CruiseModelParameter.classify)
}

// optional .RegressParameter regress = 7;
inline bool CruiseModelParameter::_internal_has_regress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regress_ != nullptr);
  return value;
}
inline bool CruiseModelParameter::has_regress() const {
  return _internal_has_regress();
}
inline void CruiseModelParameter::clear_regress() {
  if (_impl_.regress_ != nullptr) _impl_.regress_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::RegressParameter& CruiseModelParameter::_internal_regress() const {
  const ::RegressParameter* p = _impl_.regress_;
  return p != nullptr ? *p : reinterpret_cast<const ::RegressParameter&>(
      ::_RegressParameter_default_instance_);
}
inline const ::RegressParameter& CruiseModelParameter::regress() const {
  // @@protoc_insertion_point(field_get:CruiseModelParameter.regress)
  return _internal_regress();
}
inline void CruiseModelParameter::unsafe_arena_set_allocated_regress(
    ::RegressParameter* regress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regress_);
  }
  _impl_.regress_ = regress;
  if (regress) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CruiseModelParameter.regress)
}
inline ::RegressParameter* CruiseModelParameter::release_regress() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::RegressParameter* temp = _impl_.regress_;
  _impl_.regress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RegressParameter* CruiseModelParameter::unsafe_arena_release_regress() {
  // @@protoc_insertion_point(field_release:CruiseModelParameter.regress)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::RegressParameter* temp = _impl_.regress_;
  _impl_.regress_ = nullptr;
  return temp;
}
inline ::RegressParameter* CruiseModelParameter::_internal_mutable_regress() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.regress_ == nullptr) {
    auto* p = CreateMaybeMessage<::RegressParameter>(GetArenaForAllocation());
    _impl_.regress_ = p;
  }
  return _impl_.regress_;
}
inline ::RegressParameter* CruiseModelParameter::mutable_regress() {
  ::RegressParameter* _msg = _internal_mutable_regress();
  // @@protoc_insertion_point(field_mutable:CruiseModelParameter.regress)
  return _msg;
}
inline void CruiseModelParameter::set_allocated_regress(::RegressParameter* regress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regress_;
  }
  if (regress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regress);
    if (message_arena != submessage_arena) {
      regress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regress, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.regress_ = regress;
  // @@protoc_insertion_point(field_set_allocated:CruiseModelParameter.regress)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2ftools_2fprediction_2fdata_5fpipelines_2fproto_2fcruise_5fmodel_2eproto
