// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/data/proto/static_info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fdata_2fproto_2fstatic_5finfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fdata_2fproto_2fstatic_5finfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/canbus/proto/canbus_conf.pb.h"
#include "modules/canbus/proto/chassis.pb.h"
#include "modules/common/configs/proto/vehicle_config.pb.h"
#include "modules/control/proto/control_conf.pb.h"
#include "modules/routing/proto/routing.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fdata_2fproto_2fstatic_5finfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
namespace apollo {
namespace data {
class EnvironmentInfo;
struct EnvironmentInfoDefaultTypeInternal;
extern EnvironmentInfoDefaultTypeInternal _EnvironmentInfo_default_instance_;
class HardwareInfo;
struct HardwareInfoDefaultTypeInternal;
extern HardwareInfoDefaultTypeInternal _HardwareInfo_default_instance_;
class HardwareInfo_ConfigsEntry_DoNotUse;
struct HardwareInfo_ConfigsEntry_DoNotUseDefaultTypeInternal;
extern HardwareInfo_ConfigsEntry_DoNotUseDefaultTypeInternal _HardwareInfo_ConfigsEntry_DoNotUse_default_instance_;
class SoftwareInfo;
struct SoftwareInfoDefaultTypeInternal;
extern SoftwareInfoDefaultTypeInternal _SoftwareInfo_default_instance_;
class SoftwareInfo_ConfigsEntry_DoNotUse;
struct SoftwareInfo_ConfigsEntry_DoNotUseDefaultTypeInternal;
extern SoftwareInfo_ConfigsEntry_DoNotUseDefaultTypeInternal _SoftwareInfo_ConfigsEntry_DoNotUse_default_instance_;
class StaticInfo;
struct StaticInfoDefaultTypeInternal;
extern StaticInfoDefaultTypeInternal _StaticInfo_default_instance_;
class StaticInfoConf;
struct StaticInfoConfDefaultTypeInternal;
extern StaticInfoConfDefaultTypeInternal _StaticInfoConf_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class VehicleInfo;
struct VehicleInfoDefaultTypeInternal;
extern VehicleInfoDefaultTypeInternal _VehicleInfo_default_instance_;
}  // namespace data
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::data::EnvironmentInfo* Arena::CreateMaybeMessage<::apollo::data::EnvironmentInfo>(Arena*);
template<> ::apollo::data::HardwareInfo* Arena::CreateMaybeMessage<::apollo::data::HardwareInfo>(Arena*);
template<> ::apollo::data::HardwareInfo_ConfigsEntry_DoNotUse* Arena::CreateMaybeMessage<::apollo::data::HardwareInfo_ConfigsEntry_DoNotUse>(Arena*);
template<> ::apollo::data::SoftwareInfo* Arena::CreateMaybeMessage<::apollo::data::SoftwareInfo>(Arena*);
template<> ::apollo::data::SoftwareInfo_ConfigsEntry_DoNotUse* Arena::CreateMaybeMessage<::apollo::data::SoftwareInfo_ConfigsEntry_DoNotUse>(Arena*);
template<> ::apollo::data::StaticInfo* Arena::CreateMaybeMessage<::apollo::data::StaticInfo>(Arena*);
template<> ::apollo::data::StaticInfoConf* Arena::CreateMaybeMessage<::apollo::data::StaticInfoConf>(Arena*);
template<> ::apollo::data::UserInfo* Arena::CreateMaybeMessage<::apollo::data::UserInfo>(Arena*);
template<> ::apollo::data::VehicleInfo* Arena::CreateMaybeMessage<::apollo::data::VehicleInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace data {

enum VehicleInfo_Brand : int {
  VehicleInfo_Brand_LINCOLN = 1
};
bool VehicleInfo_Brand_IsValid(int value);
constexpr VehicleInfo_Brand VehicleInfo_Brand_Brand_MIN = VehicleInfo_Brand_LINCOLN;
constexpr VehicleInfo_Brand VehicleInfo_Brand_Brand_MAX = VehicleInfo_Brand_LINCOLN;
constexpr int VehicleInfo_Brand_Brand_ARRAYSIZE = VehicleInfo_Brand_Brand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleInfo_Brand_descriptor();
template<typename T>
inline const std::string& VehicleInfo_Brand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehicleInfo_Brand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehicleInfo_Brand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehicleInfo_Brand_descriptor(), enum_t_value);
}
inline bool VehicleInfo_Brand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VehicleInfo_Brand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehicleInfo_Brand>(
    VehicleInfo_Brand_descriptor(), name, value);
}
enum VehicleInfo_Model : int {
  VehicleInfo_Model_MKZ = 1
};
bool VehicleInfo_Model_IsValid(int value);
constexpr VehicleInfo_Model VehicleInfo_Model_Model_MIN = VehicleInfo_Model_MKZ;
constexpr VehicleInfo_Model VehicleInfo_Model_Model_MAX = VehicleInfo_Model_MKZ;
constexpr int VehicleInfo_Model_Model_ARRAYSIZE = VehicleInfo_Model_Model_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleInfo_Model_descriptor();
template<typename T>
inline const std::string& VehicleInfo_Model_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehicleInfo_Model>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehicleInfo_Model_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehicleInfo_Model_descriptor(), enum_t_value);
}
inline bool VehicleInfo_Model_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VehicleInfo_Model* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehicleInfo_Model>(
    VehicleInfo_Model_descriptor(), name, value);
}
// ===================================================================

class VehicleInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.VehicleInfo) */ {
 public:
  inline VehicleInfo() : VehicleInfo(nullptr) {}
  ~VehicleInfo() override;
  explicit PROTOBUF_CONSTEXPR VehicleInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehicleInfo(const VehicleInfo& from);
  VehicleInfo(VehicleInfo&& from) noexcept
    : VehicleInfo() {
    *this = ::std::move(from);
  }

  inline VehicleInfo& operator=(const VehicleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleInfo& operator=(VehicleInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleInfo* internal_default_instance() {
    return reinterpret_cast<const VehicleInfo*>(
               &_VehicleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VehicleInfo& a, VehicleInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehicleInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VehicleInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.VehicleInfo";
  }
  protected:
  explicit VehicleInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehicleInfo_Brand Brand;
  static constexpr Brand LINCOLN =
    VehicleInfo_Brand_LINCOLN;
  static inline bool Brand_IsValid(int value) {
    return VehicleInfo_Brand_IsValid(value);
  }
  static constexpr Brand Brand_MIN =
    VehicleInfo_Brand_Brand_MIN;
  static constexpr Brand Brand_MAX =
    VehicleInfo_Brand_Brand_MAX;
  static constexpr int Brand_ARRAYSIZE =
    VehicleInfo_Brand_Brand_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Brand_descriptor() {
    return VehicleInfo_Brand_descriptor();
  }
  template<typename T>
  static inline const std::string& Brand_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Brand>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Brand_Name.");
    return VehicleInfo_Brand_Name(enum_t_value);
  }
  static inline bool Brand_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Brand* value) {
    return VehicleInfo_Brand_Parse(name, value);
  }

  typedef VehicleInfo_Model Model;
  static constexpr Model MKZ =
    VehicleInfo_Model_MKZ;
  static inline bool Model_IsValid(int value) {
    return VehicleInfo_Model_IsValid(value);
  }
  static constexpr Model Model_MIN =
    VehicleInfo_Model_Model_MIN;
  static constexpr Model Model_MAX =
    VehicleInfo_Model_Model_MAX;
  static constexpr int Model_ARRAYSIZE =
    VehicleInfo_Model_Model_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Model_descriptor() {
    return VehicleInfo_Model_descriptor();
  }
  template<typename T>
  static inline const std::string& Model_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Model>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Model_Name.");
    return VehicleInfo_Model_Name(enum_t_value);
  }
  static inline bool Model_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Model* value) {
    return VehicleInfo_Model_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLicenseFieldNumber = 4,
    kCanbusConfFieldNumber = 5,
    kVehicleConfigFieldNumber = 6,
    kControlConfigFieldNumber = 7,
    kBrandFieldNumber = 2,
    kModelFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .apollo.canbus.License license = 4;
  bool has_license() const;
  private:
  bool _internal_has_license() const;
  public:
  void clear_license();
  const ::apollo::canbus::License& license() const;
  PROTOBUF_NODISCARD ::apollo::canbus::License* release_license();
  ::apollo::canbus::License* mutable_license();
  void set_allocated_license(::apollo::canbus::License* license);
  private:
  const ::apollo::canbus::License& _internal_license() const;
  ::apollo::canbus::License* _internal_mutable_license();
  public:
  void unsafe_arena_set_allocated_license(
      ::apollo::canbus::License* license);
  ::apollo::canbus::License* unsafe_arena_release_license();

  // optional .apollo.canbus.CanbusConf canbus_conf = 5;
  bool has_canbus_conf() const;
  private:
  bool _internal_has_canbus_conf() const;
  public:
  void clear_canbus_conf();
  const ::apollo::canbus::CanbusConf& canbus_conf() const;
  PROTOBUF_NODISCARD ::apollo::canbus::CanbusConf* release_canbus_conf();
  ::apollo::canbus::CanbusConf* mutable_canbus_conf();
  void set_allocated_canbus_conf(::apollo::canbus::CanbusConf* canbus_conf);
  private:
  const ::apollo::canbus::CanbusConf& _internal_canbus_conf() const;
  ::apollo::canbus::CanbusConf* _internal_mutable_canbus_conf();
  public:
  void unsafe_arena_set_allocated_canbus_conf(
      ::apollo::canbus::CanbusConf* canbus_conf);
  ::apollo::canbus::CanbusConf* unsafe_arena_release_canbus_conf();

  // optional .apollo.common.VehicleConfig vehicle_config = 6;
  bool has_vehicle_config() const;
  private:
  bool _internal_has_vehicle_config() const;
  public:
  void clear_vehicle_config();
  const ::apollo::common::VehicleConfig& vehicle_config() const;
  PROTOBUF_NODISCARD ::apollo::common::VehicleConfig* release_vehicle_config();
  ::apollo::common::VehicleConfig* mutable_vehicle_config();
  void set_allocated_vehicle_config(::apollo::common::VehicleConfig* vehicle_config);
  private:
  const ::apollo::common::VehicleConfig& _internal_vehicle_config() const;
  ::apollo::common::VehicleConfig* _internal_mutable_vehicle_config();
  public:
  void unsafe_arena_set_allocated_vehicle_config(
      ::apollo::common::VehicleConfig* vehicle_config);
  ::apollo::common::VehicleConfig* unsafe_arena_release_vehicle_config();

  // optional .apollo.control.ControlConf control_config = 7;
  bool has_control_config() const;
  private:
  bool _internal_has_control_config() const;
  public:
  void clear_control_config();
  const ::apollo::control::ControlConf& control_config() const;
  PROTOBUF_NODISCARD ::apollo::control::ControlConf* release_control_config();
  ::apollo::control::ControlConf* mutable_control_config();
  void set_allocated_control_config(::apollo::control::ControlConf* control_config);
  private:
  const ::apollo::control::ControlConf& _internal_control_config() const;
  ::apollo::control::ControlConf* _internal_mutable_control_config();
  public:
  void unsafe_arena_set_allocated_control_config(
      ::apollo::control::ControlConf* control_config);
  ::apollo::control::ControlConf* unsafe_arena_release_control_config();

  // optional .apollo.data.VehicleInfo.Brand brand = 2;
  bool has_brand() const;
  private:
  bool _internal_has_brand() const;
  public:
  void clear_brand();
  ::apollo::data::VehicleInfo_Brand brand() const;
  void set_brand(::apollo::data::VehicleInfo_Brand value);
  private:
  ::apollo::data::VehicleInfo_Brand _internal_brand() const;
  void _internal_set_brand(::apollo::data::VehicleInfo_Brand value);
  public:

  // optional .apollo.data.VehicleInfo.Model model = 3;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  ::apollo::data::VehicleInfo_Model model() const;
  void set_model(::apollo::data::VehicleInfo_Model value);
  private:
  ::apollo::data::VehicleInfo_Model _internal_model() const;
  void _internal_set_model(::apollo::data::VehicleInfo_Model value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.data.VehicleInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::apollo::canbus::License* license_;
    ::apollo::canbus::CanbusConf* canbus_conf_;
    ::apollo::common::VehicleConfig* vehicle_config_;
    ::apollo::control::ControlConf* control_config_;
    int brand_;
    int model_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class EnvironmentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.EnvironmentInfo) */ {
 public:
  inline EnvironmentInfo() : EnvironmentInfo(nullptr) {}
  ~EnvironmentInfo() override;
  explicit PROTOBUF_CONSTEXPR EnvironmentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnvironmentInfo(const EnvironmentInfo& from);
  EnvironmentInfo(EnvironmentInfo&& from) noexcept
    : EnvironmentInfo() {
    *this = ::std::move(from);
  }

  inline EnvironmentInfo& operator=(const EnvironmentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvironmentInfo& operator=(EnvironmentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnvironmentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnvironmentInfo* internal_default_instance() {
    return reinterpret_cast<const EnvironmentInfo*>(
               &_EnvironmentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EnvironmentInfo& a, EnvironmentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvironmentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnvironmentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnvironmentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnvironmentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnvironmentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnvironmentInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnvironmentInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.EnvironmentInfo";
  }
  protected:
  explicit EnvironmentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapNameFieldNumber = 1,
    kTemperatureFieldNumber = 2,
  };
  // optional string map_name = 1;
  bool has_map_name() const;
  private:
  bool _internal_has_map_name() const;
  public:
  void clear_map_name();
  const std::string& map_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_name();
  PROTOBUF_NODISCARD std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // optional float temperature = 2;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.data.EnvironmentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
    float temperature_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class HardwareInfo_ConfigsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HardwareInfo_ConfigsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HardwareInfo_ConfigsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HardwareInfo_ConfigsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HardwareInfo_ConfigsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HardwareInfo_ConfigsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HardwareInfo_ConfigsEntry_DoNotUse& other);
  static const HardwareInfo_ConfigsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HardwareInfo_ConfigsEntry_DoNotUse*>(&_HardwareInfo_ConfigsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apollo.data.HardwareInfo.ConfigsEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apollo.data.HardwareInfo.ConfigsEntry.value");
#else
    (void) s;
#endif
    return true;
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};

// -------------------------------------------------------------------

class HardwareInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.HardwareInfo) */ {
 public:
  inline HardwareInfo() : HardwareInfo(nullptr) {}
  ~HardwareInfo() override;
  explicit PROTOBUF_CONSTEXPR HardwareInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HardwareInfo(const HardwareInfo& from);
  HardwareInfo(HardwareInfo&& from) noexcept
    : HardwareInfo() {
    *this = ::std::move(from);
  }

  inline HardwareInfo& operator=(const HardwareInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareInfo& operator=(HardwareInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HardwareInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HardwareInfo* internal_default_instance() {
    return reinterpret_cast<const HardwareInfo*>(
               &_HardwareInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HardwareInfo& a, HardwareInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(HardwareInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardwareInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HardwareInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HardwareInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HardwareInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HardwareInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HardwareInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.HardwareInfo";
  }
  protected:
  explicit HardwareInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigsFieldNumber = 1,
  };
  // map<string, string> configs = 1;
  int configs_size() const;
  private:
  int _internal_configs_size() const;
  public:
  void clear_configs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configs();

  // @@protoc_insertion_point(class_scope:apollo.data.HardwareInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HardwareInfo_ConfigsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> configs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class SoftwareInfo_ConfigsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SoftwareInfo_ConfigsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SoftwareInfo_ConfigsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SoftwareInfo_ConfigsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SoftwareInfo_ConfigsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SoftwareInfo_ConfigsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SoftwareInfo_ConfigsEntry_DoNotUse& other);
  static const SoftwareInfo_ConfigsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SoftwareInfo_ConfigsEntry_DoNotUse*>(&_SoftwareInfo_ConfigsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apollo.data.SoftwareInfo.ConfigsEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "apollo.data.SoftwareInfo.ConfigsEntry.value");
#else
    (void) s;
#endif
    return true;
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};

// -------------------------------------------------------------------

class SoftwareInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.SoftwareInfo) */ {
 public:
  inline SoftwareInfo() : SoftwareInfo(nullptr) {}
  ~SoftwareInfo() override;
  explicit PROTOBUF_CONSTEXPR SoftwareInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SoftwareInfo(const SoftwareInfo& from);
  SoftwareInfo(SoftwareInfo&& from) noexcept
    : SoftwareInfo() {
    *this = ::std::move(from);
  }

  inline SoftwareInfo& operator=(const SoftwareInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftwareInfo& operator=(SoftwareInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoftwareInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoftwareInfo* internal_default_instance() {
    return reinterpret_cast<const SoftwareInfo*>(
               &_SoftwareInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SoftwareInfo& a, SoftwareInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SoftwareInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftwareInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoftwareInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoftwareInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SoftwareInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SoftwareInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoftwareInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.SoftwareInfo";
  }
  protected:
  explicit SoftwareInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigsFieldNumber = 4,
    kDockerImageFieldNumber = 1,
    kCommitIdFieldNumber = 2,
    kModeFieldNumber = 3,
    kLatestRoutingRequestFieldNumber = 5,
  };
  // map<string, string> configs = 4;
  int configs_size() const;
  private:
  int _internal_configs_size() const;
  public:
  void clear_configs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configs();

  // optional string docker_image = 1;
  bool has_docker_image() const;
  private:
  bool _internal_has_docker_image() const;
  public:
  void clear_docker_image();
  const std::string& docker_image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_docker_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_docker_image();
  PROTOBUF_NODISCARD std::string* release_docker_image();
  void set_allocated_docker_image(std::string* docker_image);
  private:
  const std::string& _internal_docker_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_docker_image(const std::string& value);
  std::string* _internal_mutable_docker_image();
  public:

  // optional string commit_id = 2;
  bool has_commit_id() const;
  private:
  bool _internal_has_commit_id() const;
  public:
  void clear_commit_id();
  const std::string& commit_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_commit_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_commit_id();
  PROTOBUF_NODISCARD std::string* release_commit_id();
  void set_allocated_commit_id(std::string* commit_id);
  private:
  const std::string& _internal_commit_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commit_id(const std::string& value);
  std::string* _internal_mutable_commit_id();
  public:

  // optional string mode = 3;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  const std::string& mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mode();
  PROTOBUF_NODISCARD std::string* release_mode();
  void set_allocated_mode(std::string* mode);
  private:
  const std::string& _internal_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode(const std::string& value);
  std::string* _internal_mutable_mode();
  public:

  // optional .apollo.routing.RoutingRequest latest_routing_request = 5;
  bool has_latest_routing_request() const;
  private:
  bool _internal_has_latest_routing_request() const;
  public:
  void clear_latest_routing_request();
  const ::apollo::routing::RoutingRequest& latest_routing_request() const;
  PROTOBUF_NODISCARD ::apollo::routing::RoutingRequest* release_latest_routing_request();
  ::apollo::routing::RoutingRequest* mutable_latest_routing_request();
  void set_allocated_latest_routing_request(::apollo::routing::RoutingRequest* latest_routing_request);
  private:
  const ::apollo::routing::RoutingRequest& _internal_latest_routing_request() const;
  ::apollo::routing::RoutingRequest* _internal_mutable_latest_routing_request();
  public:
  void unsafe_arena_set_allocated_latest_routing_request(
      ::apollo::routing::RoutingRequest* latest_routing_request);
  ::apollo::routing::RoutingRequest* unsafe_arena_release_latest_routing_request();

  // @@protoc_insertion_point(class_scope:apollo.data.SoftwareInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SoftwareInfo_ConfigsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> configs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr docker_image_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commit_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
    ::apollo::routing::RoutingRequest* latest_routing_request_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit PROTOBUF_CONSTEXPR UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 1,
    kDriverFieldNumber = 2,
    kCoDriverFieldNumber = 3,
  };
  // optional string entity = 1;
  bool has_entity() const;
  private:
  bool _internal_has_entity() const;
  public:
  void clear_entity();
  const std::string& entity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entity();
  PROTOBUF_NODISCARD std::string* release_entity();
  void set_allocated_entity(std::string* entity);
  private:
  const std::string& _internal_entity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity(const std::string& value);
  std::string* _internal_mutable_entity();
  public:

  // optional string driver = 2;
  bool has_driver() const;
  private:
  bool _internal_has_driver() const;
  public:
  void clear_driver();
  const std::string& driver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver();
  PROTOBUF_NODISCARD std::string* release_driver();
  void set_allocated_driver(std::string* driver);
  private:
  const std::string& _internal_driver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver(const std::string& value);
  std::string* _internal_mutable_driver();
  public:

  // optional string co_driver = 3;
  bool has_co_driver() const;
  private:
  bool _internal_has_co_driver() const;
  public:
  void clear_co_driver();
  const std::string& co_driver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_co_driver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_co_driver();
  PROTOBUF_NODISCARD std::string* release_co_driver();
  void set_allocated_co_driver(std::string* co_driver);
  private:
  const std::string& _internal_co_driver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_co_driver(const std::string& value);
  std::string* _internal_mutable_co_driver();
  public:

  // @@protoc_insertion_point(class_scope:apollo.data.UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr co_driver_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class StaticInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.StaticInfo) */ {
 public:
  inline StaticInfo() : StaticInfo(nullptr) {}
  ~StaticInfo() override;
  explicit PROTOBUF_CONSTEXPR StaticInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaticInfo(const StaticInfo& from);
  StaticInfo(StaticInfo&& from) noexcept
    : StaticInfo() {
    *this = ::std::move(from);
  }

  inline StaticInfo& operator=(const StaticInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticInfo& operator=(StaticInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaticInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaticInfo* internal_default_instance() {
    return reinterpret_cast<const StaticInfo*>(
               &_StaticInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StaticInfo& a, StaticInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StaticInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaticInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaticInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaticInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaticInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StaticInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.StaticInfo";
  }
  protected:
  explicit StaticInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleFieldNumber = 1,
    kEnvironmentFieldNumber = 2,
    kHardwareFieldNumber = 3,
    kSoftwareFieldNumber = 4,
    kUserFieldNumber = 5,
  };
  // optional .apollo.data.VehicleInfo vehicle = 1;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::apollo::data::VehicleInfo& vehicle() const;
  PROTOBUF_NODISCARD ::apollo::data::VehicleInfo* release_vehicle();
  ::apollo::data::VehicleInfo* mutable_vehicle();
  void set_allocated_vehicle(::apollo::data::VehicleInfo* vehicle);
  private:
  const ::apollo::data::VehicleInfo& _internal_vehicle() const;
  ::apollo::data::VehicleInfo* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::apollo::data::VehicleInfo* vehicle);
  ::apollo::data::VehicleInfo* unsafe_arena_release_vehicle();

  // optional .apollo.data.EnvironmentInfo environment = 2;
  bool has_environment() const;
  private:
  bool _internal_has_environment() const;
  public:
  void clear_environment();
  const ::apollo::data::EnvironmentInfo& environment() const;
  PROTOBUF_NODISCARD ::apollo::data::EnvironmentInfo* release_environment();
  ::apollo::data::EnvironmentInfo* mutable_environment();
  void set_allocated_environment(::apollo::data::EnvironmentInfo* environment);
  private:
  const ::apollo::data::EnvironmentInfo& _internal_environment() const;
  ::apollo::data::EnvironmentInfo* _internal_mutable_environment();
  public:
  void unsafe_arena_set_allocated_environment(
      ::apollo::data::EnvironmentInfo* environment);
  ::apollo::data::EnvironmentInfo* unsafe_arena_release_environment();

  // optional .apollo.data.HardwareInfo hardware = 3;
  bool has_hardware() const;
  private:
  bool _internal_has_hardware() const;
  public:
  void clear_hardware();
  const ::apollo::data::HardwareInfo& hardware() const;
  PROTOBUF_NODISCARD ::apollo::data::HardwareInfo* release_hardware();
  ::apollo::data::HardwareInfo* mutable_hardware();
  void set_allocated_hardware(::apollo::data::HardwareInfo* hardware);
  private:
  const ::apollo::data::HardwareInfo& _internal_hardware() const;
  ::apollo::data::HardwareInfo* _internal_mutable_hardware();
  public:
  void unsafe_arena_set_allocated_hardware(
      ::apollo::data::HardwareInfo* hardware);
  ::apollo::data::HardwareInfo* unsafe_arena_release_hardware();

  // optional .apollo.data.SoftwareInfo software = 4;
  bool has_software() const;
  private:
  bool _internal_has_software() const;
  public:
  void clear_software();
  const ::apollo::data::SoftwareInfo& software() const;
  PROTOBUF_NODISCARD ::apollo::data::SoftwareInfo* release_software();
  ::apollo::data::SoftwareInfo* mutable_software();
  void set_allocated_software(::apollo::data::SoftwareInfo* software);
  private:
  const ::apollo::data::SoftwareInfo& _internal_software() const;
  ::apollo::data::SoftwareInfo* _internal_mutable_software();
  public:
  void unsafe_arena_set_allocated_software(
      ::apollo::data::SoftwareInfo* software);
  ::apollo::data::SoftwareInfo* unsafe_arena_release_software();

  // optional .apollo.data.UserInfo user = 5;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::apollo::data::UserInfo& user() const;
  PROTOBUF_NODISCARD ::apollo::data::UserInfo* release_user();
  ::apollo::data::UserInfo* mutable_user();
  void set_allocated_user(::apollo::data::UserInfo* user);
  private:
  const ::apollo::data::UserInfo& _internal_user() const;
  ::apollo::data::UserInfo* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::apollo::data::UserInfo* user);
  ::apollo::data::UserInfo* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:apollo.data.StaticInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::data::VehicleInfo* vehicle_;
    ::apollo::data::EnvironmentInfo* environment_;
    ::apollo::data::HardwareInfo* hardware_;
    ::apollo::data::SoftwareInfo* software_;
    ::apollo::data::UserInfo* user_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// -------------------------------------------------------------------

class StaticInfoConf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.data.StaticInfoConf) */ {
 public:
  inline StaticInfoConf() : StaticInfoConf(nullptr) {}
  ~StaticInfoConf() override;
  explicit PROTOBUF_CONSTEXPR StaticInfoConf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaticInfoConf(const StaticInfoConf& from);
  StaticInfoConf(StaticInfoConf&& from) noexcept
    : StaticInfoConf() {
    *this = ::std::move(from);
  }

  inline StaticInfoConf& operator=(const StaticInfoConf& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticInfoConf& operator=(StaticInfoConf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaticInfoConf& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaticInfoConf* internal_default_instance() {
    return reinterpret_cast<const StaticInfoConf*>(
               &_StaticInfoConf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StaticInfoConf& a, StaticInfoConf& b) {
    a.Swap(&b);
  }
  inline void Swap(StaticInfoConf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaticInfoConf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaticInfoConf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaticInfoConf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaticInfoConf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StaticInfoConf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticInfoConf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.data.StaticInfoConf";
  }
  protected:
  explicit StaticInfoConf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHardwareConfigsFieldNumber = 1,
    kSoftwareConfigsFieldNumber = 2,
  };
  // repeated string hardware_configs = 1;
  int hardware_configs_size() const;
  private:
  int _internal_hardware_configs_size() const;
  public:
  void clear_hardware_configs();
  const std::string& hardware_configs(int index) const;
  std::string* mutable_hardware_configs(int index);
  void set_hardware_configs(int index, const std::string& value);
  void set_hardware_configs(int index, std::string&& value);
  void set_hardware_configs(int index, const char* value);
  void set_hardware_configs(int index, const char* value, size_t size);
  std::string* add_hardware_configs();
  void add_hardware_configs(const std::string& value);
  void add_hardware_configs(std::string&& value);
  void add_hardware_configs(const char* value);
  void add_hardware_configs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hardware_configs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hardware_configs();
  private:
  const std::string& _internal_hardware_configs(int index) const;
  std::string* _internal_add_hardware_configs();
  public:

  // repeated string software_configs = 2;
  int software_configs_size() const;
  private:
  int _internal_software_configs_size() const;
  public:
  void clear_software_configs();
  const std::string& software_configs(int index) const;
  std::string* mutable_software_configs(int index);
  void set_software_configs(int index, const std::string& value);
  void set_software_configs(int index, std::string&& value);
  void set_software_configs(int index, const char* value);
  void set_software_configs(int index, const char* value, size_t size);
  std::string* add_software_configs();
  void add_software_configs(const std::string& value);
  void add_software_configs(std::string&& value);
  void add_software_configs(const char* value);
  void add_software_configs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& software_configs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_software_configs();
  private:
  const std::string& _internal_software_configs(int index) const;
  std::string* _internal_add_software_configs();
  public:

  // @@protoc_insertion_point(class_scope:apollo.data.StaticInfoConf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hardware_configs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> software_configs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fdata_2fproto_2fstatic_5finfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VehicleInfo

// optional string name = 1;
inline bool VehicleInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VehicleInfo::has_name() const {
  return _internal_has_name();
}
inline void VehicleInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleInfo::name() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehicleInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.data.VehicleInfo.name)
}
inline std::string* VehicleInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:apollo.data.VehicleInfo.name)
  return _s;
}
inline const std::string& VehicleInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void VehicleInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* VehicleInfo::release_name() {
  // @@protoc_insertion_point(field_release:apollo.data.VehicleInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VehicleInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.data.VehicleInfo.name)
}

// optional .apollo.data.VehicleInfo.Brand brand = 2;
inline bool VehicleInfo::_internal_has_brand() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool VehicleInfo::has_brand() const {
  return _internal_has_brand();
}
inline void VehicleInfo::clear_brand() {
  _impl_.brand_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::apollo::data::VehicleInfo_Brand VehicleInfo::_internal_brand() const {
  return static_cast< ::apollo::data::VehicleInfo_Brand >(_impl_.brand_);
}
inline ::apollo::data::VehicleInfo_Brand VehicleInfo::brand() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.brand)
  return _internal_brand();
}
inline void VehicleInfo::_internal_set_brand(::apollo::data::VehicleInfo_Brand value) {
  assert(::apollo::data::VehicleInfo_Brand_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.brand_ = value;
}
inline void VehicleInfo::set_brand(::apollo::data::VehicleInfo_Brand value) {
  _internal_set_brand(value);
  // @@protoc_insertion_point(field_set:apollo.data.VehicleInfo.brand)
}

// optional .apollo.data.VehicleInfo.Model model = 3;
inline bool VehicleInfo::_internal_has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool VehicleInfo::has_model() const {
  return _internal_has_model();
}
inline void VehicleInfo::clear_model() {
  _impl_.model_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::apollo::data::VehicleInfo_Model VehicleInfo::_internal_model() const {
  return static_cast< ::apollo::data::VehicleInfo_Model >(_impl_.model_);
}
inline ::apollo::data::VehicleInfo_Model VehicleInfo::model() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.model)
  return _internal_model();
}
inline void VehicleInfo::_internal_set_model(::apollo::data::VehicleInfo_Model value) {
  assert(::apollo::data::VehicleInfo_Model_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.model_ = value;
}
inline void VehicleInfo::set_model(::apollo::data::VehicleInfo_Model value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:apollo.data.VehicleInfo.model)
}

// optional .apollo.canbus.License license = 4;
inline bool VehicleInfo::_internal_has_license() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.license_ != nullptr);
  return value;
}
inline bool VehicleInfo::has_license() const {
  return _internal_has_license();
}
inline const ::apollo::canbus::License& VehicleInfo::_internal_license() const {
  const ::apollo::canbus::License* p = _impl_.license_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::canbus::License&>(
      ::apollo::canbus::_License_default_instance_);
}
inline const ::apollo::canbus::License& VehicleInfo::license() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.license)
  return _internal_license();
}
inline void VehicleInfo::unsafe_arena_set_allocated_license(
    ::apollo::canbus::License* license) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.license_);
  }
  _impl_.license_ = license;
  if (license) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.data.VehicleInfo.license)
}
inline ::apollo::canbus::License* VehicleInfo::release_license() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::canbus::License* temp = _impl_.license_;
  _impl_.license_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::canbus::License* VehicleInfo::unsafe_arena_release_license() {
  // @@protoc_insertion_point(field_release:apollo.data.VehicleInfo.license)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::canbus::License* temp = _impl_.license_;
  _impl_.license_ = nullptr;
  return temp;
}
inline ::apollo::canbus::License* VehicleInfo::_internal_mutable_license() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.license_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::License>(GetArenaForAllocation());
    _impl_.license_ = p;
  }
  return _impl_.license_;
}
inline ::apollo::canbus::License* VehicleInfo::mutable_license() {
  ::apollo::canbus::License* _msg = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:apollo.data.VehicleInfo.license)
  return _msg;
}
inline void VehicleInfo::set_allocated_license(::apollo::canbus::License* license) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.license_);
  }
  if (license) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(license));
    if (message_arena != submessage_arena) {
      license = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, license, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.license_ = license;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.VehicleInfo.license)
}

// optional .apollo.canbus.CanbusConf canbus_conf = 5;
inline bool VehicleInfo::_internal_has_canbus_conf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.canbus_conf_ != nullptr);
  return value;
}
inline bool VehicleInfo::has_canbus_conf() const {
  return _internal_has_canbus_conf();
}
inline const ::apollo::canbus::CanbusConf& VehicleInfo::_internal_canbus_conf() const {
  const ::apollo::canbus::CanbusConf* p = _impl_.canbus_conf_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::canbus::CanbusConf&>(
      ::apollo::canbus::_CanbusConf_default_instance_);
}
inline const ::apollo::canbus::CanbusConf& VehicleInfo::canbus_conf() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.canbus_conf)
  return _internal_canbus_conf();
}
inline void VehicleInfo::unsafe_arena_set_allocated_canbus_conf(
    ::apollo::canbus::CanbusConf* canbus_conf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.canbus_conf_);
  }
  _impl_.canbus_conf_ = canbus_conf;
  if (canbus_conf) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.data.VehicleInfo.canbus_conf)
}
inline ::apollo::canbus::CanbusConf* VehicleInfo::release_canbus_conf() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::canbus::CanbusConf* temp = _impl_.canbus_conf_;
  _impl_.canbus_conf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::canbus::CanbusConf* VehicleInfo::unsafe_arena_release_canbus_conf() {
  // @@protoc_insertion_point(field_release:apollo.data.VehicleInfo.canbus_conf)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::canbus::CanbusConf* temp = _impl_.canbus_conf_;
  _impl_.canbus_conf_ = nullptr;
  return temp;
}
inline ::apollo::canbus::CanbusConf* VehicleInfo::_internal_mutable_canbus_conf() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.canbus_conf_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::canbus::CanbusConf>(GetArenaForAllocation());
    _impl_.canbus_conf_ = p;
  }
  return _impl_.canbus_conf_;
}
inline ::apollo::canbus::CanbusConf* VehicleInfo::mutable_canbus_conf() {
  ::apollo::canbus::CanbusConf* _msg = _internal_mutable_canbus_conf();
  // @@protoc_insertion_point(field_mutable:apollo.data.VehicleInfo.canbus_conf)
  return _msg;
}
inline void VehicleInfo::set_allocated_canbus_conf(::apollo::canbus::CanbusConf* canbus_conf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.canbus_conf_);
  }
  if (canbus_conf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(canbus_conf));
    if (message_arena != submessage_arena) {
      canbus_conf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, canbus_conf, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.canbus_conf_ = canbus_conf;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.VehicleInfo.canbus_conf)
}

// optional .apollo.common.VehicleConfig vehicle_config = 6;
inline bool VehicleInfo::_internal_has_vehicle_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_config_ != nullptr);
  return value;
}
inline bool VehicleInfo::has_vehicle_config() const {
  return _internal_has_vehicle_config();
}
inline const ::apollo::common::VehicleConfig& VehicleInfo::_internal_vehicle_config() const {
  const ::apollo::common::VehicleConfig* p = _impl_.vehicle_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::common::VehicleConfig&>(
      ::apollo::common::_VehicleConfig_default_instance_);
}
inline const ::apollo::common::VehicleConfig& VehicleInfo::vehicle_config() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.vehicle_config)
  return _internal_vehicle_config();
}
inline void VehicleInfo::unsafe_arena_set_allocated_vehicle_config(
    ::apollo::common::VehicleConfig* vehicle_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_config_);
  }
  _impl_.vehicle_config_ = vehicle_config;
  if (vehicle_config) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.data.VehicleInfo.vehicle_config)
}
inline ::apollo::common::VehicleConfig* VehicleInfo::release_vehicle_config() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::common::VehicleConfig* temp = _impl_.vehicle_config_;
  _impl_.vehicle_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::common::VehicleConfig* VehicleInfo::unsafe_arena_release_vehicle_config() {
  // @@protoc_insertion_point(field_release:apollo.data.VehicleInfo.vehicle_config)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::common::VehicleConfig* temp = _impl_.vehicle_config_;
  _impl_.vehicle_config_ = nullptr;
  return temp;
}
inline ::apollo::common::VehicleConfig* VehicleInfo::_internal_mutable_vehicle_config() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.vehicle_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::common::VehicleConfig>(GetArenaForAllocation());
    _impl_.vehicle_config_ = p;
  }
  return _impl_.vehicle_config_;
}
inline ::apollo::common::VehicleConfig* VehicleInfo::mutable_vehicle_config() {
  ::apollo::common::VehicleConfig* _msg = _internal_mutable_vehicle_config();
  // @@protoc_insertion_point(field_mutable:apollo.data.VehicleInfo.vehicle_config)
  return _msg;
}
inline void VehicleInfo::set_allocated_vehicle_config(::apollo::common::VehicleConfig* vehicle_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_config_);
  }
  if (vehicle_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_config));
    if (message_arena != submessage_arena) {
      vehicle_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.vehicle_config_ = vehicle_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.VehicleInfo.vehicle_config)
}

// optional .apollo.control.ControlConf control_config = 7;
inline bool VehicleInfo::_internal_has_control_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.control_config_ != nullptr);
  return value;
}
inline bool VehicleInfo::has_control_config() const {
  return _internal_has_control_config();
}
inline const ::apollo::control::ControlConf& VehicleInfo::_internal_control_config() const {
  const ::apollo::control::ControlConf* p = _impl_.control_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::control::ControlConf&>(
      ::apollo::control::_ControlConf_default_instance_);
}
inline const ::apollo::control::ControlConf& VehicleInfo::control_config() const {
  // @@protoc_insertion_point(field_get:apollo.data.VehicleInfo.control_config)
  return _internal_control_config();
}
inline void VehicleInfo::unsafe_arena_set_allocated_control_config(
    ::apollo::control::ControlConf* control_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_config_);
  }
  _impl_.control_config_ = control_config;
  if (control_config) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.data.VehicleInfo.control_config)
}
inline ::apollo::control::ControlConf* VehicleInfo::release_control_config() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::control::ControlConf* temp = _impl_.control_config_;
  _impl_.control_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::control::ControlConf* VehicleInfo::unsafe_arena_release_control_config() {
  // @@protoc_insertion_point(field_release:apollo.data.VehicleInfo.control_config)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::control::ControlConf* temp = _impl_.control_config_;
  _impl_.control_config_ = nullptr;
  return temp;
}
inline ::apollo::control::ControlConf* VehicleInfo::_internal_mutable_control_config() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.control_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::control::ControlConf>(GetArenaForAllocation());
    _impl_.control_config_ = p;
  }
  return _impl_.control_config_;
}
inline ::apollo::control::ControlConf* VehicleInfo::mutable_control_config() {
  ::apollo::control::ControlConf* _msg = _internal_mutable_control_config();
  // @@protoc_insertion_point(field_mutable:apollo.data.VehicleInfo.control_config)
  return _msg;
}
inline void VehicleInfo::set_allocated_control_config(::apollo::control::ControlConf* control_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_config_);
  }
  if (control_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control_config));
    if (message_arena != submessage_arena) {
      control_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control_config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.control_config_ = control_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.VehicleInfo.control_config)
}

// -------------------------------------------------------------------

// EnvironmentInfo

// optional string map_name = 1;
inline bool EnvironmentInfo::_internal_has_map_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EnvironmentInfo::has_map_name() const {
  return _internal_has_map_name();
}
inline void EnvironmentInfo::clear_map_name() {
  _impl_.map_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EnvironmentInfo::map_name() const {
  // @@protoc_insertion_point(field_get:apollo.data.EnvironmentInfo.map_name)
  return _internal_map_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnvironmentInfo::set_map_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.map_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.data.EnvironmentInfo.map_name)
}
inline std::string* EnvironmentInfo::mutable_map_name() {
  std::string* _s = _internal_mutable_map_name();
  // @@protoc_insertion_point(field_mutable:apollo.data.EnvironmentInfo.map_name)
  return _s;
}
inline const std::string& EnvironmentInfo::_internal_map_name() const {
  return _impl_.map_name_.Get();
}
inline void EnvironmentInfo::_internal_set_map_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_name_.Set(value, GetArenaForAllocation());
}
inline std::string* EnvironmentInfo::_internal_mutable_map_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.map_name_.Mutable(GetArenaForAllocation());
}
inline std::string* EnvironmentInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:apollo.data.EnvironmentInfo.map_name)
  if (!_internal_has_map_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.map_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_name_.IsDefault()) {
    _impl_.map_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EnvironmentInfo::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.map_name_.SetAllocated(map_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_name_.IsDefault()) {
    _impl_.map_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.data.EnvironmentInfo.map_name)
}

// optional float temperature = 2;
inline bool EnvironmentInfo::_internal_has_temperature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EnvironmentInfo::has_temperature() const {
  return _internal_has_temperature();
}
inline void EnvironmentInfo::clear_temperature() {
  _impl_.temperature_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float EnvironmentInfo::_internal_temperature() const {
  return _impl_.temperature_;
}
inline float EnvironmentInfo::temperature() const {
  // @@protoc_insertion_point(field_get:apollo.data.EnvironmentInfo.temperature)
  return _internal_temperature();
}
inline void EnvironmentInfo::_internal_set_temperature(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.temperature_ = value;
}
inline void EnvironmentInfo::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:apollo.data.EnvironmentInfo.temperature)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HardwareInfo

// map<string, string> configs = 1;
inline int HardwareInfo::_internal_configs_size() const {
  return _impl_.configs_.size();
}
inline int HardwareInfo::configs_size() const {
  return _internal_configs_size();
}
inline void HardwareInfo::clear_configs() {
  _impl_.configs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HardwareInfo::_internal_configs() const {
  return _impl_.configs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HardwareInfo::configs() const {
  // @@protoc_insertion_point(field_map:apollo.data.HardwareInfo.configs)
  return _internal_configs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HardwareInfo::_internal_mutable_configs() {
  return _impl_.configs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HardwareInfo::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:apollo.data.HardwareInfo.configs)
  return _internal_mutable_configs();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SoftwareInfo

// optional string docker_image = 1;
inline bool SoftwareInfo::_internal_has_docker_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SoftwareInfo::has_docker_image() const {
  return _internal_has_docker_image();
}
inline void SoftwareInfo::clear_docker_image() {
  _impl_.docker_image_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SoftwareInfo::docker_image() const {
  // @@protoc_insertion_point(field_get:apollo.data.SoftwareInfo.docker_image)
  return _internal_docker_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SoftwareInfo::set_docker_image(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.docker_image_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.data.SoftwareInfo.docker_image)
}
inline std::string* SoftwareInfo::mutable_docker_image() {
  std::string* _s = _internal_mutable_docker_image();
  // @@protoc_insertion_point(field_mutable:apollo.data.SoftwareInfo.docker_image)
  return _s;
}
inline const std::string& SoftwareInfo::_internal_docker_image() const {
  return _impl_.docker_image_.Get();
}
inline void SoftwareInfo::_internal_set_docker_image(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.docker_image_.Set(value, GetArenaForAllocation());
}
inline std::string* SoftwareInfo::_internal_mutable_docker_image() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.docker_image_.Mutable(GetArenaForAllocation());
}
inline std::string* SoftwareInfo::release_docker_image() {
  // @@protoc_insertion_point(field_release:apollo.data.SoftwareInfo.docker_image)
  if (!_internal_has_docker_image()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.docker_image_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docker_image_.IsDefault()) {
    _impl_.docker_image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SoftwareInfo::set_allocated_docker_image(std::string* docker_image) {
  if (docker_image != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.docker_image_.SetAllocated(docker_image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docker_image_.IsDefault()) {
    _impl_.docker_image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.data.SoftwareInfo.docker_image)
}

// optional string commit_id = 2;
inline bool SoftwareInfo::_internal_has_commit_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SoftwareInfo::has_commit_id() const {
  return _internal_has_commit_id();
}
inline void SoftwareInfo::clear_commit_id() {
  _impl_.commit_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SoftwareInfo::commit_id() const {
  // @@protoc_insertion_point(field_get:apollo.data.SoftwareInfo.commit_id)
  return _internal_commit_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SoftwareInfo::set_commit_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.commit_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.data.SoftwareInfo.commit_id)
}
inline std::string* SoftwareInfo::mutable_commit_id() {
  std::string* _s = _internal_mutable_commit_id();
  // @@protoc_insertion_point(field_mutable:apollo.data.SoftwareInfo.commit_id)
  return _s;
}
inline const std::string& SoftwareInfo::_internal_commit_id() const {
  return _impl_.commit_id_.Get();
}
inline void SoftwareInfo::_internal_set_commit_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.commit_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SoftwareInfo::_internal_mutable_commit_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.commit_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SoftwareInfo::release_commit_id() {
  // @@protoc_insertion_point(field_release:apollo.data.SoftwareInfo.commit_id)
  if (!_internal_has_commit_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.commit_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.commit_id_.IsDefault()) {
    _impl_.commit_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SoftwareInfo::set_allocated_commit_id(std::string* commit_id) {
  if (commit_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.commit_id_.SetAllocated(commit_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.commit_id_.IsDefault()) {
    _impl_.commit_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.data.SoftwareInfo.commit_id)
}

// optional string mode = 3;
inline bool SoftwareInfo::_internal_has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SoftwareInfo::has_mode() const {
  return _internal_has_mode();
}
inline void SoftwareInfo::clear_mode() {
  _impl_.mode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SoftwareInfo::mode() const {
  // @@protoc_insertion_point(field_get:apollo.data.SoftwareInfo.mode)
  return _internal_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SoftwareInfo::set_mode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.data.SoftwareInfo.mode)
}
inline std::string* SoftwareInfo::mutable_mode() {
  std::string* _s = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:apollo.data.SoftwareInfo.mode)
  return _s;
}
inline const std::string& SoftwareInfo::_internal_mode() const {
  return _impl_.mode_.Get();
}
inline void SoftwareInfo::_internal_set_mode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mode_.Set(value, GetArenaForAllocation());
}
inline std::string* SoftwareInfo::_internal_mutable_mode() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.mode_.Mutable(GetArenaForAllocation());
}
inline std::string* SoftwareInfo::release_mode() {
  // @@protoc_insertion_point(field_release:apollo.data.SoftwareInfo.mode)
  if (!_internal_has_mode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.mode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mode_.IsDefault()) {
    _impl_.mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SoftwareInfo::set_allocated_mode(std::string* mode) {
  if (mode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.mode_.SetAllocated(mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mode_.IsDefault()) {
    _impl_.mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.data.SoftwareInfo.mode)
}

// map<string, string> configs = 4;
inline int SoftwareInfo::_internal_configs_size() const {
  return _impl_.configs_.size();
}
inline int SoftwareInfo::configs_size() const {
  return _internal_configs_size();
}
inline void SoftwareInfo::clear_configs() {
  _impl_.configs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SoftwareInfo::_internal_configs() const {
  return _impl_.configs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SoftwareInfo::configs() const {
  // @@protoc_insertion_point(field_map:apollo.data.SoftwareInfo.configs)
  return _internal_configs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SoftwareInfo::_internal_mutable_configs() {
  return _impl_.configs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SoftwareInfo::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:apollo.data.SoftwareInfo.configs)
  return _internal_mutable_configs();
}

// optional .apollo.routing.RoutingRequest latest_routing_request = 5;
inline bool SoftwareInfo::_internal_has_latest_routing_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latest_routing_request_ != nullptr);
  return value;
}
inline bool SoftwareInfo::has_latest_routing_request() const {
  return _internal_has_latest_routing_request();
}
inline const ::apollo::routing::RoutingRequest& SoftwareInfo::_internal_latest_routing_request() const {
  const ::apollo::routing::RoutingRequest* p = _impl_.latest_routing_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::routing::RoutingRequest&>(
      ::apollo::routing::_RoutingRequest_default_instance_);
}
inline const ::apollo::routing::RoutingRequest& SoftwareInfo::latest_routing_request() const {
  // @@protoc_insertion_point(field_get:apollo.data.SoftwareInfo.latest_routing_request)
  return _internal_latest_routing_request();
}
inline void SoftwareInfo::unsafe_arena_set_allocated_latest_routing_request(
    ::apollo::routing::RoutingRequest* latest_routing_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_routing_request_);
  }
  _impl_.latest_routing_request_ = latest_routing_request;
  if (latest_routing_request) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.data.SoftwareInfo.latest_routing_request)
}
inline ::apollo::routing::RoutingRequest* SoftwareInfo::release_latest_routing_request() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::routing::RoutingRequest* temp = _impl_.latest_routing_request_;
  _impl_.latest_routing_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::routing::RoutingRequest* SoftwareInfo::unsafe_arena_release_latest_routing_request() {
  // @@protoc_insertion_point(field_release:apollo.data.SoftwareInfo.latest_routing_request)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::routing::RoutingRequest* temp = _impl_.latest_routing_request_;
  _impl_.latest_routing_request_ = nullptr;
  return temp;
}
inline ::apollo::routing::RoutingRequest* SoftwareInfo::_internal_mutable_latest_routing_request() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.latest_routing_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::routing::RoutingRequest>(GetArenaForAllocation());
    _impl_.latest_routing_request_ = p;
  }
  return _impl_.latest_routing_request_;
}
inline ::apollo::routing::RoutingRequest* SoftwareInfo::mutable_latest_routing_request() {
  ::apollo::routing::RoutingRequest* _msg = _internal_mutable_latest_routing_request();
  // @@protoc_insertion_point(field_mutable:apollo.data.SoftwareInfo.latest_routing_request)
  return _msg;
}
inline void SoftwareInfo::set_allocated_latest_routing_request(::apollo::routing::RoutingRequest* latest_routing_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_routing_request_);
  }
  if (latest_routing_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latest_routing_request));
    if (message_arena != submessage_arena) {
      latest_routing_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latest_routing_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.latest_routing_request_ = latest_routing_request;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.SoftwareInfo.latest_routing_request)
}

// -------------------------------------------------------------------

// UserInfo

// optional string entity = 1;
inline bool UserInfo::_internal_has_entity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserInfo::has_entity() const {
  return _internal_has_entity();
}
inline void UserInfo::clear_entity() {
  _impl_.entity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserInfo::entity() const {
  // @@protoc_insertion_point(field_get:apollo.data.UserInfo.entity)
  return _internal_entity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_entity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.entity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.data.UserInfo.entity)
}
inline std::string* UserInfo::mutable_entity() {
  std::string* _s = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:apollo.data.UserInfo.entity)
  return _s;
}
inline const std::string& UserInfo::_internal_entity() const {
  return _impl_.entity_.Get();
}
inline void UserInfo::_internal_set_entity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.entity_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_entity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.entity_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_entity() {
  // @@protoc_insertion_point(field_release:apollo.data.UserInfo.entity)
  if (!_internal_has_entity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.entity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entity_.IsDefault()) {
    _impl_.entity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_entity(std::string* entity) {
  if (entity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.entity_.SetAllocated(entity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entity_.IsDefault()) {
    _impl_.entity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.data.UserInfo.entity)
}

// optional string driver = 2;
inline bool UserInfo::_internal_has_driver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserInfo::has_driver() const {
  return _internal_has_driver();
}
inline void UserInfo::clear_driver() {
  _impl_.driver_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserInfo::driver() const {
  // @@protoc_insertion_point(field_get:apollo.data.UserInfo.driver)
  return _internal_driver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_driver(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.driver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.data.UserInfo.driver)
}
inline std::string* UserInfo::mutable_driver() {
  std::string* _s = _internal_mutable_driver();
  // @@protoc_insertion_point(field_mutable:apollo.data.UserInfo.driver)
  return _s;
}
inline const std::string& UserInfo::_internal_driver() const {
  return _impl_.driver_.Get();
}
inline void UserInfo::_internal_set_driver(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.driver_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_driver() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.driver_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_driver() {
  // @@protoc_insertion_point(field_release:apollo.data.UserInfo.driver)
  if (!_internal_has_driver()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.driver_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_.IsDefault()) {
    _impl_.driver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_driver(std::string* driver) {
  if (driver != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.driver_.SetAllocated(driver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_.IsDefault()) {
    _impl_.driver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.data.UserInfo.driver)
}

// optional string co_driver = 3;
inline bool UserInfo::_internal_has_co_driver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserInfo::has_co_driver() const {
  return _internal_has_co_driver();
}
inline void UserInfo::clear_co_driver() {
  _impl_.co_driver_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserInfo::co_driver() const {
  // @@protoc_insertion_point(field_get:apollo.data.UserInfo.co_driver)
  return _internal_co_driver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_co_driver(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.co_driver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.data.UserInfo.co_driver)
}
inline std::string* UserInfo::mutable_co_driver() {
  std::string* _s = _internal_mutable_co_driver();
  // @@protoc_insertion_point(field_mutable:apollo.data.UserInfo.co_driver)
  return _s;
}
inline const std::string& UserInfo::_internal_co_driver() const {
  return _impl_.co_driver_.Get();
}
inline void UserInfo::_internal_set_co_driver(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.co_driver_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_co_driver() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.co_driver_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_co_driver() {
  // @@protoc_insertion_point(field_release:apollo.data.UserInfo.co_driver)
  if (!_internal_has_co_driver()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.co_driver_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.co_driver_.IsDefault()) {
    _impl_.co_driver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_co_driver(std::string* co_driver) {
  if (co_driver != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.co_driver_.SetAllocated(co_driver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.co_driver_.IsDefault()) {
    _impl_.co_driver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.data.UserInfo.co_driver)
}

// -------------------------------------------------------------------

// StaticInfo

// optional .apollo.data.VehicleInfo vehicle = 1;
inline bool StaticInfo::_internal_has_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_ != nullptr);
  return value;
}
inline bool StaticInfo::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void StaticInfo::clear_vehicle() {
  if (_impl_.vehicle_ != nullptr) _impl_.vehicle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::data::VehicleInfo& StaticInfo::_internal_vehicle() const {
  const ::apollo::data::VehicleInfo* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::data::VehicleInfo&>(
      ::apollo::data::_VehicleInfo_default_instance_);
}
inline const ::apollo::data::VehicleInfo& StaticInfo::vehicle() const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfo.vehicle)
  return _internal_vehicle();
}
inline void StaticInfo::unsafe_arena_set_allocated_vehicle(
    ::apollo::data::VehicleInfo* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.data.StaticInfo.vehicle)
}
inline ::apollo::data::VehicleInfo* StaticInfo::release_vehicle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::data::VehicleInfo* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::data::VehicleInfo* StaticInfo::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:apollo.data.StaticInfo.vehicle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::data::VehicleInfo* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::apollo::data::VehicleInfo* StaticInfo::_internal_mutable_vehicle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::data::VehicleInfo>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::apollo::data::VehicleInfo* StaticInfo::mutable_vehicle() {
  ::apollo::data::VehicleInfo* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfo.vehicle)
  return _msg;
}
inline void StaticInfo::set_allocated_vehicle(::apollo::data::VehicleInfo* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.StaticInfo.vehicle)
}

// optional .apollo.data.EnvironmentInfo environment = 2;
inline bool StaticInfo::_internal_has_environment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.environment_ != nullptr);
  return value;
}
inline bool StaticInfo::has_environment() const {
  return _internal_has_environment();
}
inline void StaticInfo::clear_environment() {
  if (_impl_.environment_ != nullptr) _impl_.environment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::data::EnvironmentInfo& StaticInfo::_internal_environment() const {
  const ::apollo::data::EnvironmentInfo* p = _impl_.environment_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::data::EnvironmentInfo&>(
      ::apollo::data::_EnvironmentInfo_default_instance_);
}
inline const ::apollo::data::EnvironmentInfo& StaticInfo::environment() const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfo.environment)
  return _internal_environment();
}
inline void StaticInfo::unsafe_arena_set_allocated_environment(
    ::apollo::data::EnvironmentInfo* environment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.environment_);
  }
  _impl_.environment_ = environment;
  if (environment) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.data.StaticInfo.environment)
}
inline ::apollo::data::EnvironmentInfo* StaticInfo::release_environment() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::data::EnvironmentInfo* temp = _impl_.environment_;
  _impl_.environment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::data::EnvironmentInfo* StaticInfo::unsafe_arena_release_environment() {
  // @@protoc_insertion_point(field_release:apollo.data.StaticInfo.environment)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::data::EnvironmentInfo* temp = _impl_.environment_;
  _impl_.environment_ = nullptr;
  return temp;
}
inline ::apollo::data::EnvironmentInfo* StaticInfo::_internal_mutable_environment() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.environment_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::data::EnvironmentInfo>(GetArenaForAllocation());
    _impl_.environment_ = p;
  }
  return _impl_.environment_;
}
inline ::apollo::data::EnvironmentInfo* StaticInfo::mutable_environment() {
  ::apollo::data::EnvironmentInfo* _msg = _internal_mutable_environment();
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfo.environment)
  return _msg;
}
inline void StaticInfo::set_allocated_environment(::apollo::data::EnvironmentInfo* environment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.environment_;
  }
  if (environment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(environment);
    if (message_arena != submessage_arena) {
      environment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, environment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.environment_ = environment;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.StaticInfo.environment)
}

// optional .apollo.data.HardwareInfo hardware = 3;
inline bool StaticInfo::_internal_has_hardware() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hardware_ != nullptr);
  return value;
}
inline bool StaticInfo::has_hardware() const {
  return _internal_has_hardware();
}
inline void StaticInfo::clear_hardware() {
  if (_impl_.hardware_ != nullptr) _impl_.hardware_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::data::HardwareInfo& StaticInfo::_internal_hardware() const {
  const ::apollo::data::HardwareInfo* p = _impl_.hardware_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::data::HardwareInfo&>(
      ::apollo::data::_HardwareInfo_default_instance_);
}
inline const ::apollo::data::HardwareInfo& StaticInfo::hardware() const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfo.hardware)
  return _internal_hardware();
}
inline void StaticInfo::unsafe_arena_set_allocated_hardware(
    ::apollo::data::HardwareInfo* hardware) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hardware_);
  }
  _impl_.hardware_ = hardware;
  if (hardware) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.data.StaticInfo.hardware)
}
inline ::apollo::data::HardwareInfo* StaticInfo::release_hardware() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::data::HardwareInfo* temp = _impl_.hardware_;
  _impl_.hardware_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::data::HardwareInfo* StaticInfo::unsafe_arena_release_hardware() {
  // @@protoc_insertion_point(field_release:apollo.data.StaticInfo.hardware)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::apollo::data::HardwareInfo* temp = _impl_.hardware_;
  _impl_.hardware_ = nullptr;
  return temp;
}
inline ::apollo::data::HardwareInfo* StaticInfo::_internal_mutable_hardware() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.hardware_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::data::HardwareInfo>(GetArenaForAllocation());
    _impl_.hardware_ = p;
  }
  return _impl_.hardware_;
}
inline ::apollo::data::HardwareInfo* StaticInfo::mutable_hardware() {
  ::apollo::data::HardwareInfo* _msg = _internal_mutable_hardware();
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfo.hardware)
  return _msg;
}
inline void StaticInfo::set_allocated_hardware(::apollo::data::HardwareInfo* hardware) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hardware_;
  }
  if (hardware) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hardware);
    if (message_arena != submessage_arena) {
      hardware = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hardware, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.hardware_ = hardware;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.StaticInfo.hardware)
}

// optional .apollo.data.SoftwareInfo software = 4;
inline bool StaticInfo::_internal_has_software() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.software_ != nullptr);
  return value;
}
inline bool StaticInfo::has_software() const {
  return _internal_has_software();
}
inline void StaticInfo::clear_software() {
  if (_impl_.software_ != nullptr) _impl_.software_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::data::SoftwareInfo& StaticInfo::_internal_software() const {
  const ::apollo::data::SoftwareInfo* p = _impl_.software_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::data::SoftwareInfo&>(
      ::apollo::data::_SoftwareInfo_default_instance_);
}
inline const ::apollo::data::SoftwareInfo& StaticInfo::software() const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfo.software)
  return _internal_software();
}
inline void StaticInfo::unsafe_arena_set_allocated_software(
    ::apollo::data::SoftwareInfo* software) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.software_);
  }
  _impl_.software_ = software;
  if (software) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.data.StaticInfo.software)
}
inline ::apollo::data::SoftwareInfo* StaticInfo::release_software() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::data::SoftwareInfo* temp = _impl_.software_;
  _impl_.software_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::data::SoftwareInfo* StaticInfo::unsafe_arena_release_software() {
  // @@protoc_insertion_point(field_release:apollo.data.StaticInfo.software)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::apollo::data::SoftwareInfo* temp = _impl_.software_;
  _impl_.software_ = nullptr;
  return temp;
}
inline ::apollo::data::SoftwareInfo* StaticInfo::_internal_mutable_software() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.software_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::data::SoftwareInfo>(GetArenaForAllocation());
    _impl_.software_ = p;
  }
  return _impl_.software_;
}
inline ::apollo::data::SoftwareInfo* StaticInfo::mutable_software() {
  ::apollo::data::SoftwareInfo* _msg = _internal_mutable_software();
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfo.software)
  return _msg;
}
inline void StaticInfo::set_allocated_software(::apollo::data::SoftwareInfo* software) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.software_;
  }
  if (software) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(software);
    if (message_arena != submessage_arena) {
      software = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, software, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.software_ = software;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.StaticInfo.software)
}

// optional .apollo.data.UserInfo user = 5;
inline bool StaticInfo::_internal_has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline bool StaticInfo::has_user() const {
  return _internal_has_user();
}
inline void StaticInfo::clear_user() {
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::data::UserInfo& StaticInfo::_internal_user() const {
  const ::apollo::data::UserInfo* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::data::UserInfo&>(
      ::apollo::data::_UserInfo_default_instance_);
}
inline const ::apollo::data::UserInfo& StaticInfo::user() const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfo.user)
  return _internal_user();
}
inline void StaticInfo::unsafe_arena_set_allocated_user(
    ::apollo::data::UserInfo* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.data.StaticInfo.user)
}
inline ::apollo::data::UserInfo* StaticInfo::release_user() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::data::UserInfo* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::data::UserInfo* StaticInfo::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:apollo.data.StaticInfo.user)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::apollo::data::UserInfo* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::apollo::data::UserInfo* StaticInfo::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::data::UserInfo>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::apollo::data::UserInfo* StaticInfo::mutable_user() {
  ::apollo::data::UserInfo* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfo.user)
  return _msg;
}
inline void StaticInfo::set_allocated_user(::apollo::data::UserInfo* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:apollo.data.StaticInfo.user)
}

// -------------------------------------------------------------------

// StaticInfoConf

// repeated string hardware_configs = 1;
inline int StaticInfoConf::_internal_hardware_configs_size() const {
  return _impl_.hardware_configs_.size();
}
inline int StaticInfoConf::hardware_configs_size() const {
  return _internal_hardware_configs_size();
}
inline void StaticInfoConf::clear_hardware_configs() {
  _impl_.hardware_configs_.Clear();
}
inline std::string* StaticInfoConf::add_hardware_configs() {
  std::string* _s = _internal_add_hardware_configs();
  // @@protoc_insertion_point(field_add_mutable:apollo.data.StaticInfoConf.hardware_configs)
  return _s;
}
inline const std::string& StaticInfoConf::_internal_hardware_configs(int index) const {
  return _impl_.hardware_configs_.Get(index);
}
inline const std::string& StaticInfoConf::hardware_configs(int index) const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfoConf.hardware_configs)
  return _internal_hardware_configs(index);
}
inline std::string* StaticInfoConf::mutable_hardware_configs(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfoConf.hardware_configs)
  return _impl_.hardware_configs_.Mutable(index);
}
inline void StaticInfoConf::set_hardware_configs(int index, const std::string& value) {
  _impl_.hardware_configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::set_hardware_configs(int index, std::string&& value) {
  _impl_.hardware_configs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::set_hardware_configs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hardware_configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::set_hardware_configs(int index, const char* value, size_t size) {
  _impl_.hardware_configs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.data.StaticInfoConf.hardware_configs)
}
inline std::string* StaticInfoConf::_internal_add_hardware_configs() {
  return _impl_.hardware_configs_.Add();
}
inline void StaticInfoConf::add_hardware_configs(const std::string& value) {
  _impl_.hardware_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::add_hardware_configs(std::string&& value) {
  _impl_.hardware_configs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::add_hardware_configs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hardware_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::add_hardware_configs(const char* value, size_t size) {
  _impl_.hardware_configs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.data.StaticInfoConf.hardware_configs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StaticInfoConf::hardware_configs() const {
  // @@protoc_insertion_point(field_list:apollo.data.StaticInfoConf.hardware_configs)
  return _impl_.hardware_configs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StaticInfoConf::mutable_hardware_configs() {
  // @@protoc_insertion_point(field_mutable_list:apollo.data.StaticInfoConf.hardware_configs)
  return &_impl_.hardware_configs_;
}

// repeated string software_configs = 2;
inline int StaticInfoConf::_internal_software_configs_size() const {
  return _impl_.software_configs_.size();
}
inline int StaticInfoConf::software_configs_size() const {
  return _internal_software_configs_size();
}
inline void StaticInfoConf::clear_software_configs() {
  _impl_.software_configs_.Clear();
}
inline std::string* StaticInfoConf::add_software_configs() {
  std::string* _s = _internal_add_software_configs();
  // @@protoc_insertion_point(field_add_mutable:apollo.data.StaticInfoConf.software_configs)
  return _s;
}
inline const std::string& StaticInfoConf::_internal_software_configs(int index) const {
  return _impl_.software_configs_.Get(index);
}
inline const std::string& StaticInfoConf::software_configs(int index) const {
  // @@protoc_insertion_point(field_get:apollo.data.StaticInfoConf.software_configs)
  return _internal_software_configs(index);
}
inline std::string* StaticInfoConf::mutable_software_configs(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.data.StaticInfoConf.software_configs)
  return _impl_.software_configs_.Mutable(index);
}
inline void StaticInfoConf::set_software_configs(int index, const std::string& value) {
  _impl_.software_configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::set_software_configs(int index, std::string&& value) {
  _impl_.software_configs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::set_software_configs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.software_configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::set_software_configs(int index, const char* value, size_t size) {
  _impl_.software_configs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.data.StaticInfoConf.software_configs)
}
inline std::string* StaticInfoConf::_internal_add_software_configs() {
  return _impl_.software_configs_.Add();
}
inline void StaticInfoConf::add_software_configs(const std::string& value) {
  _impl_.software_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::add_software_configs(std::string&& value) {
  _impl_.software_configs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::add_software_configs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.software_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::add_software_configs(const char* value, size_t size) {
  _impl_.software_configs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.data.StaticInfoConf.software_configs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StaticInfoConf::software_configs() const {
  // @@protoc_insertion_point(field_list:apollo.data.StaticInfoConf.software_configs)
  return _impl_.software_configs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StaticInfoConf::mutable_software_configs() {
  // @@protoc_insertion_point(field_mutable_list:apollo.data.StaticInfoConf.software_configs)
  return &_impl_.software_configs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace data
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::data::VehicleInfo_Brand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::data::VehicleInfo_Brand>() {
  return ::apollo::data::VehicleInfo_Brand_descriptor();
}
template <> struct is_proto_enum< ::apollo::data::VehicleInfo_Model> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::data::VehicleInfo_Model>() {
  return ::apollo::data::VehicleInfo_Model_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fdata_2fproto_2fstatic_5finfo_2eproto
