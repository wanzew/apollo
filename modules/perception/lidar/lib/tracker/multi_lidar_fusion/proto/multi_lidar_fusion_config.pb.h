// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/perception/lidar/lib/tracker/multi_lidar_fusion/proto/multi_lidar_fusion_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto;
namespace apollo {
namespace perception {
namespace lidar {
class MlfDistanceConfig;
struct MlfDistanceConfigDefaultTypeInternal;
extern MlfDistanceConfigDefaultTypeInternal _MlfDistanceConfig_default_instance_;
class MlfDistanceWeight;
struct MlfDistanceWeightDefaultTypeInternal;
extern MlfDistanceWeightDefaultTypeInternal _MlfDistanceWeight_default_instance_;
class MlfEngineConfig;
struct MlfEngineConfigDefaultTypeInternal;
extern MlfEngineConfigDefaultTypeInternal _MlfEngineConfig_default_instance_;
class MlfMotionFilterConfig;
struct MlfMotionFilterConfigDefaultTypeInternal;
extern MlfMotionFilterConfigDefaultTypeInternal _MlfMotionFilterConfig_default_instance_;
class MlfMotionRefinerConfig;
struct MlfMotionRefinerConfigDefaultTypeInternal;
extern MlfMotionRefinerConfigDefaultTypeInternal _MlfMotionRefinerConfig_default_instance_;
class MlfShapeFilterConfig;
struct MlfShapeFilterConfigDefaultTypeInternal;
extern MlfShapeFilterConfigDefaultTypeInternal _MlfShapeFilterConfig_default_instance_;
class MlfTrackObjectMatcherConfig;
struct MlfTrackObjectMatcherConfigDefaultTypeInternal;
extern MlfTrackObjectMatcherConfigDefaultTypeInternal _MlfTrackObjectMatcherConfig_default_instance_;
class MlfTrackerConfig;
struct MlfTrackerConfigDefaultTypeInternal;
extern MlfTrackerConfigDefaultTypeInternal _MlfTrackerConfig_default_instance_;
}  // namespace lidar
}  // namespace perception
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::perception::lidar::MlfDistanceConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfDistanceConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfDistanceWeight* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfDistanceWeight>(Arena*);
template<> ::apollo::perception::lidar::MlfEngineConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfEngineConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfMotionFilterConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfMotionFilterConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfMotionRefinerConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfMotionRefinerConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfShapeFilterConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfShapeFilterConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfTrackObjectMatcherConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfTrackObjectMatcherConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfTrackerConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfTrackerConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace perception {
namespace lidar {

// ===================================================================

class MlfDistanceWeight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfDistanceWeight) */ {
 public:
  inline MlfDistanceWeight() : MlfDistanceWeight(nullptr) {}
  ~MlfDistanceWeight() override;
  explicit PROTOBUF_CONSTEXPR MlfDistanceWeight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MlfDistanceWeight(const MlfDistanceWeight& from);
  MlfDistanceWeight(MlfDistanceWeight&& from) noexcept
    : MlfDistanceWeight() {
    *this = ::std::move(from);
  }

  inline MlfDistanceWeight& operator=(const MlfDistanceWeight& from) {
    CopyFrom(from);
    return *this;
  }
  inline MlfDistanceWeight& operator=(MlfDistanceWeight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MlfDistanceWeight& default_instance() {
    return *internal_default_instance();
  }
  static inline const MlfDistanceWeight* internal_default_instance() {
    return reinterpret_cast<const MlfDistanceWeight*>(
               &_MlfDistanceWeight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MlfDistanceWeight& a, MlfDistanceWeight& b) {
    a.Swap(&b);
  }
  inline void Swap(MlfDistanceWeight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MlfDistanceWeight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MlfDistanceWeight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MlfDistanceWeight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MlfDistanceWeight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MlfDistanceWeight& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfDistanceWeight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.MlfDistanceWeight";
  }
  protected:
  explicit MlfDistanceWeight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorNamePairFieldNumber = 1,
    kLocationDistWeightFieldNumber = 2,
    kDirectionDistWeightFieldNumber = 3,
    kBboxSizeDistWeightFieldNumber = 4,
    kPointNumDistWeightFieldNumber = 5,
    kHistogramDistWeightFieldNumber = 6,
    kCentroidShiftDistWeightFieldNumber = 7,
    kBboxIouDistWeightFieldNumber = 8,
    kSemanticMapDistWeightFieldNumber = 9,
  };
  // optional string sensor_name_pair = 1 [default = ""];
  bool has_sensor_name_pair() const;
  private:
  bool _internal_has_sensor_name_pair() const;
  public:
  void clear_sensor_name_pair();
  const std::string& sensor_name_pair() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensor_name_pair(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensor_name_pair();
  PROTOBUF_NODISCARD std::string* release_sensor_name_pair();
  void set_allocated_sensor_name_pair(std::string* sensor_name_pair);
  private:
  const std::string& _internal_sensor_name_pair() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_name_pair(const std::string& value);
  std::string* _internal_mutable_sensor_name_pair();
  public:

  // optional float location_dist_weight = 2 [default = 0];
  bool has_location_dist_weight() const;
  private:
  bool _internal_has_location_dist_weight() const;
  public:
  void clear_location_dist_weight();
  float location_dist_weight() const;
  void set_location_dist_weight(float value);
  private:
  float _internal_location_dist_weight() const;
  void _internal_set_location_dist_weight(float value);
  public:

  // optional float direction_dist_weight = 3 [default = 0];
  bool has_direction_dist_weight() const;
  private:
  bool _internal_has_direction_dist_weight() const;
  public:
  void clear_direction_dist_weight();
  float direction_dist_weight() const;
  void set_direction_dist_weight(float value);
  private:
  float _internal_direction_dist_weight() const;
  void _internal_set_direction_dist_weight(float value);
  public:

  // optional float bbox_size_dist_weight = 4 [default = 0];
  bool has_bbox_size_dist_weight() const;
  private:
  bool _internal_has_bbox_size_dist_weight() const;
  public:
  void clear_bbox_size_dist_weight();
  float bbox_size_dist_weight() const;
  void set_bbox_size_dist_weight(float value);
  private:
  float _internal_bbox_size_dist_weight() const;
  void _internal_set_bbox_size_dist_weight(float value);
  public:

  // optional float point_num_dist_weight = 5 [default = 0];
  bool has_point_num_dist_weight() const;
  private:
  bool _internal_has_point_num_dist_weight() const;
  public:
  void clear_point_num_dist_weight();
  float point_num_dist_weight() const;
  void set_point_num_dist_weight(float value);
  private:
  float _internal_point_num_dist_weight() const;
  void _internal_set_point_num_dist_weight(float value);
  public:

  // optional float histogram_dist_weight = 6 [default = 0];
  bool has_histogram_dist_weight() const;
  private:
  bool _internal_has_histogram_dist_weight() const;
  public:
  void clear_histogram_dist_weight();
  float histogram_dist_weight() const;
  void set_histogram_dist_weight(float value);
  private:
  float _internal_histogram_dist_weight() const;
  void _internal_set_histogram_dist_weight(float value);
  public:

  // optional float centroid_shift_dist_weight = 7 [default = 0];
  bool has_centroid_shift_dist_weight() const;
  private:
  bool _internal_has_centroid_shift_dist_weight() const;
  public:
  void clear_centroid_shift_dist_weight();
  float centroid_shift_dist_weight() const;
  void set_centroid_shift_dist_weight(float value);
  private:
  float _internal_centroid_shift_dist_weight() const;
  void _internal_set_centroid_shift_dist_weight(float value);
  public:

  // optional float bbox_iou_dist_weight = 8 [default = 0];
  bool has_bbox_iou_dist_weight() const;
  private:
  bool _internal_has_bbox_iou_dist_weight() const;
  public:
  void clear_bbox_iou_dist_weight();
  float bbox_iou_dist_weight() const;
  void set_bbox_iou_dist_weight(float value);
  private:
  float _internal_bbox_iou_dist_weight() const;
  void _internal_set_bbox_iou_dist_weight(float value);
  public:

  // optional float semantic_map_dist_weight = 9 [default = 0];
  bool has_semantic_map_dist_weight() const;
  private:
  bool _internal_has_semantic_map_dist_weight() const;
  public:
  void clear_semantic_map_dist_weight();
  float semantic_map_dist_weight() const;
  void set_semantic_map_dist_weight(float value);
  private:
  float _internal_semantic_map_dist_weight() const;
  void _internal_set_semantic_map_dist_weight(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfDistanceWeight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_name_pair_;
    float location_dist_weight_;
    float direction_dist_weight_;
    float bbox_size_dist_weight_;
    float point_num_dist_weight_;
    float histogram_dist_weight_;
    float centroid_shift_dist_weight_;
    float bbox_iou_dist_weight_;
    float semantic_map_dist_weight_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class MlfDistanceConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfDistanceConfig) */ {
 public:
  inline MlfDistanceConfig() : MlfDistanceConfig(nullptr) {}
  ~MlfDistanceConfig() override;
  explicit PROTOBUF_CONSTEXPR MlfDistanceConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MlfDistanceConfig(const MlfDistanceConfig& from);
  MlfDistanceConfig(MlfDistanceConfig&& from) noexcept
    : MlfDistanceConfig() {
    *this = ::std::move(from);
  }

  inline MlfDistanceConfig& operator=(const MlfDistanceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MlfDistanceConfig& operator=(MlfDistanceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MlfDistanceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MlfDistanceConfig* internal_default_instance() {
    return reinterpret_cast<const MlfDistanceConfig*>(
               &_MlfDistanceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MlfDistanceConfig& a, MlfDistanceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MlfDistanceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MlfDistanceConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MlfDistanceConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MlfDistanceConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MlfDistanceConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MlfDistanceConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfDistanceConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.MlfDistanceConfig";
  }
  protected:
  explicit MlfDistanceConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForegroundWeightsFieldNumber = 1,
    kBackgroundWeightsFieldNumber = 2,
  };
  // repeated .apollo.perception.lidar.MlfDistanceWeight foreground_weights = 1;
  int foreground_weights_size() const;
  private:
  int _internal_foreground_weights_size() const;
  public:
  void clear_foreground_weights();
  ::apollo::perception::lidar::MlfDistanceWeight* mutable_foreground_weights(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >*
      mutable_foreground_weights();
  private:
  const ::apollo::perception::lidar::MlfDistanceWeight& _internal_foreground_weights(int index) const;
  ::apollo::perception::lidar::MlfDistanceWeight* _internal_add_foreground_weights();
  public:
  const ::apollo::perception::lidar::MlfDistanceWeight& foreground_weights(int index) const;
  ::apollo::perception::lidar::MlfDistanceWeight* add_foreground_weights();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >&
      foreground_weights() const;

  // repeated .apollo.perception.lidar.MlfDistanceWeight background_weights = 2;
  int background_weights_size() const;
  private:
  int _internal_background_weights_size() const;
  public:
  void clear_background_weights();
  ::apollo::perception::lidar::MlfDistanceWeight* mutable_background_weights(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >*
      mutable_background_weights();
  private:
  const ::apollo::perception::lidar::MlfDistanceWeight& _internal_background_weights(int index) const;
  ::apollo::perception::lidar::MlfDistanceWeight* _internal_add_background_weights();
  public:
  const ::apollo::perception::lidar::MlfDistanceWeight& background_weights(int index) const;
  ::apollo::perception::lidar::MlfDistanceWeight* add_background_weights();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >&
      background_weights() const;

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfDistanceConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight > foreground_weights_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight > background_weights_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class MlfTrackObjectMatcherConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfTrackObjectMatcherConfig) */ {
 public:
  inline MlfTrackObjectMatcherConfig() : MlfTrackObjectMatcherConfig(nullptr) {}
  ~MlfTrackObjectMatcherConfig() override;
  explicit PROTOBUF_CONSTEXPR MlfTrackObjectMatcherConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MlfTrackObjectMatcherConfig(const MlfTrackObjectMatcherConfig& from);
  MlfTrackObjectMatcherConfig(MlfTrackObjectMatcherConfig&& from) noexcept
    : MlfTrackObjectMatcherConfig() {
    *this = ::std::move(from);
  }

  inline MlfTrackObjectMatcherConfig& operator=(const MlfTrackObjectMatcherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MlfTrackObjectMatcherConfig& operator=(MlfTrackObjectMatcherConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MlfTrackObjectMatcherConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MlfTrackObjectMatcherConfig* internal_default_instance() {
    return reinterpret_cast<const MlfTrackObjectMatcherConfig*>(
               &_MlfTrackObjectMatcherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MlfTrackObjectMatcherConfig& a, MlfTrackObjectMatcherConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MlfTrackObjectMatcherConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MlfTrackObjectMatcherConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MlfTrackObjectMatcherConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MlfTrackObjectMatcherConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MlfTrackObjectMatcherConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MlfTrackObjectMatcherConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfTrackObjectMatcherConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.MlfTrackObjectMatcherConfig";
  }
  protected:
  explicit MlfTrackObjectMatcherConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForegroundMathcerMethodFieldNumber = 1,
    kBackgroundMatcherMethodFieldNumber = 2,
    kBoundValueFieldNumber = 3,
    kMaxMatchDistanceFieldNumber = 4,
  };
  // optional string foreground_mathcer_method = 1 [default = "MultiHmBipartiteGraphMatcher"];
  bool has_foreground_mathcer_method() const;
  private:
  bool _internal_has_foreground_mathcer_method() const;
  public:
  void clear_foreground_mathcer_method();
  const std::string& foreground_mathcer_method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_foreground_mathcer_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_foreground_mathcer_method();
  PROTOBUF_NODISCARD std::string* release_foreground_mathcer_method();
  void set_allocated_foreground_mathcer_method(std::string* foreground_mathcer_method);
  private:
  const std::string& _internal_foreground_mathcer_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_foreground_mathcer_method(const std::string& value);
  std::string* _internal_mutable_foreground_mathcer_method();
  public:

  // optional string background_matcher_method = 2 [default = "GnnBipartiteGraphMatcher"];
  bool has_background_matcher_method() const;
  private:
  bool _internal_has_background_matcher_method() const;
  public:
  void clear_background_matcher_method();
  const std::string& background_matcher_method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_background_matcher_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_background_matcher_method();
  PROTOBUF_NODISCARD std::string* release_background_matcher_method();
  void set_allocated_background_matcher_method(std::string* background_matcher_method);
  private:
  const std::string& _internal_background_matcher_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_background_matcher_method(const std::string& value);
  std::string* _internal_mutable_background_matcher_method();
  public:

  // optional float bound_value = 3 [default = 100];
  bool has_bound_value() const;
  private:
  bool _internal_has_bound_value() const;
  public:
  void clear_bound_value();
  float bound_value() const;
  void set_bound_value(float value);
  private:
  float _internal_bound_value() const;
  void _internal_set_bound_value(float value);
  public:

  // optional float max_match_distance = 4 [default = 4];
  bool has_max_match_distance() const;
  private:
  bool _internal_has_max_match_distance() const;
  public:
  void clear_max_match_distance();
  float max_match_distance() const;
  void set_max_match_distance(float value);
  private:
  float _internal_max_match_distance() const;
  void _internal_set_max_match_distance(float value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfTrackObjectMatcherConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_foreground_mathcer_method_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr foreground_mathcer_method_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_background_matcher_method_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr background_matcher_method_;
    float bound_value_;
    float max_match_distance_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class MlfTrackerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfTrackerConfig) */ {
 public:
  inline MlfTrackerConfig() : MlfTrackerConfig(nullptr) {}
  ~MlfTrackerConfig() override;
  explicit PROTOBUF_CONSTEXPR MlfTrackerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MlfTrackerConfig(const MlfTrackerConfig& from);
  MlfTrackerConfig(MlfTrackerConfig&& from) noexcept
    : MlfTrackerConfig() {
    *this = ::std::move(from);
  }

  inline MlfTrackerConfig& operator=(const MlfTrackerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MlfTrackerConfig& operator=(MlfTrackerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MlfTrackerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MlfTrackerConfig* internal_default_instance() {
    return reinterpret_cast<const MlfTrackerConfig*>(
               &_MlfTrackerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MlfTrackerConfig& a, MlfTrackerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MlfTrackerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MlfTrackerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MlfTrackerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MlfTrackerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MlfTrackerConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MlfTrackerConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfTrackerConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.MlfTrackerConfig";
  }
  protected:
  explicit MlfTrackerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterNameFieldNumber = 1,
  };
  // repeated string filter_name = 1;
  int filter_name_size() const;
  private:
  int _internal_filter_name_size() const;
  public:
  void clear_filter_name();
  const std::string& filter_name(int index) const;
  std::string* mutable_filter_name(int index);
  void set_filter_name(int index, const std::string& value);
  void set_filter_name(int index, std::string&& value);
  void set_filter_name(int index, const char* value);
  void set_filter_name(int index, const char* value, size_t size);
  std::string* add_filter_name();
  void add_filter_name(const std::string& value);
  void add_filter_name(std::string&& value);
  void add_filter_name(const char* value);
  void add_filter_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filter_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filter_name();
  private:
  const std::string& _internal_filter_name(int index) const;
  std::string* _internal_add_filter_name();
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfTrackerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filter_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class MlfMotionFilterConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfMotionFilterConfig) */ {
 public:
  inline MlfMotionFilterConfig() : MlfMotionFilterConfig(nullptr) {}
  ~MlfMotionFilterConfig() override;
  explicit PROTOBUF_CONSTEXPR MlfMotionFilterConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MlfMotionFilterConfig(const MlfMotionFilterConfig& from);
  MlfMotionFilterConfig(MlfMotionFilterConfig&& from) noexcept
    : MlfMotionFilterConfig() {
    *this = ::std::move(from);
  }

  inline MlfMotionFilterConfig& operator=(const MlfMotionFilterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MlfMotionFilterConfig& operator=(MlfMotionFilterConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MlfMotionFilterConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MlfMotionFilterConfig* internal_default_instance() {
    return reinterpret_cast<const MlfMotionFilterConfig*>(
               &_MlfMotionFilterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MlfMotionFilterConfig& a, MlfMotionFilterConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MlfMotionFilterConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MlfMotionFilterConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MlfMotionFilterConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MlfMotionFilterConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MlfMotionFilterConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MlfMotionFilterConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfMotionFilterConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.MlfMotionFilterConfig";
  }
  protected:
  explicit MlfMotionFilterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoostupHistorySizeMaximumFieldNumber = 9,
    kUseAdaptiveFieldNumber = 1,
    kUseBreakdownFieldNumber = 2,
    kUseConvergenceBoostupFieldNumber = 3,
    kBoostupHistorySizeMinimumFieldNumber = 8,
    kInitVelocityVarianceFieldNumber = 4,
    kInitAccelerationVarianceFieldNumber = 5,
    kMeasuredVelocityVarianceFieldNumber = 6,
    kPredictVariancePerSqrsecFieldNumber = 7,
    kConvergedConfidenceMinimumFieldNumber = 10,
    kNoiseMaximumFieldNumber = 12,
    kTrustOrientationRangeFieldNumber = 13,
  };
  // optional uint32 boostup_history_size_maximum = 9 [default = 6];
  bool has_boostup_history_size_maximum() const;
  private:
  bool _internal_has_boostup_history_size_maximum() const;
  public:
  void clear_boostup_history_size_maximum();
  uint32_t boostup_history_size_maximum() const;
  void set_boostup_history_size_maximum(uint32_t value);
  private:
  uint32_t _internal_boostup_history_size_maximum() const;
  void _internal_set_boostup_history_size_maximum(uint32_t value);
  public:

  // optional bool use_adaptive = 1 [default = true];
  bool has_use_adaptive() const;
  private:
  bool _internal_has_use_adaptive() const;
  public:
  void clear_use_adaptive();
  bool use_adaptive() const;
  void set_use_adaptive(bool value);
  private:
  bool _internal_use_adaptive() const;
  void _internal_set_use_adaptive(bool value);
  public:

  // optional bool use_breakdown = 2 [default = true];
  bool has_use_breakdown() const;
  private:
  bool _internal_has_use_breakdown() const;
  public:
  void clear_use_breakdown();
  bool use_breakdown() const;
  void set_use_breakdown(bool value);
  private:
  bool _internal_use_breakdown() const;
  void _internal_set_use_breakdown(bool value);
  public:

  // optional bool use_convergence_boostup = 3 [default = true];
  bool has_use_convergence_boostup() const;
  private:
  bool _internal_has_use_convergence_boostup() const;
  public:
  void clear_use_convergence_boostup();
  bool use_convergence_boostup() const;
  void set_use_convergence_boostup(bool value);
  private:
  bool _internal_use_convergence_boostup() const;
  void _internal_set_use_convergence_boostup(bool value);
  public:

  // optional uint32 boostup_history_size_minimum = 8 [default = 3];
  bool has_boostup_history_size_minimum() const;
  private:
  bool _internal_has_boostup_history_size_minimum() const;
  public:
  void clear_boostup_history_size_minimum();
  uint32_t boostup_history_size_minimum() const;
  void set_boostup_history_size_minimum(uint32_t value);
  private:
  uint32_t _internal_boostup_history_size_minimum() const;
  void _internal_set_boostup_history_size_minimum(uint32_t value);
  public:

  // optional double init_velocity_variance = 4 [default = 5];
  bool has_init_velocity_variance() const;
  private:
  bool _internal_has_init_velocity_variance() const;
  public:
  void clear_init_velocity_variance();
  double init_velocity_variance() const;
  void set_init_velocity_variance(double value);
  private:
  double _internal_init_velocity_variance() const;
  void _internal_set_init_velocity_variance(double value);
  public:

  // optional double init_acceleration_variance = 5 [default = 10];
  bool has_init_acceleration_variance() const;
  private:
  bool _internal_has_init_acceleration_variance() const;
  public:
  void clear_init_acceleration_variance();
  double init_acceleration_variance() const;
  void set_init_acceleration_variance(double value);
  private:
  double _internal_init_acceleration_variance() const;
  void _internal_set_init_acceleration_variance(double value);
  public:

  // optional double measured_velocity_variance = 6 [default = 0.4];
  bool has_measured_velocity_variance() const;
  private:
  bool _internal_has_measured_velocity_variance() const;
  public:
  void clear_measured_velocity_variance();
  double measured_velocity_variance() const;
  void set_measured_velocity_variance(double value);
  private:
  double _internal_measured_velocity_variance() const;
  void _internal_set_measured_velocity_variance(double value);
  public:

  // optional double predict_variance_per_sqrsec = 7 [default = 10];
  bool has_predict_variance_per_sqrsec() const;
  private:
  bool _internal_has_predict_variance_per_sqrsec() const;
  public:
  void clear_predict_variance_per_sqrsec();
  double predict_variance_per_sqrsec() const;
  void set_predict_variance_per_sqrsec(double value);
  private:
  double _internal_predict_variance_per_sqrsec() const;
  void _internal_set_predict_variance_per_sqrsec(double value);
  public:

  // optional double converged_confidence_minimum = 10 [default = 0.5];
  bool has_converged_confidence_minimum() const;
  private:
  bool _internal_has_converged_confidence_minimum() const;
  public:
  void clear_converged_confidence_minimum();
  double converged_confidence_minimum() const;
  void set_converged_confidence_minimum(double value);
  private:
  double _internal_converged_confidence_minimum() const;
  void _internal_set_converged_confidence_minimum(double value);
  public:

  // optional double noise_maximum = 12 [default = 0.1];
  bool has_noise_maximum() const;
  private:
  bool _internal_has_noise_maximum() const;
  public:
  void clear_noise_maximum();
  double noise_maximum() const;
  void set_noise_maximum(double value);
  private:
  double _internal_noise_maximum() const;
  void _internal_set_noise_maximum(double value);
  public:

  // optional double trust_orientation_range = 13 [default = 40];
  bool has_trust_orientation_range() const;
  private:
  bool _internal_has_trust_orientation_range() const;
  public:
  void clear_trust_orientation_range();
  double trust_orientation_range() const;
  void set_trust_orientation_range(double value);
  private:
  double _internal_trust_orientation_range() const;
  void _internal_set_trust_orientation_range(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfMotionFilterConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t boostup_history_size_maximum_;
    bool use_adaptive_;
    bool use_breakdown_;
    bool use_convergence_boostup_;
    uint32_t boostup_history_size_minimum_;
    double init_velocity_variance_;
    double init_acceleration_variance_;
    double measured_velocity_variance_;
    double predict_variance_per_sqrsec_;
    double converged_confidence_minimum_;
    double noise_maximum_;
    double trust_orientation_range_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class MlfMotionRefinerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfMotionRefinerConfig) */ {
 public:
  inline MlfMotionRefinerConfig() : MlfMotionRefinerConfig(nullptr) {}
  ~MlfMotionRefinerConfig() override;
  explicit PROTOBUF_CONSTEXPR MlfMotionRefinerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MlfMotionRefinerConfig(const MlfMotionRefinerConfig& from);
  MlfMotionRefinerConfig(MlfMotionRefinerConfig&& from) noexcept
    : MlfMotionRefinerConfig() {
    *this = ::std::move(from);
  }

  inline MlfMotionRefinerConfig& operator=(const MlfMotionRefinerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MlfMotionRefinerConfig& operator=(MlfMotionRefinerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MlfMotionRefinerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MlfMotionRefinerConfig* internal_default_instance() {
    return reinterpret_cast<const MlfMotionRefinerConfig*>(
               &_MlfMotionRefinerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MlfMotionRefinerConfig& a, MlfMotionRefinerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MlfMotionRefinerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MlfMotionRefinerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MlfMotionRefinerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MlfMotionRefinerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MlfMotionRefinerConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MlfMotionRefinerConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfMotionRefinerConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.MlfMotionRefinerConfig";
  }
  protected:
  explicit MlfMotionRefinerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClapingAccelerationThresholdFieldNumber = 1,
    kClapingSpeedThresholdFieldNumber = 2,
  };
  // optional double claping_acceleration_threshold = 1 [default = 10];
  bool has_claping_acceleration_threshold() const;
  private:
  bool _internal_has_claping_acceleration_threshold() const;
  public:
  void clear_claping_acceleration_threshold();
  double claping_acceleration_threshold() const;
  void set_claping_acceleration_threshold(double value);
  private:
  double _internal_claping_acceleration_threshold() const;
  void _internal_set_claping_acceleration_threshold(double value);
  public:

  // optional double claping_speed_threshold = 2 [default = 1];
  bool has_claping_speed_threshold() const;
  private:
  bool _internal_has_claping_speed_threshold() const;
  public:
  void clear_claping_speed_threshold();
  double claping_speed_threshold() const;
  void set_claping_speed_threshold(double value);
  private:
  double _internal_claping_speed_threshold() const;
  void _internal_set_claping_speed_threshold(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfMotionRefinerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double claping_acceleration_threshold_;
    double claping_speed_threshold_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class MlfShapeFilterConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfShapeFilterConfig) */ {
 public:
  inline MlfShapeFilterConfig() : MlfShapeFilterConfig(nullptr) {}
  ~MlfShapeFilterConfig() override;
  explicit PROTOBUF_CONSTEXPR MlfShapeFilterConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MlfShapeFilterConfig(const MlfShapeFilterConfig& from);
  MlfShapeFilterConfig(MlfShapeFilterConfig&& from) noexcept
    : MlfShapeFilterConfig() {
    *this = ::std::move(from);
  }

  inline MlfShapeFilterConfig& operator=(const MlfShapeFilterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MlfShapeFilterConfig& operator=(MlfShapeFilterConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MlfShapeFilterConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MlfShapeFilterConfig* internal_default_instance() {
    return reinterpret_cast<const MlfShapeFilterConfig*>(
               &_MlfShapeFilterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MlfShapeFilterConfig& a, MlfShapeFilterConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MlfShapeFilterConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MlfShapeFilterConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MlfShapeFilterConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MlfShapeFilterConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MlfShapeFilterConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MlfShapeFilterConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfShapeFilterConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.MlfShapeFilterConfig";
  }
  protected:
  explicit MlfShapeFilterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBottomPointsIgnoreThresholdFieldNumber = 1,
    kTopPointsIgnoreThresholdFieldNumber = 2,
  };
  // optional double bottom_points_ignore_threshold = 1 [default = 0.1];
  bool has_bottom_points_ignore_threshold() const;
  private:
  bool _internal_has_bottom_points_ignore_threshold() const;
  public:
  void clear_bottom_points_ignore_threshold();
  double bottom_points_ignore_threshold() const;
  void set_bottom_points_ignore_threshold(double value);
  private:
  double _internal_bottom_points_ignore_threshold() const;
  void _internal_set_bottom_points_ignore_threshold(double value);
  public:

  // optional double top_points_ignore_threshold = 2 [default = 1.6];
  bool has_top_points_ignore_threshold() const;
  private:
  bool _internal_has_top_points_ignore_threshold() const;
  public:
  void clear_top_points_ignore_threshold();
  double top_points_ignore_threshold() const;
  void set_top_points_ignore_threshold(double value);
  private:
  double _internal_top_points_ignore_threshold() const;
  void _internal_set_top_points_ignore_threshold(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfShapeFilterConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double bottom_points_ignore_threshold_;
    double top_points_ignore_threshold_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class MlfEngineConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfEngineConfig) */ {
 public:
  inline MlfEngineConfig() : MlfEngineConfig(nullptr) {}
  ~MlfEngineConfig() override;
  explicit PROTOBUF_CONSTEXPR MlfEngineConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MlfEngineConfig(const MlfEngineConfig& from);
  MlfEngineConfig(MlfEngineConfig&& from) noexcept
    : MlfEngineConfig() {
    *this = ::std::move(from);
  }

  inline MlfEngineConfig& operator=(const MlfEngineConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MlfEngineConfig& operator=(MlfEngineConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MlfEngineConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MlfEngineConfig* internal_default_instance() {
    return reinterpret_cast<const MlfEngineConfig*>(
               &_MlfEngineConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MlfEngineConfig& a, MlfEngineConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MlfEngineConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MlfEngineConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MlfEngineConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MlfEngineConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MlfEngineConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MlfEngineConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfEngineConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.perception.lidar.MlfEngineConfig";
  }
  protected:
  explicit MlfEngineConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMainSensorFieldNumber = 1,
    kOutputPredictObjectsFieldNumber = 4,
    kUseFrameTimestampFieldNumber = 6,
    kUseHistogramForMatchFieldNumber = 2,
    kHistogramBinSizeFieldNumber = 3,
    kReservedInvisibleTimeFieldNumber = 5,
  };
  // repeated string main_sensor = 1;
  int main_sensor_size() const;
  private:
  int _internal_main_sensor_size() const;
  public:
  void clear_main_sensor();
  const std::string& main_sensor(int index) const;
  std::string* mutable_main_sensor(int index);
  void set_main_sensor(int index, const std::string& value);
  void set_main_sensor(int index, std::string&& value);
  void set_main_sensor(int index, const char* value);
  void set_main_sensor(int index, const char* value, size_t size);
  std::string* add_main_sensor();
  void add_main_sensor(const std::string& value);
  void add_main_sensor(std::string&& value);
  void add_main_sensor(const char* value);
  void add_main_sensor(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& main_sensor() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_main_sensor();
  private:
  const std::string& _internal_main_sensor(int index) const;
  std::string* _internal_add_main_sensor();
  public:

  // optional bool output_predict_objects = 4 [default = false];
  bool has_output_predict_objects() const;
  private:
  bool _internal_has_output_predict_objects() const;
  public:
  void clear_output_predict_objects();
  bool output_predict_objects() const;
  void set_output_predict_objects(bool value);
  private:
  bool _internal_output_predict_objects() const;
  void _internal_set_output_predict_objects(bool value);
  public:

  // optional bool use_frame_timestamp = 6 [default = false];
  bool has_use_frame_timestamp() const;
  private:
  bool _internal_has_use_frame_timestamp() const;
  public:
  void clear_use_frame_timestamp();
  bool use_frame_timestamp() const;
  void set_use_frame_timestamp(bool value);
  private:
  bool _internal_use_frame_timestamp() const;
  void _internal_set_use_frame_timestamp(bool value);
  public:

  // optional bool use_histogram_for_match = 2 [default = true];
  bool has_use_histogram_for_match() const;
  private:
  bool _internal_has_use_histogram_for_match() const;
  public:
  void clear_use_histogram_for_match();
  bool use_histogram_for_match() const;
  void set_use_histogram_for_match(bool value);
  private:
  bool _internal_use_histogram_for_match() const;
  void _internal_set_use_histogram_for_match(bool value);
  public:

  // optional uint32 histogram_bin_size = 3 [default = 10];
  bool has_histogram_bin_size() const;
  private:
  bool _internal_has_histogram_bin_size() const;
  public:
  void clear_histogram_bin_size();
  uint32_t histogram_bin_size() const;
  void set_histogram_bin_size(uint32_t value);
  private:
  uint32_t _internal_histogram_bin_size() const;
  void _internal_set_histogram_bin_size(uint32_t value);
  public:

  // optional double reserved_invisible_time = 5 [default = 0.2];
  bool has_reserved_invisible_time() const;
  private:
  bool _internal_has_reserved_invisible_time() const;
  public:
  void clear_reserved_invisible_time();
  double reserved_invisible_time() const;
  void set_reserved_invisible_time(double value);
  private:
  double _internal_reserved_invisible_time() const;
  void _internal_set_reserved_invisible_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfEngineConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> main_sensor_;
    bool output_predict_objects_;
    bool use_frame_timestamp_;
    bool use_histogram_for_match_;
    uint32_t histogram_bin_size_;
    double reserved_invisible_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MlfDistanceWeight

// optional string sensor_name_pair = 1 [default = ""];
inline bool MlfDistanceWeight::_internal_has_sensor_name_pair() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MlfDistanceWeight::has_sensor_name_pair() const {
  return _internal_has_sensor_name_pair();
}
inline void MlfDistanceWeight::clear_sensor_name_pair() {
  _impl_.sensor_name_pair_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MlfDistanceWeight::sensor_name_pair() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
  return _internal_sensor_name_pair();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MlfDistanceWeight::set_sensor_name_pair(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sensor_name_pair_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
}
inline std::string* MlfDistanceWeight::mutable_sensor_name_pair() {
  std::string* _s = _internal_mutable_sensor_name_pair();
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
  return _s;
}
inline const std::string& MlfDistanceWeight::_internal_sensor_name_pair() const {
  return _impl_.sensor_name_pair_.Get();
}
inline void MlfDistanceWeight::_internal_set_sensor_name_pair(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sensor_name_pair_.Set(value, GetArenaForAllocation());
}
inline std::string* MlfDistanceWeight::_internal_mutable_sensor_name_pair() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sensor_name_pair_.Mutable(GetArenaForAllocation());
}
inline std::string* MlfDistanceWeight::release_sensor_name_pair() {
  // @@protoc_insertion_point(field_release:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
  if (!_internal_has_sensor_name_pair()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sensor_name_pair_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sensor_name_pair_.IsDefault()) {
    _impl_.sensor_name_pair_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MlfDistanceWeight::set_allocated_sensor_name_pair(std::string* sensor_name_pair) {
  if (sensor_name_pair != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sensor_name_pair_.SetAllocated(sensor_name_pair, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sensor_name_pair_.IsDefault()) {
    _impl_.sensor_name_pair_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
}

// optional float location_dist_weight = 2 [default = 0];
inline bool MlfDistanceWeight::_internal_has_location_dist_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MlfDistanceWeight::has_location_dist_weight() const {
  return _internal_has_location_dist_weight();
}
inline void MlfDistanceWeight::clear_location_dist_weight() {
  _impl_.location_dist_weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float MlfDistanceWeight::_internal_location_dist_weight() const {
  return _impl_.location_dist_weight_;
}
inline float MlfDistanceWeight::location_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.location_dist_weight)
  return _internal_location_dist_weight();
}
inline void MlfDistanceWeight::_internal_set_location_dist_weight(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.location_dist_weight_ = value;
}
inline void MlfDistanceWeight::set_location_dist_weight(float value) {
  _internal_set_location_dist_weight(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.location_dist_weight)
}

// optional float direction_dist_weight = 3 [default = 0];
inline bool MlfDistanceWeight::_internal_has_direction_dist_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MlfDistanceWeight::has_direction_dist_weight() const {
  return _internal_has_direction_dist_weight();
}
inline void MlfDistanceWeight::clear_direction_dist_weight() {
  _impl_.direction_dist_weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float MlfDistanceWeight::_internal_direction_dist_weight() const {
  return _impl_.direction_dist_weight_;
}
inline float MlfDistanceWeight::direction_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.direction_dist_weight)
  return _internal_direction_dist_weight();
}
inline void MlfDistanceWeight::_internal_set_direction_dist_weight(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.direction_dist_weight_ = value;
}
inline void MlfDistanceWeight::set_direction_dist_weight(float value) {
  _internal_set_direction_dist_weight(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.direction_dist_weight)
}

// optional float bbox_size_dist_weight = 4 [default = 0];
inline bool MlfDistanceWeight::_internal_has_bbox_size_dist_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MlfDistanceWeight::has_bbox_size_dist_weight() const {
  return _internal_has_bbox_size_dist_weight();
}
inline void MlfDistanceWeight::clear_bbox_size_dist_weight() {
  _impl_.bbox_size_dist_weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MlfDistanceWeight::_internal_bbox_size_dist_weight() const {
  return _impl_.bbox_size_dist_weight_;
}
inline float MlfDistanceWeight::bbox_size_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.bbox_size_dist_weight)
  return _internal_bbox_size_dist_weight();
}
inline void MlfDistanceWeight::_internal_set_bbox_size_dist_weight(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bbox_size_dist_weight_ = value;
}
inline void MlfDistanceWeight::set_bbox_size_dist_weight(float value) {
  _internal_set_bbox_size_dist_weight(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.bbox_size_dist_weight)
}

// optional float point_num_dist_weight = 5 [default = 0];
inline bool MlfDistanceWeight::_internal_has_point_num_dist_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MlfDistanceWeight::has_point_num_dist_weight() const {
  return _internal_has_point_num_dist_weight();
}
inline void MlfDistanceWeight::clear_point_num_dist_weight() {
  _impl_.point_num_dist_weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float MlfDistanceWeight::_internal_point_num_dist_weight() const {
  return _impl_.point_num_dist_weight_;
}
inline float MlfDistanceWeight::point_num_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.point_num_dist_weight)
  return _internal_point_num_dist_weight();
}
inline void MlfDistanceWeight::_internal_set_point_num_dist_weight(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.point_num_dist_weight_ = value;
}
inline void MlfDistanceWeight::set_point_num_dist_weight(float value) {
  _internal_set_point_num_dist_weight(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.point_num_dist_weight)
}

// optional float histogram_dist_weight = 6 [default = 0];
inline bool MlfDistanceWeight::_internal_has_histogram_dist_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MlfDistanceWeight::has_histogram_dist_weight() const {
  return _internal_has_histogram_dist_weight();
}
inline void MlfDistanceWeight::clear_histogram_dist_weight() {
  _impl_.histogram_dist_weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float MlfDistanceWeight::_internal_histogram_dist_weight() const {
  return _impl_.histogram_dist_weight_;
}
inline float MlfDistanceWeight::histogram_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.histogram_dist_weight)
  return _internal_histogram_dist_weight();
}
inline void MlfDistanceWeight::_internal_set_histogram_dist_weight(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.histogram_dist_weight_ = value;
}
inline void MlfDistanceWeight::set_histogram_dist_weight(float value) {
  _internal_set_histogram_dist_weight(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.histogram_dist_weight)
}

// optional float centroid_shift_dist_weight = 7 [default = 0];
inline bool MlfDistanceWeight::_internal_has_centroid_shift_dist_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MlfDistanceWeight::has_centroid_shift_dist_weight() const {
  return _internal_has_centroid_shift_dist_weight();
}
inline void MlfDistanceWeight::clear_centroid_shift_dist_weight() {
  _impl_.centroid_shift_dist_weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float MlfDistanceWeight::_internal_centroid_shift_dist_weight() const {
  return _impl_.centroid_shift_dist_weight_;
}
inline float MlfDistanceWeight::centroid_shift_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.centroid_shift_dist_weight)
  return _internal_centroid_shift_dist_weight();
}
inline void MlfDistanceWeight::_internal_set_centroid_shift_dist_weight(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.centroid_shift_dist_weight_ = value;
}
inline void MlfDistanceWeight::set_centroid_shift_dist_weight(float value) {
  _internal_set_centroid_shift_dist_weight(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.centroid_shift_dist_weight)
}

// optional float bbox_iou_dist_weight = 8 [default = 0];
inline bool MlfDistanceWeight::_internal_has_bbox_iou_dist_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MlfDistanceWeight::has_bbox_iou_dist_weight() const {
  return _internal_has_bbox_iou_dist_weight();
}
inline void MlfDistanceWeight::clear_bbox_iou_dist_weight() {
  _impl_.bbox_iou_dist_weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float MlfDistanceWeight::_internal_bbox_iou_dist_weight() const {
  return _impl_.bbox_iou_dist_weight_;
}
inline float MlfDistanceWeight::bbox_iou_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.bbox_iou_dist_weight)
  return _internal_bbox_iou_dist_weight();
}
inline void MlfDistanceWeight::_internal_set_bbox_iou_dist_weight(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.bbox_iou_dist_weight_ = value;
}
inline void MlfDistanceWeight::set_bbox_iou_dist_weight(float value) {
  _internal_set_bbox_iou_dist_weight(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.bbox_iou_dist_weight)
}

// optional float semantic_map_dist_weight = 9 [default = 0];
inline bool MlfDistanceWeight::_internal_has_semantic_map_dist_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MlfDistanceWeight::has_semantic_map_dist_weight() const {
  return _internal_has_semantic_map_dist_weight();
}
inline void MlfDistanceWeight::clear_semantic_map_dist_weight() {
  _impl_.semantic_map_dist_weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float MlfDistanceWeight::_internal_semantic_map_dist_weight() const {
  return _impl_.semantic_map_dist_weight_;
}
inline float MlfDistanceWeight::semantic_map_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.semantic_map_dist_weight)
  return _internal_semantic_map_dist_weight();
}
inline void MlfDistanceWeight::_internal_set_semantic_map_dist_weight(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.semantic_map_dist_weight_ = value;
}
inline void MlfDistanceWeight::set_semantic_map_dist_weight(float value) {
  _internal_set_semantic_map_dist_weight(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.semantic_map_dist_weight)
}

// -------------------------------------------------------------------

// MlfDistanceConfig

// repeated .apollo.perception.lidar.MlfDistanceWeight foreground_weights = 1;
inline int MlfDistanceConfig::_internal_foreground_weights_size() const {
  return _impl_.foreground_weights_.size();
}
inline int MlfDistanceConfig::foreground_weights_size() const {
  return _internal_foreground_weights_size();
}
inline void MlfDistanceConfig::clear_foreground_weights() {
  _impl_.foreground_weights_.Clear();
}
inline ::apollo::perception::lidar::MlfDistanceWeight* MlfDistanceConfig::mutable_foreground_weights(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfDistanceConfig.foreground_weights)
  return _impl_.foreground_weights_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >*
MlfDistanceConfig::mutable_foreground_weights() {
  // @@protoc_insertion_point(field_mutable_list:apollo.perception.lidar.MlfDistanceConfig.foreground_weights)
  return &_impl_.foreground_weights_;
}
inline const ::apollo::perception::lidar::MlfDistanceWeight& MlfDistanceConfig::_internal_foreground_weights(int index) const {
  return _impl_.foreground_weights_.Get(index);
}
inline const ::apollo::perception::lidar::MlfDistanceWeight& MlfDistanceConfig::foreground_weights(int index) const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceConfig.foreground_weights)
  return _internal_foreground_weights(index);
}
inline ::apollo::perception::lidar::MlfDistanceWeight* MlfDistanceConfig::_internal_add_foreground_weights() {
  return _impl_.foreground_weights_.Add();
}
inline ::apollo::perception::lidar::MlfDistanceWeight* MlfDistanceConfig::add_foreground_weights() {
  ::apollo::perception::lidar::MlfDistanceWeight* _add = _internal_add_foreground_weights();
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfDistanceConfig.foreground_weights)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >&
MlfDistanceConfig::foreground_weights() const {
  // @@protoc_insertion_point(field_list:apollo.perception.lidar.MlfDistanceConfig.foreground_weights)
  return _impl_.foreground_weights_;
}

// repeated .apollo.perception.lidar.MlfDistanceWeight background_weights = 2;
inline int MlfDistanceConfig::_internal_background_weights_size() const {
  return _impl_.background_weights_.size();
}
inline int MlfDistanceConfig::background_weights_size() const {
  return _internal_background_weights_size();
}
inline void MlfDistanceConfig::clear_background_weights() {
  _impl_.background_weights_.Clear();
}
inline ::apollo::perception::lidar::MlfDistanceWeight* MlfDistanceConfig::mutable_background_weights(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfDistanceConfig.background_weights)
  return _impl_.background_weights_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >*
MlfDistanceConfig::mutable_background_weights() {
  // @@protoc_insertion_point(field_mutable_list:apollo.perception.lidar.MlfDistanceConfig.background_weights)
  return &_impl_.background_weights_;
}
inline const ::apollo::perception::lidar::MlfDistanceWeight& MlfDistanceConfig::_internal_background_weights(int index) const {
  return _impl_.background_weights_.Get(index);
}
inline const ::apollo::perception::lidar::MlfDistanceWeight& MlfDistanceConfig::background_weights(int index) const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceConfig.background_weights)
  return _internal_background_weights(index);
}
inline ::apollo::perception::lidar::MlfDistanceWeight* MlfDistanceConfig::_internal_add_background_weights() {
  return _impl_.background_weights_.Add();
}
inline ::apollo::perception::lidar::MlfDistanceWeight* MlfDistanceConfig::add_background_weights() {
  ::apollo::perception::lidar::MlfDistanceWeight* _add = _internal_add_background_weights();
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfDistanceConfig.background_weights)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >&
MlfDistanceConfig::background_weights() const {
  // @@protoc_insertion_point(field_list:apollo.perception.lidar.MlfDistanceConfig.background_weights)
  return _impl_.background_weights_;
}

// -------------------------------------------------------------------

// MlfTrackObjectMatcherConfig

// optional string foreground_mathcer_method = 1 [default = "MultiHmBipartiteGraphMatcher"];
inline bool MlfTrackObjectMatcherConfig::_internal_has_foreground_mathcer_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MlfTrackObjectMatcherConfig::has_foreground_mathcer_method() const {
  return _internal_has_foreground_mathcer_method();
}
inline void MlfTrackObjectMatcherConfig::clear_foreground_mathcer_method() {
  _impl_.foreground_mathcer_method_.ClearToDefault(::apollo::perception::lidar::MlfTrackObjectMatcherConfig::Impl_::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MlfTrackObjectMatcherConfig::foreground_mathcer_method() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
  if (_impl_.foreground_mathcer_method_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get();
  return _internal_foreground_mathcer_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MlfTrackObjectMatcherConfig::set_foreground_mathcer_method(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.foreground_mathcer_method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
}
inline std::string* MlfTrackObjectMatcherConfig::mutable_foreground_mathcer_method() {
  std::string* _s = _internal_mutable_foreground_mathcer_method();
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
  return _s;
}
inline const std::string& MlfTrackObjectMatcherConfig::_internal_foreground_mathcer_method() const {
  return _impl_.foreground_mathcer_method_.Get();
}
inline void MlfTrackObjectMatcherConfig::_internal_set_foreground_mathcer_method(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.foreground_mathcer_method_.Set(value, GetArenaForAllocation());
}
inline std::string* MlfTrackObjectMatcherConfig::_internal_mutable_foreground_mathcer_method() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.foreground_mathcer_method_.Mutable(::apollo::perception::lidar::MlfTrackObjectMatcherConfig::Impl_::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_, GetArenaForAllocation());
}
inline std::string* MlfTrackObjectMatcherConfig::release_foreground_mathcer_method() {
  // @@protoc_insertion_point(field_release:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
  if (!_internal_has_foreground_mathcer_method()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.foreground_mathcer_method_.Release();
  return p;
}
inline void MlfTrackObjectMatcherConfig::set_allocated_foreground_mathcer_method(std::string* foreground_mathcer_method) {
  if (foreground_mathcer_method != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.foreground_mathcer_method_.SetAllocated(foreground_mathcer_method, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
}

// optional string background_matcher_method = 2 [default = "GnnBipartiteGraphMatcher"];
inline bool MlfTrackObjectMatcherConfig::_internal_has_background_matcher_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MlfTrackObjectMatcherConfig::has_background_matcher_method() const {
  return _internal_has_background_matcher_method();
}
inline void MlfTrackObjectMatcherConfig::clear_background_matcher_method() {
  _impl_.background_matcher_method_.ClearToDefault(::apollo::perception::lidar::MlfTrackObjectMatcherConfig::Impl_::_i_give_permission_to_break_this_code_default_background_matcher_method_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MlfTrackObjectMatcherConfig::background_matcher_method() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
  if (_impl_.background_matcher_method_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_background_matcher_method_.get();
  return _internal_background_matcher_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MlfTrackObjectMatcherConfig::set_background_matcher_method(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.background_matcher_method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
}
inline std::string* MlfTrackObjectMatcherConfig::mutable_background_matcher_method() {
  std::string* _s = _internal_mutable_background_matcher_method();
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
  return _s;
}
inline const std::string& MlfTrackObjectMatcherConfig::_internal_background_matcher_method() const {
  return _impl_.background_matcher_method_.Get();
}
inline void MlfTrackObjectMatcherConfig::_internal_set_background_matcher_method(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.background_matcher_method_.Set(value, GetArenaForAllocation());
}
inline std::string* MlfTrackObjectMatcherConfig::_internal_mutable_background_matcher_method() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.background_matcher_method_.Mutable(::apollo::perception::lidar::MlfTrackObjectMatcherConfig::Impl_::_i_give_permission_to_break_this_code_default_background_matcher_method_, GetArenaForAllocation());
}
inline std::string* MlfTrackObjectMatcherConfig::release_background_matcher_method() {
  // @@protoc_insertion_point(field_release:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
  if (!_internal_has_background_matcher_method()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.background_matcher_method_.Release();
  return p;
}
inline void MlfTrackObjectMatcherConfig::set_allocated_background_matcher_method(std::string* background_matcher_method) {
  if (background_matcher_method != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.background_matcher_method_.SetAllocated(background_matcher_method, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
}

// optional float bound_value = 3 [default = 100];
inline bool MlfTrackObjectMatcherConfig::_internal_has_bound_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MlfTrackObjectMatcherConfig::has_bound_value() const {
  return _internal_has_bound_value();
}
inline void MlfTrackObjectMatcherConfig::clear_bound_value() {
  _impl_.bound_value_ = 100;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float MlfTrackObjectMatcherConfig::_internal_bound_value() const {
  return _impl_.bound_value_;
}
inline float MlfTrackObjectMatcherConfig::bound_value() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfTrackObjectMatcherConfig.bound_value)
  return _internal_bound_value();
}
inline void MlfTrackObjectMatcherConfig::_internal_set_bound_value(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.bound_value_ = value;
}
inline void MlfTrackObjectMatcherConfig::set_bound_value(float value) {
  _internal_set_bound_value(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackObjectMatcherConfig.bound_value)
}

// optional float max_match_distance = 4 [default = 4];
inline bool MlfTrackObjectMatcherConfig::_internal_has_max_match_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MlfTrackObjectMatcherConfig::has_max_match_distance() const {
  return _internal_has_max_match_distance();
}
inline void MlfTrackObjectMatcherConfig::clear_max_match_distance() {
  _impl_.max_match_distance_ = 4;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MlfTrackObjectMatcherConfig::_internal_max_match_distance() const {
  return _impl_.max_match_distance_;
}
inline float MlfTrackObjectMatcherConfig::max_match_distance() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfTrackObjectMatcherConfig.max_match_distance)
  return _internal_max_match_distance();
}
inline void MlfTrackObjectMatcherConfig::_internal_set_max_match_distance(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.max_match_distance_ = value;
}
inline void MlfTrackObjectMatcherConfig::set_max_match_distance(float value) {
  _internal_set_max_match_distance(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackObjectMatcherConfig.max_match_distance)
}

// -------------------------------------------------------------------

// MlfTrackerConfig

// repeated string filter_name = 1;
inline int MlfTrackerConfig::_internal_filter_name_size() const {
  return _impl_.filter_name_.size();
}
inline int MlfTrackerConfig::filter_name_size() const {
  return _internal_filter_name_size();
}
inline void MlfTrackerConfig::clear_filter_name() {
  _impl_.filter_name_.Clear();
}
inline std::string* MlfTrackerConfig::add_filter_name() {
  std::string* _s = _internal_add_filter_name();
  // @@protoc_insertion_point(field_add_mutable:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  return _s;
}
inline const std::string& MlfTrackerConfig::_internal_filter_name(int index) const {
  return _impl_.filter_name_.Get(index);
}
inline const std::string& MlfTrackerConfig::filter_name(int index) const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  return _internal_filter_name(index);
}
inline std::string* MlfTrackerConfig::mutable_filter_name(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  return _impl_.filter_name_.Mutable(index);
}
inline void MlfTrackerConfig::set_filter_name(int index, const std::string& value) {
  _impl_.filter_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline void MlfTrackerConfig::set_filter_name(int index, std::string&& value) {
  _impl_.filter_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline void MlfTrackerConfig::set_filter_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filter_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline void MlfTrackerConfig::set_filter_name(int index, const char* value, size_t size) {
  _impl_.filter_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline std::string* MlfTrackerConfig::_internal_add_filter_name() {
  return _impl_.filter_name_.Add();
}
inline void MlfTrackerConfig::add_filter_name(const std::string& value) {
  _impl_.filter_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline void MlfTrackerConfig::add_filter_name(std::string&& value) {
  _impl_.filter_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline void MlfTrackerConfig::add_filter_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filter_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline void MlfTrackerConfig::add_filter_name(const char* value, size_t size) {
  _impl_.filter_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MlfTrackerConfig::filter_name() const {
  // @@protoc_insertion_point(field_list:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  return _impl_.filter_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MlfTrackerConfig::mutable_filter_name() {
  // @@protoc_insertion_point(field_mutable_list:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  return &_impl_.filter_name_;
}

// -------------------------------------------------------------------

// MlfMotionFilterConfig

// optional bool use_adaptive = 1 [default = true];
inline bool MlfMotionFilterConfig::_internal_has_use_adaptive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_use_adaptive() const {
  return _internal_has_use_adaptive();
}
inline void MlfMotionFilterConfig::clear_use_adaptive() {
  _impl_.use_adaptive_ = true;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool MlfMotionFilterConfig::_internal_use_adaptive() const {
  return _impl_.use_adaptive_;
}
inline bool MlfMotionFilterConfig::use_adaptive() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.use_adaptive)
  return _internal_use_adaptive();
}
inline void MlfMotionFilterConfig::_internal_set_use_adaptive(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.use_adaptive_ = value;
}
inline void MlfMotionFilterConfig::set_use_adaptive(bool value) {
  _internal_set_use_adaptive(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.use_adaptive)
}

// optional bool use_breakdown = 2 [default = true];
inline bool MlfMotionFilterConfig::_internal_has_use_breakdown() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_use_breakdown() const {
  return _internal_has_use_breakdown();
}
inline void MlfMotionFilterConfig::clear_use_breakdown() {
  _impl_.use_breakdown_ = true;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MlfMotionFilterConfig::_internal_use_breakdown() const {
  return _impl_.use_breakdown_;
}
inline bool MlfMotionFilterConfig::use_breakdown() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.use_breakdown)
  return _internal_use_breakdown();
}
inline void MlfMotionFilterConfig::_internal_set_use_breakdown(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.use_breakdown_ = value;
}
inline void MlfMotionFilterConfig::set_use_breakdown(bool value) {
  _internal_set_use_breakdown(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.use_breakdown)
}

// optional bool use_convergence_boostup = 3 [default = true];
inline bool MlfMotionFilterConfig::_internal_has_use_convergence_boostup() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_use_convergence_boostup() const {
  return _internal_has_use_convergence_boostup();
}
inline void MlfMotionFilterConfig::clear_use_convergence_boostup() {
  _impl_.use_convergence_boostup_ = true;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool MlfMotionFilterConfig::_internal_use_convergence_boostup() const {
  return _impl_.use_convergence_boostup_;
}
inline bool MlfMotionFilterConfig::use_convergence_boostup() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.use_convergence_boostup)
  return _internal_use_convergence_boostup();
}
inline void MlfMotionFilterConfig::_internal_set_use_convergence_boostup(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.use_convergence_boostup_ = value;
}
inline void MlfMotionFilterConfig::set_use_convergence_boostup(bool value) {
  _internal_set_use_convergence_boostup(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.use_convergence_boostup)
}

// optional double init_velocity_variance = 4 [default = 5];
inline bool MlfMotionFilterConfig::_internal_has_init_velocity_variance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_init_velocity_variance() const {
  return _internal_has_init_velocity_variance();
}
inline void MlfMotionFilterConfig::clear_init_velocity_variance() {
  _impl_.init_velocity_variance_ = 5;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double MlfMotionFilterConfig::_internal_init_velocity_variance() const {
  return _impl_.init_velocity_variance_;
}
inline double MlfMotionFilterConfig::init_velocity_variance() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.init_velocity_variance)
  return _internal_init_velocity_variance();
}
inline void MlfMotionFilterConfig::_internal_set_init_velocity_variance(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.init_velocity_variance_ = value;
}
inline void MlfMotionFilterConfig::set_init_velocity_variance(double value) {
  _internal_set_init_velocity_variance(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.init_velocity_variance)
}

// optional double init_acceleration_variance = 5 [default = 10];
inline bool MlfMotionFilterConfig::_internal_has_init_acceleration_variance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_init_acceleration_variance() const {
  return _internal_has_init_acceleration_variance();
}
inline void MlfMotionFilterConfig::clear_init_acceleration_variance() {
  _impl_.init_acceleration_variance_ = 10;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double MlfMotionFilterConfig::_internal_init_acceleration_variance() const {
  return _impl_.init_acceleration_variance_;
}
inline double MlfMotionFilterConfig::init_acceleration_variance() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.init_acceleration_variance)
  return _internal_init_acceleration_variance();
}
inline void MlfMotionFilterConfig::_internal_set_init_acceleration_variance(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.init_acceleration_variance_ = value;
}
inline void MlfMotionFilterConfig::set_init_acceleration_variance(double value) {
  _internal_set_init_acceleration_variance(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.init_acceleration_variance)
}

// optional double measured_velocity_variance = 6 [default = 0.4];
inline bool MlfMotionFilterConfig::_internal_has_measured_velocity_variance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_measured_velocity_variance() const {
  return _internal_has_measured_velocity_variance();
}
inline void MlfMotionFilterConfig::clear_measured_velocity_variance() {
  _impl_.measured_velocity_variance_ = 0.4;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double MlfMotionFilterConfig::_internal_measured_velocity_variance() const {
  return _impl_.measured_velocity_variance_;
}
inline double MlfMotionFilterConfig::measured_velocity_variance() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.measured_velocity_variance)
  return _internal_measured_velocity_variance();
}
inline void MlfMotionFilterConfig::_internal_set_measured_velocity_variance(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.measured_velocity_variance_ = value;
}
inline void MlfMotionFilterConfig::set_measured_velocity_variance(double value) {
  _internal_set_measured_velocity_variance(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.measured_velocity_variance)
}

// optional double predict_variance_per_sqrsec = 7 [default = 10];
inline bool MlfMotionFilterConfig::_internal_has_predict_variance_per_sqrsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_predict_variance_per_sqrsec() const {
  return _internal_has_predict_variance_per_sqrsec();
}
inline void MlfMotionFilterConfig::clear_predict_variance_per_sqrsec() {
  _impl_.predict_variance_per_sqrsec_ = 10;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double MlfMotionFilterConfig::_internal_predict_variance_per_sqrsec() const {
  return _impl_.predict_variance_per_sqrsec_;
}
inline double MlfMotionFilterConfig::predict_variance_per_sqrsec() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.predict_variance_per_sqrsec)
  return _internal_predict_variance_per_sqrsec();
}
inline void MlfMotionFilterConfig::_internal_set_predict_variance_per_sqrsec(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.predict_variance_per_sqrsec_ = value;
}
inline void MlfMotionFilterConfig::set_predict_variance_per_sqrsec(double value) {
  _internal_set_predict_variance_per_sqrsec(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.predict_variance_per_sqrsec)
}

// optional uint32 boostup_history_size_minimum = 8 [default = 3];
inline bool MlfMotionFilterConfig::_internal_has_boostup_history_size_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_boostup_history_size_minimum() const {
  return _internal_has_boostup_history_size_minimum();
}
inline void MlfMotionFilterConfig::clear_boostup_history_size_minimum() {
  _impl_.boostup_history_size_minimum_ = 3u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MlfMotionFilterConfig::_internal_boostup_history_size_minimum() const {
  return _impl_.boostup_history_size_minimum_;
}
inline uint32_t MlfMotionFilterConfig::boostup_history_size_minimum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.boostup_history_size_minimum)
  return _internal_boostup_history_size_minimum();
}
inline void MlfMotionFilterConfig::_internal_set_boostup_history_size_minimum(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.boostup_history_size_minimum_ = value;
}
inline void MlfMotionFilterConfig::set_boostup_history_size_minimum(uint32_t value) {
  _internal_set_boostup_history_size_minimum(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.boostup_history_size_minimum)
}

// optional uint32 boostup_history_size_maximum = 9 [default = 6];
inline bool MlfMotionFilterConfig::_internal_has_boostup_history_size_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_boostup_history_size_maximum() const {
  return _internal_has_boostup_history_size_maximum();
}
inline void MlfMotionFilterConfig::clear_boostup_history_size_maximum() {
  _impl_.boostup_history_size_maximum_ = 6u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MlfMotionFilterConfig::_internal_boostup_history_size_maximum() const {
  return _impl_.boostup_history_size_maximum_;
}
inline uint32_t MlfMotionFilterConfig::boostup_history_size_maximum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.boostup_history_size_maximum)
  return _internal_boostup_history_size_maximum();
}
inline void MlfMotionFilterConfig::_internal_set_boostup_history_size_maximum(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.boostup_history_size_maximum_ = value;
}
inline void MlfMotionFilterConfig::set_boostup_history_size_maximum(uint32_t value) {
  _internal_set_boostup_history_size_maximum(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.boostup_history_size_maximum)
}

// optional double converged_confidence_minimum = 10 [default = 0.5];
inline bool MlfMotionFilterConfig::_internal_has_converged_confidence_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_converged_confidence_minimum() const {
  return _internal_has_converged_confidence_minimum();
}
inline void MlfMotionFilterConfig::clear_converged_confidence_minimum() {
  _impl_.converged_confidence_minimum_ = 0.5;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double MlfMotionFilterConfig::_internal_converged_confidence_minimum() const {
  return _impl_.converged_confidence_minimum_;
}
inline double MlfMotionFilterConfig::converged_confidence_minimum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.converged_confidence_minimum)
  return _internal_converged_confidence_minimum();
}
inline void MlfMotionFilterConfig::_internal_set_converged_confidence_minimum(double value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.converged_confidence_minimum_ = value;
}
inline void MlfMotionFilterConfig::set_converged_confidence_minimum(double value) {
  _internal_set_converged_confidence_minimum(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.converged_confidence_minimum)
}

// optional double noise_maximum = 12 [default = 0.1];
inline bool MlfMotionFilterConfig::_internal_has_noise_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_noise_maximum() const {
  return _internal_has_noise_maximum();
}
inline void MlfMotionFilterConfig::clear_noise_maximum() {
  _impl_.noise_maximum_ = 0.1;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline double MlfMotionFilterConfig::_internal_noise_maximum() const {
  return _impl_.noise_maximum_;
}
inline double MlfMotionFilterConfig::noise_maximum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.noise_maximum)
  return _internal_noise_maximum();
}
inline void MlfMotionFilterConfig::_internal_set_noise_maximum(double value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.noise_maximum_ = value;
}
inline void MlfMotionFilterConfig::set_noise_maximum(double value) {
  _internal_set_noise_maximum(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.noise_maximum)
}

// optional double trust_orientation_range = 13 [default = 40];
inline bool MlfMotionFilterConfig::_internal_has_trust_orientation_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool MlfMotionFilterConfig::has_trust_orientation_range() const {
  return _internal_has_trust_orientation_range();
}
inline void MlfMotionFilterConfig::clear_trust_orientation_range() {
  _impl_.trust_orientation_range_ = 40;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline double MlfMotionFilterConfig::_internal_trust_orientation_range() const {
  return _impl_.trust_orientation_range_;
}
inline double MlfMotionFilterConfig::trust_orientation_range() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.trust_orientation_range)
  return _internal_trust_orientation_range();
}
inline void MlfMotionFilterConfig::_internal_set_trust_orientation_range(double value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.trust_orientation_range_ = value;
}
inline void MlfMotionFilterConfig::set_trust_orientation_range(double value) {
  _internal_set_trust_orientation_range(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.trust_orientation_range)
}

// -------------------------------------------------------------------

// MlfMotionRefinerConfig

// optional double claping_acceleration_threshold = 1 [default = 10];
inline bool MlfMotionRefinerConfig::_internal_has_claping_acceleration_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MlfMotionRefinerConfig::has_claping_acceleration_threshold() const {
  return _internal_has_claping_acceleration_threshold();
}
inline void MlfMotionRefinerConfig::clear_claping_acceleration_threshold() {
  _impl_.claping_acceleration_threshold_ = 10;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double MlfMotionRefinerConfig::_internal_claping_acceleration_threshold() const {
  return _impl_.claping_acceleration_threshold_;
}
inline double MlfMotionRefinerConfig::claping_acceleration_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionRefinerConfig.claping_acceleration_threshold)
  return _internal_claping_acceleration_threshold();
}
inline void MlfMotionRefinerConfig::_internal_set_claping_acceleration_threshold(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.claping_acceleration_threshold_ = value;
}
inline void MlfMotionRefinerConfig::set_claping_acceleration_threshold(double value) {
  _internal_set_claping_acceleration_threshold(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionRefinerConfig.claping_acceleration_threshold)
}

// optional double claping_speed_threshold = 2 [default = 1];
inline bool MlfMotionRefinerConfig::_internal_has_claping_speed_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MlfMotionRefinerConfig::has_claping_speed_threshold() const {
  return _internal_has_claping_speed_threshold();
}
inline void MlfMotionRefinerConfig::clear_claping_speed_threshold() {
  _impl_.claping_speed_threshold_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double MlfMotionRefinerConfig::_internal_claping_speed_threshold() const {
  return _impl_.claping_speed_threshold_;
}
inline double MlfMotionRefinerConfig::claping_speed_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionRefinerConfig.claping_speed_threshold)
  return _internal_claping_speed_threshold();
}
inline void MlfMotionRefinerConfig::_internal_set_claping_speed_threshold(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.claping_speed_threshold_ = value;
}
inline void MlfMotionRefinerConfig::set_claping_speed_threshold(double value) {
  _internal_set_claping_speed_threshold(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionRefinerConfig.claping_speed_threshold)
}

// -------------------------------------------------------------------

// MlfShapeFilterConfig

// optional double bottom_points_ignore_threshold = 1 [default = 0.1];
inline bool MlfShapeFilterConfig::_internal_has_bottom_points_ignore_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MlfShapeFilterConfig::has_bottom_points_ignore_threshold() const {
  return _internal_has_bottom_points_ignore_threshold();
}
inline void MlfShapeFilterConfig::clear_bottom_points_ignore_threshold() {
  _impl_.bottom_points_ignore_threshold_ = 0.1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double MlfShapeFilterConfig::_internal_bottom_points_ignore_threshold() const {
  return _impl_.bottom_points_ignore_threshold_;
}
inline double MlfShapeFilterConfig::bottom_points_ignore_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfShapeFilterConfig.bottom_points_ignore_threshold)
  return _internal_bottom_points_ignore_threshold();
}
inline void MlfShapeFilterConfig::_internal_set_bottom_points_ignore_threshold(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bottom_points_ignore_threshold_ = value;
}
inline void MlfShapeFilterConfig::set_bottom_points_ignore_threshold(double value) {
  _internal_set_bottom_points_ignore_threshold(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfShapeFilterConfig.bottom_points_ignore_threshold)
}

// optional double top_points_ignore_threshold = 2 [default = 1.6];
inline bool MlfShapeFilterConfig::_internal_has_top_points_ignore_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MlfShapeFilterConfig::has_top_points_ignore_threshold() const {
  return _internal_has_top_points_ignore_threshold();
}
inline void MlfShapeFilterConfig::clear_top_points_ignore_threshold() {
  _impl_.top_points_ignore_threshold_ = 1.6;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double MlfShapeFilterConfig::_internal_top_points_ignore_threshold() const {
  return _impl_.top_points_ignore_threshold_;
}
inline double MlfShapeFilterConfig::top_points_ignore_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfShapeFilterConfig.top_points_ignore_threshold)
  return _internal_top_points_ignore_threshold();
}
inline void MlfShapeFilterConfig::_internal_set_top_points_ignore_threshold(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.top_points_ignore_threshold_ = value;
}
inline void MlfShapeFilterConfig::set_top_points_ignore_threshold(double value) {
  _internal_set_top_points_ignore_threshold(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfShapeFilterConfig.top_points_ignore_threshold)
}

// -------------------------------------------------------------------

// MlfEngineConfig

// repeated string main_sensor = 1;
inline int MlfEngineConfig::_internal_main_sensor_size() const {
  return _impl_.main_sensor_.size();
}
inline int MlfEngineConfig::main_sensor_size() const {
  return _internal_main_sensor_size();
}
inline void MlfEngineConfig::clear_main_sensor() {
  _impl_.main_sensor_.Clear();
}
inline std::string* MlfEngineConfig::add_main_sensor() {
  std::string* _s = _internal_add_main_sensor();
  // @@protoc_insertion_point(field_add_mutable:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  return _s;
}
inline const std::string& MlfEngineConfig::_internal_main_sensor(int index) const {
  return _impl_.main_sensor_.Get(index);
}
inline const std::string& MlfEngineConfig::main_sensor(int index) const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  return _internal_main_sensor(index);
}
inline std::string* MlfEngineConfig::mutable_main_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  return _impl_.main_sensor_.Mutable(index);
}
inline void MlfEngineConfig::set_main_sensor(int index, const std::string& value) {
  _impl_.main_sensor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline void MlfEngineConfig::set_main_sensor(int index, std::string&& value) {
  _impl_.main_sensor_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline void MlfEngineConfig::set_main_sensor(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.main_sensor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline void MlfEngineConfig::set_main_sensor(int index, const char* value, size_t size) {
  _impl_.main_sensor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline std::string* MlfEngineConfig::_internal_add_main_sensor() {
  return _impl_.main_sensor_.Add();
}
inline void MlfEngineConfig::add_main_sensor(const std::string& value) {
  _impl_.main_sensor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline void MlfEngineConfig::add_main_sensor(std::string&& value) {
  _impl_.main_sensor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline void MlfEngineConfig::add_main_sensor(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.main_sensor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline void MlfEngineConfig::add_main_sensor(const char* value, size_t size) {
  _impl_.main_sensor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MlfEngineConfig::main_sensor() const {
  // @@protoc_insertion_point(field_list:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  return _impl_.main_sensor_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MlfEngineConfig::mutable_main_sensor() {
  // @@protoc_insertion_point(field_mutable_list:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  return &_impl_.main_sensor_;
}

// optional bool use_histogram_for_match = 2 [default = true];
inline bool MlfEngineConfig::_internal_has_use_histogram_for_match() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MlfEngineConfig::has_use_histogram_for_match() const {
  return _internal_has_use_histogram_for_match();
}
inline void MlfEngineConfig::clear_use_histogram_for_match() {
  _impl_.use_histogram_for_match_ = true;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MlfEngineConfig::_internal_use_histogram_for_match() const {
  return _impl_.use_histogram_for_match_;
}
inline bool MlfEngineConfig::use_histogram_for_match() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.use_histogram_for_match)
  return _internal_use_histogram_for_match();
}
inline void MlfEngineConfig::_internal_set_use_histogram_for_match(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.use_histogram_for_match_ = value;
}
inline void MlfEngineConfig::set_use_histogram_for_match(bool value) {
  _internal_set_use_histogram_for_match(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.use_histogram_for_match)
}

// optional uint32 histogram_bin_size = 3 [default = 10];
inline bool MlfEngineConfig::_internal_has_histogram_bin_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MlfEngineConfig::has_histogram_bin_size() const {
  return _internal_has_histogram_bin_size();
}
inline void MlfEngineConfig::clear_histogram_bin_size() {
  _impl_.histogram_bin_size_ = 10u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MlfEngineConfig::_internal_histogram_bin_size() const {
  return _impl_.histogram_bin_size_;
}
inline uint32_t MlfEngineConfig::histogram_bin_size() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.histogram_bin_size)
  return _internal_histogram_bin_size();
}
inline void MlfEngineConfig::_internal_set_histogram_bin_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.histogram_bin_size_ = value;
}
inline void MlfEngineConfig::set_histogram_bin_size(uint32_t value) {
  _internal_set_histogram_bin_size(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.histogram_bin_size)
}

// optional bool output_predict_objects = 4 [default = false];
inline bool MlfEngineConfig::_internal_has_output_predict_objects() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MlfEngineConfig::has_output_predict_objects() const {
  return _internal_has_output_predict_objects();
}
inline void MlfEngineConfig::clear_output_predict_objects() {
  _impl_.output_predict_objects_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MlfEngineConfig::_internal_output_predict_objects() const {
  return _impl_.output_predict_objects_;
}
inline bool MlfEngineConfig::output_predict_objects() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.output_predict_objects)
  return _internal_output_predict_objects();
}
inline void MlfEngineConfig::_internal_set_output_predict_objects(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.output_predict_objects_ = value;
}
inline void MlfEngineConfig::set_output_predict_objects(bool value) {
  _internal_set_output_predict_objects(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.output_predict_objects)
}

// optional double reserved_invisible_time = 5 [default = 0.2];
inline bool MlfEngineConfig::_internal_has_reserved_invisible_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MlfEngineConfig::has_reserved_invisible_time() const {
  return _internal_has_reserved_invisible_time();
}
inline void MlfEngineConfig::clear_reserved_invisible_time() {
  _impl_.reserved_invisible_time_ = 0.2;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double MlfEngineConfig::_internal_reserved_invisible_time() const {
  return _impl_.reserved_invisible_time_;
}
inline double MlfEngineConfig::reserved_invisible_time() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.reserved_invisible_time)
  return _internal_reserved_invisible_time();
}
inline void MlfEngineConfig::_internal_set_reserved_invisible_time(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.reserved_invisible_time_ = value;
}
inline void MlfEngineConfig::set_reserved_invisible_time(double value) {
  _internal_set_reserved_invisible_time(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.reserved_invisible_time)
}

// optional bool use_frame_timestamp = 6 [default = false];
inline bool MlfEngineConfig::_internal_has_use_frame_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MlfEngineConfig::has_use_frame_timestamp() const {
  return _internal_has_use_frame_timestamp();
}
inline void MlfEngineConfig::clear_use_frame_timestamp() {
  _impl_.use_frame_timestamp_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool MlfEngineConfig::_internal_use_frame_timestamp() const {
  return _impl_.use_frame_timestamp_;
}
inline bool MlfEngineConfig::use_frame_timestamp() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.use_frame_timestamp)
  return _internal_use_frame_timestamp();
}
inline void MlfEngineConfig::_internal_set_use_frame_timestamp(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.use_frame_timestamp_ = value;
}
inline void MlfEngineConfig::set_use_frame_timestamp(bool value) {
  _internal_set_use_frame_timestamp(value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.use_frame_timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lidar
}  // namespace perception
}  // namespace apollo

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fperception_2flidar_2flib_2ftracker_2fmulti_5flidar_5ffusion_2fproto_2fmulti_5flidar_5ffusion_5fconfig_2eproto
