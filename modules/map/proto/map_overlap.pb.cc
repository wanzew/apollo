// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/map/proto/map_overlap.proto

#include "modules/map/proto/map_overlap.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace apollo {
namespace hdmap {
PROTOBUF_CONSTEXPR LaneOverlapInfo::LaneOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.region_overlap_id_)*/nullptr
  , /*decltype(_impl_.start_s_)*/0
  , /*decltype(_impl_.end_s_)*/0
  , /*decltype(_impl_.is_merge_)*/false} {}
struct LaneOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaneOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaneOverlapInfoDefaultTypeInternal() {}
  union {
    LaneOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaneOverlapInfoDefaultTypeInternal _LaneOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR SignalOverlapInfo::SignalOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{} {}
struct SignalOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignalOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignalOverlapInfoDefaultTypeInternal() {}
  union {
    SignalOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignalOverlapInfoDefaultTypeInternal _SignalOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR StopSignOverlapInfo::StopSignOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{} {}
struct StopSignOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StopSignOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StopSignOverlapInfoDefaultTypeInternal() {}
  union {
    StopSignOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StopSignOverlapInfoDefaultTypeInternal _StopSignOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR CrosswalkOverlapInfo::CrosswalkOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.region_overlap_id_)*/nullptr} {}
struct CrosswalkOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CrosswalkOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CrosswalkOverlapInfoDefaultTypeInternal() {}
  union {
    CrosswalkOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CrosswalkOverlapInfoDefaultTypeInternal _CrosswalkOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR JunctionOverlapInfo::JunctionOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{} {}
struct JunctionOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JunctionOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JunctionOverlapInfoDefaultTypeInternal() {}
  union {
    JunctionOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JunctionOverlapInfoDefaultTypeInternal _JunctionOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR YieldOverlapInfo::YieldOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{} {}
struct YieldOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR YieldOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~YieldOverlapInfoDefaultTypeInternal() {}
  union {
    YieldOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 YieldOverlapInfoDefaultTypeInternal _YieldOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR ClearAreaOverlapInfo::ClearAreaOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{} {}
struct ClearAreaOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClearAreaOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClearAreaOverlapInfoDefaultTypeInternal() {}
  union {
    ClearAreaOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearAreaOverlapInfoDefaultTypeInternal _ClearAreaOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR SpeedBumpOverlapInfo::SpeedBumpOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{} {}
struct SpeedBumpOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpeedBumpOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpeedBumpOverlapInfoDefaultTypeInternal() {}
  union {
    SpeedBumpOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpeedBumpOverlapInfoDefaultTypeInternal _SpeedBumpOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR ParkingSpaceOverlapInfo::ParkingSpaceOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{} {}
struct ParkingSpaceOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParkingSpaceOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParkingSpaceOverlapInfoDefaultTypeInternal() {}
  union {
    ParkingSpaceOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParkingSpaceOverlapInfoDefaultTypeInternal _ParkingSpaceOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR PNCJunctionOverlapInfo::PNCJunctionOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{} {}
struct PNCJunctionOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PNCJunctionOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PNCJunctionOverlapInfoDefaultTypeInternal() {}
  union {
    PNCJunctionOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PNCJunctionOverlapInfoDefaultTypeInternal _PNCJunctionOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR RSUOverlapInfo::RSUOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{} {}
struct RSUOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RSUOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RSUOverlapInfoDefaultTypeInternal() {}
  union {
    RSUOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RSUOverlapInfoDefaultTypeInternal _RSUOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR RegionOverlapInfo::RegionOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.polygon_)*/{}
  , /*decltype(_impl_.id_)*/nullptr} {}
struct RegionOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RegionOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RegionOverlapInfoDefaultTypeInternal() {}
  union {
    RegionOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RegionOverlapInfoDefaultTypeInternal _RegionOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR ObjectOverlapInfo::ObjectOverlapInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/nullptr
  , /*decltype(_impl_.overlap_info_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ObjectOverlapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObjectOverlapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObjectOverlapInfoDefaultTypeInternal() {}
  union {
    ObjectOverlapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObjectOverlapInfoDefaultTypeInternal _ObjectOverlapInfo_default_instance_;
PROTOBUF_CONSTEXPR Overlap::Overlap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_)*/{}
  , /*decltype(_impl_.region_overlap_)*/{}
  , /*decltype(_impl_.id_)*/nullptr} {}
struct OverlapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OverlapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OverlapDefaultTypeInternal() {}
  union {
    Overlap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OverlapDefaultTypeInternal _Overlap_default_instance_;
}  // namespace hdmap
}  // namespace apollo
static ::_pb::Metadata file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[14];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_modules_2fmap_2fproto_2fmap_5foverlap_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_modules_2fmap_2fproto_2fmap_5foverlap_2eproto = nullptr;

const uint32_t TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::LaneOverlapInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::LaneOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::LaneOverlapInfo, _impl_.start_s_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::LaneOverlapInfo, _impl_.end_s_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::LaneOverlapInfo, _impl_.is_merge_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::LaneOverlapInfo, _impl_.region_overlap_id_),
  1,
  2,
  3,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::SignalOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::StopSignOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::CrosswalkOverlapInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::CrosswalkOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::CrosswalkOverlapInfo, _impl_.region_overlap_id_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::JunctionOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::YieldOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::ClearAreaOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::SpeedBumpOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::ParkingSpaceOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::PNCJunctionOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::RSUOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::RegionOverlapInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::RegionOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::RegionOverlapInfo, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::RegionOverlapInfo, _impl_.polygon_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::ObjectOverlapInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::ObjectOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::ObjectOverlapInfo, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::ObjectOverlapInfo, _impl_.id_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::ObjectOverlapInfo, _impl_.overlap_info_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::Overlap, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::Overlap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::Overlap, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::Overlap, _impl_.object_),
  PROTOBUF_FIELD_OFFSET(::apollo::hdmap::Overlap, _impl_.region_overlap_),
  0,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::apollo::hdmap::LaneOverlapInfo)},
  { 14, -1, -1, sizeof(::apollo::hdmap::SignalOverlapInfo)},
  { 20, -1, -1, sizeof(::apollo::hdmap::StopSignOverlapInfo)},
  { 26, 33, -1, sizeof(::apollo::hdmap::CrosswalkOverlapInfo)},
  { 34, -1, -1, sizeof(::apollo::hdmap::JunctionOverlapInfo)},
  { 40, -1, -1, sizeof(::apollo::hdmap::YieldOverlapInfo)},
  { 46, -1, -1, sizeof(::apollo::hdmap::ClearAreaOverlapInfo)},
  { 52, -1, -1, sizeof(::apollo::hdmap::SpeedBumpOverlapInfo)},
  { 58, -1, -1, sizeof(::apollo::hdmap::ParkingSpaceOverlapInfo)},
  { 64, -1, -1, sizeof(::apollo::hdmap::PNCJunctionOverlapInfo)},
  { 70, -1, -1, sizeof(::apollo::hdmap::RSUOverlapInfo)},
  { 76, 84, -1, sizeof(::apollo::hdmap::RegionOverlapInfo)},
  { 86, 105, -1, sizeof(::apollo::hdmap::ObjectOverlapInfo)},
  { 117, 126, -1, sizeof(::apollo::hdmap::Overlap)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::apollo::hdmap::_LaneOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_SignalOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_StopSignOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_CrosswalkOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_JunctionOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_YieldOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_ClearAreaOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_SpeedBumpOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_ParkingSpaceOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_PNCJunctionOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_RSUOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_RegionOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_ObjectOverlapInfo_default_instance_._instance,
  &::apollo::hdmap::_Overlap_default_instance_._instance,
};

const char descriptor_table_protodef_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n#modules/map/proto/map_overlap.proto\022\014a"
  "pollo.hdmap\032\036modules/map/proto/map_id.pr"
  "oto\032$modules/map/proto/map_geometry.prot"
  "o\"p\n\017LaneOverlapInfo\022\017\n\007start_s\030\001 \001(\001\022\r\n"
  "\005end_s\030\002 \001(\001\022\020\n\010is_merge\030\003 \001(\010\022+\n\021region"
  "_overlap_id\030\004 \001(\0132\020.apollo.hdmap.Id\"\023\n\021S"
  "ignalOverlapInfo\"\025\n\023StopSignOverlapInfo\""
  "C\n\024CrosswalkOverlapInfo\022+\n\021region_overla"
  "p_id\030\001 \001(\0132\020.apollo.hdmap.Id\"\025\n\023Junction"
  "OverlapInfo\"\022\n\020YieldOverlapInfo\"\026\n\024Clear"
  "AreaOverlapInfo\"\026\n\024SpeedBumpOverlapInfo\""
  "\031\n\027ParkingSpaceOverlapInfo\"\030\n\026PNCJunctio"
  "nOverlapInfo\"\020\n\016RSUOverlapInfo\"Y\n\021Region"
  "OverlapInfo\022\034\n\002id\030\001 \001(\0132\020.apollo.hdmap.I"
  "d\022&\n\007polygon\030\002 \003(\0132\025.apollo.hdmap.Polygo"
  "n\"\257\006\n\021ObjectOverlapInfo\022\034\n\002id\030\001 \001(\0132\020.ap"
  "ollo.hdmap.Id\022:\n\021lane_overlap_info\030\003 \001(\013"
  "2\035.apollo.hdmap.LaneOverlapInfoH\000\022>\n\023sig"
  "nal_overlap_info\030\004 \001(\0132\037.apollo.hdmap.Si"
  "gnalOverlapInfoH\000\022C\n\026stop_sign_overlap_i"
  "nfo\030\005 \001(\0132!.apollo.hdmap.StopSignOverlap"
  "InfoH\000\022D\n\026crosswalk_overlap_info\030\006 \001(\0132\""
  ".apollo.hdmap.CrosswalkOverlapInfoH\000\022B\n\025"
  "junction_overlap_info\030\007 \001(\0132!.apollo.hdm"
  "ap.JunctionOverlapInfoH\000\022A\n\027yield_sign_o"
  "verlap_info\030\010 \001(\0132\036.apollo.hdmap.YieldOv"
  "erlapInfoH\000\022E\n\027clear_area_overlap_info\030\t"
  " \001(\0132\".apollo.hdmap.ClearAreaOverlapInfo"
  "H\000\022E\n\027speed_bump_overlap_info\030\n \001(\0132\".ap"
  "ollo.hdmap.SpeedBumpOverlapInfoH\000\022K\n\032par"
  "king_space_overlap_info\030\013 \001(\0132%.apollo.h"
  "dmap.ParkingSpaceOverlapInfoH\000\022I\n\031pnc_ju"
  "nction_overlap_info\030\014 \001(\0132$.apollo.hdmap"
  ".PNCJunctionOverlapInfoH\000\0228\n\020rsu_overlap"
  "_info\030\r \001(\0132\034.apollo.hdmap.RSUOverlapInf"
  "oH\000B\016\n\014overlap_info\"\221\001\n\007Overlap\022\034\n\002id\030\001 "
  "\001(\0132\020.apollo.hdmap.Id\022/\n\006object\030\002 \003(\0132\037."
  "apollo.hdmap.ObjectOverlapInfo\0227\n\016region"
  "_overlap\030\003 \003(\0132\037.apollo.hdmap.RegionOver"
  "lapInfo"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_deps[2] = {
  &::descriptor_table_modules_2fmap_2fproto_2fmap_5fgeometry_2eproto,
  &::descriptor_table_modules_2fmap_2fproto_2fmap_5fid_2eproto,
};
static ::_pbi::once_flag descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto = {
    false, false, 1567, descriptor_table_protodef_modules_2fmap_2fproto_2fmap_5foverlap_2eproto,
    "modules/map/proto/map_overlap.proto",
    &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once, descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_deps, 2, 14,
    schemas, file_default_instances, TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::offsets,
    file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto, file_level_enum_descriptors_modules_2fmap_2fproto_2fmap_5foverlap_2eproto,
    file_level_service_descriptors_modules_2fmap_2fproto_2fmap_5foverlap_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter() {
  return &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_modules_2fmap_2fproto_2fmap_5foverlap_2eproto(&descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
namespace apollo {
namespace hdmap {

// ===================================================================

class LaneOverlapInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<LaneOverlapInfo>()._impl_._has_bits_);
  static void set_has_start_s(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_end_s(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_merge(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::apollo::hdmap::Id& region_overlap_id(const LaneOverlapInfo* msg);
  static void set_has_region_overlap_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::apollo::hdmap::Id&
LaneOverlapInfo::_Internal::region_overlap_id(const LaneOverlapInfo* msg) {
  return *msg->_impl_.region_overlap_id_;
}
void LaneOverlapInfo::clear_region_overlap_id() {
  if (_impl_.region_overlap_id_ != nullptr) _impl_.region_overlap_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
LaneOverlapInfo::LaneOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.LaneOverlapInfo)
}
LaneOverlapInfo::LaneOverlapInfo(const LaneOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.region_overlap_id_){nullptr}
    , decltype(_impl_.start_s_){}
    , decltype(_impl_.end_s_){}
    , decltype(_impl_.is_merge_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_region_overlap_id()) {
    _impl_.region_overlap_id_ = new ::apollo::hdmap::Id(*from._impl_.region_overlap_id_);
  }
  ::memcpy(&_impl_.start_s_, &from._impl_.start_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_merge_) -
    reinterpret_cast<char*>(&_impl_.start_s_)) + sizeof(_impl_.is_merge_));
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.LaneOverlapInfo)
}

inline void LaneOverlapInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.region_overlap_id_){nullptr}
    , decltype(_impl_.start_s_){0}
    , decltype(_impl_.end_s_){0}
    , decltype(_impl_.is_merge_){false}
  };
}

LaneOverlapInfo::~LaneOverlapInfo() {
  // @@protoc_insertion_point(destructor:apollo.hdmap.LaneOverlapInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LaneOverlapInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.region_overlap_id_;
}

void LaneOverlapInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LaneOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.hdmap.LaneOverlapInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.region_overlap_id_ != nullptr);
    _impl_.region_overlap_id_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.start_s_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_merge_) -
        reinterpret_cast<char*>(&_impl_.start_s_)) + sizeof(_impl_.is_merge_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LaneOverlapInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double start_s = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_start_s(&has_bits);
          _impl_.start_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double end_s = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_end_s(&has_bits);
          _impl_.end_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_merge = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_merge(&has_bits);
          _impl_.is_merge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .apollo.hdmap.Id region_overlap_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_region_overlap_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LaneOverlapInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.hdmap.LaneOverlapInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double start_s = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_start_s(), target);
  }

  // optional double end_s = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_end_s(), target);
  }

  // optional bool is_merge = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_merge(), target);
  }

  // optional .apollo.hdmap.Id region_overlap_id = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::region_overlap_id(this),
        _Internal::region_overlap_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.hdmap.LaneOverlapInfo)
  return target;
}

size_t LaneOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.hdmap.LaneOverlapInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .apollo.hdmap.Id region_overlap_id = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.region_overlap_id_);
    }

    // optional double start_s = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double end_s = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional bool is_merge = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LaneOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LaneOverlapInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LaneOverlapInfo::GetClassData() const { return &_class_data_; }

void LaneOverlapInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LaneOverlapInfo *>(to)->MergeFrom(
      static_cast<const LaneOverlapInfo &>(from));
}


void LaneOverlapInfo::MergeFrom(const LaneOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.hdmap.LaneOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_region_overlap_id()->::apollo::hdmap::Id::MergeFrom(from._internal_region_overlap_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.start_s_ = from._impl_.start_s_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.end_s_ = from._impl_.end_s_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.is_merge_ = from._impl_.is_merge_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LaneOverlapInfo::CopyFrom(const LaneOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.hdmap.LaneOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneOverlapInfo::IsInitialized() const {
  return true;
}

void LaneOverlapInfo::InternalSwap(LaneOverlapInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaneOverlapInfo, _impl_.is_merge_)
      + sizeof(LaneOverlapInfo::_impl_.is_merge_)
      - PROTOBUF_FIELD_OFFSET(LaneOverlapInfo, _impl_.region_overlap_id_)>(
          reinterpret_cast<char*>(&_impl_.region_overlap_id_),
          reinterpret_cast<char*>(&other->_impl_.region_overlap_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LaneOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[0]);
}

// ===================================================================

class SignalOverlapInfo::_Internal {
 public:
};

SignalOverlapInfo::SignalOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.SignalOverlapInfo)
}
SignalOverlapInfo::SignalOverlapInfo(const SignalOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  new (&_impl_) Impl_{};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.SignalOverlapInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignalOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignalOverlapInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata SignalOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[1]);
}

// ===================================================================

class StopSignOverlapInfo::_Internal {
 public:
};

StopSignOverlapInfo::StopSignOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.StopSignOverlapInfo)
}
StopSignOverlapInfo::StopSignOverlapInfo(const StopSignOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  new (&_impl_) Impl_{};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.StopSignOverlapInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StopSignOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StopSignOverlapInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata StopSignOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[2]);
}

// ===================================================================

class CrosswalkOverlapInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CrosswalkOverlapInfo>()._impl_._has_bits_);
  static const ::apollo::hdmap::Id& region_overlap_id(const CrosswalkOverlapInfo* msg);
  static void set_has_region_overlap_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::apollo::hdmap::Id&
CrosswalkOverlapInfo::_Internal::region_overlap_id(const CrosswalkOverlapInfo* msg) {
  return *msg->_impl_.region_overlap_id_;
}
void CrosswalkOverlapInfo::clear_region_overlap_id() {
  if (_impl_.region_overlap_id_ != nullptr) _impl_.region_overlap_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CrosswalkOverlapInfo::CrosswalkOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.CrosswalkOverlapInfo)
}
CrosswalkOverlapInfo::CrosswalkOverlapInfo(const CrosswalkOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.region_overlap_id_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_region_overlap_id()) {
    _impl_.region_overlap_id_ = new ::apollo::hdmap::Id(*from._impl_.region_overlap_id_);
  }
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.CrosswalkOverlapInfo)
}

inline void CrosswalkOverlapInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.region_overlap_id_){nullptr}
  };
}

CrosswalkOverlapInfo::~CrosswalkOverlapInfo() {
  // @@protoc_insertion_point(destructor:apollo.hdmap.CrosswalkOverlapInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CrosswalkOverlapInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.region_overlap_id_;
}

void CrosswalkOverlapInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CrosswalkOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.hdmap.CrosswalkOverlapInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.region_overlap_id_ != nullptr);
    _impl_.region_overlap_id_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CrosswalkOverlapInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.hdmap.Id region_overlap_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_region_overlap_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CrosswalkOverlapInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.hdmap.CrosswalkOverlapInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.hdmap.Id region_overlap_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::region_overlap_id(this),
        _Internal::region_overlap_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.hdmap.CrosswalkOverlapInfo)
  return target;
}

size_t CrosswalkOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.hdmap.CrosswalkOverlapInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .apollo.hdmap.Id region_overlap_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.region_overlap_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CrosswalkOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CrosswalkOverlapInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CrosswalkOverlapInfo::GetClassData() const { return &_class_data_; }

void CrosswalkOverlapInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CrosswalkOverlapInfo *>(to)->MergeFrom(
      static_cast<const CrosswalkOverlapInfo &>(from));
}


void CrosswalkOverlapInfo::MergeFrom(const CrosswalkOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.hdmap.CrosswalkOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_region_overlap_id()) {
    _internal_mutable_region_overlap_id()->::apollo::hdmap::Id::MergeFrom(from._internal_region_overlap_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CrosswalkOverlapInfo::CopyFrom(const CrosswalkOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.hdmap.CrosswalkOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrosswalkOverlapInfo::IsInitialized() const {
  return true;
}

void CrosswalkOverlapInfo::InternalSwap(CrosswalkOverlapInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.region_overlap_id_, other->_impl_.region_overlap_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CrosswalkOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[3]);
}

// ===================================================================

class JunctionOverlapInfo::_Internal {
 public:
};

JunctionOverlapInfo::JunctionOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.JunctionOverlapInfo)
}
JunctionOverlapInfo::JunctionOverlapInfo(const JunctionOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  new (&_impl_) Impl_{};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.JunctionOverlapInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JunctionOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JunctionOverlapInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata JunctionOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[4]);
}

// ===================================================================

class YieldOverlapInfo::_Internal {
 public:
};

YieldOverlapInfo::YieldOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.YieldOverlapInfo)
}
YieldOverlapInfo::YieldOverlapInfo(const YieldOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  new (&_impl_) Impl_{};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.YieldOverlapInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData YieldOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*YieldOverlapInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata YieldOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[5]);
}

// ===================================================================

class ClearAreaOverlapInfo::_Internal {
 public:
};

ClearAreaOverlapInfo::ClearAreaOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.ClearAreaOverlapInfo)
}
ClearAreaOverlapInfo::ClearAreaOverlapInfo(const ClearAreaOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  new (&_impl_) Impl_{};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.ClearAreaOverlapInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClearAreaOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClearAreaOverlapInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ClearAreaOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[6]);
}

// ===================================================================

class SpeedBumpOverlapInfo::_Internal {
 public:
};

SpeedBumpOverlapInfo::SpeedBumpOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.SpeedBumpOverlapInfo)
}
SpeedBumpOverlapInfo::SpeedBumpOverlapInfo(const SpeedBumpOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  new (&_impl_) Impl_{};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.SpeedBumpOverlapInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpeedBumpOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpeedBumpOverlapInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata SpeedBumpOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[7]);
}

// ===================================================================

class ParkingSpaceOverlapInfo::_Internal {
 public:
};

ParkingSpaceOverlapInfo::ParkingSpaceOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.ParkingSpaceOverlapInfo)
}
ParkingSpaceOverlapInfo::ParkingSpaceOverlapInfo(const ParkingSpaceOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  new (&_impl_) Impl_{};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.ParkingSpaceOverlapInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ParkingSpaceOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ParkingSpaceOverlapInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ParkingSpaceOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[8]);
}

// ===================================================================

class PNCJunctionOverlapInfo::_Internal {
 public:
};

PNCJunctionOverlapInfo::PNCJunctionOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.PNCJunctionOverlapInfo)
}
PNCJunctionOverlapInfo::PNCJunctionOverlapInfo(const PNCJunctionOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  new (&_impl_) Impl_{};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.PNCJunctionOverlapInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PNCJunctionOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PNCJunctionOverlapInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata PNCJunctionOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[9]);
}

// ===================================================================

class RSUOverlapInfo::_Internal {
 public:
};

RSUOverlapInfo::RSUOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.RSUOverlapInfo)
}
RSUOverlapInfo::RSUOverlapInfo(const RSUOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  new (&_impl_) Impl_{};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.RSUOverlapInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RSUOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RSUOverlapInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata RSUOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[10]);
}

// ===================================================================

class RegionOverlapInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<RegionOverlapInfo>()._impl_._has_bits_);
  static const ::apollo::hdmap::Id& id(const RegionOverlapInfo* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::apollo::hdmap::Id&
RegionOverlapInfo::_Internal::id(const RegionOverlapInfo* msg) {
  return *msg->_impl_.id_;
}
void RegionOverlapInfo::clear_id() {
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RegionOverlapInfo::clear_polygon() {
  _impl_.polygon_.Clear();
}
RegionOverlapInfo::RegionOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.RegionOverlapInfo)
}
RegionOverlapInfo::RegionOverlapInfo(const RegionOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.polygon_){from._impl_.polygon_}
    , decltype(_impl_.id_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    _impl_.id_ = new ::apollo::hdmap::Id(*from._impl_.id_);
  }
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.RegionOverlapInfo)
}

inline void RegionOverlapInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.polygon_){arena}
    , decltype(_impl_.id_){nullptr}
  };
}

RegionOverlapInfo::~RegionOverlapInfo() {
  // @@protoc_insertion_point(destructor:apollo.hdmap.RegionOverlapInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RegionOverlapInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.polygon_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.id_;
}

void RegionOverlapInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RegionOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.hdmap.RegionOverlapInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.polygon_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.id_ != nullptr);
    _impl_.id_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegionOverlapInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.hdmap.Id id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .apollo.hdmap.Polygon polygon = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_polygon(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegionOverlapInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.hdmap.RegionOverlapInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.hdmap.Id id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::id(this),
        _Internal::id(this).GetCachedSize(), target, stream);
  }

  // repeated .apollo.hdmap.Polygon polygon = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_polygon_size()); i < n; i++) {
    const auto& repfield = this->_internal_polygon(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.hdmap.RegionOverlapInfo)
  return target;
}

size_t RegionOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.hdmap.RegionOverlapInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .apollo.hdmap.Polygon polygon = 2;
  total_size += 1UL * this->_internal_polygon_size();
  for (const auto& msg : this->_impl_.polygon_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .apollo.hdmap.Id id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegionOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RegionOverlapInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegionOverlapInfo::GetClassData() const { return &_class_data_; }

void RegionOverlapInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegionOverlapInfo *>(to)->MergeFrom(
      static_cast<const RegionOverlapInfo &>(from));
}


void RegionOverlapInfo::MergeFrom(const RegionOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.hdmap.RegionOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.polygon_.MergeFrom(from._impl_.polygon_);
  if (from._internal_has_id()) {
    _internal_mutable_id()->::apollo::hdmap::Id::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegionOverlapInfo::CopyFrom(const RegionOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.hdmap.RegionOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegionOverlapInfo::IsInitialized() const {
  return true;
}

void RegionOverlapInfo::InternalSwap(RegionOverlapInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.polygon_.InternalSwap(&other->_impl_.polygon_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RegionOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[11]);
}

// ===================================================================

class ObjectOverlapInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ObjectOverlapInfo>()._impl_._has_bits_);
  static const ::apollo::hdmap::Id& id(const ObjectOverlapInfo* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::apollo::hdmap::LaneOverlapInfo& lane_overlap_info(const ObjectOverlapInfo* msg);
  static const ::apollo::hdmap::SignalOverlapInfo& signal_overlap_info(const ObjectOverlapInfo* msg);
  static const ::apollo::hdmap::StopSignOverlapInfo& stop_sign_overlap_info(const ObjectOverlapInfo* msg);
  static const ::apollo::hdmap::CrosswalkOverlapInfo& crosswalk_overlap_info(const ObjectOverlapInfo* msg);
  static const ::apollo::hdmap::JunctionOverlapInfo& junction_overlap_info(const ObjectOverlapInfo* msg);
  static const ::apollo::hdmap::YieldOverlapInfo& yield_sign_overlap_info(const ObjectOverlapInfo* msg);
  static const ::apollo::hdmap::ClearAreaOverlapInfo& clear_area_overlap_info(const ObjectOverlapInfo* msg);
  static const ::apollo::hdmap::SpeedBumpOverlapInfo& speed_bump_overlap_info(const ObjectOverlapInfo* msg);
  static const ::apollo::hdmap::ParkingSpaceOverlapInfo& parking_space_overlap_info(const ObjectOverlapInfo* msg);
  static const ::apollo::hdmap::PNCJunctionOverlapInfo& pnc_junction_overlap_info(const ObjectOverlapInfo* msg);
  static const ::apollo::hdmap::RSUOverlapInfo& rsu_overlap_info(const ObjectOverlapInfo* msg);
};

const ::apollo::hdmap::Id&
ObjectOverlapInfo::_Internal::id(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.id_;
}
const ::apollo::hdmap::LaneOverlapInfo&
ObjectOverlapInfo::_Internal::lane_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.lane_overlap_info_;
}
const ::apollo::hdmap::SignalOverlapInfo&
ObjectOverlapInfo::_Internal::signal_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.signal_overlap_info_;
}
const ::apollo::hdmap::StopSignOverlapInfo&
ObjectOverlapInfo::_Internal::stop_sign_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.stop_sign_overlap_info_;
}
const ::apollo::hdmap::CrosswalkOverlapInfo&
ObjectOverlapInfo::_Internal::crosswalk_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.crosswalk_overlap_info_;
}
const ::apollo::hdmap::JunctionOverlapInfo&
ObjectOverlapInfo::_Internal::junction_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.junction_overlap_info_;
}
const ::apollo::hdmap::YieldOverlapInfo&
ObjectOverlapInfo::_Internal::yield_sign_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.yield_sign_overlap_info_;
}
const ::apollo::hdmap::ClearAreaOverlapInfo&
ObjectOverlapInfo::_Internal::clear_area_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.clear_area_overlap_info_;
}
const ::apollo::hdmap::SpeedBumpOverlapInfo&
ObjectOverlapInfo::_Internal::speed_bump_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.speed_bump_overlap_info_;
}
const ::apollo::hdmap::ParkingSpaceOverlapInfo&
ObjectOverlapInfo::_Internal::parking_space_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.parking_space_overlap_info_;
}
const ::apollo::hdmap::PNCJunctionOverlapInfo&
ObjectOverlapInfo::_Internal::pnc_junction_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.pnc_junction_overlap_info_;
}
const ::apollo::hdmap::RSUOverlapInfo&
ObjectOverlapInfo::_Internal::rsu_overlap_info(const ObjectOverlapInfo* msg) {
  return *msg->_impl_.overlap_info_.rsu_overlap_info_;
}
void ObjectOverlapInfo::clear_id() {
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ObjectOverlapInfo::set_allocated_lane_overlap_info(::apollo::hdmap::LaneOverlapInfo* lane_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (lane_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lane_overlap_info);
    if (message_arena != submessage_arena) {
      lane_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lane_overlap_info, submessage_arena);
    }
    set_has_lane_overlap_info();
    _impl_.overlap_info_.lane_overlap_info_ = lane_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.lane_overlap_info)
}
void ObjectOverlapInfo::set_allocated_signal_overlap_info(::apollo::hdmap::SignalOverlapInfo* signal_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (signal_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(signal_overlap_info);
    if (message_arena != submessage_arena) {
      signal_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_overlap_info, submessage_arena);
    }
    set_has_signal_overlap_info();
    _impl_.overlap_info_.signal_overlap_info_ = signal_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.signal_overlap_info)
}
void ObjectOverlapInfo::set_allocated_stop_sign_overlap_info(::apollo::hdmap::StopSignOverlapInfo* stop_sign_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (stop_sign_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stop_sign_overlap_info);
    if (message_arena != submessage_arena) {
      stop_sign_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_sign_overlap_info, submessage_arena);
    }
    set_has_stop_sign_overlap_info();
    _impl_.overlap_info_.stop_sign_overlap_info_ = stop_sign_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
}
void ObjectOverlapInfo::set_allocated_crosswalk_overlap_info(::apollo::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (crosswalk_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(crosswalk_overlap_info);
    if (message_arena != submessage_arena) {
      crosswalk_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crosswalk_overlap_info, submessage_arena);
    }
    set_has_crosswalk_overlap_info();
    _impl_.overlap_info_.crosswalk_overlap_info_ = crosswalk_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
}
void ObjectOverlapInfo::set_allocated_junction_overlap_info(::apollo::hdmap::JunctionOverlapInfo* junction_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (junction_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(junction_overlap_info);
    if (message_arena != submessage_arena) {
      junction_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, junction_overlap_info, submessage_arena);
    }
    set_has_junction_overlap_info();
    _impl_.overlap_info_.junction_overlap_info_ = junction_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.junction_overlap_info)
}
void ObjectOverlapInfo::set_allocated_yield_sign_overlap_info(::apollo::hdmap::YieldOverlapInfo* yield_sign_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (yield_sign_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(yield_sign_overlap_info);
    if (message_arena != submessage_arena) {
      yield_sign_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yield_sign_overlap_info, submessage_arena);
    }
    set_has_yield_sign_overlap_info();
    _impl_.overlap_info_.yield_sign_overlap_info_ = yield_sign_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
}
void ObjectOverlapInfo::set_allocated_clear_area_overlap_info(::apollo::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (clear_area_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clear_area_overlap_info);
    if (message_arena != submessage_arena) {
      clear_area_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clear_area_overlap_info, submessage_arena);
    }
    set_has_clear_area_overlap_info();
    _impl_.overlap_info_.clear_area_overlap_info_ = clear_area_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
}
void ObjectOverlapInfo::set_allocated_speed_bump_overlap_info(::apollo::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (speed_bump_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(speed_bump_overlap_info);
    if (message_arena != submessage_arena) {
      speed_bump_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed_bump_overlap_info, submessage_arena);
    }
    set_has_speed_bump_overlap_info();
    _impl_.overlap_info_.speed_bump_overlap_info_ = speed_bump_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
}
void ObjectOverlapInfo::set_allocated_parking_space_overlap_info(::apollo::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (parking_space_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parking_space_overlap_info);
    if (message_arena != submessage_arena) {
      parking_space_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parking_space_overlap_info, submessage_arena);
    }
    set_has_parking_space_overlap_info();
    _impl_.overlap_info_.parking_space_overlap_info_ = parking_space_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
}
void ObjectOverlapInfo::set_allocated_pnc_junction_overlap_info(::apollo::hdmap::PNCJunctionOverlapInfo* pnc_junction_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (pnc_junction_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pnc_junction_overlap_info);
    if (message_arena != submessage_arena) {
      pnc_junction_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pnc_junction_overlap_info, submessage_arena);
    }
    set_has_pnc_junction_overlap_info();
    _impl_.overlap_info_.pnc_junction_overlap_info_ = pnc_junction_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
}
void ObjectOverlapInfo::set_allocated_rsu_overlap_info(::apollo::hdmap::RSUOverlapInfo* rsu_overlap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_overlap_info();
  if (rsu_overlap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rsu_overlap_info);
    if (message_arena != submessage_arena) {
      rsu_overlap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsu_overlap_info, submessage_arena);
    }
    set_has_rsu_overlap_info();
    _impl_.overlap_info_.rsu_overlap_info_ = rsu_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.rsu_overlap_info)
}
ObjectOverlapInfo::ObjectOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.ObjectOverlapInfo)
}
ObjectOverlapInfo::ObjectOverlapInfo(const ObjectOverlapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){nullptr}
    , decltype(_impl_.overlap_info_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    _impl_.id_ = new ::apollo::hdmap::Id(*from._impl_.id_);
  }
  clear_has_overlap_info();
  switch (from.overlap_info_case()) {
    case kLaneOverlapInfo: {
      _internal_mutable_lane_overlap_info()->::apollo::hdmap::LaneOverlapInfo::MergeFrom(from._internal_lane_overlap_info());
      break;
    }
    case kSignalOverlapInfo: {
      _internal_mutable_signal_overlap_info()->::apollo::hdmap::SignalOverlapInfo::MergeFrom(from._internal_signal_overlap_info());
      break;
    }
    case kStopSignOverlapInfo: {
      _internal_mutable_stop_sign_overlap_info()->::apollo::hdmap::StopSignOverlapInfo::MergeFrom(from._internal_stop_sign_overlap_info());
      break;
    }
    case kCrosswalkOverlapInfo: {
      _internal_mutable_crosswalk_overlap_info()->::apollo::hdmap::CrosswalkOverlapInfo::MergeFrom(from._internal_crosswalk_overlap_info());
      break;
    }
    case kJunctionOverlapInfo: {
      _internal_mutable_junction_overlap_info()->::apollo::hdmap::JunctionOverlapInfo::MergeFrom(from._internal_junction_overlap_info());
      break;
    }
    case kYieldSignOverlapInfo: {
      _internal_mutable_yield_sign_overlap_info()->::apollo::hdmap::YieldOverlapInfo::MergeFrom(from._internal_yield_sign_overlap_info());
      break;
    }
    case kClearAreaOverlapInfo: {
      _internal_mutable_clear_area_overlap_info()->::apollo::hdmap::ClearAreaOverlapInfo::MergeFrom(from._internal_clear_area_overlap_info());
      break;
    }
    case kSpeedBumpOverlapInfo: {
      _internal_mutable_speed_bump_overlap_info()->::apollo::hdmap::SpeedBumpOverlapInfo::MergeFrom(from._internal_speed_bump_overlap_info());
      break;
    }
    case kParkingSpaceOverlapInfo: {
      _internal_mutable_parking_space_overlap_info()->::apollo::hdmap::ParkingSpaceOverlapInfo::MergeFrom(from._internal_parking_space_overlap_info());
      break;
    }
    case kPncJunctionOverlapInfo: {
      _internal_mutable_pnc_junction_overlap_info()->::apollo::hdmap::PNCJunctionOverlapInfo::MergeFrom(from._internal_pnc_junction_overlap_info());
      break;
    }
    case kRsuOverlapInfo: {
      _internal_mutable_rsu_overlap_info()->::apollo::hdmap::RSUOverlapInfo::MergeFrom(from._internal_rsu_overlap_info());
      break;
    }
    case OVERLAP_INFO_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.ObjectOverlapInfo)
}

inline void ObjectOverlapInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){nullptr}
    , decltype(_impl_.overlap_info_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_overlap_info();
}

ObjectOverlapInfo::~ObjectOverlapInfo() {
  // @@protoc_insertion_point(destructor:apollo.hdmap.ObjectOverlapInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ObjectOverlapInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.id_;
  if (has_overlap_info()) {
    clear_overlap_info();
  }
}

void ObjectOverlapInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ObjectOverlapInfo::clear_overlap_info() {
// @@protoc_insertion_point(one_of_clear_start:apollo.hdmap.ObjectOverlapInfo)
  switch (overlap_info_case()) {
    case kLaneOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.lane_overlap_info_;
      }
      break;
    }
    case kSignalOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.signal_overlap_info_;
      }
      break;
    }
    case kStopSignOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.stop_sign_overlap_info_;
      }
      break;
    }
    case kCrosswalkOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.crosswalk_overlap_info_;
      }
      break;
    }
    case kJunctionOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.junction_overlap_info_;
      }
      break;
    }
    case kYieldSignOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.yield_sign_overlap_info_;
      }
      break;
    }
    case kClearAreaOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.clear_area_overlap_info_;
      }
      break;
    }
    case kSpeedBumpOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.speed_bump_overlap_info_;
      }
      break;
    }
    case kParkingSpaceOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.parking_space_overlap_info_;
      }
      break;
    }
    case kPncJunctionOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.pnc_junction_overlap_info_;
      }
      break;
    }
    case kRsuOverlapInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.overlap_info_.rsu_overlap_info_;
      }
      break;
    }
    case OVERLAP_INFO_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = OVERLAP_INFO_NOT_SET;
}


void ObjectOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.hdmap.ObjectOverlapInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.id_ != nullptr);
    _impl_.id_->Clear();
  }
  clear_overlap_info();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectOverlapInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.hdmap.Id id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.LaneOverlapInfo lane_overlap_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lane_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.SignalOverlapInfo signal_overlap_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_signal_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_sign_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_crosswalk_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_junction_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_yield_sign_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_clear_area_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_speed_bump_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_parking_space_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.PNCJunctionOverlapInfo pnc_junction_overlap_info = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_pnc_junction_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .apollo.hdmap.RSUOverlapInfo rsu_overlap_info = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsu_overlap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectOverlapInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.hdmap.ObjectOverlapInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.hdmap.Id id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::id(this),
        _Internal::id(this).GetCachedSize(), target, stream);
  }

  switch (overlap_info_case()) {
    case kLaneOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::lane_overlap_info(this),
          _Internal::lane_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    case kSignalOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::signal_overlap_info(this),
          _Internal::signal_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    case kStopSignOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::stop_sign_overlap_info(this),
          _Internal::stop_sign_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    case kCrosswalkOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::crosswalk_overlap_info(this),
          _Internal::crosswalk_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    case kJunctionOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::junction_overlap_info(this),
          _Internal::junction_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    case kYieldSignOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::yield_sign_overlap_info(this),
          _Internal::yield_sign_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    case kClearAreaOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::clear_area_overlap_info(this),
          _Internal::clear_area_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    case kSpeedBumpOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::speed_bump_overlap_info(this),
          _Internal::speed_bump_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    case kParkingSpaceOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::parking_space_overlap_info(this),
          _Internal::parking_space_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    case kPncJunctionOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::pnc_junction_overlap_info(this),
          _Internal::pnc_junction_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    case kRsuOverlapInfo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::rsu_overlap_info(this),
          _Internal::rsu_overlap_info(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.hdmap.ObjectOverlapInfo)
  return target;
}

size_t ObjectOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.hdmap.ObjectOverlapInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .apollo.hdmap.Id id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.id_);
  }

  switch (overlap_info_case()) {
    // .apollo.hdmap.LaneOverlapInfo lane_overlap_info = 3;
    case kLaneOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.lane_overlap_info_);
      break;
    }
    // .apollo.hdmap.SignalOverlapInfo signal_overlap_info = 4;
    case kSignalOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.signal_overlap_info_);
      break;
    }
    // .apollo.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
    case kStopSignOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.stop_sign_overlap_info_);
      break;
    }
    // .apollo.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
    case kCrosswalkOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.crosswalk_overlap_info_);
      break;
    }
    // .apollo.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
    case kJunctionOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.junction_overlap_info_);
      break;
    }
    // .apollo.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
    case kYieldSignOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.yield_sign_overlap_info_);
      break;
    }
    // .apollo.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
    case kClearAreaOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.clear_area_overlap_info_);
      break;
    }
    // .apollo.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
    case kSpeedBumpOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.speed_bump_overlap_info_);
      break;
    }
    // .apollo.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
    case kParkingSpaceOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.parking_space_overlap_info_);
      break;
    }
    // .apollo.hdmap.PNCJunctionOverlapInfo pnc_junction_overlap_info = 12;
    case kPncJunctionOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.pnc_junction_overlap_info_);
      break;
    }
    // .apollo.hdmap.RSUOverlapInfo rsu_overlap_info = 13;
    case kRsuOverlapInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.overlap_info_.rsu_overlap_info_);
      break;
    }
    case OVERLAP_INFO_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectOverlapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectOverlapInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectOverlapInfo::GetClassData() const { return &_class_data_; }

void ObjectOverlapInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectOverlapInfo *>(to)->MergeFrom(
      static_cast<const ObjectOverlapInfo &>(from));
}


void ObjectOverlapInfo::MergeFrom(const ObjectOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.hdmap.ObjectOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_id()) {
    _internal_mutable_id()->::apollo::hdmap::Id::MergeFrom(from._internal_id());
  }
  switch (from.overlap_info_case()) {
    case kLaneOverlapInfo: {
      _internal_mutable_lane_overlap_info()->::apollo::hdmap::LaneOverlapInfo::MergeFrom(from._internal_lane_overlap_info());
      break;
    }
    case kSignalOverlapInfo: {
      _internal_mutable_signal_overlap_info()->::apollo::hdmap::SignalOverlapInfo::MergeFrom(from._internal_signal_overlap_info());
      break;
    }
    case kStopSignOverlapInfo: {
      _internal_mutable_stop_sign_overlap_info()->::apollo::hdmap::StopSignOverlapInfo::MergeFrom(from._internal_stop_sign_overlap_info());
      break;
    }
    case kCrosswalkOverlapInfo: {
      _internal_mutable_crosswalk_overlap_info()->::apollo::hdmap::CrosswalkOverlapInfo::MergeFrom(from._internal_crosswalk_overlap_info());
      break;
    }
    case kJunctionOverlapInfo: {
      _internal_mutable_junction_overlap_info()->::apollo::hdmap::JunctionOverlapInfo::MergeFrom(from._internal_junction_overlap_info());
      break;
    }
    case kYieldSignOverlapInfo: {
      _internal_mutable_yield_sign_overlap_info()->::apollo::hdmap::YieldOverlapInfo::MergeFrom(from._internal_yield_sign_overlap_info());
      break;
    }
    case kClearAreaOverlapInfo: {
      _internal_mutable_clear_area_overlap_info()->::apollo::hdmap::ClearAreaOverlapInfo::MergeFrom(from._internal_clear_area_overlap_info());
      break;
    }
    case kSpeedBumpOverlapInfo: {
      _internal_mutable_speed_bump_overlap_info()->::apollo::hdmap::SpeedBumpOverlapInfo::MergeFrom(from._internal_speed_bump_overlap_info());
      break;
    }
    case kParkingSpaceOverlapInfo: {
      _internal_mutable_parking_space_overlap_info()->::apollo::hdmap::ParkingSpaceOverlapInfo::MergeFrom(from._internal_parking_space_overlap_info());
      break;
    }
    case kPncJunctionOverlapInfo: {
      _internal_mutable_pnc_junction_overlap_info()->::apollo::hdmap::PNCJunctionOverlapInfo::MergeFrom(from._internal_pnc_junction_overlap_info());
      break;
    }
    case kRsuOverlapInfo: {
      _internal_mutable_rsu_overlap_info()->::apollo::hdmap::RSUOverlapInfo::MergeFrom(from._internal_rsu_overlap_info());
      break;
    }
    case OVERLAP_INFO_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectOverlapInfo::CopyFrom(const ObjectOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.hdmap.ObjectOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectOverlapInfo::IsInitialized() const {
  return true;
}

void ObjectOverlapInfo::InternalSwap(ObjectOverlapInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.id_, other->_impl_.id_);
  swap(_impl_.overlap_info_, other->_impl_.overlap_info_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectOverlapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[12]);
}

// ===================================================================

class Overlap::_Internal {
 public:
  using HasBits = decltype(std::declval<Overlap>()._impl_._has_bits_);
  static const ::apollo::hdmap::Id& id(const Overlap* msg);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::apollo::hdmap::Id&
Overlap::_Internal::id(const Overlap* msg) {
  return *msg->_impl_.id_;
}
void Overlap::clear_id() {
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Overlap::Overlap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:apollo.hdmap.Overlap)
}
Overlap::Overlap(const Overlap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_){from._impl_.object_}
    , decltype(_impl_.region_overlap_){from._impl_.region_overlap_}
    , decltype(_impl_.id_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_id()) {
    _impl_.id_ = new ::apollo::hdmap::Id(*from._impl_.id_);
  }
  // @@protoc_insertion_point(copy_constructor:apollo.hdmap.Overlap)
}

inline void Overlap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_){arena}
    , decltype(_impl_.region_overlap_){arena}
    , decltype(_impl_.id_){nullptr}
  };
}

Overlap::~Overlap() {
  // @@protoc_insertion_point(destructor:apollo.hdmap.Overlap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Overlap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.object_.~RepeatedPtrField();
  _impl_.region_overlap_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.id_;
}

void Overlap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Overlap::Clear() {
// @@protoc_insertion_point(message_clear_start:apollo.hdmap.Overlap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.object_.Clear();
  _impl_.region_overlap_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.id_ != nullptr);
    _impl_.id_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Overlap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .apollo.hdmap.Id id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .apollo.hdmap.ObjectOverlapInfo object = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_object(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .apollo.hdmap.RegionOverlapInfo region_overlap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_region_overlap(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Overlap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:apollo.hdmap.Overlap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .apollo.hdmap.Id id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::id(this),
        _Internal::id(this).GetCachedSize(), target, stream);
  }

  // repeated .apollo.hdmap.ObjectOverlapInfo object = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_object_size()); i < n; i++) {
    const auto& repfield = this->_internal_object(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .apollo.hdmap.RegionOverlapInfo region_overlap = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_region_overlap_size()); i < n; i++) {
    const auto& repfield = this->_internal_region_overlap(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:apollo.hdmap.Overlap)
  return target;
}

size_t Overlap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:apollo.hdmap.Overlap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .apollo.hdmap.ObjectOverlapInfo object = 2;
  total_size += 1UL * this->_internal_object_size();
  for (const auto& msg : this->_impl_.object_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .apollo.hdmap.RegionOverlapInfo region_overlap = 3;
  total_size += 1UL * this->_internal_region_overlap_size();
  for (const auto& msg : this->_impl_.region_overlap_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .apollo.hdmap.Id id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Overlap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Overlap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Overlap::GetClassData() const { return &_class_data_; }

void Overlap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Overlap *>(to)->MergeFrom(
      static_cast<const Overlap &>(from));
}


void Overlap::MergeFrom(const Overlap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:apollo.hdmap.Overlap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _impl_.object_.MergeFrom(from._impl_.object_);
  _impl_.region_overlap_.MergeFrom(from._impl_.region_overlap_);
  if (from._internal_has_id()) {
    _internal_mutable_id()->::apollo::hdmap::Id::MergeFrom(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Overlap::CopyFrom(const Overlap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:apollo.hdmap.Overlap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Overlap::IsInitialized() const {
  return true;
}

void Overlap::InternalSwap(Overlap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.object_.InternalSwap(&other->_impl_.object_);
  _impl_.region_overlap_.InternalSwap(&other->_impl_.region_overlap_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Overlap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_getter, &descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto_once,
      file_level_metadata_modules_2fmap_2fproto_2fmap_5foverlap_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace hdmap
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::apollo::hdmap::LaneOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::LaneOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::LaneOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::SignalOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::SignalOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::SignalOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::StopSignOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::StopSignOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::StopSignOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::CrosswalkOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::CrosswalkOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::CrosswalkOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::JunctionOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::JunctionOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::JunctionOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::YieldOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::YieldOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::YieldOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::ClearAreaOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::ClearAreaOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::ClearAreaOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::SpeedBumpOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::SpeedBumpOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::SpeedBumpOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::ParkingSpaceOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::ParkingSpaceOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::ParkingSpaceOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::PNCJunctionOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::PNCJunctionOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::PNCJunctionOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::RSUOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::RSUOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::RSUOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::RegionOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::RegionOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::RegionOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::ObjectOverlapInfo*
Arena::CreateMaybeMessage< ::apollo::hdmap::ObjectOverlapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::ObjectOverlapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::apollo::hdmap::Overlap*
Arena::CreateMaybeMessage< ::apollo::hdmap::Overlap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::apollo::hdmap::Overlap >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
