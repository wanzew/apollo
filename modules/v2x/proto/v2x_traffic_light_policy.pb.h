// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/v2x/proto/v2x_traffic_light_policy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
namespace apollo {
namespace v2x {
class Connection;
struct ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class Intersection;
struct IntersectionDefaultTypeInternal;
extern IntersectionDefaultTypeInternal _Intersection_default_instance_;
class IntersectionState;
struct IntersectionStateDefaultTypeInternal;
extern IntersectionStateDefaultTypeInternal _IntersectionState_default_instance_;
class Lane;
struct LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class Map;
struct MapDefaultTypeInternal;
extern MapDefaultTypeInternal _Map_default_instance_;
class Phase;
struct PhaseDefaultTypeInternal;
extern PhaseDefaultTypeInternal _Phase_default_instance_;
class PolicyData;
struct PolicyDataDefaultTypeInternal;
extern PolicyDataDefaultTypeInternal _PolicyData_default_instance_;
class Position2D;
struct Position2DDefaultTypeInternal;
extern Position2DDefaultTypeInternal _Position2D_default_instance_;
class Road;
struct RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
class Spat;
struct SpatDefaultTypeInternal;
extern SpatDefaultTypeInternal _Spat_default_instance_;
}  // namespace v2x
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::v2x::Connection* Arena::CreateMaybeMessage<::apollo::v2x::Connection>(Arena*);
template<> ::apollo::v2x::Intersection* Arena::CreateMaybeMessage<::apollo::v2x::Intersection>(Arena*);
template<> ::apollo::v2x::IntersectionState* Arena::CreateMaybeMessage<::apollo::v2x::IntersectionState>(Arena*);
template<> ::apollo::v2x::Lane* Arena::CreateMaybeMessage<::apollo::v2x::Lane>(Arena*);
template<> ::apollo::v2x::Map* Arena::CreateMaybeMessage<::apollo::v2x::Map>(Arena*);
template<> ::apollo::v2x::Phase* Arena::CreateMaybeMessage<::apollo::v2x::Phase>(Arena*);
template<> ::apollo::v2x::PolicyData* Arena::CreateMaybeMessage<::apollo::v2x::PolicyData>(Arena*);
template<> ::apollo::v2x::Position2D* Arena::CreateMaybeMessage<::apollo::v2x::Position2D>(Arena*);
template<> ::apollo::v2x::Road* Arena::CreateMaybeMessage<::apollo::v2x::Road>(Arena*);
template<> ::apollo::v2x::Spat* Arena::CreateMaybeMessage<::apollo::v2x::Spat>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace v2x {

enum Connection_Type : int {
  Connection_Type_STRAIGHT = 0,
  Connection_Type_LEFT = 1,
  Connection_Type_RIGHT = 2,
  Connection_Type_U_TURN = 3
};
bool Connection_Type_IsValid(int value);
constexpr Connection_Type Connection_Type_Type_MIN = Connection_Type_STRAIGHT;
constexpr Connection_Type Connection_Type_Type_MAX = Connection_Type_U_TURN;
constexpr int Connection_Type_Type_ARRAYSIZE = Connection_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Connection_Type_descriptor();
template<typename T>
inline const std::string& Connection_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Connection_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Connection_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Connection_Type_descriptor(), enum_t_value);
}
inline bool Connection_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Connection_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Connection_Type>(
    Connection_Type_descriptor(), name, value);
}
enum Phase_Color : int {
  Phase_Color_UNKNOWN = 0,
  Phase_Color_RED = 1,
  Phase_Color_YELLOW = 2,
  Phase_Color_GREEN = 3,
  Phase_Color_BLACK = 4,
  Phase_Color_FLASH_GREEN = 5
};
bool Phase_Color_IsValid(int value);
constexpr Phase_Color Phase_Color_Color_MIN = Phase_Color_UNKNOWN;
constexpr Phase_Color Phase_Color_Color_MAX = Phase_Color_FLASH_GREEN;
constexpr int Phase_Color_Color_ARRAYSIZE = Phase_Color_Color_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Phase_Color_descriptor();
template<typename T>
inline const std::string& Phase_Color_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Phase_Color>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Phase_Color_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Phase_Color_descriptor(), enum_t_value);
}
inline bool Phase_Color_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Phase_Color* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Phase_Color>(
    Phase_Color_descriptor(), name, value);
}
// ===================================================================

class Position2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.v2x.Position2D) */ {
 public:
  inline Position2D() : Position2D(nullptr) {}
  ~Position2D() override;
  explicit PROTOBUF_CONSTEXPR Position2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position2D(const Position2D& from);
  Position2D(Position2D&& from) noexcept
    : Position2D() {
    *this = ::std::move(from);
  }

  inline Position2D& operator=(const Position2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position2D& operator=(Position2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position2D* internal_default_instance() {
    return reinterpret_cast<const Position2D*>(
               &_Position2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Position2D& a, Position2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Position2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Position2D& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.v2x.Position2D";
  }
  protected:
  explicit Position2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.v2x.Position2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double x_;
    double y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class Connection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.v2x.Connection) */ {
 public:
  inline Connection() : Connection(nullptr) {}
  ~Connection() override;
  explicit PROTOBUF_CONSTEXPR Connection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connection(const Connection& from);
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connection& operator=(Connection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }
  inline void Swap(Connection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Connection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Connection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.v2x.Connection";
  }
  protected:
  explicit Connection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Connection_Type Type;
  static constexpr Type STRAIGHT =
    Connection_Type_STRAIGHT;
  static constexpr Type LEFT =
    Connection_Type_LEFT;
  static constexpr Type RIGHT =
    Connection_Type_RIGHT;
  static constexpr Type U_TURN =
    Connection_Type_U_TURN;
  static inline bool Type_IsValid(int value) {
    return Connection_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Connection_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Connection_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Connection_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Connection_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Connection_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Connection_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAllowDrivingBehaviorFieldNumber = 1,
    kPhaseIdFieldNumber = 2,
  };
  // optional .apollo.v2x.Connection.Type allow_driving_behavior = 1;
  bool has_allow_driving_behavior() const;
  private:
  bool _internal_has_allow_driving_behavior() const;
  public:
  void clear_allow_driving_behavior();
  ::apollo::v2x::Connection_Type allow_driving_behavior() const;
  void set_allow_driving_behavior(::apollo::v2x::Connection_Type value);
  private:
  ::apollo::v2x::Connection_Type _internal_allow_driving_behavior() const;
  void _internal_set_allow_driving_behavior(::apollo::v2x::Connection_Type value);
  public:

  // optional int32 phase_id = 2;
  bool has_phase_id() const;
  private:
  bool _internal_has_phase_id() const;
  public:
  void clear_phase_id();
  int32_t phase_id() const;
  void set_phase_id(int32_t value);
  private:
  int32_t _internal_phase_id() const;
  void _internal_set_phase_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.v2x.Connection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int allow_driving_behavior_;
    int32_t phase_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class Lane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.v2x.Lane) */ {
 public:
  inline Lane() : Lane(nullptr) {}
  ~Lane() override;
  explicit PROTOBUF_CONSTEXPR Lane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lane(const Lane& from);
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lane& operator=(Lane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lane& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }
  inline void Swap(Lane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Lane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Lane& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.v2x.Lane";
  }
  protected:
  explicit Lane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionOffsetFieldNumber = 2,
    kConnectionsFieldNumber = 3,
    kLaneIdFieldNumber = 1,
  };
  // repeated .apollo.v2x.Position2D position_offset = 2;
  int position_offset_size() const;
  private:
  int _internal_position_offset_size() const;
  public:
  void clear_position_offset();
  ::apollo::v2x::Position2D* mutable_position_offset(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Position2D >*
      mutable_position_offset();
  private:
  const ::apollo::v2x::Position2D& _internal_position_offset(int index) const;
  ::apollo::v2x::Position2D* _internal_add_position_offset();
  public:
  const ::apollo::v2x::Position2D& position_offset(int index) const;
  ::apollo::v2x::Position2D* add_position_offset();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Position2D >&
      position_offset() const;

  // repeated .apollo.v2x.Connection connections = 3;
  int connections_size() const;
  private:
  int _internal_connections_size() const;
  public:
  void clear_connections();
  ::apollo::v2x::Connection* mutable_connections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Connection >*
      mutable_connections();
  private:
  const ::apollo::v2x::Connection& _internal_connections(int index) const;
  ::apollo::v2x::Connection* _internal_add_connections();
  public:
  const ::apollo::v2x::Connection& connections(int index) const;
  ::apollo::v2x::Connection* add_connections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Connection >&
      connections() const;

  // optional int32 lane_id = 1;
  bool has_lane_id() const;
  private:
  bool _internal_has_lane_id() const;
  public:
  void clear_lane_id();
  int32_t lane_id() const;
  void set_lane_id(int32_t value);
  private:
  int32_t _internal_lane_id() const;
  void _internal_set_lane_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.v2x.Lane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Position2D > position_offset_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Connection > connections_;
    int32_t lane_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class Road final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.v2x.Road) */ {
 public:
  inline Road() : Road(nullptr) {}
  ~Road() override;
  explicit PROTOBUF_CONSTEXPR Road(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Road(const Road& from);
  Road(Road&& from) noexcept
    : Road() {
    *this = ::std::move(from);
  }

  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }
  inline Road& operator=(Road&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Road& default_instance() {
    return *internal_default_instance();
  }
  static inline const Road* internal_default_instance() {
    return reinterpret_cast<const Road*>(
               &_Road_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Road& a, Road& b) {
    a.Swap(&b);
  }
  inline void Swap(Road* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Road* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Road* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Road>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Road& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Road& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Road* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.v2x.Road";
  }
  protected:
  explicit Road(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanesFieldNumber = 3,
    kPointsFieldNumber = 2,
    kUpstreamNodeIdFieldNumber = 1,
  };
  // repeated .apollo.v2x.Lane lanes = 3;
  int lanes_size() const;
  private:
  int _internal_lanes_size() const;
  public:
  void clear_lanes();
  ::apollo::v2x::Lane* mutable_lanes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Lane >*
      mutable_lanes();
  private:
  const ::apollo::v2x::Lane& _internal_lanes(int index) const;
  ::apollo::v2x::Lane* _internal_add_lanes();
  public:
  const ::apollo::v2x::Lane& lanes(int index) const;
  ::apollo::v2x::Lane* add_lanes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Lane >&
      lanes() const;

  // optional .apollo.v2x.Position2D points = 2;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::apollo::v2x::Position2D& points() const;
  PROTOBUF_NODISCARD ::apollo::v2x::Position2D* release_points();
  ::apollo::v2x::Position2D* mutable_points();
  void set_allocated_points(::apollo::v2x::Position2D* points);
  private:
  const ::apollo::v2x::Position2D& _internal_points() const;
  ::apollo::v2x::Position2D* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::apollo::v2x::Position2D* points);
  ::apollo::v2x::Position2D* unsafe_arena_release_points();

  // optional int32 upstream_node_id = 1;
  bool has_upstream_node_id() const;
  private:
  bool _internal_has_upstream_node_id() const;
  public:
  void clear_upstream_node_id();
  int32_t upstream_node_id() const;
  void set_upstream_node_id(int32_t value);
  private:
  int32_t _internal_upstream_node_id() const;
  void _internal_set_upstream_node_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.v2x.Road)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Lane > lanes_;
    ::apollo::v2x::Position2D* points_;
    int32_t upstream_node_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class Intersection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.v2x.Intersection) */ {
 public:
  inline Intersection() : Intersection(nullptr) {}
  ~Intersection() override;
  explicit PROTOBUF_CONSTEXPR Intersection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Intersection(const Intersection& from);
  Intersection(Intersection&& from) noexcept
    : Intersection() {
    *this = ::std::move(from);
  }

  inline Intersection& operator=(const Intersection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Intersection& operator=(Intersection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Intersection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Intersection* internal_default_instance() {
    return reinterpret_cast<const Intersection*>(
               &_Intersection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Intersection& a, Intersection& b) {
    a.Swap(&b);
  }
  inline void Swap(Intersection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Intersection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Intersection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Intersection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Intersection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Intersection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Intersection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.v2x.Intersection";
  }
  protected:
  explicit Intersection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoadsFieldNumber = 3,
    kPositionFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .apollo.v2x.Road roads = 3;
  int roads_size() const;
  private:
  int _internal_roads_size() const;
  public:
  void clear_roads();
  ::apollo::v2x::Road* mutable_roads(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Road >*
      mutable_roads();
  private:
  const ::apollo::v2x::Road& _internal_roads(int index) const;
  ::apollo::v2x::Road* _internal_add_roads();
  public:
  const ::apollo::v2x::Road& roads(int index) const;
  ::apollo::v2x::Road* add_roads();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Road >&
      roads() const;

  // optional .apollo.v2x.Position2D position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::apollo::v2x::Position2D& position() const;
  PROTOBUF_NODISCARD ::apollo::v2x::Position2D* release_position();
  ::apollo::v2x::Position2D* mutable_position();
  void set_allocated_position(::apollo::v2x::Position2D* position);
  private:
  const ::apollo::v2x::Position2D& _internal_position() const;
  ::apollo::v2x::Position2D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::apollo::v2x::Position2D* position);
  ::apollo::v2x::Position2D* unsafe_arena_release_position();

  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.v2x.Intersection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Road > roads_;
    ::apollo::v2x::Position2D* position_;
    int32_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class Map final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.v2x.Map) */ {
 public:
  inline Map() : Map(nullptr) {}
  ~Map() override;
  explicit PROTOBUF_CONSTEXPR Map(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map(const Map& from);
  Map(Map&& from) noexcept
    : Map() {
    *this = ::std::move(from);
  }

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map& operator=(Map&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map* internal_default_instance() {
    return reinterpret_cast<const Map*>(
               &_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Map& a, Map& b) {
    a.Swap(&b);
  }
  inline void Swap(Map* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Map& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.v2x.Map";
  }
  protected:
  explicit Map(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntersectionsFieldNumber = 3,
    kTimeStampFieldNumber = 1,
    kMsgCntFieldNumber = 2,
  };
  // repeated .apollo.v2x.Intersection intersections = 3;
  int intersections_size() const;
  private:
  int _internal_intersections_size() const;
  public:
  void clear_intersections();
  ::apollo::v2x::Intersection* mutable_intersections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Intersection >*
      mutable_intersections();
  private:
  const ::apollo::v2x::Intersection& _internal_intersections(int index) const;
  ::apollo::v2x::Intersection* _internal_add_intersections();
  public:
  const ::apollo::v2x::Intersection& intersections(int index) const;
  ::apollo::v2x::Intersection* add_intersections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Intersection >&
      intersections() const;

  // optional double time_stamp = 1;
  bool has_time_stamp() const;
  private:
  bool _internal_has_time_stamp() const;
  public:
  void clear_time_stamp();
  double time_stamp() const;
  void set_time_stamp(double value);
  private:
  double _internal_time_stamp() const;
  void _internal_set_time_stamp(double value);
  public:

  // optional int32 msg_cnt = 2;
  bool has_msg_cnt() const;
  private:
  bool _internal_has_msg_cnt() const;
  public:
  void clear_msg_cnt();
  int32_t msg_cnt() const;
  void set_msg_cnt(int32_t value);
  private:
  int32_t _internal_msg_cnt() const;
  void _internal_set_msg_cnt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.v2x.Map)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Intersection > intersections_;
    double time_stamp_;
    int32_t msg_cnt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class Phase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.v2x.Phase) */ {
 public:
  inline Phase() : Phase(nullptr) {}
  ~Phase() override;
  explicit PROTOBUF_CONSTEXPR Phase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Phase(const Phase& from);
  Phase(Phase&& from) noexcept
    : Phase() {
    *this = ::std::move(from);
  }

  inline Phase& operator=(const Phase& from) {
    CopyFrom(from);
    return *this;
  }
  inline Phase& operator=(Phase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Phase& default_instance() {
    return *internal_default_instance();
  }
  static inline const Phase* internal_default_instance() {
    return reinterpret_cast<const Phase*>(
               &_Phase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Phase& a, Phase& b) {
    a.Swap(&b);
  }
  inline void Swap(Phase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Phase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Phase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Phase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Phase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Phase& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Phase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.v2x.Phase";
  }
  protected:
  explicit Phase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Phase_Color Color;
  static constexpr Color UNKNOWN =
    Phase_Color_UNKNOWN;
  static constexpr Color RED =
    Phase_Color_RED;
  static constexpr Color YELLOW =
    Phase_Color_YELLOW;
  static constexpr Color GREEN =
    Phase_Color_GREEN;
  static constexpr Color BLACK =
    Phase_Color_BLACK;
  static constexpr Color FLASH_GREEN =
    Phase_Color_FLASH_GREEN;
  static inline bool Color_IsValid(int value) {
    return Phase_Color_IsValid(value);
  }
  static constexpr Color Color_MIN =
    Phase_Color_Color_MIN;
  static constexpr Color Color_MAX =
    Phase_Color_Color_MAX;
  static constexpr int Color_ARRAYSIZE =
    Phase_Color_Color_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Color_descriptor() {
    return Phase_Color_descriptor();
  }
  template<typename T>
  static inline const std::string& Color_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Color>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Color_Name.");
    return Phase_Color_Name(enum_t_value);
  }
  static inline bool Color_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Color* value) {
    return Phase_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kColorFieldNumber = 2,
    kColorRemainingTimeSFieldNumber = 3,
  };
  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional .apollo.v2x.Phase.Color color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  ::apollo::v2x::Phase_Color color() const;
  void set_color(::apollo::v2x::Phase_Color value);
  private:
  ::apollo::v2x::Phase_Color _internal_color() const;
  void _internal_set_color(::apollo::v2x::Phase_Color value);
  public:

  // optional int32 color_remaining_time_s = 3;
  bool has_color_remaining_time_s() const;
  private:
  bool _internal_has_color_remaining_time_s() const;
  public:
  void clear_color_remaining_time_s();
  int32_t color_remaining_time_s() const;
  void set_color_remaining_time_s(int32_t value);
  private:
  int32_t _internal_color_remaining_time_s() const;
  void _internal_set_color_remaining_time_s(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.v2x.Phase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t id_;
    int color_;
    int32_t color_remaining_time_s_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class IntersectionState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.v2x.IntersectionState) */ {
 public:
  inline IntersectionState() : IntersectionState(nullptr) {}
  ~IntersectionState() override;
  explicit PROTOBUF_CONSTEXPR IntersectionState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntersectionState(const IntersectionState& from);
  IntersectionState(IntersectionState&& from) noexcept
    : IntersectionState() {
    *this = ::std::move(from);
  }

  inline IntersectionState& operator=(const IntersectionState& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntersectionState& operator=(IntersectionState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntersectionState& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntersectionState* internal_default_instance() {
    return reinterpret_cast<const IntersectionState*>(
               &_IntersectionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(IntersectionState& a, IntersectionState& b) {
    a.Swap(&b);
  }
  inline void Swap(IntersectionState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntersectionState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntersectionState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntersectionState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntersectionState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IntersectionState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntersectionState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.v2x.IntersectionState";
  }
  protected:
  explicit IntersectionState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhasesFieldNumber = 2,
    kIntersectionIdFieldNumber = 1,
    kMoyFieldNumber = 3,
    kTimeStampDsecondFieldNumber = 4,
  };
  // repeated .apollo.v2x.Phase Phases = 2;
  int phases_size() const;
  private:
  int _internal_phases_size() const;
  public:
  void clear_phases();
  ::apollo::v2x::Phase* mutable_phases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Phase >*
      mutable_phases();
  private:
  const ::apollo::v2x::Phase& _internal_phases(int index) const;
  ::apollo::v2x::Phase* _internal_add_phases();
  public:
  const ::apollo::v2x::Phase& phases(int index) const;
  ::apollo::v2x::Phase* add_phases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Phase >&
      phases() const;

  // optional int32 intersection_id = 1;
  bool has_intersection_id() const;
  private:
  bool _internal_has_intersection_id() const;
  public:
  void clear_intersection_id();
  int32_t intersection_id() const;
  void set_intersection_id(int32_t value);
  private:
  int32_t _internal_intersection_id() const;
  void _internal_set_intersection_id(int32_t value);
  public:

  // optional int32 moy = 3;
  bool has_moy() const;
  private:
  bool _internal_has_moy() const;
  public:
  void clear_moy();
  int32_t moy() const;
  void set_moy(int32_t value);
  private:
  int32_t _internal_moy() const;
  void _internal_set_moy(int32_t value);
  public:

  // optional int32 time_stamp_dsecond = 4;
  bool has_time_stamp_dsecond() const;
  private:
  bool _internal_has_time_stamp_dsecond() const;
  public:
  void clear_time_stamp_dsecond();
  int32_t time_stamp_dsecond() const;
  void set_time_stamp_dsecond(int32_t value);
  private:
  int32_t _internal_time_stamp_dsecond() const;
  void _internal_set_time_stamp_dsecond(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.v2x.IntersectionState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Phase > phases_;
    int32_t intersection_id_;
    int32_t moy_;
    int32_t time_stamp_dsecond_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class Spat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.v2x.Spat) */ {
 public:
  inline Spat() : Spat(nullptr) {}
  ~Spat() override;
  explicit PROTOBUF_CONSTEXPR Spat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Spat(const Spat& from);
  Spat(Spat&& from) noexcept
    : Spat() {
    *this = ::std::move(from);
  }

  inline Spat& operator=(const Spat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Spat& operator=(Spat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Spat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Spat* internal_default_instance() {
    return reinterpret_cast<const Spat*>(
               &_Spat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Spat& a, Spat& b) {
    a.Swap(&b);
  }
  inline void Swap(Spat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Spat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Spat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Spat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Spat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Spat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Spat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.v2x.Spat";
  }
  protected:
  explicit Spat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntersectionsFieldNumber = 3,
    kTimeStampFieldNumber = 1,
    kMsgCntFieldNumber = 2,
  };
  // repeated .apollo.v2x.IntersectionState intersections = 3;
  int intersections_size() const;
  private:
  int _internal_intersections_size() const;
  public:
  void clear_intersections();
  ::apollo::v2x::IntersectionState* mutable_intersections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::IntersectionState >*
      mutable_intersections();
  private:
  const ::apollo::v2x::IntersectionState& _internal_intersections(int index) const;
  ::apollo::v2x::IntersectionState* _internal_add_intersections();
  public:
  const ::apollo::v2x::IntersectionState& intersections(int index) const;
  ::apollo::v2x::IntersectionState* add_intersections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::IntersectionState >&
      intersections() const;

  // optional double time_stamp = 1;
  bool has_time_stamp() const;
  private:
  bool _internal_has_time_stamp() const;
  public:
  void clear_time_stamp();
  double time_stamp() const;
  void set_time_stamp(double value);
  private:
  double _internal_time_stamp() const;
  void _internal_set_time_stamp(double value);
  public:

  // optional int32 msg_cnt = 2;
  bool has_msg_cnt() const;
  private:
  bool _internal_has_msg_cnt() const;
  public:
  void clear_msg_cnt();
  int32_t msg_cnt() const;
  void set_msg_cnt(int32_t value);
  private:
  int32_t _internal_msg_cnt() const;
  void _internal_set_msg_cnt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.v2x.Spat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::IntersectionState > intersections_;
    double time_stamp_;
    int32_t msg_cnt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
};
// -------------------------------------------------------------------

class PolicyData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.v2x.PolicyData) */ {
 public:
  inline PolicyData() : PolicyData(nullptr) {}
  ~PolicyData() override;
  explicit PROTOBUF_CONSTEXPR PolicyData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyData(const PolicyData& from);
  PolicyData(PolicyData&& from) noexcept
    : PolicyData() {
    *this = ::std::move(from);
  }

  inline PolicyData& operator=(const PolicyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyData& operator=(PolicyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolicyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyData* internal_default_instance() {
    return reinterpret_cast<const PolicyData*>(
               &_PolicyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PolicyData& a, PolicyData& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolicyData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolicyData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolicyData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.v2x.PolicyData";
  }
  protected:
  explicit PolicyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapFieldNumber = 1,
    kSpatFieldNumber = 2,
  };
  // optional .apollo.v2x.Map map = 1;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::apollo::v2x::Map& map() const;
  PROTOBUF_NODISCARD ::apollo::v2x::Map* release_map();
  ::apollo::v2x::Map* mutable_map();
  void set_allocated_map(::apollo::v2x::Map* map);
  private:
  const ::apollo::v2x::Map& _internal_map() const;
  ::apollo::v2x::Map* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::apollo::v2x::Map* map);
  ::apollo::v2x::Map* unsafe_arena_release_map();

  // optional .apollo.v2x.Spat spat = 2;
  bool has_spat() const;
  private:
  bool _internal_has_spat() const;
  public:
  void clear_spat();
  const ::apollo::v2x::Spat& spat() const;
  PROTOBUF_NODISCARD ::apollo::v2x::Spat* release_spat();
  ::apollo::v2x::Spat* mutable_spat();
  void set_allocated_spat(::apollo::v2x::Spat* spat);
  private:
  const ::apollo::v2x::Spat& _internal_spat() const;
  ::apollo::v2x::Spat* _internal_mutable_spat();
  public:
  void unsafe_arena_set_allocated_spat(
      ::apollo::v2x::Spat* spat);
  ::apollo::v2x::Spat* unsafe_arena_release_spat();

  // @@protoc_insertion_point(class_scope:apollo.v2x.PolicyData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::apollo::v2x::Map* map_;
    ::apollo::v2x::Spat* spat_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Position2D

// optional double x = 1;
inline bool Position2D::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Position2D::has_x() const {
  return _internal_has_x();
}
inline void Position2D::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Position2D::_internal_x() const {
  return _impl_.x_;
}
inline double Position2D::x() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Position2D.x)
  return _internal_x();
}
inline void Position2D::_internal_set_x(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Position2D::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Position2D.x)
}

// optional double y = 2;
inline bool Position2D::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Position2D::has_y() const {
  return _internal_has_y();
}
inline void Position2D::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Position2D::_internal_y() const {
  return _impl_.y_;
}
inline double Position2D::y() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Position2D.y)
  return _internal_y();
}
inline void Position2D::_internal_set_y(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Position2D::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Position2D.y)
}

// -------------------------------------------------------------------

// Connection

// optional .apollo.v2x.Connection.Type allow_driving_behavior = 1;
inline bool Connection::_internal_has_allow_driving_behavior() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Connection::has_allow_driving_behavior() const {
  return _internal_has_allow_driving_behavior();
}
inline void Connection::clear_allow_driving_behavior() {
  _impl_.allow_driving_behavior_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::v2x::Connection_Type Connection::_internal_allow_driving_behavior() const {
  return static_cast< ::apollo::v2x::Connection_Type >(_impl_.allow_driving_behavior_);
}
inline ::apollo::v2x::Connection_Type Connection::allow_driving_behavior() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Connection.allow_driving_behavior)
  return _internal_allow_driving_behavior();
}
inline void Connection::_internal_set_allow_driving_behavior(::apollo::v2x::Connection_Type value) {
  assert(::apollo::v2x::Connection_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.allow_driving_behavior_ = value;
}
inline void Connection::set_allow_driving_behavior(::apollo::v2x::Connection_Type value) {
  _internal_set_allow_driving_behavior(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Connection.allow_driving_behavior)
}

// optional int32 phase_id = 2;
inline bool Connection::_internal_has_phase_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Connection::has_phase_id() const {
  return _internal_has_phase_id();
}
inline void Connection::clear_phase_id() {
  _impl_.phase_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Connection::_internal_phase_id() const {
  return _impl_.phase_id_;
}
inline int32_t Connection::phase_id() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Connection.phase_id)
  return _internal_phase_id();
}
inline void Connection::_internal_set_phase_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.phase_id_ = value;
}
inline void Connection::set_phase_id(int32_t value) {
  _internal_set_phase_id(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Connection.phase_id)
}

// -------------------------------------------------------------------

// Lane

// optional int32 lane_id = 1;
inline bool Lane::_internal_has_lane_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Lane::has_lane_id() const {
  return _internal_has_lane_id();
}
inline void Lane::clear_lane_id() {
  _impl_.lane_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Lane::_internal_lane_id() const {
  return _impl_.lane_id_;
}
inline int32_t Lane::lane_id() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Lane.lane_id)
  return _internal_lane_id();
}
inline void Lane::_internal_set_lane_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lane_id_ = value;
}
inline void Lane::set_lane_id(int32_t value) {
  _internal_set_lane_id(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Lane.lane_id)
}

// repeated .apollo.v2x.Position2D position_offset = 2;
inline int Lane::_internal_position_offset_size() const {
  return _impl_.position_offset_.size();
}
inline int Lane::position_offset_size() const {
  return _internal_position_offset_size();
}
inline void Lane::clear_position_offset() {
  _impl_.position_offset_.Clear();
}
inline ::apollo::v2x::Position2D* Lane::mutable_position_offset(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.v2x.Lane.position_offset)
  return _impl_.position_offset_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Position2D >*
Lane::mutable_position_offset() {
  // @@protoc_insertion_point(field_mutable_list:apollo.v2x.Lane.position_offset)
  return &_impl_.position_offset_;
}
inline const ::apollo::v2x::Position2D& Lane::_internal_position_offset(int index) const {
  return _impl_.position_offset_.Get(index);
}
inline const ::apollo::v2x::Position2D& Lane::position_offset(int index) const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Lane.position_offset)
  return _internal_position_offset(index);
}
inline ::apollo::v2x::Position2D* Lane::_internal_add_position_offset() {
  return _impl_.position_offset_.Add();
}
inline ::apollo::v2x::Position2D* Lane::add_position_offset() {
  ::apollo::v2x::Position2D* _add = _internal_add_position_offset();
  // @@protoc_insertion_point(field_add:apollo.v2x.Lane.position_offset)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Position2D >&
Lane::position_offset() const {
  // @@protoc_insertion_point(field_list:apollo.v2x.Lane.position_offset)
  return _impl_.position_offset_;
}

// repeated .apollo.v2x.Connection connections = 3;
inline int Lane::_internal_connections_size() const {
  return _impl_.connections_.size();
}
inline int Lane::connections_size() const {
  return _internal_connections_size();
}
inline void Lane::clear_connections() {
  _impl_.connections_.Clear();
}
inline ::apollo::v2x::Connection* Lane::mutable_connections(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.v2x.Lane.connections)
  return _impl_.connections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Connection >*
Lane::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_list:apollo.v2x.Lane.connections)
  return &_impl_.connections_;
}
inline const ::apollo::v2x::Connection& Lane::_internal_connections(int index) const {
  return _impl_.connections_.Get(index);
}
inline const ::apollo::v2x::Connection& Lane::connections(int index) const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Lane.connections)
  return _internal_connections(index);
}
inline ::apollo::v2x::Connection* Lane::_internal_add_connections() {
  return _impl_.connections_.Add();
}
inline ::apollo::v2x::Connection* Lane::add_connections() {
  ::apollo::v2x::Connection* _add = _internal_add_connections();
  // @@protoc_insertion_point(field_add:apollo.v2x.Lane.connections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Connection >&
Lane::connections() const {
  // @@protoc_insertion_point(field_list:apollo.v2x.Lane.connections)
  return _impl_.connections_;
}

// -------------------------------------------------------------------

// Road

// optional int32 upstream_node_id = 1;
inline bool Road::_internal_has_upstream_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Road::has_upstream_node_id() const {
  return _internal_has_upstream_node_id();
}
inline void Road::clear_upstream_node_id() {
  _impl_.upstream_node_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Road::_internal_upstream_node_id() const {
  return _impl_.upstream_node_id_;
}
inline int32_t Road::upstream_node_id() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Road.upstream_node_id)
  return _internal_upstream_node_id();
}
inline void Road::_internal_set_upstream_node_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.upstream_node_id_ = value;
}
inline void Road::set_upstream_node_id(int32_t value) {
  _internal_set_upstream_node_id(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Road.upstream_node_id)
}

// optional .apollo.v2x.Position2D points = 2;
inline bool Road::_internal_has_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.points_ != nullptr);
  return value;
}
inline bool Road::has_points() const {
  return _internal_has_points();
}
inline void Road::clear_points() {
  if (_impl_.points_ != nullptr) _impl_.points_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::v2x::Position2D& Road::_internal_points() const {
  const ::apollo::v2x::Position2D* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::v2x::Position2D&>(
      ::apollo::v2x::_Position2D_default_instance_);
}
inline const ::apollo::v2x::Position2D& Road::points() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Road.points)
  return _internal_points();
}
inline void Road::unsafe_arena_set_allocated_points(
    ::apollo::v2x::Position2D* points) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = points;
  if (points) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.v2x.Road.points)
}
inline ::apollo::v2x::Position2D* Road::release_points() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::v2x::Position2D* temp = _impl_.points_;
  _impl_.points_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::v2x::Position2D* Road::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_release:apollo.v2x.Road.points)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::v2x::Position2D* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::apollo::v2x::Position2D* Road::_internal_mutable_points() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.points_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::v2x::Position2D>(GetArenaForAllocation());
    _impl_.points_ = p;
  }
  return _impl_.points_;
}
inline ::apollo::v2x::Position2D* Road::mutable_points() {
  ::apollo::v2x::Position2D* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:apollo.v2x.Road.points)
  return _msg;
}
inline void Road::set_allocated_points(::apollo::v2x::Position2D* points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.points_;
  }
  if (points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(points);
    if (message_arena != submessage_arena) {
      points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.points_ = points;
  // @@protoc_insertion_point(field_set_allocated:apollo.v2x.Road.points)
}

// repeated .apollo.v2x.Lane lanes = 3;
inline int Road::_internal_lanes_size() const {
  return _impl_.lanes_.size();
}
inline int Road::lanes_size() const {
  return _internal_lanes_size();
}
inline void Road::clear_lanes() {
  _impl_.lanes_.Clear();
}
inline ::apollo::v2x::Lane* Road::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.v2x.Road.lanes)
  return _impl_.lanes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Lane >*
Road::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:apollo.v2x.Road.lanes)
  return &_impl_.lanes_;
}
inline const ::apollo::v2x::Lane& Road::_internal_lanes(int index) const {
  return _impl_.lanes_.Get(index);
}
inline const ::apollo::v2x::Lane& Road::lanes(int index) const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Road.lanes)
  return _internal_lanes(index);
}
inline ::apollo::v2x::Lane* Road::_internal_add_lanes() {
  return _impl_.lanes_.Add();
}
inline ::apollo::v2x::Lane* Road::add_lanes() {
  ::apollo::v2x::Lane* _add = _internal_add_lanes();
  // @@protoc_insertion_point(field_add:apollo.v2x.Road.lanes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Lane >&
Road::lanes() const {
  // @@protoc_insertion_point(field_list:apollo.v2x.Road.lanes)
  return _impl_.lanes_;
}

// -------------------------------------------------------------------

// Intersection

// optional int32 id = 1;
inline bool Intersection::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Intersection::has_id() const {
  return _internal_has_id();
}
inline void Intersection::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Intersection::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Intersection::id() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Intersection.id)
  return _internal_id();
}
inline void Intersection::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void Intersection::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Intersection.id)
}

// optional .apollo.v2x.Position2D position = 2;
inline bool Intersection::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool Intersection::has_position() const {
  return _internal_has_position();
}
inline void Intersection::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::v2x::Position2D& Intersection::_internal_position() const {
  const ::apollo::v2x::Position2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::v2x::Position2D&>(
      ::apollo::v2x::_Position2D_default_instance_);
}
inline const ::apollo::v2x::Position2D& Intersection::position() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Intersection.position)
  return _internal_position();
}
inline void Intersection::unsafe_arena_set_allocated_position(
    ::apollo::v2x::Position2D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.v2x.Intersection.position)
}
inline ::apollo::v2x::Position2D* Intersection::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::v2x::Position2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::v2x::Position2D* Intersection::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:apollo.v2x.Intersection.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::v2x::Position2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::apollo::v2x::Position2D* Intersection::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::v2x::Position2D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::apollo::v2x::Position2D* Intersection::mutable_position() {
  ::apollo::v2x::Position2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:apollo.v2x.Intersection.position)
  return _msg;
}
inline void Intersection::set_allocated_position(::apollo::v2x::Position2D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:apollo.v2x.Intersection.position)
}

// repeated .apollo.v2x.Road roads = 3;
inline int Intersection::_internal_roads_size() const {
  return _impl_.roads_.size();
}
inline int Intersection::roads_size() const {
  return _internal_roads_size();
}
inline void Intersection::clear_roads() {
  _impl_.roads_.Clear();
}
inline ::apollo::v2x::Road* Intersection::mutable_roads(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.v2x.Intersection.roads)
  return _impl_.roads_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Road >*
Intersection::mutable_roads() {
  // @@protoc_insertion_point(field_mutable_list:apollo.v2x.Intersection.roads)
  return &_impl_.roads_;
}
inline const ::apollo::v2x::Road& Intersection::_internal_roads(int index) const {
  return _impl_.roads_.Get(index);
}
inline const ::apollo::v2x::Road& Intersection::roads(int index) const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Intersection.roads)
  return _internal_roads(index);
}
inline ::apollo::v2x::Road* Intersection::_internal_add_roads() {
  return _impl_.roads_.Add();
}
inline ::apollo::v2x::Road* Intersection::add_roads() {
  ::apollo::v2x::Road* _add = _internal_add_roads();
  // @@protoc_insertion_point(field_add:apollo.v2x.Intersection.roads)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Road >&
Intersection::roads() const {
  // @@protoc_insertion_point(field_list:apollo.v2x.Intersection.roads)
  return _impl_.roads_;
}

// -------------------------------------------------------------------

// Map

// optional double time_stamp = 1;
inline bool Map::_internal_has_time_stamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Map::has_time_stamp() const {
  return _internal_has_time_stamp();
}
inline void Map::clear_time_stamp() {
  _impl_.time_stamp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Map::_internal_time_stamp() const {
  return _impl_.time_stamp_;
}
inline double Map::time_stamp() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Map.time_stamp)
  return _internal_time_stamp();
}
inline void Map::_internal_set_time_stamp(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.time_stamp_ = value;
}
inline void Map::set_time_stamp(double value) {
  _internal_set_time_stamp(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Map.time_stamp)
}

// optional int32 msg_cnt = 2;
inline bool Map::_internal_has_msg_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Map::has_msg_cnt() const {
  return _internal_has_msg_cnt();
}
inline void Map::clear_msg_cnt() {
  _impl_.msg_cnt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Map::_internal_msg_cnt() const {
  return _impl_.msg_cnt_;
}
inline int32_t Map::msg_cnt() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Map.msg_cnt)
  return _internal_msg_cnt();
}
inline void Map::_internal_set_msg_cnt(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.msg_cnt_ = value;
}
inline void Map::set_msg_cnt(int32_t value) {
  _internal_set_msg_cnt(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Map.msg_cnt)
}

// repeated .apollo.v2x.Intersection intersections = 3;
inline int Map::_internal_intersections_size() const {
  return _impl_.intersections_.size();
}
inline int Map::intersections_size() const {
  return _internal_intersections_size();
}
inline void Map::clear_intersections() {
  _impl_.intersections_.Clear();
}
inline ::apollo::v2x::Intersection* Map::mutable_intersections(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.v2x.Map.intersections)
  return _impl_.intersections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Intersection >*
Map::mutable_intersections() {
  // @@protoc_insertion_point(field_mutable_list:apollo.v2x.Map.intersections)
  return &_impl_.intersections_;
}
inline const ::apollo::v2x::Intersection& Map::_internal_intersections(int index) const {
  return _impl_.intersections_.Get(index);
}
inline const ::apollo::v2x::Intersection& Map::intersections(int index) const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Map.intersections)
  return _internal_intersections(index);
}
inline ::apollo::v2x::Intersection* Map::_internal_add_intersections() {
  return _impl_.intersections_.Add();
}
inline ::apollo::v2x::Intersection* Map::add_intersections() {
  ::apollo::v2x::Intersection* _add = _internal_add_intersections();
  // @@protoc_insertion_point(field_add:apollo.v2x.Map.intersections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Intersection >&
Map::intersections() const {
  // @@protoc_insertion_point(field_list:apollo.v2x.Map.intersections)
  return _impl_.intersections_;
}

// -------------------------------------------------------------------

// Phase

// optional int32 id = 1;
inline bool Phase::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Phase::has_id() const {
  return _internal_has_id();
}
inline void Phase::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Phase::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Phase::id() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Phase.id)
  return _internal_id();
}
inline void Phase::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void Phase::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Phase.id)
}

// optional .apollo.v2x.Phase.Color color = 2;
inline bool Phase::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Phase::has_color() const {
  return _internal_has_color();
}
inline void Phase::clear_color() {
  _impl_.color_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::v2x::Phase_Color Phase::_internal_color() const {
  return static_cast< ::apollo::v2x::Phase_Color >(_impl_.color_);
}
inline ::apollo::v2x::Phase_Color Phase::color() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Phase.color)
  return _internal_color();
}
inline void Phase::_internal_set_color(::apollo::v2x::Phase_Color value) {
  assert(::apollo::v2x::Phase_Color_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.color_ = value;
}
inline void Phase::set_color(::apollo::v2x::Phase_Color value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Phase.color)
}

// optional int32 color_remaining_time_s = 3;
inline bool Phase::_internal_has_color_remaining_time_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Phase::has_color_remaining_time_s() const {
  return _internal_has_color_remaining_time_s();
}
inline void Phase::clear_color_remaining_time_s() {
  _impl_.color_remaining_time_s_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Phase::_internal_color_remaining_time_s() const {
  return _impl_.color_remaining_time_s_;
}
inline int32_t Phase::color_remaining_time_s() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Phase.color_remaining_time_s)
  return _internal_color_remaining_time_s();
}
inline void Phase::_internal_set_color_remaining_time_s(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.color_remaining_time_s_ = value;
}
inline void Phase::set_color_remaining_time_s(int32_t value) {
  _internal_set_color_remaining_time_s(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Phase.color_remaining_time_s)
}

// -------------------------------------------------------------------

// IntersectionState

// optional int32 intersection_id = 1;
inline bool IntersectionState::_internal_has_intersection_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IntersectionState::has_intersection_id() const {
  return _internal_has_intersection_id();
}
inline void IntersectionState::clear_intersection_id() {
  _impl_.intersection_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t IntersectionState::_internal_intersection_id() const {
  return _impl_.intersection_id_;
}
inline int32_t IntersectionState::intersection_id() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.IntersectionState.intersection_id)
  return _internal_intersection_id();
}
inline void IntersectionState::_internal_set_intersection_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.intersection_id_ = value;
}
inline void IntersectionState::set_intersection_id(int32_t value) {
  _internal_set_intersection_id(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.IntersectionState.intersection_id)
}

// repeated .apollo.v2x.Phase Phases = 2;
inline int IntersectionState::_internal_phases_size() const {
  return _impl_.phases_.size();
}
inline int IntersectionState::phases_size() const {
  return _internal_phases_size();
}
inline void IntersectionState::clear_phases() {
  _impl_.phases_.Clear();
}
inline ::apollo::v2x::Phase* IntersectionState::mutable_phases(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.v2x.IntersectionState.Phases)
  return _impl_.phases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Phase >*
IntersectionState::mutable_phases() {
  // @@protoc_insertion_point(field_mutable_list:apollo.v2x.IntersectionState.Phases)
  return &_impl_.phases_;
}
inline const ::apollo::v2x::Phase& IntersectionState::_internal_phases(int index) const {
  return _impl_.phases_.Get(index);
}
inline const ::apollo::v2x::Phase& IntersectionState::phases(int index) const {
  // @@protoc_insertion_point(field_get:apollo.v2x.IntersectionState.Phases)
  return _internal_phases(index);
}
inline ::apollo::v2x::Phase* IntersectionState::_internal_add_phases() {
  return _impl_.phases_.Add();
}
inline ::apollo::v2x::Phase* IntersectionState::add_phases() {
  ::apollo::v2x::Phase* _add = _internal_add_phases();
  // @@protoc_insertion_point(field_add:apollo.v2x.IntersectionState.Phases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::Phase >&
IntersectionState::phases() const {
  // @@protoc_insertion_point(field_list:apollo.v2x.IntersectionState.Phases)
  return _impl_.phases_;
}

// optional int32 moy = 3;
inline bool IntersectionState::_internal_has_moy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IntersectionState::has_moy() const {
  return _internal_has_moy();
}
inline void IntersectionState::clear_moy() {
  _impl_.moy_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t IntersectionState::_internal_moy() const {
  return _impl_.moy_;
}
inline int32_t IntersectionState::moy() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.IntersectionState.moy)
  return _internal_moy();
}
inline void IntersectionState::_internal_set_moy(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.moy_ = value;
}
inline void IntersectionState::set_moy(int32_t value) {
  _internal_set_moy(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.IntersectionState.moy)
}

// optional int32 time_stamp_dsecond = 4;
inline bool IntersectionState::_internal_has_time_stamp_dsecond() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IntersectionState::has_time_stamp_dsecond() const {
  return _internal_has_time_stamp_dsecond();
}
inline void IntersectionState::clear_time_stamp_dsecond() {
  _impl_.time_stamp_dsecond_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t IntersectionState::_internal_time_stamp_dsecond() const {
  return _impl_.time_stamp_dsecond_;
}
inline int32_t IntersectionState::time_stamp_dsecond() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.IntersectionState.time_stamp_dsecond)
  return _internal_time_stamp_dsecond();
}
inline void IntersectionState::_internal_set_time_stamp_dsecond(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.time_stamp_dsecond_ = value;
}
inline void IntersectionState::set_time_stamp_dsecond(int32_t value) {
  _internal_set_time_stamp_dsecond(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.IntersectionState.time_stamp_dsecond)
}

// -------------------------------------------------------------------

// Spat

// optional double time_stamp = 1;
inline bool Spat::_internal_has_time_stamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Spat::has_time_stamp() const {
  return _internal_has_time_stamp();
}
inline void Spat::clear_time_stamp() {
  _impl_.time_stamp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Spat::_internal_time_stamp() const {
  return _impl_.time_stamp_;
}
inline double Spat::time_stamp() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Spat.time_stamp)
  return _internal_time_stamp();
}
inline void Spat::_internal_set_time_stamp(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.time_stamp_ = value;
}
inline void Spat::set_time_stamp(double value) {
  _internal_set_time_stamp(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Spat.time_stamp)
}

// optional int32 msg_cnt = 2;
inline bool Spat::_internal_has_msg_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Spat::has_msg_cnt() const {
  return _internal_has_msg_cnt();
}
inline void Spat::clear_msg_cnt() {
  _impl_.msg_cnt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Spat::_internal_msg_cnt() const {
  return _impl_.msg_cnt_;
}
inline int32_t Spat::msg_cnt() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Spat.msg_cnt)
  return _internal_msg_cnt();
}
inline void Spat::_internal_set_msg_cnt(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.msg_cnt_ = value;
}
inline void Spat::set_msg_cnt(int32_t value) {
  _internal_set_msg_cnt(value);
  // @@protoc_insertion_point(field_set:apollo.v2x.Spat.msg_cnt)
}

// repeated .apollo.v2x.IntersectionState intersections = 3;
inline int Spat::_internal_intersections_size() const {
  return _impl_.intersections_.size();
}
inline int Spat::intersections_size() const {
  return _internal_intersections_size();
}
inline void Spat::clear_intersections() {
  _impl_.intersections_.Clear();
}
inline ::apollo::v2x::IntersectionState* Spat::mutable_intersections(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.v2x.Spat.intersections)
  return _impl_.intersections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::IntersectionState >*
Spat::mutable_intersections() {
  // @@protoc_insertion_point(field_mutable_list:apollo.v2x.Spat.intersections)
  return &_impl_.intersections_;
}
inline const ::apollo::v2x::IntersectionState& Spat::_internal_intersections(int index) const {
  return _impl_.intersections_.Get(index);
}
inline const ::apollo::v2x::IntersectionState& Spat::intersections(int index) const {
  // @@protoc_insertion_point(field_get:apollo.v2x.Spat.intersections)
  return _internal_intersections(index);
}
inline ::apollo::v2x::IntersectionState* Spat::_internal_add_intersections() {
  return _impl_.intersections_.Add();
}
inline ::apollo::v2x::IntersectionState* Spat::add_intersections() {
  ::apollo::v2x::IntersectionState* _add = _internal_add_intersections();
  // @@protoc_insertion_point(field_add:apollo.v2x.Spat.intersections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::v2x::IntersectionState >&
Spat::intersections() const {
  // @@protoc_insertion_point(field_list:apollo.v2x.Spat.intersections)
  return _impl_.intersections_;
}

// -------------------------------------------------------------------

// PolicyData

// optional .apollo.v2x.Map map = 1;
inline bool PolicyData::_internal_has_map() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.map_ != nullptr);
  return value;
}
inline bool PolicyData::has_map() const {
  return _internal_has_map();
}
inline void PolicyData::clear_map() {
  if (_impl_.map_ != nullptr) _impl_.map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::v2x::Map& PolicyData::_internal_map() const {
  const ::apollo::v2x::Map* p = _impl_.map_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::v2x::Map&>(
      ::apollo::v2x::_Map_default_instance_);
}
inline const ::apollo::v2x::Map& PolicyData::map() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.PolicyData.map)
  return _internal_map();
}
inline void PolicyData::unsafe_arena_set_allocated_map(
    ::apollo::v2x::Map* map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_);
  }
  _impl_.map_ = map;
  if (map) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.v2x.PolicyData.map)
}
inline ::apollo::v2x::Map* PolicyData::release_map() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::v2x::Map* temp = _impl_.map_;
  _impl_.map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::v2x::Map* PolicyData::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_release:apollo.v2x.PolicyData.map)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::apollo::v2x::Map* temp = _impl_.map_;
  _impl_.map_ = nullptr;
  return temp;
}
inline ::apollo::v2x::Map* PolicyData::_internal_mutable_map() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.map_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::v2x::Map>(GetArenaForAllocation());
    _impl_.map_ = p;
  }
  return _impl_.map_;
}
inline ::apollo::v2x::Map* PolicyData::mutable_map() {
  ::apollo::v2x::Map* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:apollo.v2x.PolicyData.map)
  return _msg;
}
inline void PolicyData::set_allocated_map(::apollo::v2x::Map* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.map_;
  }
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map);
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.map_ = map;
  // @@protoc_insertion_point(field_set_allocated:apollo.v2x.PolicyData.map)
}

// optional .apollo.v2x.Spat spat = 2;
inline bool PolicyData::_internal_has_spat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spat_ != nullptr);
  return value;
}
inline bool PolicyData::has_spat() const {
  return _internal_has_spat();
}
inline void PolicyData::clear_spat() {
  if (_impl_.spat_ != nullptr) _impl_.spat_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::v2x::Spat& PolicyData::_internal_spat() const {
  const ::apollo::v2x::Spat* p = _impl_.spat_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::v2x::Spat&>(
      ::apollo::v2x::_Spat_default_instance_);
}
inline const ::apollo::v2x::Spat& PolicyData::spat() const {
  // @@protoc_insertion_point(field_get:apollo.v2x.PolicyData.spat)
  return _internal_spat();
}
inline void PolicyData::unsafe_arena_set_allocated_spat(
    ::apollo::v2x::Spat* spat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spat_);
  }
  _impl_.spat_ = spat;
  if (spat) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.v2x.PolicyData.spat)
}
inline ::apollo::v2x::Spat* PolicyData::release_spat() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::v2x::Spat* temp = _impl_.spat_;
  _impl_.spat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::v2x::Spat* PolicyData::unsafe_arena_release_spat() {
  // @@protoc_insertion_point(field_release:apollo.v2x.PolicyData.spat)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::apollo::v2x::Spat* temp = _impl_.spat_;
  _impl_.spat_ = nullptr;
  return temp;
}
inline ::apollo::v2x::Spat* PolicyData::_internal_mutable_spat() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.spat_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::v2x::Spat>(GetArenaForAllocation());
    _impl_.spat_ = p;
  }
  return _impl_.spat_;
}
inline ::apollo::v2x::Spat* PolicyData::mutable_spat() {
  ::apollo::v2x::Spat* _msg = _internal_mutable_spat();
  // @@protoc_insertion_point(field_mutable:apollo.v2x.PolicyData.spat)
  return _msg;
}
inline void PolicyData::set_allocated_spat(::apollo::v2x::Spat* spat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spat_;
  }
  if (spat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spat);
    if (message_arena != submessage_arena) {
      spat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spat, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.spat_ = spat;
  // @@protoc_insertion_point(field_set_allocated:apollo.v2x.PolicyData.spat)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2x
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::v2x::Connection_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::v2x::Connection_Type>() {
  return ::apollo::v2x::Connection_Type_descriptor();
}
template <> struct is_proto_enum< ::apollo::v2x::Phase_Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::v2x::Phase_Color>() {
  return ::apollo::v2x::Phase_Color_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fv2x_2fproto_2fv2x_5ftraffic_5flight_5fpolicy_2eproto
